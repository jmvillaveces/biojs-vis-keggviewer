require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
//Libraries
var xhr = require('nets');
var Slider = require("bootstrap-slider");

//Modules
var render = require('./pathwayrender.js');

//Private members
var _KEGGAPI = 'http://rest.kegg.jp/get/';

var _target = null, _pathway = 'hsa04910', _proxy = null, _expression = null, _cy = null, _conditions = null, _interval = null, _slider = null;

var _finder = function(cmp, arr){
    var y = arr[0] || null;
    for(var i = 1; i < arr.length; i++){
        y = cmp(y, arr[i]);
    }
    return y;
};

var _setBackground = function(el, bkg){
    
    el.setAttribute('style', 'background:'+bkg);
    
    var content = el.innerHTML;
    container.innerHTML= content;
};

var _query = function(){
    
    var url = _KEGGAPI+_pathway+'/kgml';
    url = (typeof _proxy === 'function') ? _proxy(url) : url;
    
    xhr({
        url: url,
        method: 'GET',
        encoding: undefined
    }, 
    function(err, resp, body){
        
        if(err){ 
            console.error(err); 
            return;
        }
        
        // Create container div
        var div = _target.appendChild(document.createElement('div'));
            div.style.left = 0;
            div.style.top = 0;
            div.style.width = '100%';
            div.style.height = '100%';
            div.style.position = 'absolute';
        
        _cy = render(resp.rawRequest.responseXML, div);
    });
};

var _clearExpression = function(){
    var nodes = _cy.nodes();
    for(var j=0; j<nodes.length; j++){
        for(var k=0; k<_expression.genes.length; k++){
            if(nodes[j].data().keggId == _expression.genes[k]){
                nodes[j].css('background-color', nodes[j].data().bkg_color);
            }
        }
    }
};

var _paintExpression = function(condition){
    
    
    if(condition.name == 'no condition'){ 
        _clearExpression();
        return;
    }
    
    var slider = _slider.getValue();
        
    var min = slider[0];
    var max = slider[1];
    
    var nodes = _cy.nodes();
    for(var i = 0; i < _expression.genes.length; i++){
        
        var node = nodes.filterFn(function(ele){
            
            var ids = ele.data().keggId;
            for(var j = 0; j < ids.length; j++){
                
                if(ids[j].toLowerCase() === _expression.genes[i].toLowerCase()) return true;
                
            }
            return false;
        });
                
        if(node.length !== 0){
            
            var exp = condition.values[i];
            var color = node.data().bkg_color;
            
            if(exp < min){
                color = _expression.downColor;
            }else if(exp > max){
                color = _expression.upColor;
            }
            node.css('background-color', color);
        }
    }
};

var _initControlBar = function(){
    
    var min = Number.POSITIVE_INFINITY, max = Number.NEGATIVE_INFINITY;
    
    var toolbar = document.createElement('div');
    toolbar.setAttribute('style', 'position:relative;z-index:999999;top:20px;float:right;font-size:0.8em;margin-right: 20px;');
    toolbar.setAttribute('class', 'well form-group');
    
    /*Select*/
    var select = document.createElement('select');
    select.setAttribute('class', 'form-control');
    
    _expression.conditions.unshift({name : 'no condition'});
    
    
    for(var i=0; i<_expression.conditions.length; i++){
        var e = _expression.conditions[i];
        var opt = document.createElement('option');
        opt.setAttribute('value', e.name);
        opt.text = e.name;
        
        select.appendChild(opt);
        
        if(e.values){
            max = Math.max(max, _finder(Math.max, e.values));
            min = Math.min(min, _finder(Math.min, e.values));
        }
    }
    
    /*On Change Event*/
    select.addEventListener('change', function(){
        _paintExpression(_expression.conditions[select.selectedIndex]);
    });
    
    /* Play Button */
    var span = document.createElement('span');
    span.setAttribute('class', 'glyphicon glyphicon-play');
    span.setAttribute('aria-hidden', 'true');
    
    
    var playBtn = document.createElement('button');
    playBtn.setAttribute('type', 'button');
    playBtn.setAttribute('class', 'btn btn-default btn-sm form-control');
    playBtn.setAttribute('style', 'margin-top:5px;margin-bottom:5px;');
    playBtn.appendChild(span);
    
    /*On Click Event*/
    playBtn.addEventListener('click', function(e){
        
        
        if(span.className.lastIndexOf('glyphicon-play') != -1){
            
            //Play
            span.className = span.className.replace('glyphicon-play' , 'glyphicon-stop' );
            
            _interval = setInterval(function(){
                
                select.selectedIndex = (select.selectedIndex === select.length - 1) ? 0 : select.selectedIndex + 1;
                _paintExpression(_expression.conditions[select.selectedIndex]);
            
            }, 2000);
            
            
        }else{
            //Stop
            span.className = span.className.replace('glyphicon-stop' , 'glyphicon-play' );
            window.clearInterval(_interval);
        }
        
    });
    
    /* Slider Input */
    var input = document.createElement('input');
    input.setAttribute('id', 'sl');
    input.setAttribute('class', 'slider');
    
    /* Slider Style */
    var style = document.createElement('style');
    style.innerHTML = '.slider-track-high { background: '+ _expression.upColor +';} .slider-track-low { background: '+ _expression.downColor +';}';
    document.getElementsByTagName('head')[0].appendChild(style);
    
    toolbar.appendChild(select);
    toolbar.appendChild(playBtn);
    toolbar.appendChild(input);
    
    _target.appendChild(toolbar);
    
    var cut = (max - min)/4;
    
    //Init slider
    _slider = new Slider('#sl', {min  : min, max  : max, value: [ min + cut, max - cut ], step:0.01});
    _slider.on('slideStop', function(e){
        _paintExpression(_expression.conditions[select.selectedIndex]);
    });
};

// Public members
var app = function(){};

app.target = function(_){
    if (!arguments.length)
        return _target;
    _target = _;
    return app;
};

app.pathway = function(_){
    if (!arguments.length)
        return _pathway;
    _pathway = _;
    return app;
};

app.proxy = function(_){
    if (!arguments.length)
        return _proxy;
    _proxy = _;
    return app;
};

app.expression = function(_){
    if (!arguments.length)
        return _expression;
    _expression = _;
    return app;
};

app.init = function(){
    if(_expression !== null) _initControlBar();
    _query();
};

module.exports = app;
},{"./pathwayrender.js":2,"bootstrap-slider":3,"nets":11}],2:[function(require,module,exports){
//Libraries
var cytoscape = require('cytoscape');

//Variables
var positions = {}, node_map = {}, nodes = [], links = [];

function _processEntry(entry){

    var node = {
        shape: 'rectangle',
        bkg_color: '#99ff99',
        text_valign: 'center',
        border_width: 0
    };
    
    var graphics = entry.getElementsByTagName('graphics')[0];
    var type = entry.getAttribute('type');
    var names = (graphics.getAttribute('name') !== null) ? graphics.getAttribute('name').split(',') : [];
        
    node.width = graphics.getAttribute('width');
    node.height = graphics.getAttribute('height');
    node.type = type;
    node.id = entry.getAttribute('id');
    node.keggId = entry.getAttribute('name').split(' ');
    node.name = names[0] || '';
    node.names = names;
    node.link = entry.getAttribute('link');
    
    if(type == 'ortholog' || type == 'gene'){
            node.border_width = 1;
    }else if(type == 'compound'){
        node.shape = 'ellipse';
        node.bkg_color = '#aaaaee';
        node.text_valign = 'bottom';
    }else if(type == 'map'){
        node.shape = 'roundrectangle';
        node.bkg_color = '#00bfff';
    }else if( type == 'group'){
        
        var components = entry.getElementsByTagName('component');
        for(var i = 0; i < components.length; i++){
            node_map[components[i].getAttribute('id')].data.parent = node.id;
        }
    }
    
    node_map[node.id] = {data: node};
    nodes.push(node_map[node.id]);
            
    positions[node.id] = {
        x : +graphics.getAttribute('x'),
        y : +graphics.getAttribute('y')
    };
};

function _processRelation(rel){
    var type = rel.getAttribute('type'), subtypes = [];
    
    var subs = rel.getElementsByTagName('subtype');
    for(var i=0; i<subs.length; i++){
        var sub = subs[i];
        
        var edge = {
            source: rel.getAttribute('entry1'),
            target: rel.getAttribute('entry2'),
            name: sub.getAttribute('name'),
            reaction: type,
            line_style: 'solid',
            target_arrow_shape: 'none',
            text: ''
        };
        
        if(edge.name == 'maplink'){
            edge.target_arrow_shape = 'diamond';
        }else if(edge.name == 'indirect effect'){
            edge.line_style = 'dotted';
            edge.target_arrow_shape = 'diamond'
        }else if(edge.name == 'state change'){
            edge.line_style = 'dotted';
        }else if(edge.name == 'missing interaction'){
            edge.line_style = 'dotted';
            edge.target_arrow_shape = 'triangle';
        }else if(edge.name == 'phosphorylation'){
            edge.target_arrow_shape = 'triangle';
            edge.text = 'p+';
        }else if(edge.name == 'dephosphorylation'){
            edge.target_arrow_shape = 'triangle';
            edge.text = 'p-';
        }else if(edge.name == 'glycosylation'){
            edge.line_style = 'dashed';
            edge.target_arrow_shape = 'circle';
        }else if(edge.name == 'ubiquitination'){
            edge.line_style = 'dashed';
            edge.target_arrow_shape = 'circle';
        }else if(edge.name == 'methylation'){
            edge.line_style = 'dashed';
            edge.target_arrow_shape = 'circle';
        }else if(edge.name == 'activation'){
            edge.target_arrow_shape = 'triangle';
        }else if(edge.name == 'inhibition'){
            edge.target_arrow_shape = 'tee';
        }else if(edge.name == 'expression'){
            edge.target_arrow_shape = 'triangle';
        }else if(edge.name == 'repression'){
            edge.target_arrow_shape = 'tee';
        }
        
        links.push({
            data:edge
        });
        
    };
};

var renderPathway = function(data, target){
    
    
    
    var entries = data.getElementsByTagName('entry');
    for(var i = 0; i < entries.length; i++){
        _processEntry(entries[i]);
    }
    
    var rels = data.getElementsByTagName('relation');
    for(var i = 0; i < rels.length; i++){
        _processRelation(rels[i]);
    }
    
    var cy = cytoscape({
        container: target,
        elements: {
            nodes : nodes,
            edges : links
        },
        style: cytoscape.stylesheet()
            .selector('node').css({
                'content': 'data(name)',
                'text-valign': 'center',
                'width':  'data(width)',
                'height':  'data(height)',
                'shape':'data(shape)',
                'background-color': 'data(bkg_color)',
                'text-valign': 'data(text_valign)',
                /*'opacity': 'data(opacity)',*/
                'border-color': '#000000',
                'border-width': 'data(border_width)',
                'font-size': 11,
                'text-wrap': 'wrap',
                'text-max-width': 'data(width)'
            })
            .selector('node')
            .selector('edge').css({
                'content': 'data(text)',
                'target-arrow-shape': 'data(target_arrow_shape)',
                'line-style': 'data(line_style)',
                'line-color':'#000000',
                'target-arrow-color':'#000000',
                'text-valign' : 'bottom',
                'font-size': 11
            }),
        layout: {
            name: "preset",
            fit: false,
            positions: positions
        },ready:function(){
            console.log('Kegg Viewer ready');
        }
    });
    
    return cy;
};
module.exports = renderPathway;
},{"cytoscape":9}],3:[function(require,module,exports){
/*! =======================================================
                      VERSION  6.0.6              
========================================================= */
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

/*! =========================================================
 * bootstrap-slider.js
 *
 * Maintainers:
 *		Kyle Kemp
 *			- Twitter: @seiyria
 *			- Github:  seiyria
 *		Rohit Kalkur
 *			- Twitter: @Rovolutionary
 *			- Github:  rovolution
 *
 * =========================================================
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

/**
 * Bridget makes jQuery widgets
 * v1.0.1
 * MIT license
 */

(function (factory) {
	if (typeof define === "function" && define.amd) {
		define(["jquery"], factory);
	} else if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports) {
		var jQuery;
		try {
			jQuery = require("jquery");
		} catch (err) {
			jQuery = null;
		}
		module.exports = factory(jQuery);
	} else if (window) {
		window.Slider = factory(window.jQuery);
	}
})(function ($) {
	// Reference to Slider constructor
	var Slider;

	(function ($) {

		'use strict';

		// -------------------------- utils -------------------------- //

		var slice = Array.prototype.slice;

		function noop() {}

		// -------------------------- definition -------------------------- //

		function defineBridget($) {

			// bail if no jQuery
			if (!$) {
				return;
			}

			// -------------------------- addOptionMethod -------------------------- //

			/**
    * adds option method -> $().plugin('option', {...})
    * @param {Function} PluginClass - constructor class
    */
			function addOptionMethod(PluginClass) {
				// don't overwrite original option method
				if (PluginClass.prototype.option) {
					return;
				}

				// option setter
				PluginClass.prototype.option = function (opts) {
					// bail out if not an object
					if (!$.isPlainObject(opts)) {
						return;
					}
					this.options = $.extend(true, this.options, opts);
				};
			}

			// -------------------------- plugin bridge -------------------------- //

			// helper function for logging errors
			// $.error breaks jQuery chaining
			var logError = typeof console === 'undefined' ? noop : function (message) {
				console.error(message);
			};

			/**
    * jQuery plugin bridge, access methods like $elem.plugin('method')
    * @param {String} namespace - plugin name
    * @param {Function} PluginClass - constructor class
    */
			function bridge(namespace, PluginClass) {
				// add to jQuery fn namespace
				$.fn[namespace] = function (options) {
					if (typeof options === 'string') {
						// call plugin method when first argument is a string
						// get arguments for method
						var args = slice.call(arguments, 1);

						for (var i = 0, len = this.length; i < len; i++) {
							var elem = this[i];
							var instance = $.data(elem, namespace);
							if (!instance) {
								logError("cannot call methods on " + namespace + " prior to initialization; " + "attempted to call '" + options + "'");
								continue;
							}
							if (!$.isFunction(instance[options]) || options.charAt(0) === '_') {
								logError("no such method '" + options + "' for " + namespace + " instance");
								continue;
							}

							// trigger method with arguments
							var returnValue = instance[options].apply(instance, args);

							// break look and return first value if provided
							if (returnValue !== undefined && returnValue !== instance) {
								return returnValue;
							}
						}
						// return this if no return value
						return this;
					} else {
						var objects = this.map(function () {
							var instance = $.data(this, namespace);
							if (instance) {
								// apply options & init
								instance.option(options);
								instance._init();
							} else {
								// initialize new instance
								instance = new PluginClass(this, options);
								$.data(this, namespace, instance);
							}
							return $(this);
						});

						if (!objects || objects.length > 1) {
							return objects;
						} else {
							return objects[0];
						}
					}
				};
			}

			// -------------------------- bridget -------------------------- //

			/**
    * converts a Prototypical class into a proper jQuery plugin
    *   the class must have a ._init method
    * @param {String} namespace - plugin name, used in $().pluginName
    * @param {Function} PluginClass - constructor class
    */
			$.bridget = function (namespace, PluginClass) {
				addOptionMethod(PluginClass);
				bridge(namespace, PluginClass);
			};

			return $.bridget;
		}

		// get jquery from browser global
		defineBridget($);
	})($);

	/*************************************************
 			BOOTSTRAP-SLIDER SOURCE CODE
 	**************************************************/

	(function ($) {

		var ErrorMsgs = {
			formatInvalidInputErrorMsg: function formatInvalidInputErrorMsg(input) {
				return "Invalid input value '" + input + "' passed in";
			},
			callingContextNotSliderInstance: "Calling context element does not have instance of Slider bound to it. Check your code to make sure the JQuery object returned from the call to the slider() initializer is calling the method"
		};

		var SliderScale = {
			linear: {
				toValue: function toValue(percentage) {
					var rawValue = percentage / 100 * (this.options.max - this.options.min);
					var shouldAdjustWithBase = true;
					if (this.options.ticks_positions.length > 0) {
						var minv,
						    maxv,
						    minp,
						    maxp = 0;
						for (var i = 1; i < this.options.ticks_positions.length; i++) {
							if (percentage <= this.options.ticks_positions[i]) {
								minv = this.options.ticks[i - 1];
								minp = this.options.ticks_positions[i - 1];
								maxv = this.options.ticks[i];
								maxp = this.options.ticks_positions[i];

								break;
							}
						}
						var partialPercentage = (percentage - minp) / (maxp - minp);
						rawValue = minv + partialPercentage * (maxv - minv);
						shouldAdjustWithBase = false;
					}

					var adjustment = shouldAdjustWithBase ? this.options.min : 0;
					var value = adjustment + Math.round(rawValue / this.options.step) * this.options.step;
					if (value < this.options.min) {
						return this.options.min;
					} else if (value > this.options.max) {
						return this.options.max;
					} else {
						return value;
					}
				},
				toPercentage: function toPercentage(value) {
					if (this.options.max === this.options.min) {
						return 0;
					}

					if (this.options.ticks_positions.length > 0) {
						var minv,
						    maxv,
						    minp,
						    maxp = 0;
						for (var i = 0; i < this.options.ticks.length; i++) {
							if (value <= this.options.ticks[i]) {
								minv = i > 0 ? this.options.ticks[i - 1] : 0;
								minp = i > 0 ? this.options.ticks_positions[i - 1] : 0;
								maxv = this.options.ticks[i];
								maxp = this.options.ticks_positions[i];

								break;
							}
						}
						if (i > 0) {
							var partialPercentage = (value - minv) / (maxv - minv);
							return minp + partialPercentage * (maxp - minp);
						}
					}

					return 100 * (value - this.options.min) / (this.options.max - this.options.min);
				}
			},

			logarithmic: {
				/* Based on http://stackoverflow.com/questions/846221/logarithmic-slider */
				toValue: function toValue(percentage) {
					var min = this.options.min === 0 ? 0 : Math.log(this.options.min);
					var max = Math.log(this.options.max);
					var value = Math.exp(min + (max - min) * percentage / 100);
					value = this.options.min + Math.round((value - this.options.min) / this.options.step) * this.options.step;
					/* Rounding to the nearest step could exceed the min or
      * max, so clip to those values. */
					if (value < this.options.min) {
						return this.options.min;
					} else if (value > this.options.max) {
						return this.options.max;
					} else {
						return value;
					}
				},
				toPercentage: function toPercentage(value) {
					if (this.options.max === this.options.min) {
						return 0;
					} else {
						var max = Math.log(this.options.max);
						var min = this.options.min === 0 ? 0 : Math.log(this.options.min);
						var v = value === 0 ? 0 : Math.log(value);
						return 100 * (v - min) / (max - min);
					}
				}
			}
		};

		/*************************************************
  						CONSTRUCTOR
  	**************************************************/
		Slider = function Slider(element, options) {
			createNewSlider.call(this, element, options);
			return this;
		};

		function createNewSlider(element, options) {

			/*
   	The internal state object is used to store data about the current 'state' of slider.
   		This includes values such as the `value`, `enabled`, etc...
   */
			this._state = {
				value: null,
				enabled: null,
				offset: null,
				size: null,
				percentage: null,
				inDrag: false,
				over: false
			};

			if (typeof element === "string") {
				this.element = document.querySelector(element);
			} else if (element instanceof HTMLElement) {
				this.element = element;
			}

			/*************************************************
   					Process Options
   	**************************************************/
			options = options ? options : {};
			var optionTypes = Object.keys(this.defaultOptions);

			for (var i = 0; i < optionTypes.length; i++) {
				var optName = optionTypes[i];

				// First check if an option was passed in via the constructor
				var val = options[optName];
				// If no data attrib, then check data atrributes
				val = typeof val !== 'undefined' ? val : getDataAttrib(this.element, optName);
				// Finally, if nothing was specified, use the defaults
				val = val !== null ? val : this.defaultOptions[optName];

				// Set all options on the instance of the Slider
				if (!this.options) {
					this.options = {};
				}
				this.options[optName] = val;
			}

			/*
   	Validate `tooltip_position` against 'orientation`
   	- if `tooltip_position` is incompatible with orientation, swith it to a default compatible with specified `orientation`
   		-- default for "vertical" -> "right"
   		-- default for "horizontal" -> "left"
   */
			if (this.options.orientation === "vertical" && (this.options.tooltip_position === "top" || this.options.tooltip_position === "bottom")) {

				this.options.tooltip_position = "right";
			} else if (this.options.orientation === "horizontal" && (this.options.tooltip_position === "left" || this.options.tooltip_position === "right")) {

				this.options.tooltip_position = "top";
			}

			function getDataAttrib(element, optName) {
				var dataName = "data-slider-" + optName.replace(/_/g, '-');
				var dataValString = element.getAttribute(dataName);

				try {
					return JSON.parse(dataValString);
				} catch (err) {
					return dataValString;
				}
			}

			/*************************************************
   					Create Markup
   	**************************************************/

			var origWidth = this.element.style.width;
			var updateSlider = false;
			var parent = this.element.parentNode;
			var sliderTrackSelection;
			var sliderTrackLow, sliderTrackHigh;
			var sliderMinHandle;
			var sliderMaxHandle;

			if (this.sliderElem) {
				updateSlider = true;
			} else {
				/* Create elements needed for slider */
				this.sliderElem = document.createElement("div");
				this.sliderElem.className = "slider";

				/* Create slider track elements */
				var sliderTrack = document.createElement("div");
				sliderTrack.className = "slider-track";

				sliderTrackLow = document.createElement("div");
				sliderTrackLow.className = "slider-track-low";

				sliderTrackSelection = document.createElement("div");
				sliderTrackSelection.className = "slider-selection";

				sliderTrackHigh = document.createElement("div");
				sliderTrackHigh.className = "slider-track-high";

				sliderMinHandle = document.createElement("div");
				sliderMinHandle.className = "slider-handle min-slider-handle";
				sliderMinHandle.setAttribute('role', 'slider');
				sliderMinHandle.setAttribute('aria-valuemin', this.options.min);
				sliderMinHandle.setAttribute('aria-valuemax', this.options.max);

				sliderMaxHandle = document.createElement("div");
				sliderMaxHandle.className = "slider-handle max-slider-handle";
				sliderMaxHandle.setAttribute('role', 'slider');
				sliderMaxHandle.setAttribute('aria-valuemin', this.options.min);
				sliderMaxHandle.setAttribute('aria-valuemax', this.options.max);

				sliderTrack.appendChild(sliderTrackLow);
				sliderTrack.appendChild(sliderTrackSelection);
				sliderTrack.appendChild(sliderTrackHigh);

				/* Add aria-labelledby to handle's */
				var isLabelledbyArray = Array.isArray(this.options.labelledby);
				if (isLabelledbyArray && this.options.labelledby[0]) {
					sliderMinHandle.setAttribute('aria-labelledby', this.options.labelledby[0]);
				}
				if (isLabelledbyArray && this.options.labelledby[1]) {
					sliderMaxHandle.setAttribute('aria-labelledby', this.options.labelledby[1]);
				}
				if (!isLabelledbyArray && this.options.labelledby) {
					sliderMinHandle.setAttribute('aria-labelledby', this.options.labelledby);
					sliderMaxHandle.setAttribute('aria-labelledby', this.options.labelledby);
				}

				/* Create ticks */
				this.ticks = [];
				if (Array.isArray(this.options.ticks) && this.options.ticks.length > 0) {
					for (i = 0; i < this.options.ticks.length; i++) {
						var tick = document.createElement('div');
						tick.className = 'slider-tick';

						this.ticks.push(tick);
						sliderTrack.appendChild(tick);
					}

					sliderTrackSelection.className += " tick-slider-selection";
				}

				sliderTrack.appendChild(sliderMinHandle);
				sliderTrack.appendChild(sliderMaxHandle);

				this.tickLabels = [];
				if (Array.isArray(this.options.ticks_labels) && this.options.ticks_labels.length > 0) {
					this.tickLabelContainer = document.createElement('div');
					this.tickLabelContainer.className = 'slider-tick-label-container';

					for (i = 0; i < this.options.ticks_labels.length; i++) {
						var label = document.createElement('div');
						var noTickPositionsSpecified = this.options.ticks_positions.length === 0;
						var tickLabelsIndex = this.options.reversed && noTickPositionsSpecified ? this.options.ticks_labels.length - (i + 1) : i;
						label.className = 'slider-tick-label';
						label.innerHTML = this.options.ticks_labels[tickLabelsIndex];

						this.tickLabels.push(label);
						this.tickLabelContainer.appendChild(label);
					}
				}

				var createAndAppendTooltipSubElements = function createAndAppendTooltipSubElements(tooltipElem) {
					var arrow = document.createElement("div");
					arrow.className = "tooltip-arrow";

					var inner = document.createElement("div");
					inner.className = "tooltip-inner";

					tooltipElem.appendChild(arrow);
					tooltipElem.appendChild(inner);
				};

				/* Create tooltip elements */
				var sliderTooltip = document.createElement("div");
				sliderTooltip.className = "tooltip tooltip-main";
				sliderTooltip.setAttribute('role', 'presentation');
				createAndAppendTooltipSubElements(sliderTooltip);

				var sliderTooltipMin = document.createElement("div");
				sliderTooltipMin.className = "tooltip tooltip-min";
				sliderTooltipMin.setAttribute('role', 'presentation');
				createAndAppendTooltipSubElements(sliderTooltipMin);

				var sliderTooltipMax = document.createElement("div");
				sliderTooltipMax.className = "tooltip tooltip-max";
				sliderTooltipMax.setAttribute('role', 'presentation');
				createAndAppendTooltipSubElements(sliderTooltipMax);

				/* Append components to sliderElem */
				this.sliderElem.appendChild(sliderTrack);
				this.sliderElem.appendChild(sliderTooltip);
				this.sliderElem.appendChild(sliderTooltipMin);
				this.sliderElem.appendChild(sliderTooltipMax);

				if (this.tickLabelContainer) {
					this.sliderElem.appendChild(this.tickLabelContainer);
				}

				/* Append slider element to parent container, right before the original <input> element */
				parent.insertBefore(this.sliderElem, this.element);

				/* Hide original <input> element */
				this.element.style.display = "none";
			}
			/* If JQuery exists, cache JQ references */
			if ($) {
				this.$element = $(this.element);
				this.$sliderElem = $(this.sliderElem);
			}

			/*************************************************
   						Setup
   	**************************************************/
			this.eventToCallbackMap = {};
			this.sliderElem.id = this.options.id;

			this.touchCapable = 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch;

			this.tooltip = this.sliderElem.querySelector('.tooltip-main');
			this.tooltipInner = this.tooltip.querySelector('.tooltip-inner');

			this.tooltip_min = this.sliderElem.querySelector('.tooltip-min');
			this.tooltipInner_min = this.tooltip_min.querySelector('.tooltip-inner');

			this.tooltip_max = this.sliderElem.querySelector('.tooltip-max');
			this.tooltipInner_max = this.tooltip_max.querySelector('.tooltip-inner');

			if (SliderScale[this.options.scale]) {
				this.options.scale = SliderScale[this.options.scale];
			}

			if (updateSlider === true) {
				// Reset classes
				this._removeClass(this.sliderElem, 'slider-horizontal');
				this._removeClass(this.sliderElem, 'slider-vertical');
				this._removeClass(this.tooltip, 'hide');
				this._removeClass(this.tooltip_min, 'hide');
				this._removeClass(this.tooltip_max, 'hide');

				// Undo existing inline styles for track
				["left", "top", "width", "height"].forEach(function (prop) {
					this._removeProperty(this.trackLow, prop);
					this._removeProperty(this.trackSelection, prop);
					this._removeProperty(this.trackHigh, prop);
				}, this);

				// Undo inline styles on handles
				[this.handle1, this.handle2].forEach(function (handle) {
					this._removeProperty(handle, 'left');
					this._removeProperty(handle, 'top');
				}, this);

				// Undo inline styles and classes on tooltips
				[this.tooltip, this.tooltip_min, this.tooltip_max].forEach(function (tooltip) {
					this._removeProperty(tooltip, 'left');
					this._removeProperty(tooltip, 'top');
					this._removeProperty(tooltip, 'margin-left');
					this._removeProperty(tooltip, 'margin-top');

					this._removeClass(tooltip, 'right');
					this._removeClass(tooltip, 'top');
				}, this);
			}

			if (this.options.orientation === 'vertical') {
				this._addClass(this.sliderElem, 'slider-vertical');
				this.stylePos = 'top';
				this.mousePos = 'pageY';
				this.sizePos = 'offsetHeight';
			} else {
				this._addClass(this.sliderElem, 'slider-horizontal');
				this.sliderElem.style.width = origWidth;
				this.options.orientation = 'horizontal';
				this.stylePos = 'left';
				this.mousePos = 'pageX';
				this.sizePos = 'offsetWidth';
			}
			this._setTooltipPosition();
			/* In case ticks are specified, overwrite the min and max bounds */
			if (Array.isArray(this.options.ticks) && this.options.ticks.length > 0) {
				this.options.max = Math.max.apply(Math, this.options.ticks);
				this.options.min = Math.min.apply(Math, this.options.ticks);
			}

			if (Array.isArray(this.options.value)) {
				this.options.range = true;
				this._state.value = this.options.value;
			} else if (this.options.range) {
				// User wants a range, but value is not an array
				this._state.value = [this.options.value, this.options.max];
			} else {
				this._state.value = this.options.value;
			}

			this.trackLow = sliderTrackLow || this.trackLow;
			this.trackSelection = sliderTrackSelection || this.trackSelection;
			this.trackHigh = sliderTrackHigh || this.trackHigh;

			if (this.options.selection === 'none') {
				this._addClass(this.trackLow, 'hide');
				this._addClass(this.trackSelection, 'hide');
				this._addClass(this.trackHigh, 'hide');
			}

			this.handle1 = sliderMinHandle || this.handle1;
			this.handle2 = sliderMaxHandle || this.handle2;

			if (updateSlider === true) {
				// Reset classes
				this._removeClass(this.handle1, 'round triangle');
				this._removeClass(this.handle2, 'round triangle hide');

				for (i = 0; i < this.ticks.length; i++) {
					this._removeClass(this.ticks[i], 'round triangle hide');
				}
			}

			var availableHandleModifiers = ['round', 'triangle', 'custom'];
			var isValidHandleType = availableHandleModifiers.indexOf(this.options.handle) !== -1;
			if (isValidHandleType) {
				this._addClass(this.handle1, this.options.handle);
				this._addClass(this.handle2, this.options.handle);

				for (i = 0; i < this.ticks.length; i++) {
					this._addClass(this.ticks[i], this.options.handle);
				}
			}

			this._state.offset = this._offset(this.sliderElem);
			this._state.size = this.sliderElem[this.sizePos];
			this.setValue(this._state.value);

			/******************************************
   				Bind Event Listeners
   	******************************************/

			// Bind keyboard handlers
			this.handle1Keydown = this._keydown.bind(this, 0);
			this.handle1.addEventListener("keydown", this.handle1Keydown, false);

			this.handle2Keydown = this._keydown.bind(this, 1);
			this.handle2.addEventListener("keydown", this.handle2Keydown, false);

			this.mousedown = this._mousedown.bind(this);
			if (this.touchCapable) {
				// Bind touch handlers
				this.sliderElem.addEventListener("touchstart", this.mousedown, false);
			}
			this.sliderElem.addEventListener("mousedown", this.mousedown, false);

			// Bind window handlers
			this.resize = this._resize.bind(this);
			window.addEventListener("resize", this.resize, false);

			// Bind tooltip-related handlers
			if (this.options.tooltip === 'hide') {
				this._addClass(this.tooltip, 'hide');
				this._addClass(this.tooltip_min, 'hide');
				this._addClass(this.tooltip_max, 'hide');
			} else if (this.options.tooltip === 'always') {
				this._showTooltip();
				this._alwaysShowTooltip = true;
			} else {
				this.showTooltip = this._showTooltip.bind(this);
				this.hideTooltip = this._hideTooltip.bind(this);

				this.sliderElem.addEventListener("mouseenter", this.showTooltip, false);
				this.sliderElem.addEventListener("mouseleave", this.hideTooltip, false);

				this.handle1.addEventListener("focus", this.showTooltip, false);
				this.handle1.addEventListener("blur", this.hideTooltip, false);

				this.handle2.addEventListener("focus", this.showTooltip, false);
				this.handle2.addEventListener("blur", this.hideTooltip, false);
			}

			if (this.options.enabled) {
				this.enable();
			} else {
				this.disable();
			}
		}

		/*************************************************
  				INSTANCE PROPERTIES/METHODS
  	- Any methods bound to the prototype are considered
  part of the plugin's `public` interface
  	**************************************************/
		Slider.prototype = {
			_init: function _init() {}, // NOTE: Must exist to support bridget

			constructor: Slider,

			defaultOptions: {
				id: "",
				min: 0,
				max: 10,
				step: 1,
				precision: 0,
				orientation: 'horizontal',
				value: 5,
				range: false,
				selection: 'before',
				tooltip: 'show',
				tooltip_split: false,
				handle: 'round',
				reversed: false,
				enabled: true,
				formatter: function formatter(val) {
					if (Array.isArray(val)) {
						return val[0] + " : " + val[1];
					} else {
						return val;
					}
				},
				natural_arrow_keys: false,
				ticks: [],
				ticks_positions: [],
				ticks_labels: [],
				ticks_snap_bounds: 0,
				scale: 'linear',
				focus: false,
				tooltip_position: null,
				labelledby: null
			},

			getElement: function getElement() {
				return this.sliderElem;
			},

			getValue: function getValue() {
				if (this.options.range) {
					return this._state.value;
				} else {
					return this._state.value[0];
				}
			},

			setValue: function setValue(val, triggerSlideEvent, triggerChangeEvent) {
				if (!val) {
					val = 0;
				}
				var oldValue = this.getValue();
				this._state.value = this._validateInputValue(val);
				var applyPrecision = this._applyPrecision.bind(this);

				if (this.options.range) {
					this._state.value[0] = applyPrecision(this._state.value[0]);
					this._state.value[1] = applyPrecision(this._state.value[1]);

					this._state.value[0] = Math.max(this.options.min, Math.min(this.options.max, this._state.value[0]));
					this._state.value[1] = Math.max(this.options.min, Math.min(this.options.max, this._state.value[1]));
				} else {
					this._state.value = applyPrecision(this._state.value);
					this._state.value = [Math.max(this.options.min, Math.min(this.options.max, this._state.value))];
					this._addClass(this.handle2, 'hide');
					if (this.options.selection === 'after') {
						this._state.value[1] = this.options.max;
					} else {
						this._state.value[1] = this.options.min;
					}
				}

				if (this.options.max > this.options.min) {
					this._state.percentage = [this._toPercentage(this._state.value[0]), this._toPercentage(this._state.value[1]), this.options.step * 100 / (this.options.max - this.options.min)];
				} else {
					this._state.percentage = [0, 0, 100];
				}

				this._layout();
				var newValue = this.options.range ? this._state.value : this._state.value[0];

				if (triggerSlideEvent === true) {
					this._trigger('slide', newValue);
				}
				if (oldValue !== newValue && triggerChangeEvent === true) {
					this._trigger('change', {
						oldValue: oldValue,
						newValue: newValue
					});
				}
				this._setDataVal(newValue);

				return this;
			},

			destroy: function destroy() {
				// Remove event handlers on slider elements
				this._removeSliderEventHandlers();

				// Remove the slider from the DOM
				this.sliderElem.parentNode.removeChild(this.sliderElem);
				/* Show original <input> element */
				this.element.style.display = "";

				// Clear out custom event bindings
				this._cleanUpEventCallbacksMap();

				// Remove data values
				this.element.removeAttribute("data");

				// Remove JQuery handlers/data
				if ($) {
					this._unbindJQueryEventHandlers();
					this.$element.removeData('slider');
				}
			},

			disable: function disable() {
				this._state.enabled = false;
				this.handle1.removeAttribute("tabindex");
				this.handle2.removeAttribute("tabindex");
				this._addClass(this.sliderElem, 'slider-disabled');
				this._trigger('slideDisabled');

				return this;
			},

			enable: function enable() {
				this._state.enabled = true;
				this.handle1.setAttribute("tabindex", 0);
				this.handle2.setAttribute("tabindex", 0);
				this._removeClass(this.sliderElem, 'slider-disabled');
				this._trigger('slideEnabled');

				return this;
			},

			toggle: function toggle() {
				if (this._state.enabled) {
					this.disable();
				} else {
					this.enable();
				}
				return this;
			},

			isEnabled: function isEnabled() {
				return this._state.enabled;
			},

			on: function on(evt, callback) {
				this._bindNonQueryEventHandler(evt, callback);
				return this;
			},

			off: function off(evt, callback) {
				if ($) {
					this.$element.off(evt, callback);
					this.$sliderElem.off(evt, callback);
				} else {
					this._unbindNonQueryEventHandler(evt, callback);
				}
			},

			getAttribute: function getAttribute(attribute) {
				if (attribute) {
					return this.options[attribute];
				} else {
					return this.options;
				}
			},

			setAttribute: function setAttribute(attribute, value) {
				this.options[attribute] = value;
				return this;
			},

			refresh: function refresh() {
				this._removeSliderEventHandlers();
				createNewSlider.call(this, this.element, this.options);
				if ($) {
					// Bind new instance of slider to the element
					$.data(this.element, 'slider', this);
				}
				return this;
			},

			relayout: function relayout() {
				this._layout();
				return this;
			},

			/******************************+
   				HELPERS
   	- Any method that is not part of the public interface.
   - Place it underneath this comment block and write its signature like so:
   	  					_fnName : function() {...}
   	********************************/
			_removeSliderEventHandlers: function _removeSliderEventHandlers() {
				// Remove keydown event listeners
				this.handle1.removeEventListener("keydown", this.handle1Keydown, false);
				this.handle2.removeEventListener("keydown", this.handle2Keydown, false);

				if (this.showTooltip) {
					this.handle1.removeEventListener("focus", this.showTooltip, false);
					this.handle2.removeEventListener("focus", this.showTooltip, false);
				}
				if (this.hideTooltip) {
					this.handle1.removeEventListener("blur", this.hideTooltip, false);
					this.handle2.removeEventListener("blur", this.hideTooltip, false);
				}

				// Remove event listeners from sliderElem
				if (this.showTooltip) {
					this.sliderElem.removeEventListener("mouseenter", this.showTooltip, false);
				}
				if (this.hideTooltip) {
					this.sliderElem.removeEventListener("mouseleave", this.hideTooltip, false);
				}
				this.sliderElem.removeEventListener("touchstart", this.mousedown, false);
				this.sliderElem.removeEventListener("mousedown", this.mousedown, false);

				// Remove window event listener
				window.removeEventListener("resize", this.resize, false);
			},
			_bindNonQueryEventHandler: function _bindNonQueryEventHandler(evt, callback) {
				if (this.eventToCallbackMap[evt] === undefined) {
					this.eventToCallbackMap[evt] = [];
				}
				this.eventToCallbackMap[evt].push(callback);
			},
			_unbindNonQueryEventHandler: function _unbindNonQueryEventHandler(evt, callback) {
				var callbacks = this.eventToCallbackMap[evt];
				if (callbacks !== undefined) {
					for (var i = 0; i < callbacks.length; i++) {
						if (callbacks[i] === callback) {
							callbacks.splice(i, 1);
							break;
						}
					}
				}
			},
			_cleanUpEventCallbacksMap: function _cleanUpEventCallbacksMap() {
				var eventNames = Object.keys(this.eventToCallbackMap);
				for (var i = 0; i < eventNames.length; i++) {
					var eventName = eventNames[i];
					this.eventToCallbackMap[eventName] = null;
				}
			},
			_showTooltip: function _showTooltip() {
				if (this.options.tooltip_split === false) {
					this._addClass(this.tooltip, 'in');
					this.tooltip_min.style.display = 'none';
					this.tooltip_max.style.display = 'none';
				} else {
					this._addClass(this.tooltip_min, 'in');
					this._addClass(this.tooltip_max, 'in');
					this.tooltip.style.display = 'none';
				}
				this._state.over = true;
			},
			_hideTooltip: function _hideTooltip() {
				if (this._state.inDrag === false && this.alwaysShowTooltip !== true) {
					this._removeClass(this.tooltip, 'in');
					this._removeClass(this.tooltip_min, 'in');
					this._removeClass(this.tooltip_max, 'in');
				}
				this._state.over = false;
			},
			_layout: function _layout() {
				var positionPercentages;

				if (this.options.reversed) {
					positionPercentages = [100 - this._state.percentage[0], this.options.range ? 100 - this._state.percentage[1] : this._state.percentage[1]];
				} else {
					positionPercentages = [this._state.percentage[0], this._state.percentage[1]];
				}

				this.handle1.style[this.stylePos] = positionPercentages[0] + '%';
				this.handle1.setAttribute('aria-valuenow', this._state.value[0]);

				this.handle2.style[this.stylePos] = positionPercentages[1] + '%';
				this.handle2.setAttribute('aria-valuenow', this._state.value[1]);

				/* Position ticks and labels */
				if (Array.isArray(this.options.ticks) && this.options.ticks.length > 0) {

					var styleSize = this.options.orientation === 'vertical' ? 'height' : 'width';
					var styleMargin = this.options.orientation === 'vertical' ? 'marginTop' : 'marginLeft';
					var labelSize = this._state.size / (this.options.ticks.length - 1);

					if (this.tickLabelContainer) {
						var extraMargin = 0;
						if (this.options.ticks_positions.length === 0) {
							if (this.options.orientation !== 'vertical') {
								this.tickLabelContainer.style[styleMargin] = -labelSize / 2 + 'px';
							}

							extraMargin = this.tickLabelContainer.offsetHeight;
						} else {
							/* Chidren are position absolute, calculate height by finding the max offsetHeight of a child */
							for (i = 0; i < this.tickLabelContainer.childNodes.length; i++) {
								if (this.tickLabelContainer.childNodes[i].offsetHeight > extraMargin) {
									extraMargin = this.tickLabelContainer.childNodes[i].offsetHeight;
								}
							}
						}
						if (this.options.orientation === 'horizontal') {
							this.sliderElem.style.marginBottom = extraMargin + 'px';
						}
					}
					for (var i = 0; i < this.options.ticks.length; i++) {

						var percentage = this.options.ticks_positions[i] || this._toPercentage(this.options.ticks[i]);

						if (this.options.reversed) {
							percentage = 100 - percentage;
						}

						this.ticks[i].style[this.stylePos] = percentage + '%';

						/* Set class labels to denote whether ticks are in the selection */
						this._removeClass(this.ticks[i], 'in-selection');
						if (!this.options.range) {
							if (this.options.selection === 'after' && percentage >= positionPercentages[0]) {
								this._addClass(this.ticks[i], 'in-selection');
							} else if (this.options.selection === 'before' && percentage <= positionPercentages[0]) {
								this._addClass(this.ticks[i], 'in-selection');
							}
						} else if (percentage >= positionPercentages[0] && percentage <= positionPercentages[1]) {
							this._addClass(this.ticks[i], 'in-selection');
						}

						if (this.tickLabels[i]) {
							this.tickLabels[i].style[styleSize] = labelSize + 'px';

							if (this.options.orientation !== 'vertical' && this.options.ticks_positions[i] !== undefined) {
								this.tickLabels[i].style.position = 'absolute';
								this.tickLabels[i].style[this.stylePos] = percentage + '%';
								this.tickLabels[i].style[styleMargin] = -labelSize / 2 + 'px';
							} else if (this.options.orientation === 'vertical') {
								this.tickLabels[i].style['marginLeft'] = this.sliderElem.offsetWidth + 'px';
								this.tickLabelContainer.style['marginTop'] = this.sliderElem.offsetWidth / 2 * -1 + 'px';
							}
						}
					}
				}

				var formattedTooltipVal;

				if (this.options.range) {
					formattedTooltipVal = this.options.formatter(this._state.value);
					this._setText(this.tooltipInner, formattedTooltipVal);
					this.tooltip.style[this.stylePos] = (positionPercentages[1] + positionPercentages[0]) / 2 + '%';

					if (this.options.orientation === 'vertical') {
						this._css(this.tooltip, 'margin-top', -this.tooltip.offsetHeight / 2 + 'px');
					} else {
						this._css(this.tooltip, 'margin-left', -this.tooltip.offsetWidth / 2 + 'px');
					}

					if (this.options.orientation === 'vertical') {
						this._css(this.tooltip, 'margin-top', -this.tooltip.offsetHeight / 2 + 'px');
					} else {
						this._css(this.tooltip, 'margin-left', -this.tooltip.offsetWidth / 2 + 'px');
					}

					var innerTooltipMinText = this.options.formatter(this._state.value[0]);
					this._setText(this.tooltipInner_min, innerTooltipMinText);

					var innerTooltipMaxText = this.options.formatter(this._state.value[1]);
					this._setText(this.tooltipInner_max, innerTooltipMaxText);

					this.tooltip_min.style[this.stylePos] = positionPercentages[0] + '%';

					if (this.options.orientation === 'vertical') {
						this._css(this.tooltip_min, 'margin-top', -this.tooltip_min.offsetHeight / 2 + 'px');
					} else {
						this._css(this.tooltip_min, 'margin-left', -this.tooltip_min.offsetWidth / 2 + 'px');
					}

					this.tooltip_max.style[this.stylePos] = positionPercentages[1] + '%';

					if (this.options.orientation === 'vertical') {
						this._css(this.tooltip_max, 'margin-top', -this.tooltip_max.offsetHeight / 2 + 'px');
					} else {
						this._css(this.tooltip_max, 'margin-left', -this.tooltip_max.offsetWidth / 2 + 'px');
					}
				} else {
					formattedTooltipVal = this.options.formatter(this._state.value[0]);
					this._setText(this.tooltipInner, formattedTooltipVal);

					this.tooltip.style[this.stylePos] = positionPercentages[0] + '%';
					if (this.options.orientation === 'vertical') {
						this._css(this.tooltip, 'margin-top', -this.tooltip.offsetHeight / 2 + 'px');
					} else {
						this._css(this.tooltip, 'margin-left', -this.tooltip.offsetWidth / 2 + 'px');
					}
				}

				if (this.options.orientation === 'vertical') {
					this.trackLow.style.top = '0';
					this.trackLow.style.height = Math.min(positionPercentages[0], positionPercentages[1]) + '%';

					this.trackSelection.style.top = Math.min(positionPercentages[0], positionPercentages[1]) + '%';
					this.trackSelection.style.height = Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';

					this.trackHigh.style.bottom = '0';
					this.trackHigh.style.height = 100 - Math.min(positionPercentages[0], positionPercentages[1]) - Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';
				} else {
					this.trackLow.style.left = '0';
					this.trackLow.style.width = Math.min(positionPercentages[0], positionPercentages[1]) + '%';

					this.trackSelection.style.left = Math.min(positionPercentages[0], positionPercentages[1]) + '%';
					this.trackSelection.style.width = Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';

					this.trackHigh.style.right = '0';
					this.trackHigh.style.width = 100 - Math.min(positionPercentages[0], positionPercentages[1]) - Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';

					var offset_min = this.tooltip_min.getBoundingClientRect();
					var offset_max = this.tooltip_max.getBoundingClientRect();

					if (offset_min.right > offset_max.left) {
						this._removeClass(this.tooltip_max, 'top');
						this._addClass(this.tooltip_max, 'bottom');
						this.tooltip_max.style.top = 18 + 'px';
					} else {
						this._removeClass(this.tooltip_max, 'bottom');
						this._addClass(this.tooltip_max, 'top');
						this.tooltip_max.style.top = this.tooltip_min.style.top;
					}
				}
			},
			_resize: function _resize(ev) {
				/*jshint unused:false*/
				this._state.offset = this._offset(this.sliderElem);
				this._state.size = this.sliderElem[this.sizePos];
				this._layout();
			},
			_removeProperty: function _removeProperty(element, prop) {
				if (element.style.removeProperty) {
					element.style.removeProperty(prop);
				} else {
					element.style.removeAttribute(prop);
				}
			},
			_mousedown: function _mousedown(ev) {
				if (!this._state.enabled) {
					return false;
				}

				this._state.offset = this._offset(this.sliderElem);
				this._state.size = this.sliderElem[this.sizePos];

				var percentage = this._getPercentage(ev);

				if (this.options.range) {
					var diff1 = Math.abs(this._state.percentage[0] - percentage);
					var diff2 = Math.abs(this._state.percentage[1] - percentage);
					this._state.dragged = diff1 < diff2 ? 0 : 1;
				} else {
					this._state.dragged = 0;
				}

				this._state.percentage[this._state.dragged] = percentage;
				this._layout();

				if (this.touchCapable) {
					document.removeEventListener("touchmove", this.mousemove, false);
					document.removeEventListener("touchend", this.mouseup, false);
				}

				if (this.mousemove) {
					document.removeEventListener("mousemove", this.mousemove, false);
				}
				if (this.mouseup) {
					document.removeEventListener("mouseup", this.mouseup, false);
				}

				this.mousemove = this._mousemove.bind(this);
				this.mouseup = this._mouseup.bind(this);

				if (this.touchCapable) {
					// Touch: Bind touch events:
					document.addEventListener("touchmove", this.mousemove, false);
					document.addEventListener("touchend", this.mouseup, false);
				}
				// Bind mouse events:
				document.addEventListener("mousemove", this.mousemove, false);
				document.addEventListener("mouseup", this.mouseup, false);

				this._state.inDrag = true;
				var newValue = this._calculateValue();

				this._trigger('slideStart', newValue);

				this._setDataVal(newValue);
				this.setValue(newValue, false, true);

				this._pauseEvent(ev);

				if (this.options.focus) {
					this._triggerFocusOnHandle(this._state.dragged);
				}

				return true;
			},
			_triggerFocusOnHandle: function _triggerFocusOnHandle(handleIdx) {
				if (handleIdx === 0) {
					this.handle1.focus();
				}
				if (handleIdx === 1) {
					this.handle2.focus();
				}
			},
			_keydown: function _keydown(handleIdx, ev) {
				if (!this._state.enabled) {
					return false;
				}

				var dir;
				switch (ev.keyCode) {
					case 37: // left
					case 40:
						// down
						dir = -1;
						break;
					case 39: // right
					case 38:
						// up
						dir = 1;
						break;
				}
				if (!dir) {
					return;
				}

				// use natural arrow keys instead of from min to max
				if (this.options.natural_arrow_keys) {
					var ifVerticalAndNotReversed = this.options.orientation === 'vertical' && !this.options.reversed;
					var ifHorizontalAndReversed = this.options.orientation === 'horizontal' && this.options.reversed;

					if (ifVerticalAndNotReversed || ifHorizontalAndReversed) {
						dir = -dir;
					}
				}

				var val = this._state.value[handleIdx] + dir * this.options.step;
				if (this.options.range) {
					val = [!handleIdx ? val : this._state.value[0], handleIdx ? val : this._state.value[1]];
				}

				this._trigger('slideStart', val);
				this._setDataVal(val);
				this.setValue(val, true, true);

				this._setDataVal(val);
				this._trigger('slideStop', val);
				this._layout();

				this._pauseEvent(ev);

				return false;
			},
			_pauseEvent: function _pauseEvent(ev) {
				if (ev.stopPropagation) {
					ev.stopPropagation();
				}
				if (ev.preventDefault) {
					ev.preventDefault();
				}
				ev.cancelBubble = true;
				ev.returnValue = false;
			},
			_mousemove: function _mousemove(ev) {
				if (!this._state.enabled) {
					return false;
				}

				var percentage = this._getPercentage(ev);
				this._adjustPercentageForRangeSliders(percentage);
				this._state.percentage[this._state.dragged] = percentage;
				this._layout();

				var val = this._calculateValue(true);
				this.setValue(val, true, true);

				return false;
			},
			_adjustPercentageForRangeSliders: function _adjustPercentageForRangeSliders(percentage) {
				if (this.options.range) {
					var precision = this._getNumDigitsAfterDecimalPlace(percentage);
					precision = precision ? precision - 1 : 0;
					var percentageWithAdjustedPrecision = this._applyToFixedAndParseFloat(percentage, precision);
					if (this._state.dragged === 0 && this._applyToFixedAndParseFloat(this._state.percentage[1], precision) < percentageWithAdjustedPrecision) {
						this._state.percentage[0] = this._state.percentage[1];
						this._state.dragged = 1;
					} else if (this._state.dragged === 1 && this._applyToFixedAndParseFloat(this._state.percentage[0], precision) > percentageWithAdjustedPrecision) {
						this._state.percentage[1] = this._state.percentage[0];
						this._state.dragged = 0;
					}
				}
			},
			_mouseup: function _mouseup() {
				if (!this._state.enabled) {
					return false;
				}
				if (this.touchCapable) {
					// Touch: Unbind touch event handlers:
					document.removeEventListener("touchmove", this.mousemove, false);
					document.removeEventListener("touchend", this.mouseup, false);
				}
				// Unbind mouse event handlers:
				document.removeEventListener("mousemove", this.mousemove, false);
				document.removeEventListener("mouseup", this.mouseup, false);

				this._state.inDrag = false;
				if (this._state.over === false) {
					this._hideTooltip();
				}
				var val = this._calculateValue(true);

				this._layout();
				this._setDataVal(val);
				this._trigger('slideStop', val);

				return false;
			},
			_calculateValue: function _calculateValue(snapToClosestTick) {
				var val;
				if (this.options.range) {
					val = [this.options.min, this.options.max];
					if (this._state.percentage[0] !== 0) {
						val[0] = this._toValue(this._state.percentage[0]);
						val[0] = this._applyPrecision(val[0]);
					}
					if (this._state.percentage[1] !== 100) {
						val[1] = this._toValue(this._state.percentage[1]);
						val[1] = this._applyPrecision(val[1]);
					}
				} else {
					val = this._toValue(this._state.percentage[0]);
					val = parseFloat(val);
					val = this._applyPrecision(val);
				}

				if (snapToClosestTick) {
					var min = [val, Infinity];
					for (var i = 0; i < this.options.ticks.length; i++) {
						var diff = Math.abs(this.options.ticks[i] - val);
						if (diff <= min[1]) {
							min = [this.options.ticks[i], diff];
						}
					}
					if (min[1] <= this.options.ticks_snap_bounds) {
						return min[0];
					}
				}

				return val;
			},
			_applyPrecision: function _applyPrecision(val) {
				var precision = this.options.precision || this._getNumDigitsAfterDecimalPlace(this.options.step);
				return this._applyToFixedAndParseFloat(val, precision);
			},
			_getNumDigitsAfterDecimalPlace: function _getNumDigitsAfterDecimalPlace(num) {
				var match = ('' + num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
				if (!match) {
					return 0;
				}
				return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
			},
			_applyToFixedAndParseFloat: function _applyToFixedAndParseFloat(num, toFixedInput) {
				var truncatedNum = num.toFixed(toFixedInput);
				return parseFloat(truncatedNum);
			},
			/*
   	Credits to Mike Samuel for the following method!
   	Source: http://stackoverflow.com/questions/10454518/javascript-how-to-retrieve-the-number-of-decimals-of-a-string-number
   */
			_getPercentage: function _getPercentage(ev) {
				if (this.touchCapable && (ev.type === 'touchstart' || ev.type === 'touchmove')) {
					ev = ev.touches[0];
				}

				var eventPosition = ev[this.mousePos];
				var sliderOffset = this._state.offset[this.stylePos];
				var distanceToSlide = eventPosition - sliderOffset;
				// Calculate what percent of the length the slider handle has slid
				var percentage = distanceToSlide / this._state.size * 100;
				percentage = Math.round(percentage / this._state.percentage[2]) * this._state.percentage[2];
				if (this.options.reversed) {
					percentage = 100 - percentage;
				}

				// Make sure the percent is within the bounds of the slider.
				// 0% corresponds to the 'min' value of the slide
				// 100% corresponds to the 'max' value of the slide
				return Math.max(0, Math.min(100, percentage));
			},
			_validateInputValue: function _validateInputValue(val) {
				if (typeof val === 'number') {
					return val;
				} else if (Array.isArray(val)) {
					this._validateArray(val);
					return val;
				} else {
					throw new Error(ErrorMsgs.formatInvalidInputErrorMsg(val));
				}
			},
			_validateArray: function _validateArray(val) {
				for (var i = 0; i < val.length; i++) {
					var input = val[i];
					if (typeof input !== 'number') {
						throw new Error(ErrorMsgs.formatInvalidInputErrorMsg(input));
					}
				}
			},
			_setDataVal: function _setDataVal(val) {
				this.element.setAttribute('data-value', val);
				this.element.setAttribute('value', val);
				this.element.value = val;
			},
			_trigger: function _trigger(evt, val) {
				val = val || val === 0 ? val : undefined;

				var callbackFnArray = this.eventToCallbackMap[evt];
				if (callbackFnArray && callbackFnArray.length) {
					for (var i = 0; i < callbackFnArray.length; i++) {
						var callbackFn = callbackFnArray[i];
						callbackFn(val);
					}
				}

				/* If JQuery exists, trigger JQuery events */
				if ($) {
					this._triggerJQueryEvent(evt, val);
				}
			},
			_triggerJQueryEvent: function _triggerJQueryEvent(evt, val) {
				var eventData = {
					type: evt,
					value: val
				};
				this.$element.trigger(eventData);
				this.$sliderElem.trigger(eventData);
			},
			_unbindJQueryEventHandlers: function _unbindJQueryEventHandlers() {
				this.$element.off();
				this.$sliderElem.off();
			},
			_setText: function _setText(element, text) {
				if (typeof element.innerText !== "undefined") {
					element.innerText = text;
				} else if (typeof element.textContent !== "undefined") {
					element.textContent = text;
				}
			},
			_removeClass: function _removeClass(element, classString) {
				var classes = classString.split(" ");
				var newClasses = element.className;

				for (var i = 0; i < classes.length; i++) {
					var classTag = classes[i];
					var regex = new RegExp("(?:\\s|^)" + classTag + "(?:\\s|$)");
					newClasses = newClasses.replace(regex, " ");
				}

				element.className = newClasses.trim();
			},
			_addClass: function _addClass(element, classString) {
				var classes = classString.split(" ");
				var newClasses = element.className;

				for (var i = 0; i < classes.length; i++) {
					var classTag = classes[i];
					var regex = new RegExp("(?:\\s|^)" + classTag + "(?:\\s|$)");
					var ifClassExists = regex.test(newClasses);

					if (!ifClassExists) {
						newClasses += " " + classTag;
					}
				}

				element.className = newClasses.trim();
			},
			_offsetLeft: function _offsetLeft(obj) {
				return obj.getBoundingClientRect().left;
			},
			_offsetTop: function _offsetTop(obj) {
				var offsetTop = obj.offsetTop;
				while ((obj = obj.offsetParent) && !isNaN(obj.offsetTop)) {
					offsetTop += obj.offsetTop;
				}
				return offsetTop;
			},
			_offset: function _offset(obj) {
				return {
					left: this._offsetLeft(obj),
					top: this._offsetTop(obj)
				};
			},
			_css: function _css(elementRef, styleName, value) {
				if ($) {
					$.style(elementRef, styleName, value);
				} else {
					var style = styleName.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function (all, letter) {
						return letter.toUpperCase();
					});
					elementRef.style[style] = value;
				}
			},
			_toValue: function _toValue(percentage) {
				return this.options.scale.toValue.apply(this, [percentage]);
			},
			_toPercentage: function _toPercentage(value) {
				return this.options.scale.toPercentage.apply(this, [value]);
			},
			_setTooltipPosition: function _setTooltipPosition() {
				var tooltips = [this.tooltip, this.tooltip_min, this.tooltip_max];
				if (this.options.orientation === 'vertical') {
					var tooltipPos = this.options.tooltip_position || 'right';
					var oppositeSide = tooltipPos === 'left' ? 'right' : 'left';
					tooltips.forEach(function (tooltip) {
						this._addClass(tooltip, tooltipPos);
						tooltip.style[oppositeSide] = '100%';
					}.bind(this));
				} else if (this.options.tooltip_position === 'bottom') {
					tooltips.forEach(function (tooltip) {
						this._addClass(tooltip, 'bottom');
						tooltip.style.top = 22 + 'px';
					}.bind(this));
				} else {
					tooltips.forEach(function (tooltip) {
						this._addClass(tooltip, 'top');
						tooltip.style.top = -this.tooltip.outerHeight - 14 + 'px';
					}.bind(this));
				}
			}
		};

		/*********************************
  		Attach to global namespace
  	*********************************/
		if ($) {
			var namespace = $.fn.slider ? 'bootstrapSlider' : 'slider';
			$.bridget(namespace, Slider);
		}
	})($);

	return Slider;
});

},{"jquery":10}],4:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number') {
    length = +subject
  } else if (type === 'string') {
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length
  } else {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  if (length < 0)
    length = 0
  else
    length >>>= 0 // Coerce to uint32.

  var self = this
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    /*eslint-disable consistent-this */
    self = Buffer._augment(new Uint8Array(length))
    /*eslint-enable consistent-this */
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    self.length = length
    self._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    self._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        self[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        self[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    self.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      self[i] = 0
    }
  }

  if (length > 0 && length <= Buffer.poolSize)
    self.parent = rootParent

  return self
}

function SlowBuffer (subject, encoding, noZero) {
  if (!(this instanceof SlowBuffer))
    return new SlowBuffer(subject, encoding, noZero)

  var buf = new Buffer(subject, encoding, noZero)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  if (a === b) return 0

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0

  if (length < 0 || offset < 0 || offset > this.length)
    throw new RangeError('attempt to write outside buffer bounds')

  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length)
    newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100))
    val += this[offset + i] * mul

  return val
}

Buffer.prototype.readUIntBE = function (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkOffset(offset, byteLength, this.length)

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100))
    val += this[offset + --byteLength] * mul

  return val
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readIntLE = function (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100))
    val += this[offset + i] * mul
  mul *= 0x80

  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100))
    val += this[offset + --i] * mul
  mul *= 0x80

  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100))
    this[offset + i] = (value / mul) >>> 0 & 0xFF

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100))
    this[offset + i] = (value / mul) >>> 0 & 0xFF

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeIntLE = function (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(this,
             value,
             offset,
             byteLength,
             Math.pow(2, 8 * byteLength - 1) - 1,
             -Math.pow(2, 8 * byteLength - 1))
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100))
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(this,
             value,
             offset,
             byteLength,
             Math.pow(2, 8 * byteLength - 1) - 1,
             -Math.pow(2, 8 * byteLength - 1))
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100))
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var self = this // source

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (target_start >= target.length) target_start = target.length
  if (!target_start) target_start = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || self.length === 0) return 0

  // Fatal error conditions
  if (target_start < 0)
    throw new RangeError('targetStart out of bounds')
  if (start < 0 || start >= self.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":5,"ieee754":6,"is-array":7}],5:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],6:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],7:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],8:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],9:[function(require,module,exports){
(function (global,__dirname){
/*!
 * This file is part of Cytoscape.js 2.5.5.
 *
 * Cytoscape.js is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * Cytoscape.js is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with
 * Cytoscape.js. If not, see <http://www.gnu.org/licenses/>.
 */

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.cytoscape = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('./util');
var is = _dereq_('./is');
var Promise = _dereq_('./promise');

var Animation = function( target, opts, opts2 ){
  if( !(this instanceof Animation) ){
    return new Animation( target, opts, opts2 );
  }

  var _p = this._private = util.extend( {
    duration: 1000
  }, opts, opts2 );

  _p.target = target;
  _p.style = _p.style || _p.css;
  _p.started = false;
  _p.playing = false;
  _p.hooked = false;
  _p.applying = false;
  _p.progress = 0;
  _p.completes = [];
  _p.frames = [];

  if( _p.complete && is.fn(_p.complete) ){
    _p.completes.push( _p.complete );
  }

  // for future timeline/animations impl
  this.length = 1;
  this[0] = this;
};

var anifn = Animation.prototype;

util.extend( anifn, {

  instanceString: function(){ return 'animation'; },

  hook: function(){
    var _p = this._private;

    if( !_p.hooked ){
      // add to target's animation queue
      var q;
      var tAni = _p.target._private.animation;
      if( _p.queue ){
        q = tAni.queue;
      } else {
        q = tAni.current;
      }
      q.push( this );

      // add to the animation loop pool
      if( is.elementOrCollection( _p.target ) ){
        _p.target.cy().addToAnimationPool( _p.target );
      }

      _p.hooked = true;
    }

    return this;
  },

  play: function(){
    var _p = this._private;

    // autorewind
    if( _p.progress === 1 ){
      _p.progress = 0;
    }

    _p.playing = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will start the animation...

    return this;
  },

  playing: function(){
    return this._private.playing;
  },

  apply: function(){
    var _p = this._private;

    _p.applying = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will apply the animation at this progress

    return this;
  },

  applying: function(){
    return this._private.applying;
  },

  pause: function(){
    var _p = this._private;

    _p.playing = false;
    _p.started = false;

    return this;
  },

  stop: function(){
    var _p = this._private;

    _p.playing = false;
    _p.started = false;
    _p.stopped = true; // to be removed from animation queues

    return this;
  },

  rewind: function(){
    return this.progress(0);
  },

  fastforward: function(){
    return this.progress(1);
  },

  time: function( t ){
    var _p = this._private;

    if( t === undefined ){
      return _p.progress * _p.duration;
    } else {
      return this.progress( t / _p.duration );
    }
  },

  progress: function( p ){
    var _p = this._private;
    var wasPlaying = _p.playing;

    if( p === undefined ){
      return _p.progress;
    } else {
      if( wasPlaying ){
        this.pause();
      }

      _p.progress = p;
      _p.started = false;

      if( wasPlaying ){
        this.play();
      }
    }

    return this;
  },

  completed: function(){
    return this._private.progress === 1;
  },

  reverse: function(){
    var _p = this._private;
    var wasPlaying = _p.playing;

    if( wasPlaying ){
      this.pause();
    }

    _p.progress = 1 - _p.progress;
    _p.started = false;

    var swap = function( a, b ){
      var _pa = _p[a];

      _p[a] = _p[b];
      _p[b] = _pa;
    };

    swap( 'zoom', 'startZoom' );
    swap( 'pan', 'startPan' );
    swap( 'position', 'startPosition' );

    // swap styles
    for( var i = 0; i < _p.style.length; i++ ){
      var prop = _p.style[i];
      var name = prop.name;
      var startStyleProp = _p.startStyle[ name ];

      _p.startStyle[ name ] = _p.startStyle[ util.dash2camel( name ) ] = prop;
      _p.style[i] = startStyleProp;
    }

    if( wasPlaying ){
      this.play();
    }

    return this;
  },

  promise: function( type ){
    var _p = this._private;

    var arr;

    switch( type ){
      case 'frame':
        arr = _p.frames;
        break;
      default:
      case 'complete':
      case 'completed':
        arr = _p.completes;
    }

    return new Promise(function( resolve, reject ){
      arr.push(function(){
        resolve();
      });
    });
  }

} );

anifn.complete = anifn.completed;

module.exports = Animation;

},{"./is":77,"./promise":80,"./util":94}],2:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  aStar: function(options) {
    var eles = this;

    options = options || {};

    // Reconstructs the path from Start to End, acumulating the result in pathAcum
    var reconstructPath = function(start, end, cameFromMap, pathAcum) {
      // Base case
      if (start == end) {
        pathAcum.push( cy.getElementById(end) );
        return pathAcum;
      }

      if (end in cameFromMap) {
        // We know which node is before the last one
        var previous = cameFromMap[end];
        var previousEdge = cameFromEdge[end];

        pathAcum.push( cy.getElementById(end) );
        pathAcum.push( cy.getElementById(previousEdge) );


        return reconstructPath(start,
                     previous,
                     cameFromMap,
                     pathAcum);
      }

      // We should not reach here!
      return undefined;
    };

    // Returns the index of the element in openSet which has minimum fScore
    var findMin = function(openSet, fScore) {
      if (openSet.length === 0) {
        // Should never be the case
        return undefined;
      }
      var minPos = 0;
      var tempScore = fScore[openSet[0]];
      for (var i = 1; i < openSet.length; i++) {
        var s = fScore[openSet[i]];
        if (s < tempScore) {
          tempScore = s;
          minPos = i;
        }
      }
      return minPos;
    };

    var cy = this._private.cy;

    // root - mandatory!
    if (options != null && options.root != null) {
      var source = is.string(options.root) ?
        // use it as a selector, e.g. "#rootID
        this.filter(options.root)[0] :
        options.root[0];
    } else {
      return undefined;
    }

    // goal - mandatory!
    if (options.goal != null) {
      var target = is.string(options.goal) ?
        // use it as a selector, e.g. "#goalID
        this.filter(options.goal)[0] :
        options.goal[0];
    } else {
      return undefined;
    }

    // Heuristic function - optional
    if (options.heuristic != null && is.fn(options.heuristic)) {
      var heuristic = options.heuristic;
    } else {
      var heuristic = function(){ return 0; }; // use constant if unspecified
    }

    // Weight function - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function(e) {return 1;};
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var closedSet = [];
    var openSet = [source.id()];
    var cameFrom = {};
    var cameFromEdge = {};
    var gScore = {};
    var fScore = {};

    gScore[source.id()] = 0;
    fScore[source.id()] = heuristic(source);

    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
    var nodes = this.nodes();

    // Counter
    var steps = 0;

    // Main loop
    while (openSet.length > 0) {
      var minPos = findMin(openSet, fScore);
      var cMin = cy.getElementById( openSet[minPos] );
      steps++;

      // If we've found our goal, then we are done
      if (cMin.id() == target.id()) {
        var rPath = reconstructPath(source.id(), target.id(), cameFrom, []);
        rPath.reverse();
        return {
          found : true,
          distance : gScore[cMin.id()],
          path : eles.spawn(rPath),
          steps : steps
        };
      }

      // Add cMin to processed nodes
      closedSet.push(cMin.id());
      // Remove cMin from boundary nodes
      openSet.splice(minPos, 1);

      // Update scores for neighbors of cMin
      // Take into account if graph is directed or not
      var vwEdges = cMin.connectedEdges();
      if( directed ){ vwEdges = vwEdges.stdFilter(function(ele){ return ele.data('source') === cMin.id(); }); }
      vwEdges = vwEdges.intersect(edges);

      for (var i = 0; i < vwEdges.length; i++) {
        var e = vwEdges[i];
        var w = e.connectedNodes().stdFilter(function(n){ return n.id() !== cMin.id(); }).intersect(nodes);

        // if node is in closedSet, ignore it
        if (closedSet.indexOf(w.id()) != -1) {
          continue;
        }

        // New tentative score for node w
        var tempScore = gScore[cMin.id()] + weightFn.apply(e, [e]);

        // Update gScore for node w if:
        //   w not present in openSet
        // OR
        //   tentative gScore is less than previous value

        // w not in openSet
        if (openSet.indexOf(w.id()) == -1) {
          gScore[w.id()] = tempScore;
          fScore[w.id()] = tempScore + heuristic(w);
          openSet.push(w.id()); // Add node to openSet
          cameFrom[w.id()] = cMin.id();
          cameFromEdge[w.id()] = e.id();
          continue;
        }
        // w already in openSet, but with greater gScore
        if (tempScore < gScore[w.id()]) {
          gScore[w.id()] = tempScore;
          fScore[w.id()] = tempScore + heuristic(w);
          cameFrom[w.id()] = cMin.id();
        }

      } // End of neighbors update

    } // End of main loop

    // If we've reached here, then we've not reached our goal
    return {
      found : false,
      distance : undefined,
      path : undefined,
      steps : steps
    };
  }

}); // elesfn


module.exports = elesfn;

},{"../../is":77}],3:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');
var util = _dereq_('../../util');

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  bellmanFord: function(options) {
    var eles = this;

    options = options || {};

    // Weight function - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function(e) {return 1;};
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // root - mandatory!
    if (options.root != null) {
      if (is.string(options.root)) {
        // use it as a selector, e.g. "#rootID
        var source = this.filter(options.root)[0];
      } else {
        var source = options.root[0];
      }
    } else {
      return undefined;
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Initializations
    var cost = [];
    var predecessor = [];
    var predEdge = [];

    for (var i = 0; i < numNodes; i++) {
      if (nodes[i].id() === source.id()) {
        cost[i] = 0;
      } else {
        cost[i] = Infinity;
      }
      predecessor[i] = undefined;
    }

    // Edges relaxation
    var flag = false;
    for (var i = 1; i < numNodes; i++) {
      flag = false;
      for (var e = 0; e < edges.length; e++) {
        var sourceIndex = id2position[edges[e].source().id()];
        var targetIndex = id2position[edges[e].target().id()];
        var weight = weightFn.apply(edges[e], [edges[e]]);

        var temp = cost[sourceIndex] + weight;
        if (temp < cost[targetIndex]) {
          cost[targetIndex] = temp;
          predecessor[targetIndex] = sourceIndex;
          predEdge[targetIndex] = edges[e];
          flag = true;
        }

        // If undirected graph, we need to take into account the 'reverse' edge
        if (!directed) {
          var temp = cost[targetIndex] + weight;
          if (temp < cost[sourceIndex]) {
            cost[sourceIndex] = temp;
            predecessor[sourceIndex] = targetIndex;
            predEdge[sourceIndex] = edges[e];
            flag = true;
          }
        }
      }

      if (!flag) {
        break;
      }
    }

    if (flag) {
      // Check for negative weight cycles
      for (var e = 0; e < edges.length; e++) {
        var sourceIndex = id2position[edges[e].source().id()];
        var targetIndex = id2position[edges[e].target().id()];
        var weight = weightFn.apply(edges[e], [edges[e]]);

        if (cost[sourceIndex] + weight < cost[targetIndex]) {
          util.error("Graph contains a negative weight cycle for Bellman-Ford");
          return { pathTo: undefined,
               distanceTo: undefined,
               hasNegativeWeightCycle: true};
        }
      }
    }

    // Build result object
    var position2id = [];
    for (var i = 0; i < numNodes; i++) {
      position2id.push(nodes[i].id());
    }


    var res = {
      distanceTo : function(to) {
        if (is.string(to)) {
          // to is a selector string
          var toId = (cy.filter(to)[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return cost[id2position[toId]];
      },

      pathTo : function(to) {

        var reconstructPathAux = function(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {
          for(;;){
            // Add toId to path
            acumPath.push( cy.getElementById(position2id[toPos]) );
            acumPath.push( predEdge[toPos] );

            if (fromPos === toPos) {
              // reached starting node
              return acumPath;
            }

            // If no path exists, discart acumulated path and return undefined
            var predPos = predecessor[toPos];
            if (typeof predPos === "undefined") {
              return undefined;
            }

            toPos = predPos;
          }

        };

        if (is.string(to)) {
          // to is a selector string
          var toId = (cy.filter(to)[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }
        var path = [];

        // This returns a reversed path
        var res =  reconstructPathAux(predecessor,
                      id2position[source.id()],
                      id2position[toId],
                      position2id,
                      path,
                      predEdge);

        // Get it in the correct order and return it
        if (res != null) {
          res.reverse();
        }

        return eles.spawn(res);
      },

      hasNegativeWeightCycle: false
    };

    return res;

  } // bellmanFord

}); // elesfn

module.exports = elesfn;

},{"../../is":77,"../../util":94}],4:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');

var elesfn = ({

  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function (options) {
    options = options || {};

    // Weight - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
      var weighted = true;
    } else {
      var weighted = false;
    }

    // Directed - default false
    if (options.directed != null && is.bool(options.directed)) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var priorityInsert = function (queue, ele) {
      queue.unshift(ele);
      for (var i = 0; d[queue[i]] < d[queue[i + 1]] && i < queue.length - 1; i++) {
        var tmp = queue[i];
        queue[i] = queue[i + 1];
        queue[i + 1] = tmp;
      }
    };

    var cy = this._private.cy;

    // starting
    var V = this.nodes();
    var A = {};
    var C = {};

    // A contains the neighborhoods of every node
    for (var i = 0; i < V.length; i++) {
      if (directed) {
        A[V[i].id()] = V[i].outgoers("node"); // get outgoers of every node
      } else {
        A[V[i].id()] = V[i].openNeighborhood("node"); // get neighbors of every node
      }
    }

    // C contains the betweenness values
    for (var i = 0; i < V.length; i++) {
      C[V[i].id()] = 0;
    }

    for (var s = 0; s < V.length; s++) {
      var S = []; // stack
      var P = {};
      var g = {};
      var d = {};
      var Q = []; // queue

      // init dictionaries
      for (var i = 0; i < V.length; i++) {
        P[V[i].id()] = [];
        g[V[i].id()] = 0;
        d[V[i].id()] = Number.POSITIVE_INFINITY;
      }

      g[V[s].id()] = 1; // sigma
      d[V[s].id()] = 0; // distance to s

      Q.unshift(V[s].id());

      while (Q.length > 0) {
        var v = Q.pop();
        S.push(v);
        if (weighted) {
          A[v].forEach(function (w) {
            if (cy.$('#' + v).edgesTo(w).length > 0) {
              var edge = cy.$('#' + v).edgesTo(w)[0];
            } else {
              var edge = w.edgesTo('#' + v)[0];
            }

            var edgeWeight = weightFn.apply(edge, [edge]);

            if (d[w.id()] > d[v] + edgeWeight) {
              d[w.id()] = d[v] + edgeWeight;
              if (Q.indexOf(w.id()) < 0) { //if w is not in Q
                priorityInsert(Q, w.id());
              } else { // update position if w is in Q
                Q.splice(Q.indexOf(w.id()), 1);
                priorityInsert(Q, w.id());
              }
              g[w.id()] = 0;
              P[w.id()] = [];
            }
            if (d[w.id()] == d[v] + edgeWeight) {
              g[w.id()] = g[w.id()] + g[v];
              P[w.id()].push(v);
            }
          });
        } else {
          A[v].forEach(function (w) {
            if (d[w.id()] == Number.POSITIVE_INFINITY) {
              Q.unshift(w.id());
              d[w.id()] = d[v] + 1;
            }
            if (d[w.id()] == d[v] + 1) {
              g[w.id()] = g[w.id()] + g[v];
              P[w.id()].push(v);
            }
          });
        }
      }

      var e = {};
      for (var i = 0; i < V.length; i++) {
        e[V[i].id()] = 0;
      }

      while (S.length > 0) {
        var w = S.pop();
        P[w].forEach(function (v) {
          e[v] = e[v] + (g[v] / g[w]) * (1 + e[w]);
          if (w != V[s].id())
            C[w] = C[w] + e[w];
        });
      }
    }

    var max = 0;
    for (var key in C) {
      if (max < C[key])
        max = C[key];
    }

    var ret = {
      betweenness: function (node) {
        if (is.string(node)) {
          var node = (cy.filter(node)[0]).id();
        } else {
          var node = node.id();
        }

        return C[node];
      },

      betweennessNormalized: function (node) {
        if (is.string(node)) {
          var node = (cy.filter(node)[0]).id();
        } else {
          var node = node.id();
        }

        return C[node] / max;
      }
    };

    // alias
    ret.betweennessNormalised = ret.betweennessNormalized;

    return ret;
  } // betweennessCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.bc = elesfn.betweennessCentrality;

module.exports = elesfn;

},{"../../is":77}],5:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');
var Heap = _dereq_('../../heap');

var defineSearch = function( params ){
  params = {
    bfs: params.bfs || !params.dfs,
    dfs: params.dfs || !params.bfs
  };

  // from pseudocode on wikipedia
  return function searchFn( roots, fn, directed ){
    var options;
    var std;
    var thisArg;
    if( is.plainObject(roots) && !is.elementOrCollection(roots) ){
      options = roots;
      roots = options.roots || options.root;
      fn = options.visit;
      directed = options.directed;
      std = options.std;
      thisArg = options.thisArg;
    }

    directed = arguments.length === 2 && !is.fn(fn) ? fn : directed;
    fn = is.fn(fn) ? fn : function(){};

    var cy = this._private.cy;
    var v = roots = is.string(roots) ? this.filter(roots) : roots;
    var Q = [];
    var connectedNodes = [];
    var connectedBy = {};
    var id2depth = {};
    var V = {};
    var j = 0;
    var found;
    var nodes = this.nodes();
    var edges = this.edges();

    // enqueue v
    for( var i = 0; i < v.length; i++ ){
      if( v[i].isNode() ){
        Q.unshift( v[i] );

        if( params.bfs ){
          V[ v[i].id() ] = true;

          connectedNodes.push( v[i] );
        }

        id2depth[ v[i].id() ] = 0;
      }
    }

    while( Q.length !== 0 ){
      var v = params.bfs ? Q.shift() : Q.pop();

      if( params.dfs ){
        if( V[ v.id() ] ){ continue; }

        V[ v.id() ] = true;

        connectedNodes.push( v );
      }

      var depth = id2depth[ v.id() ];
      var prevEdge = connectedBy[ v.id() ];
      var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
      var ret;

      if( std ){
        ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
      } else {
        ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
      }

      if( ret === true ){
        found = v;
        break;
      }

      if( ret === false ){
        break;
      }

      var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
      for( var i = 0; i < vwEdges.length; i++ ){
        var e = vwEdges[i];
        var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );

        if( w.length !== 0 && !V[ w.id() ] ){
          w = w[0];

          Q.push( w );

          if( params.bfs ){
            V[ w.id() ] = true;

            connectedNodes.push( w );
          }

          connectedBy[ w.id() ] = e;

          id2depth[ w.id() ] = id2depth[ v.id() ] + 1;
        }
      }

    }

    var connectedEles = [];

    for( var i = 0; i < connectedNodes.length; i++ ){
      var node = connectedNodes[i];
      var edge = connectedBy[ node.id() ];

      if( edge ){
        connectedEles.push( edge );
      }

      connectedEles.push( node );
    }

    return {
      path: cy.collection( connectedEles, { unique: true } ),
      found: cy.collection( found )
    };
  };
};

// search, spanning trees, etc
var elesfn = ({

  breadthFirstSearch: defineSearch({ bfs: true }),
  depthFirstSearch: defineSearch({ dfs: true }),

  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function( weightFn ){
    var cy = this.cy();

    weightFn = is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

    function findSet(ele){
      for( var i = 0; i < forest.length; i++ ){
        var eles = forest[i];

        if( eles.anySame(ele) ){
          return {
            eles: eles,
            index: i
          };
        }
      }
    }

    var A = cy.collection(cy, []);
    var forest = [];
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      forest.push( nodes[i].collection() );
    }

    var edges = this.edges();
    var S = edges.toArray().sort(function(a, b){
      var weightA = weightFn.call(a, a);
      var weightB = weightFn.call(b, b);

      return weightA - weightB;
    });

    for(var i = 0; i < S.length; i++){
      var edge = S[i];
      var u = edge.source()[0];
      var v = edge.target()[0];
      var setU = findSet(u);
      var setV = findSet(v);

      if( setU.index !== setV.index ){
        A = A.add( edge );

        // combine forests for u and v
        forest[ setU.index ] = setU.eles.add( setV.eles );
        forest.splice( setV.index, 1 );
      }
    }

    return nodes.add( A );

  },

  dijkstra: function( root, weightFn, directed ){
    var options;
    if( is.plainObject(root) && !is.elementOrCollection(root) ){
      options = root;
      root = options.root;
      weightFn = options.weight;
      directed = options.directed;
    }

    var cy = this._private.cy;
    weightFn = is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

    var source = is.string(root) ? this.filter(root)[0] : root[0];
    var dist = {};
    var prev = {};
    var knownDist = {};

    var edges = this.edges().filter(function(){ return !this.isLoop(); });
    var nodes = this.nodes();

    var getDist = function(node){
      return dist[ node.id() ];
    };

    var setDist = function(node, d){
      dist[ node.id() ] = d;

      Q.updateItem( node );
    };

    var Q = new Heap(function( a, b ){
      return getDist(a) - getDist(b);
    });

    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];

      dist[ node.id() ] = node.same( source ) ? 0 : Infinity;
      Q.push( node );
    }

    var distBetween = function(u, v){
      var uvs = ( directed ? u.edgesTo(v) : u.edgesWith(v) ).intersect(edges);
      var smallestDistance = Infinity;
      var smallestEdge;

      for( var i = 0; i < uvs.length; i++ ){
        var edge = uvs[i];
        var weight = weightFn.apply( edge, [edge] );

        if( weight < smallestDistance || !smallestEdge ){
          smallestDistance = weight;
          smallestEdge = edge;
        }
      }

      return {
        edge: smallestEdge,
        dist: smallestDistance
      };
    };

    while( Q.size() > 0 ){
      var u = Q.pop();
      var smalletsDist = getDist(u);
      var uid = u.id();

      knownDist[uid] = smalletsDist;

      if( smalletsDist === Math.Infinite ){
        break;
      }

      var neighbors = u.neighborhood().intersect(nodes);
      for( var i = 0; i < neighbors.length; i++ ){
        var v = neighbors[i];
        var vid = v.id();
        var vDist = distBetween(u, v);

        var alt = smalletsDist + vDist.dist;

        if( alt < getDist(v) ){
          setDist(v, alt);

          prev[ vid ] = {
            node: u,
            edge: vDist.edge
          };
        }
      } // for
    } // while

    return {
      distanceTo: function(node){
        var target = is.string(node) ? nodes.filter(node)[0] : node[0];

        return knownDist[ target.id() ];
      },

      pathTo: function(node){
        var target = is.string(node) ? nodes.filter(node)[0] : node[0];
        var S = [];
        var u = target;

        if( target.length > 0 ){
          S.unshift( target );

          while( prev[ u.id() ] ){
            var p = prev[ u.id() ];

            S.unshift( p.edge );
            S.unshift( p.node );

            u = p.node;
          }
        }

        return cy.collection( S );
      }
    };
  }
});

// nice, short mathemathical alias
elesfn.bfs = elesfn.breadthFirstSearch;
elesfn.dfs = elesfn.depthFirstSearch;

module.exports = elesfn;

},{"../../heap":75,"../../is":77}],6:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');

var elesfn = ({

  closenessCentralityNormalized: function (options) {
    options = options || {};

    var cy = this.cy();

    var harmonic = options.harmonic;
    if( harmonic === undefined ){
      harmonic = true;
    }

    var closenesses = {};
    var maxCloseness = 0;
    var nodes = this.nodes();
    var fw = this.floydWarshall({ weight: options.weight, directed: options.directed });

    // Compute closeness for every node and find the maximum closeness
    for(var i = 0; i < nodes.length; i++){
      var currCloseness = 0;
      for (var j = 0; j < nodes.length; j++) {
        if (i != j) {
          var d = fw.distance(nodes[i], nodes[j]);

          if( harmonic ){
            currCloseness += 1 / d;
          } else {
            currCloseness += d;
          }
        }
      }

      if( !harmonic ){
        currCloseness = 1 / currCloseness;
      }

      if (maxCloseness < currCloseness){
        maxCloseness = currCloseness;
      }

      closenesses[nodes[i].id()] = currCloseness;
    }

    return {
      closeness: function (node) {
        if (is.string(node)) {
          // from is a selector string
          var node = (cy.filter(node)[0]).id();
        } else {
          // from is a node
          var node = node.id();
        }

        return closenesses[node] / maxCloseness;
      }
    };
  },

  // Implemented from pseudocode from wikipedia
  closenessCentrality: function (options) {
    options = options || {};

    // root - mandatory!
    if (options.root != null) {
      if (is.string(options.root)) {
        // use it as a selector, e.g. "#rootID
        var root = this.filter(options.root)[0];
      } else {
        var root = options.root[0];
      }
    } else {
      return undefined;
    }

    // weight - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weight = options.weight;
    } else {
      var weight = function(){return 1;};
    }

    // directed - optional
    if (options.directed != null && is.bool(options.directed)) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var harmonic = options.harmonic;
    if( harmonic === undefined ){
      harmonic = true;
    }

    // we need distance from this node to every other node
    var dijkstra = this.dijkstra({
      root: root,
      weight: weight,
      directed: directed
    });
    var totalDistance = 0;

    var nodes = this.nodes();
    for (var i = 0; i < nodes.length; i++){
      if (nodes[i].id() != root.id()){
        var d = dijkstra.distanceTo(nodes[i]);

        if( harmonic ){
          totalDistance += 1 / d;
        } else {
          totalDistance += d;
        }
      }
    }

    return harmonic ? totalDistance : 1 / totalDistance;
  } // closenessCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.cc = elesfn.closenessCentrality;
elesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;

module.exports = elesfn;

},{"../../is":77}],7:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');
var util = _dereq_('../../util');

var elesfn = ({

  degreeCentralityNormalized: function (options) {
    options = options || {};

    var cy = this.cy();

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var nodes = this.nodes();
    var numNodes = nodes.length;

    if (!directed) {
      var degrees = {};
      var maxDegree = 0;

      for (var i = 0; i < numNodes; i++) {
        var node = nodes[i];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality(util.extend({}, options, {root: node}));
        if (maxDegree < currDegree.degree)
          maxDegree = currDegree.degree;

        degrees[node.id()] = currDegree.degree;
      }

      return {
        degree: function (node) {
          if (is.string(node)) {
            // from is a selector string
            var node = (cy.filter(node)[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return degrees[node] / maxDegree;
        }
      };
    } else {
      var indegrees = {};
      var outdegrees = {};
      var maxIndegree = 0;
      var maxOutdegree = 0;

      for (var i = 0; i < numNodes; i++) {
        var node = nodes[i];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality(util.extend({}, options, {root: node}));

        if (maxIndegree < currDegree.indegree)
          maxIndegree = currDegree.indegree;

        if (maxOutdegree < currDegree.outdegree)
          maxOutdegree = currDegree.outdegree;

        indegrees[node.id()] = currDegree.indegree;
        outdegrees[node.id()] = currDegree.outdegree;
      }

      return {
        indegree: function (node) {
          if (is.string(node)) {
            // from is a selector string
            var node = (cy.filter(node)[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return indegrees[node] / maxIndegree;
        },
        outdegree: function (node) {
          if (is.string(node)) {
            // from is a selector string
            var node = (cy.filter(node)[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return outdegrees[node] / maxOutdegree;
        }

      };
    }

  }, // degreeCentralityNormalized

  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function (options) {
    options = options || {};

    var callingEles = this;

    // root - mandatory!
    if (options != null && options.root != null) {
      var root = is.string(options.root) ? this.filter(options.root)[0] : options.root[0];
    } else {
      return undefined;
    }

    // weight - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function (e) {
        return 1;
      };
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // alpha - optional
    if (options.alpha != null && is.number(options.alpha)) {
      var alpha = options.alpha;
    } else {
      alpha = 0;
    }


    if (!directed) {
      var connEdges = root.connectedEdges().intersection( callingEles );
      var k = connEdges.length;
      var s = 0;

      // Now, sum edge weights
      for (var i = 0; i < connEdges.length; i++) {
        var edge = connEdges[i];
        s += weightFn.apply(edge, [edge]);
      }

      return {
        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
      };
    } else {
      var incoming = root.connectedEdges('edge[target = "' + root.id() + '"]').intersection( callingEles );
      var outgoing = root.connectedEdges('edge[source = "' + root.id() + '"]').intersection( callingEles );
      var k_in = incoming.length;
      var k_out = outgoing.length;
      var s_in = 0;
      var s_out = 0;

      // Now, sum incoming edge weights
      for (var i = 0; i < incoming.length; i++) {
        var edge = incoming[i];
        s_in += weightFn.apply(edge, [edge]);
      }

      // Now, sum outgoing edge weights
      for (var i = 0; i < outgoing.length; i++) {
        var edge = outgoing[i];
        s_out += weightFn.apply(edge, [edge]);
      }

      return {
        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
      };
    }
  } // degreeCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.dc = elesfn.degreeCentrality;
elesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;

module.exports = elesfn;

},{"../../is":77,"../../util":94}],8:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  floydWarshall: function(options) {
    options = options || {};

    var cy = this.cy();

    // Weight function - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function(e) {return 1;};
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Initialize distance matrix
    var dist = [];
    for (var i = 0; i < numNodes; i++) {
      var newRow = new Array(numNodes);
      for (var j = 0; j < numNodes; j++) {
        if (i == j) {
          newRow[j] = 0;
        } else {
          newRow[j] = Infinity;
        }
      }
      dist.push(newRow);
    }

    // Initialize matrix used for path reconstruction
    // Initialize distance matrix
    var next = [];
    var edgeNext = [];

    var initMatrix = function(next){
      for (var i = 0; i < numNodes; i++) {
        var newRow = new Array(numNodes);
        for (var j = 0; j < numNodes; j++) {
          newRow[j] = undefined;
        }
        next.push(newRow);
      }
    };

    initMatrix(next);
    initMatrix(edgeNext);

    // Process edges
    for (var i = 0; i < edges.length ; i++) {
      var sourceIndex = id2position[edges[i].source().id()];
      var targetIndex = id2position[edges[i].target().id()];
      var weight = weightFn.apply(edges[i], [edges[i]]);

      // Check if already process another edge between same 2 nodes
      if (dist[sourceIndex][targetIndex] > weight) {
        dist[sourceIndex][targetIndex] = weight;
        next[sourceIndex][targetIndex] = targetIndex;
        edgeNext[sourceIndex][targetIndex] = edges[i];
      }
    }

    // If undirected graph, process 'reversed' edges
    if (!directed) {
      for (var i = 0; i < edges.length ; i++) {
        var sourceIndex = id2position[edges[i].target().id()];
        var targetIndex = id2position[edges[i].source().id()];
        var weight = weightFn.apply(edges[i], [edges[i]]);

        // Check if already process another edge between same 2 nodes
        if (dist[sourceIndex][targetIndex] > weight) {
          dist[sourceIndex][targetIndex] = weight;
          next[sourceIndex][targetIndex] = targetIndex;
          edgeNext[sourceIndex][targetIndex] = edges[i];
        }
      }
    }

    // Main loop
    for (var k = 0; k < numNodes; k++) {
      for (var i = 0; i < numNodes; i++) {
        for (var j = 0; j < numNodes; j++) {
          if (dist[i][k] + dist[k][j] < dist[i][j]) {
            dist[i][j] = dist[i][k] + dist[k][j];
            next[i][j] = next[i][k];
          }
        }
      }
    }

    // Build result object
    var position2id = [];
    for (var i = 0; i < numNodes; i++) {
      position2id.push(nodes[i].id());
    }

    var res = {
      distance: function(from, to) {
        if (is.string(from)) {
          // from is a selector string
          var fromId = (cy.filter(from)[0]).id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if (is.string(to)) {
          // to is a selector string
          var toId = (cy.filter(to)[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return dist[id2position[fromId]][id2position[toId]];
      },

      path: function(from, to) {
        var reconstructPathAux = function(from, to, next, position2id, edgeNext) {
          if (from === to) {
            return cy.getElementById( position2id[from] );
          }
          if (next[from][to] === undefined) {
            return undefined;
          }

          var path = [ cy.getElementById(position2id[from]) ];
          var prev = from;
          while (from !== to) {
            prev = from;
            from = next[from][to];

            var edge = edgeNext[prev][from];
            path.push( edge );

            path.push( cy.getElementById(position2id[from]) );
          }
          return path;
        };

        if (is.string(from)) {
          // from is a selector string
          var fromId = (cy.filter(from)[0]).id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if (is.string(to)) {
          // to is a selector string
          var toId = (cy.filter(to)[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        var pathArr = reconstructPathAux(id2position[fromId],
                      id2position[toId],
                      next,
                      position2id,
                      edgeNext);

        return cy.collection( pathArr );
      }
    };

    return res;

  } // floydWarshall

}); // elesfn

module.exports = elesfn;

},{"../../is":77}],9:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');

var elesfn = {};

[
  _dereq_('./bfs-dfs'),
  _dereq_('./a-star'),
  _dereq_('./floyd-warshall'),
  _dereq_('./bellman-ford'),
  _dereq_('./kerger-stein'),
  _dereq_('./page-rank'),
  _dereq_('./degree-centrality'),
  _dereq_('./closeness-centrality'),
  _dereq_('./betweenness-centrality')
].forEach(function( props ){
  util.extend( elesfn, props );
});

module.exports = elesfn;

},{"../../util":94,"./a-star":2,"./bellman-ford":3,"./betweenness-centrality":4,"./bfs-dfs":5,"./closeness-centrality":6,"./degree-centrality":7,"./floyd-warshall":8,"./kerger-stein":10,"./page-rank":11}],10:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');

var elesfn = ({

  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function(options) {
    var eles = this;

    options = options || {};

    // Function which colapses 2 (meta) nodes into one
    // Updates the remaining edge lists
    // Receives as a paramater the edge which causes the collapse
    var colapse = function(edgeIndex, nodeMap, remainingEdges) {
      var edgeInfo = remainingEdges[edgeIndex];
      var sourceIn = edgeInfo[1];
      var targetIn = edgeInfo[2];
      var partition1 = nodeMap[sourceIn];
      var partition2 = nodeMap[targetIn];

      // Delete all edges between partition1 and partition2
      var newEdges = remainingEdges.filter(function(edge) {
        if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {
          return false;
        }
        if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {
          return false;
        }
        return true;
      });

      // All edges pointing to partition2 should now point to partition1
      for (var i = 0; i < newEdges.length; i++) {
        var edge = newEdges[i];
        if (edge[1] === partition2) { // Check source
          newEdges[i] = edge.slice(0);
          newEdges[i][1] = partition1;
        } else if (edge[2] === partition2) { // Check target
          newEdges[i] = edge.slice(0);
          newEdges[i][2] = partition1;
        }
      }

      // Move all nodes from partition2 to partition1
      for (var i = 0; i < nodeMap.length; i++) {
        if (nodeMap[i] === partition2) {
          nodeMap[i] = partition1;
        }
      }

      return newEdges;
    };


    // Contracts a graph until we reach a certain number of meta nodes
    var contractUntil = function(metaNodeMap,
                   remainingEdges,
                   size,
                   sizeLimit) {
      // Stop condition
      if (size <= sizeLimit) {
        return remainingEdges;
      }

      // Choose an edge randomly
      var edgeIndex = Math.floor((Math.random() * remainingEdges.length));

      // Colapse graph based on edge
      var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);

      return contractUntil(metaNodeMap,
                 newEdges,
                 size - 1,
                 sizeLimit);
    };

    var cy = this._private.cy;
    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;
    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
    var stopSize = Math.floor(numNodes / Math.sqrt(2));

    if (numNodes < 2) {
      util.error("At least 2 nodes are required for Karger-Stein algorithm");
      return undefined;
    }

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Now store edge destination as indexes
    // Format for each edge (edge index, source node index, target node index)
    var edgeIndexes = [];
    for (var i = 0; i < numEdges; i++) {
      var e = edges[i];
      edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);
    }

    // We will store the best cut found here
    var minCutSize = Infinity;
    var minCut;

    // Initial meta node partition
    var originalMetaNode = [];
    for (var i = 0; i < numNodes; i++) {
      originalMetaNode.push(i);
    }

    // Main loop
    for (var iter = 0; iter <= numIter; iter++) {
      // Create new meta node partition
      var metaNodeMap = originalMetaNode.slice(0);

      // Contract until stop point (stopSize nodes)
      var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);

      // Create a copy of the colapsed nodes state
      var metaNodeMap2 = metaNodeMap.slice(0);

      // Run 2 iterations starting in the stop state
      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
      var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);

      // Is any of the 2 results the best cut so far?
      if (res1.length <= res2.length && res1.length < minCutSize) {
        minCutSize = res1.length;
        minCut = [res1, metaNodeMap];
      } else if (res2.length <= res1.length && res2.length < minCutSize) {
        minCutSize = res2.length;
        minCut = [res2, metaNodeMap2];
      }
    } // end of main loop


    // Construct result
    var resEdges = (minCut[0]).map(function(e){ return edges[e[0]]; });
    var partition1 = [];
    var partition2 = [];

    // traverse metaNodeMap for best cut
    var witnessNodePartition = minCut[1][0];
    for (var i = 0; i < minCut[1].length; i++) {
      var partitionId = minCut[1][i];
      if (partitionId === witnessNodePartition) {
        partition1.push(nodes[i]);
      } else {
        partition2.push(nodes[i]);
      }
    }

    var ret = {
      cut: eles.spawn(cy, resEdges),
      partition1: eles.spawn(partition1),
      partition2: eles.spawn(partition2)
    };

    return ret;
  }
}); // elesfn


module.exports = elesfn;

},{"../../util":94}],11:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');

var elesfn = ({

  pageRank: function(options) {
    options = options || {};

    var normalizeVector = function(vector) {
      var length = vector.length;

      // First, get sum of all elements
      var total = 0;
      for (var i = 0; i < length; i++) {
        total += vector[i];
      }

      // Now, divide each by the sum of all elements
      for (var i = 0; i < length; i++) {
        vector[i] = vector[i] / total;
      }
    };

    // dampingFactor - optional
    if (options != null &&
      options.dampingFactor != null) {
      var dampingFactor = options.dampingFactor;
    } else {
      var dampingFactor = 0.8; // Default damping factor
    }

    // desired precision - optional
    if (options != null &&
      options.precision != null) {
      var epsilon = options.precision;
    } else {
      var epsilon = 0.000001; // Default precision
    }

    // Max number of iterations - optional
    if (options != null &&
      options.iterations != null) {
      var numIter = options.iterations;
    } else {
      var numIter = 200; // Default number of iterations
    }

    // Weight function - optional
    if (options != null &&
      options.weight != null &&
      is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function(e) {return 1;};
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Construct transposed adjacency matrix
    // First lets have a zeroed matrix of the right size
    // We'll also keep track of the sum of each column
    var matrix = [];
    var columnSum = [];
    var additionalProb = (1 - dampingFactor) / numNodes;

    // Create null matric
    for (var i = 0; i < numNodes; i++) {
      var newRow = [];
      for (var j = 0; j < numNodes; j++) {
        newRow.push(0.0);
      }
      matrix.push(newRow);
      columnSum.push(0.0);
    }

    // Now, process edges
    for (var i = 0; i < numEdges; i++) {
      var edge = edges[i];
      var s = id2position[edge.source().id()];
      var t = id2position[edge.target().id()];
      var w = weightFn.apply(edge, [edge]);

      // Update matrix
      matrix[t][s] += w;

      // Update column sum
      columnSum[s] += w;
    }

    // Add additional probability based on damping factor
    // Also, take into account columns that have sum = 0
    var p = 1.0 / numNodes + additionalProb; // Shorthand
    // Traverse matrix, column by column
    for (var j = 0; j < numNodes; j++) {
      if (columnSum[j] === 0) {
        // No 'links' out from node jth, assume equal probability for each possible node
        for (var i = 0; i < numNodes; i++) {
          matrix[i][j] = p;
        }
      } else {
        // Node jth has outgoing link, compute normalized probabilities
        for (var i = 0; i < numNodes; i++) {
          matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;
        }
      }
    }

    // Compute dominant eigenvector using power method
    var eigenvector = [];
    var nullVector = [];
    var previous;

    // Start with a vector of all 1's
    // Also, initialize a null vector which will be used as shorthand
    for (var i = 0; i < numNodes; i++) {
      eigenvector.push(1.0);
      nullVector.push(0.0);
    }

    for (var iter = 0; iter < numIter; iter++) {
      // New array with all 0's
      var temp = nullVector.slice(0);

      // Multiply matrix with previous result
      for (var i = 0; i < numNodes; i++) {
        for (var j = 0; j < numNodes; j++) {
          temp[i] += matrix[i][j] * eigenvector[j];
        }
      }

      normalizeVector(temp);
      previous = eigenvector;
      eigenvector = temp;

      var diff = 0;
      // Compute difference (squared module) of both vectors
      for (var i = 0; i < numNodes; i++) {
        diff += Math.pow(previous[i] - eigenvector[i], 2);
      }

      // If difference is less than the desired threshold, stop iterating
      if (diff < epsilon) {
        break;
      }
    }

    // Construct result
    var res = {
      rank : function(node) {
        if (is.string(node)) {
          // is a selector string
          var nodeId = (cy.filter(node)[0]).id();
        } else {
          // is a node object
          var nodeId = node.id();
        }
        return eigenvector[id2position[nodeId]];
      }
    };


    return res;
  } // pageRank

}); // elesfn

module.exports = elesfn;

},{"../../is":77}],12:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('../define');

var elesfn = ({
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop()
});

module.exports = elesfn;

},{"../define":41}],13:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');

var elesfn = ({
  classes: function( classes ){
    classes = classes.match(/\S+/g) || [];
    var self = this;
    var changed = [];
    var classesMap = {};

    // fill in classes map
    for( var i = 0; i < classes.length; i++ ){
      var cls = classes[i];

      classesMap[ cls ] = true;
    }

    // check and update each ele
    for( var j = 0; j < self.length; j++ ){
      var ele = self[j];
      var _p = ele._private;
      var eleClasses = _p.classes;
      var changedEle = false;

      // check if ele has all of the passed classes
      for( var i = 0; i < classes.length; i++ ){
        var cls = classes[i];
        var eleHasClass = eleClasses[ cls ];

        if( !eleHasClass ){
          changedEle = true;
          break;
        }
      }

      // check if ele has classes outside of those passed
      if( !changedEle ){ for( var eleCls in eleClasses ){
        var eleHasClass = eleClasses[ eleCls ];
        var specdClass = classesMap[ eleCls ]; // i.e. this class is passed to the function

        if( eleHasClass && !specdClass ){
          changedEle = true;
          break;
        }
      } }

      if( changedEle ){
        _p.classes = util.copy( classesMap );

        changed.push( ele );
      }
    }

    // trigger update style on those eles that had class changes
    if( changed.length > 0 ){
      this.spawn(changed)
        .updateStyle()
        .trigger('class')
      ;
    }

    return self;
  },

  addClass: function( classes ){
    return this.toggleClass( classes, true );
  },

  hasClass: function( className ){
    var ele = this[0];
    return ( ele != null && ele._private.classes[className] ) ? true : false;
  },

  toggleClass: function( classesStr, toggle ){
    var classes = classesStr.match(/\S+/g) || [];
    var self = this;
    var changed = []; // eles who had classes changed

    for( var i = 0, il = self.length; i < il; i++ ){
      var ele = self[i];
      var changedEle = false;

      for( var j = 0; j < classes.length; j++ ){
        var cls = classes[j];
        var eleClasses = ele._private.classes;
        var hasClass = eleClasses[cls];
        var shouldAdd = toggle || (toggle === undefined && !hasClass);

        if( shouldAdd ){
          eleClasses[cls] = true;

          if( !hasClass && !changedEle ){
            changed.push(ele);
            changedEle = true;
          }
        } else { // then remove
          eleClasses[cls] = false;

          if( hasClass && !changedEle ){
            changed.push(ele);
            changedEle = true;
          }
        }

      } // for j classes
    } // for i eles

    // trigger update style on those eles that had class changes
    if( changed.length > 0 ){
      this.spawn(changed)
        .updateStyle()
        .trigger('class')
      ;
    }

    return self;
  },

  removeClass: function( classes ){
    return this.toggleClass( classes, false );
  },

  flashClass: function( classes, duration ){
    var self = this;

    if( duration == null ){
      duration = 250;
    } else if( duration === 0 ){
      return self; // nothing to do really
    }

    self.addClass( classes );
    setTimeout(function(){
      self.removeClass( classes );
    }, duration);

    return self;
  }
});

module.exports = elesfn;

},{"../util":94}],14:[function(_dereq_,module,exports){
'use strict';

var elesfn = ({
  allAre: function( selector ){
    return this.filter(selector).length === this.length;
  },

  is: function( selector ){
    return this.filter(selector).length > 0;
  },

  some: function( fn, thisArg ){
    for( var i = 0; i < this.length; i++ ){
      var ret = !thisArg ? fn( this[i], i, this ) : fn.apply( thisArg, [ this[i], i, this ] );

      if( ret ){
        return true;
      }
    }

    return false;
  },

  every: function( fn, thisArg ){
    for( var i = 0; i < this.length; i++ ){
      var ret = !thisArg ? fn( this[i], i, this ) : fn.apply( thisArg, [ this[i], i, this ] );

      if( !ret ){
        return false;
      }
    }

    return true;
  },

  same: function( collection ){
    collection = this.cy().collection( collection );

    // cheap extra check
    if( this.length !== collection.length ){
      return false;
    }

    return this.intersect( collection ).length === this.length;
  },

  anySame: function( collection ){
    collection = this.cy().collection( collection );

    return this.intersect( collection ).length > 0;
  },

  allAreNeighbors: function( collection ){
    collection = this.cy().collection( collection );

    return this.neighborhood().intersect( collection ).length === collection.length;
  }
});

elesfn.allAreNeighbours = elesfn.allAreNeighbors;

module.exports = elesfn;

},{}],15:[function(_dereq_,module,exports){
'use strict';

var elesfn = ({
  parent: function( selector ){
    var parents = [];
    var cy = this._private.cy;

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var parent = cy.getElementById( ele._private.data.parent );

      if( parent.size() > 0 ){
        parents.push( parent );
      }
    }

    return this.spawn( parents, { unique: true } ).filter( selector );
  },

  parents: function( selector ){
    var parents = [];

    var eles = this.parent();
    while( eles.nonempty() ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        parents.push( ele );
      }

      eles = eles.parent();
    }

    return this.spawn( parents, { unique: true } ).filter( selector );
  },

  commonAncestors: function( selector ){
    var ancestors;

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var parents = ele.parents();

      ancestors = ancestors || parents;

      ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set
    }

    return ancestors.filter( selector );
  },

  orphans: function( selector ){
    return this.stdFilter(function( ele ){
      return ele.isNode() && ele.parent().empty();
    }).filter( selector );
  },

  nonorphans: function( selector ){
    return this.stdFilter(function( ele ){
      return ele.isNode() && ele.parent().nonempty();
    }).filter( selector );
  },

  children: function( selector ){
    var children = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      children = children.concat( ele._private.children );
    }

    return this.spawn( children, { unique: true } ).filter( selector );
  },

  siblings: function( selector ){
    return this.parent().children().not( this ).filter( selector );
  },

  isParent: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.children.length !== 0;
    }
  },

  isChild: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.data.parent !== undefined && ele.parent().length !== 0;
    }
  },

  descendants: function( selector ){
    var elements = [];

    function add( eles ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        elements.push( ele );

        if( ele.children().nonempty() ){
          add( ele.children() );
        }
      }
    }

    add( this.children() );

    return this.spawn( elements, { unique: true } ).filter( selector );
  }
});

// aliases
elesfn.ancestors = elesfn.parents;

module.exports = elesfn;

},{}],16:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('../define');
var fn, elesfn;

fn = elesfn = ({

  data: define.data({
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),

  removeData: define.removeData({
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),

  scratch: define.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    updateStyle: true
  }),

  removeScratch: define.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true,
    updateStyle: true
  }),

  rscratch: define.data({
    field: 'rscratch',
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: true
  }),

  removeRscratch: define.removeData({
    field: 'rscratch',
    triggerEvent: false
  }),

  id: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.data.id;
    }
  }

});

// aliases
fn.attr = fn.data;
fn.removeAttr = fn.removeData;

module.exports = elesfn;

},{"../define":41}],17:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');

var elesfn = {};

function defineDegreeFunction(callback){
  return function( includeLoops ){
    var self = this;

    if( includeLoops === undefined ){
      includeLoops = true;
    }

    if( self.length === 0 ){ return; }

    if( self.isNode() && !self.removed() ){
      var degree = 0;
      var node = self[0];
      var connectedEdges = node._private.edges;

      for( var i = 0; i < connectedEdges.length; i++ ){
        var edge = connectedEdges[i];

        if( !includeLoops && edge.isLoop() ){
          continue;
        }

        degree += callback( node, edge );
      }

      return degree;
    } else {
      return;
    }
  };
}

util.extend(elesfn, {
  degree: defineDegreeFunction(function(node, edge){
    if( edge.source().same( edge.target() ) ){
      return 2;
    } else {
      return 1;
    }
  }),

  indegree: defineDegreeFunction(function(node, edge){
    if( edge.target().same(node) ){
      return 1;
    } else {
      return 0;
    }
  }),

  outdegree: defineDegreeFunction(function(node, edge){
    if( edge.source().same(node) ){
      return 1;
    } else {
      return 0;
    }
  })
});

function defineDegreeBoundsFunction(degreeFn, callback){
  return function( includeLoops ){
    var ret;
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      var ele = nodes[i];
      var degree = ele[degreeFn]( includeLoops );
      if( degree !== undefined && (ret === undefined || callback(degree, ret)) ){
        ret = degree;
      }
    }

    return ret;
  };
}

util.extend(elesfn, {
  minDegree: defineDegreeBoundsFunction('degree', function(degree, min){
    return degree < min;
  }),

  maxDegree: defineDegreeBoundsFunction('degree', function(degree, max){
    return degree > max;
  }),

  minIndegree: defineDegreeBoundsFunction('indegree', function(degree, min){
    return degree < min;
  }),

  maxIndegree: defineDegreeBoundsFunction('indegree', function(degree, max){
    return degree > max;
  }),

  minOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, min){
    return degree < min;
  }),

  maxOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, max){
    return degree > max;
  })
});

util.extend(elesfn, {
  totalDegree: function( includeLoops ){
    var total = 0;
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      total += nodes[i].degree( includeLoops );
    }

    return total;
  }
});

module.exports = elesfn;

},{"../util":94}],18:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('../define');
var is = _dereq_('../is');
var util = _dereq_('../util');
var fn, elesfn;

fn = elesfn = ({

  position: define.data({
    field: 'position',
    bindingEvent: 'position',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: true,
    triggerFnName: 'rtrigger',
    allowGetting: true,
    validKeys: ['x', 'y'],
    onSet: function( eles ){
      var updatedEles = eles.updateCompoundBounds();
      updatedEles.rtrigger('position');
    },
    canSet: function( ele ){
      return !ele.locked() && !ele.isParent();
    }
  }),

  // position but no notification to renderer
  silentPosition: define.data({
    field: 'position',
    bindingEvent: 'position',
    allowBinding: false,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: false,
    triggerFnName: 'trigger',
    allowGetting: true,
    validKeys: ['x', 'y'],
    onSet: function( eles ){
      eles.updateCompoundBounds();
    },
    canSet: function( ele ){
      return !ele.locked() && !ele.isParent();
    }
  }),

  positions: function( pos, silent ){
    if( is.plainObject(pos) ){
      this.position(pos);

    } else if( is.fn(pos) ){
      var fn = pos;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];

        var pos = fn.apply(ele, [i, ele]);

        if( pos && !ele.locked() && !ele.isParent() ){
          var elePos = ele._private.position;
          elePos.x = pos.x;
          elePos.y = pos.y;
        }
      }

      var updatedEles = this.updateCompoundBounds();
      var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;

      if( silent ){
        toTrigger.trigger('position');
      } else {
        toTrigger.rtrigger('position');
      }
    }

    return this; // chaining
  },

  silentPositions: function( pos ){
    return this.positions( pos, true );
  },

  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function( dim, val ){
    var ele = this[0];
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();
    var rpos = is.plainObject( dim ) ? dim : undefined;
    var setting = rpos !== undefined || ( val !== undefined && is.string(dim) );

    if( ele && ele.isNode() ){ // must have an element and must be a node to return position
      if( setting ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          if( val !== undefined ){ // set one dimension
            ele._private.position[dim] = ( val - pan[dim] )/zoom;
          } else if( rpos !== undefined ){ // set whole position
            ele._private.position = {
              x: ( rpos.x - pan.x ) /zoom,
              y: ( rpos.y - pan.y ) /zoom
            };
          }
        }

        this.rtrigger('position');
      } else { // getting
        var pos = ele._private.position;
        rpos = {
          x: pos.x * zoom + pan.x,
          y: pos.y * zoom + pan.y
        };

        if( dim === undefined ){ // then return the whole rendered position
          return rpos;
        } else { // then return the specified dimension
          return rpos[ dim ];
        }
      }
    } else if( !setting ){
      return undefined; // for empty collection case
    }

    return this; // chaining
  },

  // get/set the position relative to the parent
  relativePosition: function( dim, val ){
    var ele = this[0];
    var cy = this.cy();
    var ppos = is.plainObject( dim ) ? dim : undefined;
    var setting = ppos !== undefined || ( val !== undefined && is.string(dim) );
    var hasCompoundNodes = cy.hasCompoundNodes();

    if( ele && ele.isNode() ){ // must have an element and must be a node to return position
      if( setting ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];
          var parent = hasCompoundNodes ? ele.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if( hasParent ){
            parent = parent[0];
          }

          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

          if( val !== undefined ){ // set one dimension
            ele._private.position[dim] = val + origin[dim];
          } else if( ppos !== undefined ){ // set whole position
            ele._private.position = {
              x: ppos.x + origin.x,
              y: ppos.y + origin.y
            };
          }
        }

        this.rtrigger('position');

      } else { // getting
        var pos = ele._private.position;
        var parent = hasCompoundNodes ? ele.parent() : null;
        var hasParent = parent && parent.length > 0;
        var relativeToParent = hasParent;

        if( hasParent ){
          parent = parent[0];
        }

        var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

        ppos = {
          x: pos.x - origin.x,
          y: pos.y - origin.y
        };

        if( dim === undefined ){ // then return the whole rendered position
          return ppos;
        } else { // then return the specified dimension
          return ppos[ dim ];
        }
      }
    } else if( !setting ){
      return undefined; // for empty collection case
    }

    return this; // chaining
  },

  renderedBoundingBox: function( options ){
    var bb = this.boundingBox( options );
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();

    var x1 = bb.x1 * zoom + pan.x;
    var x2 = bb.x2 * zoom + pan.x;
    var y1 = bb.y1 * zoom + pan.y;
    var y2 = bb.y2 * zoom + pan.y;

    return {
      x1: x1,
      x2: x2,
      y1: y1,
      y2: y2,
      w: x2 - x1,
      h: y2 - y1
    };
  },

  updateCompoundBounds: function(){
    var cy = this.cy();

    if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); } // save cycles for non compound graphs or when style disabled

    var updated = [];

    function update( parent ){
      var children = parent.children();
      var style = parent._private.style;
      var includeLabels = style['compound-sizing-wrt-labels'].value === 'include';
      var bb = children.boundingBox({ includeLabels: includeLabels, includeEdges: true });
      var padding = {
        top: style['padding-top'].pfValue,
        bottom: style['padding-bottom'].pfValue,
        left: style['padding-left'].pfValue,
        right: style['padding-right'].pfValue
      };
      var pos = parent._private.position;
      var didUpdate = false;

      if( style['width'].value === 'auto' ){
        parent._private.autoWidth = bb.w;
        pos.x = (bb.x1 + bb.x2 - padding.left + padding.right)/2;
        didUpdate = true;
      }

      if( style['height'].value === 'auto' ){
        parent._private.autoHeight = bb.h;
        pos.y = (bb.y1 + bb.y2 - padding.top + padding.bottom)/2;
        didUpdate = true;
      }

      if( didUpdate ){
        updated.push( parent );
      }
    }

    // go up, level by level
    var eles = this.parent();
    while( eles.nonempty() ){

      // update each parent node in this level
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        update( ele );
      }

      // next level
      eles = eles.parent();
    }

    // return changed
    return this.spawn( updated );
  },

  // get the bounding box of the elements (in raw model position)
  boundingBox: function( options ){
    var eles = this;
    var cy = eles._private.cy;
    var cy_p = cy._private;
    var styleEnabled = cy_p.styleEnabled;

    options = options || util.staticEmptyObject();

    var includeNodes = options.includeNodes === undefined ? true : options.includeNodes;
    var includeEdges = options.includeEdges === undefined ? true : options.includeEdges;
    var includeLabels = options.includeLabels === undefined ? true : options.includeLabels;

    // recalculate projections etc
    if( styleEnabled ){
      cy_p.renderer.recalculateRenderedStyle( this );
    }

    var x1 = Infinity;
    var x2 = -Infinity;
    var y1 = Infinity;
    var y2 = -Infinity;

    // find bounds of elements
    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var _p = ele._private;
      var style = _p.style;
      var display = styleEnabled ? _p.style['display'].value : 'element';
      var isNode = _p.group === 'nodes';
      var ex1, ex2, ey1, ey2, x, y;
      var includedEle = false;

      if( display === 'none' ){ continue; } // then ele doesn't take up space

      if( isNode && includeNodes ){
        includedEle = true;

        var pos = _p.position;
        x = pos.x;
        y = pos.y;
        var w = ele.outerWidth();
        var halfW = w/2;
        var h = ele.outerHeight();
        var halfH = h/2;

        // handle node dimensions
        /////////////////////////

        ex1 = x - halfW;
        ex2 = x + halfW;
        ey1 = y - halfH;
        ey2 = y + halfH;

        x1 = ex1 < x1 ? ex1 : x1;
        x2 = ex2 > x2 ? ex2 : x2;
        y1 = ey1 < y1 ? ey1 : y1;
        y2 = ey2 > y2 ? ey2 : y2;

      } else if( ele.isEdge() && includeEdges ){
        includedEle = true;

        var n1 = _p.source;
        var n1_p = n1._private;
        var n1pos = n1_p.position;

        var n2 = _p.target;
        var n2_p = n2._private;
        var n2pos = n2_p.position;


        // handle edge dimensions (rough box estimate)
        //////////////////////////////////////////////

        var rstyle = _p.rstyle || {};
        var w = 0;
        var wHalf = 0;

        if( styleEnabled ){
          w = style['width'].pfValue;
          wHalf = w/2;
        }

        ex1 = n1pos.x;
        ex2 = n2pos.x;
        ey1 = n1pos.y;
        ey2 = n2pos.y;

        if( ex1 > ex2 ){
          var temp = ex1;
          ex1 = ex2;
          ex2 = temp;
        }

        if( ey1 > ey2 ){
          var temp = ey1;
          ey1 = ey2;
          ey2 = temp;
        }

        // take into account edge width
        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;

        x1 = ex1 < x1 ? ex1 : x1;
        x2 = ex2 > x2 ? ex2 : x2;
        y1 = ey1 < y1 ? ey1 : y1;
        y2 = ey2 > y2 ? ey2 : y2;

        // handle points along edge (sanity check)
        //////////////////////////////////////////

        if( styleEnabled ){
          var pts = rstyle.bezierPts || rstyle.linePts || [];

          for( var j = 0; j < pts.length; j++ ){
            var pt = pts[j];

            ex1 = pt.x - wHalf;
            ex2 = pt.x + wHalf;
            ey1 = pt.y - wHalf;
            ey2 = pt.y + wHalf;

            x1 = ex1 < x1 ? ex1 : x1;
            x2 = ex2 > x2 ? ex2 : x2;
            y1 = ey1 < y1 ? ey1 : y1;
            y2 = ey2 > y2 ? ey2 : y2;
          }
        }

        // precise haystacks (sanity check)
        ///////////////////////////////////

        if( styleEnabled && style['curve-style'].strValue === 'haystack' ){
          var hpts = rstyle.haystackPts;

          ex1 = hpts[0].x;
          ey1 = hpts[0].y;
          ex2 = hpts[1].x;
          ey2 = hpts[1].y;

          if( ex1 > ex2 ){
            var temp = ex1;
            ex1 = ex2;
            ex2 = temp;
          }

          if( ey1 > ey2 ){
            var temp = ey1;
            ey1 = ey2;
            ey2 = temp;
          }

          x1 = ex1 < x1 ? ex1 : x1;
          x2 = ex2 > x2 ? ex2 : x2;
          y1 = ey1 < y1 ? ey1 : y1;
          y2 = ey2 > y2 ? ey2 : y2;
        }

      } // edges


      // handle label dimensions
      //////////////////////////

      if( styleEnabled ){

        var _p = ele._private;
        var style = _p.style;
        var rstyle = _p.rstyle;
        var label = style['label'].strValue;
        var fontSize = style['font-size'];
        var halign = style['text-halign'];
        var valign = style['text-valign'];
        var labelWidth = rstyle.labelWidth;
        var labelHeight = rstyle.labelHeight;
        var labelX = rstyle.labelX;
        var labelY = rstyle.labelY;
        var isEdge = ele.isEdge();
        var autorotate = style['edge-text-rotation'].strValue === 'autorotate';

        if( includeLabels && label && fontSize && labelHeight != null && labelWidth != null && labelX != null && labelY != null && halign && valign ){
          var lh = labelHeight;
          var lw = labelWidth;
          var lx1, lx2, ly1, ly2;

          if( isEdge ){
            lx1 = labelX - lw/2;
            lx2 = labelX + lw/2;
            ly1 = labelY - lh/2;
            ly2 = labelY + lh/2;

            if( autorotate ){
              var theta = _p.rscratch.labelAngle;
              var cos = Math.cos( theta );
              var sin = Math.sin( theta );

              var rotate = function( x, y ){
                x = x - labelX;
                y = y - labelY;

                return {
                  x: x*cos - y*sin + labelX,
                  y: x*sin + y*cos + labelY
                };
              };

              var px1y1 = rotate( lx1, ly1 );
              var px1y2 = rotate( lx1, ly2 );
              var px2y1 = rotate( lx2, ly1 );
              var px2y2 = rotate( lx2, ly2 );

              lx1 = Math.min( px1y1.x, px1y2.x, px2y1.x, px2y2.x );
              lx2 = Math.max( px1y1.x, px1y2.x, px2y1.x, px2y2.x );
              ly1 = Math.min( px1y1.y, px1y2.y, px2y1.y, px2y2.y );
              ly2 = Math.max( px1y1.y, px1y2.y, px2y1.y, px2y2.y );
            }
          } else {
            switch( halign.value ){
              case 'left':
                lx1 = labelX - lw;
                lx2 = labelX;
                break;

              case 'center':
                lx1 = labelX - lw/2;
                lx2 = labelX + lw/2;
                break;

              case 'right':
                lx1 = labelX;
                lx2 = labelX + lw;
                break;
            }

            switch( valign.value ){
              case 'top':
                ly1 = labelY - lh;
                ly2 = labelY;
                break;

              case 'center':
                ly1 = labelY - lh/2;
                ly2 = labelY + lh/2;
                break;

              case 'bottom':
                ly1 = labelY;
                ly2 = labelY + lh;
                break;
            }
          }

          x1 = lx1 < x1 ? lx1 : x1;
          x2 = lx2 > x2 ? lx2 : x2;
          y1 = ly1 < y1 ? ly1 : y1;
          y2 = ly2 > y2 ? ly2 : y2;
        }
      } // style enabled for labels
    } // for

    var noninf = function(x){
      if( x === Infinity || x === -Infinity ){
        return 0;
      }

      return x;
    };

    x1 = noninf(x1);
    x2 = noninf(x2);
    y1 = noninf(y1);
    y2 = noninf(y2);

    return {
      x1: x1,
      x2: x2,
      y1: y1,
      y2: y2,
      w: x2 - x1,
      h: y2 - y1
    };
  }
});

var defineDimFns = function( opts ){
  opts.uppercaseName = util.capitalize( opts.name );
  opts.autoName = 'auto' + opts.uppercaseName;
  opts.labelName = 'label' + opts.uppercaseName;
  opts.outerName = 'outer' + opts.uppercaseName;
  opts.uppercaseOuterName = util.capitalize( opts.outerName );

  fn[ opts.name ] = function dimImpl(){
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if( ele ){
      if( styleEnabled ){
        var d = _p.style[ opts.name ];

        switch( d.strValue ){
          case 'auto':
            return _p[ opts.autoName ] || 0;
          case 'label':
            return _p.rstyle[ opts.labelName ] || 0;
          default:
            return d.pfValue;
        }
      } else {
        return 1;
      }
    }
  };

  fn[ 'outer' + opts.uppercaseName ] = function outerDimImpl(){
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if( ele ){
      if( styleEnabled ){
        var style = _p.style;
        var dim = ele[ opts.name ]();
        var border = style['border-width'].pfValue;
        var padding = style[ opts.paddings[0] ].pfValue + style[ opts.paddings[1] ].pfValue;

        return dim + border + padding;
      } else {
        return 1;
      }
    }
  };

  fn[ 'rendered' + opts.uppercaseName ] = function renderedDimImpl(){
    var ele = this[0];

    if( ele ){
      var d = ele[ opts.name ]();
      return d * this.cy().zoom();
    }
  };

  fn[ 'rendered' + opts.uppercaseOuterName ] = function renderedOuterDimImpl(){
    var ele = this[0];

    if( ele ){
      var od = ele[ opts.outerName ]();
      return od * this.cy().zoom();
    }
  };
};

defineDimFns({
  name: 'width',
  paddings: ['padding-left', 'padding-right']
});

defineDimFns({
  name: 'height',
  paddings: ['padding-top', 'padding-bottom']
});

// aliases
fn.modelPosition = fn.point = fn.position;
fn.modelPositions = fn.points = fn.positions;
fn.renderedPoint = fn.renderedPosition;
fn.relativePoint = fn.relativePosition;
fn.boundingbox = fn.boundingBox;
fn.renderedBoundingbox = fn.renderedBoundingBox;

module.exports = elesfn;

},{"../define":41,"../is":77,"../util":94}],19:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

// represents a node or an edge
var Element = function(cy, params, restore){
  if( !(this instanceof Element) ){
    return new Element(cy, params, restore);
  }

  var self = this;
  restore = (restore === undefined || restore ? true : false);

  if( cy === undefined || params === undefined || !is.core(cy) ){
    util.error('An element must have a core reference and parameters set');
    return;
  }

  var group = params.group;

  // try to automatically infer the group if unspecified
  if( group == null ){
    if( params.data.source != null && params.data.target != null ){
      group = 'edges';
    } else {
      group = 'nodes';
    }
  }

  // validate group
  if( group !== 'nodes' && group !== 'edges' ){
    util.error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');
    return;
  }

  // make the element array-like, just like a collection
  this.length = 1;
  this[0] = this;

  // NOTE: when something is added here, add also to ele.json()
  this._private = {
    cy: cy,
    single: true, // indicates this is an element
    data: params.data || {}, // data object
    position: params.position || {}, // (x, y) position pair
    autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: undefined,
    listeners: [], // array of bound listeners
    group: group, // string; 'nodes' or 'edges'
    style: {}, // properties as set by the style
    rstyle: {}, // properties for style sent from the renderer to the core
    styleCxts: [], // applied style contexts from the styler
    removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: params.selected ? true : false, // whether it's selected
    selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable
    locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
    grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed
    active: false, // whether the element is active from user interaction
    classes: {}, // map ( className => true )
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {}, // object in which the renderer can store information
    scratch: params.scratch || {}, // scratch objects
    edges: [], // array of connected edges
    children: [] // array of children
  };

  // renderedPosition overrides if specified
  if( params.renderedPosition ){
    var rpos = params.renderedPosition;
    var pan = cy.pan();
    var zoom = cy.zoom();

    this._private.position = {
      x: (rpos.x - pan.x)/zoom,
      y: (rpos.y - pan.y)/zoom
    };
  }

  if( is.string(params.classes) ){
    var classes = params.classes.split(/\s+/);
    for( var i = 0, l = classes.length; i < l; i++ ){
      var cls = classes[i];
      if( !cls || cls === '' ){ continue; }

      self._private.classes[cls] = true;
    }
  }

  if( params.style || params.css ){
    cy.style().applyBypass( this, params.style || params.css );
  }

  if( restore === undefined || restore ){
    this.restore();
  }

};

module.exports = Element;

},{"../is":77,"../util":94}],20:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('../define');

var elesfn = ({
  on: define.on(), // .on( events [, selector] [, data], handler)
  one: define.on({ unbindSelfOnTrigger: true }),
  once: define.on({ unbindAllBindersOnTrigger: true }),
  off: define.off(), // .off( events [, selector] [, handler] )
  trigger: define.trigger(), // .trigger( events [, extraParams] )

  rtrigger: function(event, extraParams){ // for internal use only
    if( this.length === 0 ){ return; } // empty collections don't need to notify anything

    // notify renderer
    this.cy().notify({
      type: event,
      collection: this
    });

    this.trigger(event, extraParams);
    return this;
  }
});

// aliases:
define.eventAliasesOn( elesfn );

module.exports = elesfn;

},{"../define":41}],21:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var Selector = _dereq_('../selector');

var elesfn = ({
  nodes: function( selector ){
    return this.filter(function(i, element){
      return element.isNode();
    }).filter(selector);
  },

  edges: function( selector ){
    return this.filter(function(i, element){
      return element.isEdge();
    }).filter(selector);
  },

  filter: function( filter ){
    if( is.fn(filter) ){
      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];

        if( filter.apply(ele, [i, ele]) ){
          elements.push(ele);
        }
      }

      return this.spawn(elements);

    } else if( is.string(filter) || is.elementOrCollection(filter) ){
      return Selector(filter).filter(this);

    } else if( filter === undefined ){
      return this;
    }

    return this.spawn(); // if not handled by above, give 'em an empty collection
  },

  not: function( toRemove ){
    if( !toRemove ){
      return this;
    } else {

      if( is.string( toRemove ) ){
        toRemove = this.filter( toRemove );
      }

      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        var element = this[i];

        var remove = toRemove._private.ids[ element.id() ];
        if( !remove ){
          elements.push( element );
        }
      }

      return this.spawn( elements );
    }

  },

  absoluteComplement: function(){
    var cy = this._private.cy;

    return cy.elements().not( this );
  },

  intersect: function( other ){
    // if a selector is specified, then filter by it instead
    if( is.string(other) ){
      var selector = other;
      return this.filter( selector );
    }

    var elements = [];
    var col1 = this;
    var col2 = other;
    var col1Smaller = this.length < other.length;
    // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;
    var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;
    var col = col1Smaller ? col1 : col2;

    for( var i = 0; i < col.length; i++ ){
      var id = col[i]._private.data.id;
      var ele = ids2[ id ];

      if( ele ){
        elements.push( ele );
      }
    }

    return this.spawn( elements );
  },

  xor: function( other ){
    var cy = this._private.cy;

    if( is.string(other) ){
      other = cy.$( other );
    }

    var elements = [];
    var col1 = this;
    var col2 = other;

    var add = function( col, other ){

      for( var i = 0; i < col.length; i++ ){
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other._private.ids[ id ];

        if( !inOther ){
          elements.push( ele );
        }
      }

    };

    add( col1, col2 );
    add( col2, col1 );

    return this.spawn( elements );
  },

  diff: function( other ){
    var cy = this._private.cy;

    if( is.string(other) ){
      other = cy.$( other );
    }

    var left = [];
    var right = [];
    var both = [];
    var col1 = this;
    var col2 = other;

    var add = function( col, other, retEles ){

      for( var i = 0; i < col.length; i++ ){
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other._private.ids[ id ];

        if( inOther ){
          both.push( ele );
        } else {
          retEles.push( ele );
        }
      }

    };

    add( col1, col2, left );
    add( col2, col1, right );

    return {
      left: this.spawn( left, { unique: true } ),
      right: this.spawn( right, { unique: true } ),
      both: this.spawn( both, { unique: true } )
    };
  },

  add: function( toAdd ){
    var cy = this._private.cy;

    if( !toAdd ){
      return this;
    }

    if( is.string(toAdd) ){
      var selector = toAdd;
      toAdd = cy.elements(selector);
    }

    var elements = [];

    for( var i = 0; i < this.length; i++ ){
      elements.push( this[i] );
    }

    for( var i = 0; i < toAdd.length; i++ ){

      var add = !this._private.ids[ toAdd[i].id() ];
      if( add ){
        elements.push( toAdd[i] );
      }
    }

    return this.spawn(elements);
  },

  // in place merge on calling collection
  merge: function( toAdd ){
    var _p = this._private;
    var cy = _p.cy;

    if( !toAdd ){
      return this;
    }

    if( is.string(toAdd) ){
      var selector = toAdd;
      toAdd = cy.elements(selector);
    }

    for( var i = 0; i < toAdd.length; i++ ){
      var toAddEle = toAdd[i];
      var id = toAddEle.id();
      var add = !_p.ids[ id ];

      if( add ){
        var index = this.length++;

        this[ index ] = toAddEle;
        _p.ids[ id ] = toAddEle;
        _p.indexes[ id ] = index;
      }
    }

    return this; // chaining
  },

  // remove single ele in place in calling collection
  unmergeOne: function( ele ){
    ele = ele[0];

    var _p = this._private;
    var id = ele.id();
    var i = _p.indexes[ id ];

    if( i == null ){
      return this; // no need to remove
    }

    // remove ele
    this[i] = undefined;
    _p.ids[ id ] = undefined;
    _p.indexes[ id ] = undefined;

    var unmergedLastEle = i === this.length - 1;

    // replace empty spot with last ele in collection
    if( this.length > 1 && !unmergedLastEle ){
      var lastEleI = this.length - 1;
      var lastEle = this[ lastEleI ];

      this[ lastEleI ] = undefined;
      this[i] = lastEle;
      _p.indexes[ lastEle.id() ] = i;
    }

    // the collection is now 1 ele smaller
    this.length--;

    return this;
  },

  // remove eles in place on calling collection
  unmerge: function( toRemove ){
    var cy = this._private.cy;

    if( !toRemove ){
      return this;
    }

    if( is.string(toRemove) ){
      var selector = toRemove;
      toRemove = cy.elements(selector);
    }

    for( var i = 0; i < toRemove.length; i++ ){
      this.unmergeOne( toRemove[i] );
    }

    return this; // chaining
  },

  map: function( mapFn, thisArg ){
    var arr = [];
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var ret = thisArg ? mapFn.apply( thisArg, [ele, i, eles] ) : mapFn( ele, i, eles );

      arr.push( ret );
    }

    return arr;
  },

  stdFilter: function( fn, thisArg ){
    var filterEles = [];
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var include = thisArg ? fn.apply( thisArg, [ele, i, eles] ) : fn( ele, i, eles );

      if( include ){
        filterEles.push( ele );
      }
    }

    return this.spawn( filterEles );
  },

  max: function( valFn, thisArg ){
    var max = -Infinity;
    var maxEle;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

      if( val > max ){
        max = val;
        maxEle = ele;
      }
    }

    return {
      value: max,
      ele: maxEle
    };
  },

  min: function( valFn, thisArg ){
    var min = Infinity;
    var minEle;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

      if( val < min ){
        min = val;
        minEle = ele;
      }
    }

    return {
      value: min,
      ele: minEle
    };
  }
});

// aliases
var fn = elesfn;
fn['u'] = fn['|'] = fn['+'] = fn.union = fn.or = fn.add;
fn['\\'] = fn['!'] = fn['-'] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;
fn['n'] = fn['&'] = fn['.'] = fn.and = fn.intersection = fn.intersect;
fn['^'] = fn['(+)'] = fn['(-)'] = fn.symmetricDifference = fn.symdiff = fn.xor;
fn.fnFilter = fn.filterFn = fn.stdFilter;
fn.complement = fn.abscomp = fn.absoluteComplement;

module.exports = elesfn;

},{"../is":77,"../selector":81}],22:[function(_dereq_,module,exports){
'use strict';

var elesfn = ({
  isNode: function(){
    return this.group() === 'nodes';
  },

  isEdge: function(){
    return this.group() === 'edges';
  },

  isLoop: function(){
    return this.isEdge() && this.source().id() === this.target().id();
  },

  isSimple: function(){
    return this.isEdge() && this.source().id() !== this.target().id();
  },

  group: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.group;
    }
  }
});


module.exports = elesfn;

},{}],23:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

var Element = _dereq_('./element');

// factory for generating edge ids when no id is specified for a new element
var idFactory = {
  prefix: 'ele',
  id: 0,
  generate: function(cy, element, tryThisId){
    var json = is.element( element ) ? element._private : element;
    var id = tryThisId != null ? tryThisId : this.prefix + this.id;

    if( cy.getElementById(id).empty() ){
      this.id++; // we've used the current id, so move it up
    } else { // otherwise keep trying successive unused ids
      while( !cy.getElementById(id).empty() ){
        id = this.prefix + ( ++this.id );
      }
    }

    return id;
  }
};

// represents a set of nodes, edges, or both together
var Collection = function(cy, elements, options){
  if( !(this instanceof Collection) ){
    return new Collection(cy, elements, options);
  }

  if( cy === undefined || !is.core(cy) ){
    util.error('A collection must have a reference to the core');
    return;
  }

  var ids = {};
  var indexes = {};
  var createdElements = false;

  if( !elements ){
    elements = [];
  } else if( elements.length > 0 && is.plainObject( elements[0] ) && !is.element( elements[0] ) ){
    createdElements = true;

    // make elements from json and restore all at once later
    var eles = [];
    var elesIds = {};

    for( var i = 0, l = elements.length; i < l; i++ ){
      var json = elements[i];

      if( json.data == null ){
        json.data = {};
      }

      var data = json.data;

      // make sure newly created elements have valid ids
      if( data.id == null ){
        data.id = idFactory.generate( cy, json );
      } else if( cy.getElementById( data.id ).length !== 0 || elesIds[ data.id ] ){
        continue; // can't create element if prior id already exists
      }

      var ele = new Element( cy, json, false );
      eles.push( ele );
      elesIds[ data.id ] = true;
    }

    elements = eles;
  }

  this.length = 0;

  for( var i = 0, l = elements.length; i < l; i++ ){
    var element = elements[i];
    if( !element ){  continue; }

    var id = element._private.data.id;

    if( !options || (options.unique && !ids[ id ] ) ){
      ids[ id ] = element;
      indexes[ id ] = this.length;

      this[ this.length ] = element;
      this.length++;
    }
  }

  this._private = {
    cy: cy,
    ids: ids,
    indexes: indexes
  };

  // restore the elements if we created them from json
  if( createdElements ){
    this.restore();
  }
};

// Functions
////////////////////////////////////////////////////////////////////////////////////////////////////

// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes
var elesfn = Element.prototype = Collection.prototype;

elesfn.instanceString = function(){
  return 'collection';
};

elesfn.spawn = function( cy, eles, opts ){
  if( !is.core(cy) ){ // cy is optional
    opts = eles;
    eles = cy;
    cy = this.cy();
  }

  return new Collection( cy, eles, opts );
};

elesfn.cy = function(){
  return this._private.cy;
};

elesfn.element = function(){
  return this[0];
};

elesfn.collection = function(){
  if( is.collection(this) ){
    return this;
  } else { // an element
    return new Collection( this._private.cy, [this] );
  }
};

elesfn.unique = function(){
  return new Collection( this._private.cy, this, { unique: true } );
};

elesfn.getElementById = function( id ){
  var cy = this._private.cy;
  var ele = this._private.ids[ id ];

  return ele ? ele : new Collection(cy); // get ele or empty collection
};

elesfn.json = function( obj ){
  var ele = this.element();
  var cy = this.cy();

  if( ele == null && obj ){ return this; } // can't set to no eles

  if( ele == null ){ return undefined; } // can't get from no eles

  var p = ele._private;

  if( is.plainObject(obj) ){ // set

    cy.startBatch();

    if( obj.data ){
      ele.data( obj.data );
    }

    if( obj.position ){
      ele.position( obj.position );
    }

    // ignore group -- immutable

    var checkSwitch = function( k, trueFnName, falseFnName ){
      var obj_k = obj[k];

      if( obj_k != null && obj_k !== p[k] ){
        if( obj_k ){
          ele[ trueFnName ]();
        } else {
          ele[ falseFnName ]();
        }
      }
    };

    checkSwitch( 'removed', 'remove', 'restore' );

    checkSwitch( 'selected', 'select', 'unselect' );

    checkSwitch( 'selectable', 'selectify', 'unselectify' );

    checkSwitch( 'locked', 'lock', 'unlock' );

    checkSwitch( 'grabbable', 'grabify', 'ungrabify' );

    if( obj.classes != null ){
      ele.classes( obj.classes );
    }

    cy.endBatch();

    return this;

  } else if( obj === undefined ){ // get

    var json = {
      data: util.copy( p.data ),
      position: util.copy( p.position ),
      group: p.group,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbable: p.grabbable,
      classes: null
    };

    var classes = [];
    for( var cls in p.classes ){
      if( p.classes[cls] ){
        classes.push(cls);
      }
    }
    json.classes = classes.join(' ');

    return json;
  }
};

elesfn.jsons = function(){
  var jsons = [];

  for( var i = 0; i < this.length; i++ ){
    var ele = this[i];
    var json = ele.json();

    jsons.push( json );
  }

  return jsons;
};

elesfn.clone = function(){
  var cy = this.cy();
  var elesArr = [];

  for( var i = 0; i < this.length; i++ ){
    var ele = this[i];
    var json = ele.json();
    var clone = new Element(cy, json, false); // NB no restore

    elesArr.push( clone );
  }

  return new Collection( cy, elesArr );
};
elesfn.copy = elesfn.clone;

elesfn.restore = function( notifyRenderer ){
  var self = this;
  var restored = [];
  var cy = self.cy();

  if( notifyRenderer === undefined ){
    notifyRenderer = true;
  }

  // create arrays of nodes and edges, since we need to
  // restore the nodes first
  var elements = [];
  var nodes = [], edges = [];
  var numNodes = 0;
  var numEdges = 0;
  for( var i = 0, l = self.length; i < l; i++ ){
    var ele = self[i];

    // keep nodes first in the array and edges after
    if( ele.isNode() ){ // put to front of array if node
      nodes.push( ele );
      numNodes++;
    } else { // put to end of array if edge
      edges.push( ele );
      numEdges++;
    }
  }

  elements = nodes.concat( edges );

  // now, restore each element
  for( var i = 0, l = elements.length; i < l; i++ ){
    var ele = elements[i];

    if( !ele.removed() ){
      // don't need to do anything
      continue;
    }

    var _private = ele._private;
    var data = _private.data;

    // set id and validate
    if( data.id === undefined ){
      data.id = idFactory.generate( cy, ele );

    } else if( is.number(data.id) ){
      data.id = '' + data.id; // now it's a string

    } else if( is.emptyString(data.id) || !is.string(data.id) ){
      util.error('Can not create element with invalid string ID `' + data.id + '`');

      // can't create element if it has empty string as id or non-string id
      continue;
    } else if( cy.getElementById( data.id ).length !== 0 ){
      util.error('Can not create second element with ID `' + data.id + '`');

      // can't create element if one already has that id
      continue;
    }

    var id = data.id; // id is finalised, now let's keep a ref

    if( ele.isNode() ){ // extra checks for nodes
      var node = ele;
      var pos = _private.position;

      // make sure the nodes have a defined position

      if( pos.x == null ){
        pos.x = 0;
      }

      if( pos.y == null ){
        pos.y = 0;
      }
    }

    if( ele.isEdge() ){ // extra checks for edges

      var edge = ele;
      var fields = ['source', 'target'];
      var fieldsLength = fields.length;
      var badSourceOrTarget = false;
      for(var j = 0; j < fieldsLength; j++){

        var field = fields[j];
        var val = data[field];

        if( is.number(val) ){
          val = data[field] = '' + data[field]; // now string
        }

        if( val == null || val === '' ){
          // can't create if source or target is not defined properly
          util.error('Can not create edge `' + id + '` with unspecified ' + field);
          badSourceOrTarget = true;
        } else if( cy.getElementById(val).empty() ){
          // can't create edge if one of its nodes doesn't exist
          util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
          badSourceOrTarget = true;
        }
      }

      if( badSourceOrTarget ){ continue; } // can't create this

      var src = cy.getElementById( data.source );
      var tgt = cy.getElementById( data.target );

      src._private.edges.push( edge );
      tgt._private.edges.push( edge );

      edge._private.source = src;
      edge._private.target = tgt;

    } // if is edge

    // create mock ids map for element so it can be used like collections
    _private.ids = {};
    _private.ids[ id ] = ele;

    _private.removed = false;
    cy.addToPool( ele );

    restored.push( ele );
  } // for each element

  // do compound node sanity checks
  for( var i = 0; i < numNodes; i++ ){ // each node
    var node = elements[i];
    var data = node._private.data;

    if( is.number(data.parent) ){ // then automake string
      data.parent = '' + data.parent;
    }

    var parentId = data.parent;

    var specifiedParent = parentId != null;

    if( specifiedParent ){
      var parent = cy.getElementById( parentId );

      if( parent.empty() ){
        // non-existant parent; just remove it
        data.parent = undefined;
      } else {
        var selfAsParent = false;
        var ancestor = parent;
        while( !ancestor.empty() ){
          if( node.same(ancestor) ){
            // mark self as parent and remove from data
            selfAsParent = true;
            data.parent = undefined; // remove parent reference

            // exit or we loop forever
            break;
          }

          ancestor = ancestor.parent();
        }

        if( !selfAsParent ){
          // connect with children
          parent[0]._private.children.push( node );
          node._private.parent = parent[0];

          // let the core know we have a compound graph
          cy._private.hasCompoundNodes = true;
        }
      } // else
    } // if specified parent
  } // for each node

  restored = new Collection( cy, restored );
  if( restored.length > 0 ){

    var toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );
    toUpdateStyle.updateStyle( notifyRenderer );

    if( notifyRenderer ){
      restored.rtrigger('add');
    } else {
      restored.trigger('add');
    }
  }

  return self; // chainability
};

elesfn.removed = function(){
  var ele = this[0];
  return ele && ele._private.removed;
};

elesfn.inside = function(){
  var ele = this[0];
  return ele && !ele._private.removed;
};

elesfn.remove = function( notifyRenderer ){
  var self = this;
  var removed = [];
  var elesToRemove = [];
  var elesToRemoveIds = {};
  var cy = self._private.cy;

  if( notifyRenderer === undefined ){
    notifyRenderer = true;
  }

  // add connected edges
  function addConnectedEdges(node){
    var edges = node._private.edges;
    for( var i = 0; i < edges.length; i++ ){
      add( edges[i] );
    }
  }


  // add descendant nodes
  function addChildren(node){
    var children = node._private.children;

    for( var i = 0; i < children.length; i++ ){
      add( children[i] );
    }
  }

  function add( ele ){
    var alreadyAdded =  elesToRemoveIds[ ele.id() ];
    if( alreadyAdded ){
      return;
    } else {
      elesToRemoveIds[ ele.id() ] = true;
    }

    if( ele.isNode() ){
      elesToRemove.push( ele ); // nodes are removed last

      addConnectedEdges( ele );
      addChildren( ele );
    } else {
      elesToRemove.unshift( ele ); // edges are removed first
    }
  }

  // make the list of elements to remove
  // (may be removing more than specified due to connected edges etc)

  for( var i = 0, l = self.length; i < l; i++ ){
    var ele = self[i];

    add( ele );
  }

  function removeEdgeRef(node, edge){
    var connectedEdges = node._private.edges;
    for( var j = 0; j < connectedEdges.length; j++ ){
      var connectedEdge = connectedEdges[j];

      if( edge === connectedEdge ){
        connectedEdges.splice( j, 1 );
        break;
      }
    }
  }

  function removeChildRef(parent, ele){
    ele = ele[0];
    parent = parent[0];
    var children = parent._private.children;

    for( var j = 0; j < children.length; j++ ){
      if( children[j][0] === ele[0] ){
        children.splice(j, 1);
        break;
      }
    }
  }

  for( var i = 0; i < elesToRemove.length; i++ ){
    var ele = elesToRemove[i];

    // mark as removed
    ele._private.removed = true;

    // remove from core pool
    cy.removeFromPool( ele );

    // add to list of removed elements
    removed.push( ele );

    if( ele.isEdge() ){ // remove references to this edge in its connected nodes
      var src = ele.source()[0];
      var tgt = ele.target()[0];

      removeEdgeRef( src, ele );
      removeEdgeRef( tgt, ele );

    } else { // remove reference to parent
      var parent = ele.parent();

      if( parent.length !== 0 ){
        removeChildRef(parent, ele);
      }
    }
  }

  // check to see if we have a compound graph or not
  var elesStillInside = cy._private.elements;
  cy._private.hasCompoundNodes = false;
  for( var i = 0; i < elesStillInside.length; i++ ){
    var ele = elesStillInside[i];

    if( ele.isParent() ){
      cy._private.hasCompoundNodes = true;
      break;
    }
  }

  var removedElements = new Collection( this.cy(), removed );
  if( removedElements.size() > 0 ){
    // must manually notify since trigger won't do this automatically once removed

    if( notifyRenderer ){
      this.cy().notify({
        type: 'remove',
        collection: removedElements
      });
    }

    removedElements.trigger('remove');
  }

  // check for empty remaining parent nodes
  var checkedParentId = {};
  for( var i = 0; i < elesToRemove.length; i++ ){
    var ele = elesToRemove[i];
    var isNode = ele._private.group === 'nodes';
    var parentId = ele._private.data.parent;

    if( isNode && parentId !== undefined && !checkedParentId[ parentId ] ){
      checkedParentId[ parentId ] = true;
      var parent = cy.getElementById( parentId );

      if( parent && parent.length !== 0 && !parent._private.removed && parent.children().length === 0 ){
        parent.updateStyle();
      }
    }
  }

  return new Collection( cy, removed );
};

elesfn.move = function( struct ){
  var cy = this._private.cy;

  if( struct.source !== undefined || struct.target !== undefined ){
    var srcId = struct.source;
    var tgtId = struct.target;
    var srcExists = cy.getElementById( srcId ).length > 0;
    var tgtExists = cy.getElementById( tgtId ).length > 0;

    if( srcExists || tgtExists ){
      var jsons = this.jsons();

      this.remove();

      for( var i = 0; i < jsons.length; i++ ){
        var json = jsons[i];

        if( json.group === 'edges' ){
          if( srcExists ){ json.data.source = srcId; }
          if( tgtExists ){ json.data.target = tgtId; }
        }
      }

      return cy.add( jsons );
    }

  } else if( struct.parent !== undefined ){ // move node to new parent
    var parentId = struct.parent;
    var parentExists = parentId === null || cy.getElementById( parentId ).length > 0;

    if( parentExists ){
      var jsons = this.jsons();
      var descs = this.descendants();
      var descsEtc = descs.merge( descs.add(this).connectedEdges() );

      this.remove(); // NB: also removes descendants and their connected edges

      for( var i = 0; i < this.length; i++ ){
        var json = jsons[i];

        if( json.group === 'nodes' ){
          json.data.parent = parentId === null ? undefined : parentId;
        }
      }
    }

    return cy.add( jsons ).merge( descsEtc.restore() );
  }

  return this; // if nothing done
};

[
  _dereq_('./algorithms'),
  _dereq_('./animation'),
  _dereq_('./class'),
  _dereq_('./comparators'),
  _dereq_('./compounds'),
  _dereq_('./data'),
  _dereq_('./degree'),
  _dereq_('./dimensions'),
  _dereq_('./events'),
  _dereq_('./filter'),
  _dereq_('./group'),
  _dereq_('./index'),
  _dereq_('./iteration'),
  _dereq_('./layout'),
  _dereq_('./style'),
  _dereq_('./switch-functions'),
  _dereq_('./traversing')
].forEach(function( props ){
  util.extend( elesfn, props );
});

module.exports = Collection;

},{"../is":77,"../util":94,"./algorithms":9,"./animation":12,"./class":13,"./comparators":14,"./compounds":15,"./data":16,"./degree":17,"./dimensions":18,"./element":19,"./events":20,"./filter":21,"./group":22,"./index":23,"./iteration":24,"./layout":25,"./style":26,"./switch-functions":27,"./traversing":28}],24:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var zIndexSort = _dereq_('./zsort');

var elesfn = ({
  each: function(fn){
    if( is.fn(fn) ){
      for(var i = 0; i < this.length; i++){
        var ele = this[i];
        var ret = fn.apply( ele, [ i, ele ] );

        if( ret === false ){ break; } // exit each early on return false
      }
    }
    return this;
  },

  forEach: function(fn, thisArg){
    if( is.fn(fn) ){

      for(var i = 0; i < this.length; i++){
        var ele = this[i];
        var ret = thisArg ? fn.apply( thisArg, [ ele, i, this ] ) : fn( ele, i, this );

        if( ret === false ){ break; } // exit each early on return false
      }
    }

    return this;
  },

  toArray: function(){
    var array = [];

    for(var i = 0; i < this.length; i++){
      array.push( this[i] );
    }

    return array;
  },

  slice: function(start, end){
    var array = [];
    var thisSize = this.length;

    if( end == null ){
      end = thisSize;
    }

    if( start == null ){
      start = 0;
    }

    if( start < 0 ){
      start = thisSize + start;
    }

    if( end < 0 ){
      end = thisSize + end;
    }

    for(var i = start; i >= 0 && i < end && i < thisSize; i++){
      array.push( this[i] );
    }

    return this.spawn(array);
  },

  size: function(){
    return this.length;
  },

  eq: function(i){
    return this[i] || this.spawn();
  },

  first: function(){
    return this[0] || this.spawn();
  },

  last: function(){
    return this[ this.length - 1 ] || this.spawn();
  },

  empty: function(){
    return this.length === 0;
  },

  nonempty: function(){
    return !this.empty();
  },

  sort: function( sortFn ){
    if( !is.fn( sortFn ) ){
      return this;
    }

    var sorted = this.toArray().sort( sortFn );

    return this.spawn(sorted);
  },

  sortByZIndex: function(){
    return this.sort( zIndexSort );
  },

  zDepth: function(){
    var ele = this[0];
    if( !ele ){ return undefined; }

    // var cy = ele.cy();
    var _p = ele._private;
    var group = _p.group;

    if( group === 'nodes' ){
      var depth = _p.data.parent ? ele.parents().size() : 0;

      if( !ele.isParent() ){
        return Number.MAX_VALUE; // childless nodes always on top
      }

      return depth;
    } else {
      var src = _p.source;
      var tgt = _p.target;
      var srcDepth = src.zDepth();
      var tgtDepth = tgt.zDepth();

      return Math.max( srcDepth, tgtDepth, 0 ); // depth of deepest parent
    }
  }
});

module.exports = elesfn;

},{"../is":77,"./zsort":29}],25:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var util = _dereq_('../util');

var elesfn = ({

  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function( layout, options, fn ){
    var nodes = this.nodes();
    var cy = this.cy();

    layout.trigger({ type: 'layoutstart', layout: layout });

    layout.animations = [];

    if( options.animate ){
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var lastNode = i === nodes.length - 1;

        var newPos = fn.call( node, i, node );
        var pos = node.position();

        if( !is.number(pos.x) || !is.number(pos.y) ){
          node.silentPosition({ x: 0, y: 0 });
        }

        var ani = node.animation({
          position: newPos,
          duration: options.animationDuration,
          easing: options.animationEasing,
          step: !lastNode ? undefined : function(){
            if( options.fit ){
              cy.fit( options.eles, options.padding );
            }
          },
          complete: !lastNode ? undefined : function(){
            if( options.zoom != null ){
              cy.zoom( options.zoom );
            }

            if( options.pan ){
              cy.pan( options.pan );
            }

            if( options.fit ){
              cy.fit( options.eles, options.padding );
            }

            layout.one('layoutstop', options.stop);
            layout.trigger({ type: 'layoutstop', layout: layout });
          }
        });

        layout.animations.push( ani );

        ani.play();
      }

      layout.one('layoutready', options.ready);
      layout.trigger({ type: 'layoutready', layout: layout });
    } else {
      nodes.positions( fn );

      if( options.fit ){
        cy.fit( options.eles, options.padding );
      }

      if( options.zoom != null ){
        cy.zoom( options.zoom );
      }

      if( options.pan ){
        cy.pan( options.pan );
      }

      layout.one('layoutready', options.ready);
      layout.trigger({ type: 'layoutready', layout: layout });

      layout.one('layoutstop', options.stop);
      layout.trigger({ type: 'layoutstop', layout: layout });
    }

    return this; // chaining
  },

  layout: function( options ){
    var cy = this.cy();

    cy.layout( util.extend({}, options, {
      eles: this
    }) );

    return this;
  },

  makeLayout: function( options ){
    var cy = this.cy();

    return cy.makeLayout( util.extend({}, options, {
      eles: this
    }) );
  }

});

// aliases:
elesfn.createLayout = elesfn.makeLayout;

module.exports = elesfn;

},{"../is":77,"../util":94}],26:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');

var elesfn = ({

  // fully updates (recalculates) the style for the elements
  updateStyle: function( notifyRenderer ){
    var cy = this._private.cy;

    if( !cy.styleEnabled() ){ return this; }

    if( cy._private.batchingStyle ){
      var bEles = cy._private.batchStyleEles;

      bEles.merge( this );

      return this; // chaining and exit early when batching
    }

    var style = cy.style();
    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    style.apply( this );

    var updatedCompounds = this.updateCompoundBounds();
    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

    if( notifyRenderer ){
      toNotify.rtrigger('style'); // let renderer know we changed style
    } else {
      toNotify.trigger('style'); // just fire the event
    }
    return this; // chaining
  },

  // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
  updateMappers: function( notifyRenderer ){
    var cy = this._private.cy;
    var style = cy.style();
    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if( !cy.styleEnabled() ){ return this; }

    style.updateMappers( this );

    var updatedCompounds = this.updateCompoundBounds();
    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

    if( notifyRenderer ){
      toNotify.rtrigger('style'); // let renderer know we changed style
    } else {
      toNotify.trigger('style'); // just fire the event
    }
    return this; // chaining
  },

  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedCss: function( property ){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return this; }

    var ele = this[0];

    if( ele ){
      var renstyle = ele.cy().style().getRenderedStyle( ele );

      if( property === undefined ){
        return renstyle;
      } else {
        return renstyle[ property ];
      }
    }
  },

  // read the calculated css style of the element or override the style (via a bypass)
  css: function( name, value ){
    var cy = this.cy();

    if( !cy.styleEnabled() ){ return this; }

    var updateTransitions = false;
    var style = cy.style();

    if( is.plainObject(name) ){ // then extend the bypass
      var props = name;
      style.applyBypass( this, props, updateTransitions );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
      toNotify.rtrigger('style'); // let the renderer know we've updated style

    } else if( is.string(name) ){

      if( value === undefined ){ // then get the property from the style
        var ele = this[0];

        if( ele ){
          return style.getStylePropertyValue( ele, name );
        } else { // empty collection => can't get any value
          return;
        }

      } else { // then set the bypass with the property value
        style.applyBypass( this, name, value, updateTransitions );

        var updatedCompounds = this.updateCompoundBounds();
        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
        toNotify.rtrigger('style'); // let the renderer know we've updated style
      }

    } else if( name === undefined ){
      var ele = this[0];

      if( ele ){
        return style.getRawStyle( ele );
      } else { // empty collection => can't get any value
        return;
      }
    }

    return this; // chaining
  },

  removeCss: function( names ){
    var cy = this.cy();

    if( !cy.styleEnabled() ){ return this; }

    var updateTransitions = false;
    var style = cy.style();
    var eles = this;

    if( names === undefined ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        style.removeAllBypasses( ele, updateTransitions );
      }
    } else {
      names = names.split(/\s+/);

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        style.removeBypasses( ele, names, updateTransitions );
      }
    }

    var updatedCompounds = this.updateCompoundBounds();
    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
    toNotify.rtrigger('style'); // let the renderer know we've updated style

    return this; // chaining
  },

  show: function(){
    this.css('display', 'element');
    return this; // chaining
  },

  hide: function(){
    this.css('display', 'none');
    return this; // chaining
  },

  visible: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return true; }

    var ele = this[0];
    var hasCompoundNodes = cy.hasCompoundNodes();

    if( ele ){
      var style = ele._private.style;

      if(
        style['visibility'].value !== 'visible'
        || style['display'].value !== 'element'
      ){
        return false;
      }

      if( ele._private.group === 'nodes' ){
        if( !hasCompoundNodes ){ return true; }

        var parents = ele._private.data.parent ? ele.parents() : null;

        if( parents ){
          for( var i = 0; i < parents.length; i++ ){
            var parent = parents[i];
            var pStyle = parent._private.style;
            var pVis = pStyle['visibility'].value;
            var pDis = pStyle['display'].value;

            if( pVis !== 'visible' || pDis !== 'element' ){
              return false;
            }
          }
        }

        return true;
      } else {
        var src = ele._private.source;
        var tgt = ele._private.target;

        return src.visible() && tgt.visible();
      }

    }
  },

  hidden: function(){
    var ele = this[0];

    if( ele ){
      return !ele.visible();
    }
  },

  effectiveOpacity: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return 1; }

    var hasCompoundNodes = cy.hasCompoundNodes();
    var ele = this[0];

    if( ele ){
      var _p = ele._private;
      var parentOpacity = _p.style.opacity.value;

      if( !hasCompoundNodes ){ return parentOpacity; }

      var parents = !_p.data.parent ? null : ele.parents();

      if( parents ){
        for( var i = 0; i < parents.length; i++ ){
          var parent = parents[i];
          var opacity = parent._private.style.opacity.value;

          parentOpacity = opacity * parentOpacity;
        }
      }

      return parentOpacity;
    }
  },

  transparent: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return false; }

    var ele = this[0];
    var hasCompoundNodes = ele.cy().hasCompoundNodes();

    if( ele ){
      if( !hasCompoundNodes ){
        return ele._private.style.opacity.value === 0;
      } else {
        return ele.effectiveOpacity() === 0;
      }
    }
  },

  isFullAutoParent: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return false; }

    var ele = this[0];

    if( ele ){
      var autoW = ele._private.style['width'].value === 'auto';
      var autoH = ele._private.style['height'].value === 'auto';

      return ele.isParent() && autoW && autoH;
    }
  },

  backgrounding: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return false; }

    var ele = this[0];

    return ele._private.backgrounding ? true : false;
  }

});


elesfn.bypass = elesfn.style = elesfn.css;
elesfn.renderedStyle = elesfn.renderedCss;
elesfn.removeBypass = elesfn.removeStyle = elesfn.removeCss;

module.exports = elesfn;

},{"../is":77}],27:[function(_dereq_,module,exports){
'use strict';

var elesfn = {};

function defineSwitchFunction(params){
  return function(){
    var args = arguments;
    var changedEles = [];

    // e.g. cy.nodes().select( data, handler )
    if( args.length === 2 ){
      var data = args[0];
      var handler = args[1];
      this.bind( params.event, data, handler );
    }

    // e.g. cy.nodes().select( handler )
    else if( args.length === 1 ){
      var handler = args[0];
      this.bind( params.event, handler );
    }

    // e.g. cy.nodes().select()
    else if( args.length === 0 ){
      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var able = !params.ableField || ele._private[params.ableField];
        var changed = ele._private[params.field] != params.value;

        if( params.overrideAble ){
          var overrideAble = params.overrideAble(ele);

          if( overrideAble !== undefined ){
            able = overrideAble;

            if( !overrideAble ){ return this; } // to save cycles assume not able for all on override
          }
        }

        if( able ){
          ele._private[params.field] = params.value;

          if( changed ){
            changedEles.push( ele );
          }
        }
      }

      var changedColl = this.spawn( changedEles );
      changedColl.updateStyle(); // change of state => possible change of style
      changedColl.trigger( params.event );
    }

    return this;
  };
}

function defineSwitchSet( params ){
  elesfn[ params.field ] = function(){
    var ele = this[0];

    if( ele ){
      if( params.overrideField ){
        var val = params.overrideField(ele);

        if( val !== undefined ){
          return val;
        }
      }

      return ele._private[ params.field ];
    }
  };

  elesfn[ params.on ] = defineSwitchFunction({
    event: params.on,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: true
  });

  elesfn[ params.off ] = defineSwitchFunction({
    event: params.off,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: false
  });
}

defineSwitchSet({
  field: 'locked',
  overrideField: function(ele){
    return ele.cy().autolock() ? true : undefined;
  },
  on: 'lock',
  off: 'unlock'
});

defineSwitchSet({
  field: 'grabbable',
  overrideField: function(ele){
    return ele.cy().autoungrabify() ? false : undefined;
  },
  on: 'grabify',
  off: 'ungrabify'
});

defineSwitchSet({
  field: 'selected',
  ableField: 'selectable',
  overrideAble: function(ele){
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'select',
  off: 'unselect'
});

defineSwitchSet({
  field: 'selectable',
  overrideField: function(ele){
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'selectify',
  off: 'unselectify'
});

elesfn.deselect = elesfn.unselect;

elesfn.grabbed = function(){
  var ele = this[0];
  if( ele ){
    return ele._private.grabbed;
  }
};

defineSwitchSet({
  field: 'active',
  on: 'activate',
  off: 'unactivate'
});

elesfn.inactive = function(){
  var ele = this[0];
  if( ele ){
    return !ele._private.active;
  }
};

module.exports = elesfn;

},{}],28:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

var elesfn = {};

util.extend(elesfn, {
  // get the root nodes in the DAG
  roots: function( selector ){
    var eles = this;
    var roots = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      if( !ele.isNode() ){
        continue;
      }

      var hasEdgesPointingIn = ele.connectedEdges(function(){
        return this.data('target') === ele.id() && this.data('source') !== ele.id();
      }).length > 0;

      if( !hasEdgesPointingIn ){
        roots.push( ele );
      }
    }

    return this.spawn( roots, { unique: true } ).filter( selector );
  },

  // get the leaf nodes in the DAG
  leaves: function( selector ){
    var eles = this;
    var leaves = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      if( !ele.isNode() ){
        continue;
      }

      var hasEdgesPointingOut = ele.connectedEdges(function(){
        return this.data('source') === ele.id() && this.data('target') !== ele.id();
      }).length > 0;

      if( !hasEdgesPointingOut ){
        leaves.push( ele );
      }
    }

    return this.spawn( leaves, { unique: true } ).filter( selector );
  },

  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: function( selector ){
    var eles = this;
    var oEles = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var eleId = ele.id();

      if( !ele.isNode() ){ continue; }

      var edges = ele._private.edges;
      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[j];
        var srcId = edge._private.data.source;
        var tgtId = edge._private.data.target;

        if( srcId === eleId && tgtId !== eleId ){
          oEles.push( edge );
          oEles.push( edge.target()[0] );
        }
      }
    }

    return this.spawn( oEles, { unique: true } ).filter( selector );
  },

  // aka DAG descendants
  successors: function( selector ){
    var eles = this;
    var sEles = [];
    var sElesIds = {};

    for(;;){
      var outgoers = eles.outgoers();

      if( outgoers.length === 0 ){ break; } // done if no outgoers left

      var newOutgoers = false;
      for( var i = 0; i < outgoers.length; i++ ){
        var outgoer = outgoers[i];
        var outgoerId = outgoer.id();

        if( !sElesIds[ outgoerId ] ){
          sElesIds[ outgoerId ] = true;
          sEles.push( outgoer );
          newOutgoers = true;
        }
      }

      if( !newOutgoers ){ break; } // done if touched all outgoers already

      eles = outgoers;
    }

    return this.spawn( sEles, { unique: true } ).filter( selector );
  },

  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: function( selector ){
    var eles = this;
    var oEles = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var eleId = ele.id();

      if( !ele.isNode() ){ continue; }

      var edges = ele._private.edges;
      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[j];
        var srcId = edge._private.data.source;
        var tgtId = edge._private.data.target;

        if( tgtId === eleId && srcId !== eleId ){
          oEles.push( edge );
          oEles.push( edge.source()[0] );
        }
      }
    }

    return this.spawn( oEles, { unique: true } ).filter( selector );
  },

  // aka DAG ancestors
  predecessors: function( selector ){
    var eles = this;
    var pEles = [];
    var pElesIds = {};

    for(;;){
      var incomers = eles.incomers();

      if( incomers.length === 0 ){ break; } // done if no incomers left

      var newIncomers = false;
      for( var i = 0; i < incomers.length; i++ ){
        var incomer = incomers[i];
        var incomerId = incomer.id();

        if( !pElesIds[ incomerId ] ){
          pElesIds[ incomerId ] = true;
          pEles.push( incomer );
          newIncomers = true;
        }
      }

      if( !newIncomers ){ break; } // done if touched all incomers already

      eles = incomers;
    }

    return this.spawn( pEles, { unique: true } ).filter( selector );
  }
});


// Neighbourhood functions
//////////////////////////

util.extend(elesfn, {
  neighborhood: function(selector){
    var elements = [];
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){ // for all nodes
      var node = nodes[i];
      var connectedEdges = node.connectedEdges();

      // for each connected edge, add the edge and the other node
      for( var j = 0; j < connectedEdges.length; j++ ){
        var edge = connectedEdges[j];
        var src = edge._private.source;
        var tgt = edge._private.target;
        var otherNode = node === src ? tgt : src;

        // need check in case of loop
        if( otherNode.length > 0 ){
          elements.push( otherNode[0] ); // add node 1 hop away
        }

        // add connected edge
        elements.push( edge[0] );
      }

    }

    return ( this.spawn( elements, { unique: true } ) ).filter( selector );
  },

  closedNeighborhood: function(selector){
    return this.neighborhood().add( this ).filter( selector );
  },

  openNeighborhood: function(selector){
    return this.neighborhood( selector );
  }
});

// aliases
elesfn.neighbourhood = elesfn.neighborhood;
elesfn.closedNeighbourhood = elesfn.closedNeighborhood;
elesfn.openNeighbourhood = elesfn.openNeighborhood;

// Edge functions
/////////////////

util.extend(elesfn, {
  source: function( selector ){
    var ele = this[0];
    var src;

    if( ele ){
      src = ele._private.source;
    }

    return src && selector ? src.filter( selector ) : src;
  },

  target: function( selector ){
    var ele = this[0];
    var tgt;

    if( ele ){
      tgt = ele._private.target;
    }

    return tgt && selector ? tgt.filter( selector ) : tgt;
  },

  sources: defineSourceFunction({
    attr: 'source'
  }),

  targets: defineSourceFunction({
    attr: 'target'
  })
});

function defineSourceFunction( params ){
  return function( selector ){
    var sources = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var src = ele._private[ params.attr ];

      if( src ){
        sources.push( src );
      }
    }

    return this.spawn( sources, { unique: true } ).filter( selector );
  };
}

util.extend(elesfn, {
  edgesWith: defineEdgesWithFunction(),

  edgesTo: defineEdgesWithFunction({
    thisIs: 'source'
  })
});

function defineEdgesWithFunction( params ){

  return function edgesWithImpl( otherNodes ){
    var elements = [];
    var cy = this._private.cy;
    var p = params || {};

    // get elements if a selector is specified
    if( is.string(otherNodes) ){
      otherNodes = cy.$( otherNodes );
    }

    var thisIds = this._private.ids;
    var otherIds = otherNodes._private.ids;

    for( var h = 0; h < otherNodes.length; h++ ){
      var edges = otherNodes[h]._private.edges;

      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];
        var edgeData = edge._private.data;
        var thisToOther = thisIds[ edgeData.source ] && otherIds[ edgeData.target ];
        var otherToThis = otherIds[ edgeData.source ] && thisIds[ edgeData.target ];
        var edgeConnectsThisAndOther = thisToOther || otherToThis;

        if( !edgeConnectsThisAndOther ){ continue; }

        if( p.thisIs ){
          if( p.thisIs === 'source' && !thisToOther ){ continue; }

          if( p.thisIs === 'target' && !otherToThis ){ continue; }
        }

        elements.push( edge );
      }
    }

    return this.spawn( elements, { unique: true } );
  };
}

util.extend(elesfn, {
  connectedEdges: function( selector ){
    var retEles = [];

    var eles = this;
    for( var i = 0; i < eles.length; i++ ){
      var node = eles[i];
      if( !node.isNode() ){ continue; }

      var edges = node._private.edges;

      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[j];
        retEles.push( edge );
      }
    }

    return this.spawn( retEles, { unique: true } ).filter( selector );
  },

  connectedNodes: function( selector ){
    var retEles = [];

    var eles = this;
    for( var i = 0; i < eles.length; i++ ){
      var edge = eles[i];
      if( !edge.isEdge() ){ continue; }

      retEles.push( edge.source()[0] );
      retEles.push( edge.target()[0] );
    }

    return this.spawn( retEles, { unique: true } ).filter( selector );
  },

  parallelEdges: defineParallelEdgesFunction(),

  codirectedEdges: defineParallelEdgesFunction({
    codirected: true
  })
});

function defineParallelEdgesFunction(params){
  var defaults = {
    codirected: false
  };
  params = util.extend({}, defaults, params);

  return function( selector ){
    var elements = [];
    var edges = this.edges();
    var p = params;

    // look at all the edges in the collection
    for( var i = 0; i < edges.length; i++ ){
      var edge1 = edges[i];
      var src1 = edge1.source()[0];
      var srcid1 = src1.id();
      var tgt1 = edge1.target()[0];
      var tgtid1 = tgt1.id();
      var srcEdges1 = src1._private.edges;

      // look at edges connected to the src node of this edge
      for( var j = 0; j < srcEdges1.length; j++ ){
        var edge2 = srcEdges1[j];
        var edge2data = edge2._private.data;
        var tgtid2 = edge2data.target;
        var srcid2 = edge2data.source;

        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

        if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){
          elements.push( edge2 );
        }
      }
    }

    return this.spawn( elements, { unique: true } ).filter( selector );
  };

}

// Misc functions
/////////////////

util.extend(elesfn, {
  components: function(){
    var cy = this.cy();
    var visited = cy.collection();
    var unvisited = this.nodes();
    var components = [];

    var visitInComponent = function( node, component ){
      visited.merge( node );
      unvisited.unmerge( node );
      component.merge( node );
    };

    do {
      var component = cy.collection();
      components.push( component );

      var root = unvisited[0];
      visitInComponent( root, component );

      this.bfs({
        directed: false,
        roots: root,
        visit: function( i, depth, v, e, u ){
          visitInComponent( v, component );
        }
      });

    } while( unvisited.length > 0 );

    return components.map(function( component ){
      return component.closedNeighborhood(); // add the edges
    });
  }
});

module.exports = elesfn;

},{"../is":77,"../util":94}],29:[function(_dereq_,module,exports){
'use strict';

var zIndexSort = function( a, b ){
  var cy = a.cy();
  var a_p = a._private;
  var b_p = b._private;
  var zDiff = a_p.style['z-index'].value - b_p.style['z-index'].value;
  var depthA = 0;
  var depthB = 0;
  var hasCompoundNodes = cy.hasCompoundNodes();
  var aIsNode = a_p.group === 'nodes';
  var aIsEdge = a_p.group === 'edges';
  var bIsNode = b_p.group === 'nodes';
  var bIsEdge = b_p.group === 'edges';

  // no need to calculate element depth if there is no compound node
  if( hasCompoundNodes ){
    depthA = a.zDepth();
    depthB = b.zDepth();
  }

  var depthDiff = depthA - depthB;
  var sameDepth = depthDiff === 0;

  if( sameDepth ){

    if( aIsNode && bIsEdge ){
      return 1; // 'a' is a node, it should be drawn later

    } else if( aIsEdge && bIsNode ){
      return -1; // 'a' is an edge, it should be drawn first

    } else { // both nodes or both edges
      if( zDiff === 0 ){ // same z-index => compare indices in the core (order added to graph w/ last on top)
        return a_p.index - b_p.index;
      } else {
        return zDiff;
      }
    }

  // elements on different level
  } else {
    return depthDiff; // deeper element should be drawn later
  }

};

module.exports = zIndexSort;

},{}],30:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var util = _dereq_('../util');
var Collection = _dereq_('../collection');
var Element = _dereq_('../collection/element');
var window = _dereq_('../window');
var document = window ? window.document : null;
var NullRenderer = _dereq_('../extensions/renderer/null');

var corefn = {
  add: function(opts){

    var elements;
    var cy = this;

    // add the elements
    if( is.elementOrCollection(opts) ){
      var eles = opts;

      if( eles._private.cy === cy ){ // same instance => just restore
        elements = eles.restore();

      } else { // otherwise, copy from json
        var jsons = [];

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];
          jsons.push( ele.json() );
        }

        elements = new Collection( cy, jsons );
      }
    }

    // specify an array of options
    else if( is.array(opts) ){
      var jsons = opts;

      elements = new Collection(cy, jsons);
    }

    // specify via opts.nodes and opts.edges
    else if( is.plainObject(opts) && (is.array(opts.nodes) || is.array(opts.edges)) ){
      var elesByGroup = opts;
      var jsons = [];

      var grs = ['nodes', 'edges'];
      for( var i = 0, il = grs.length; i < il; i++ ){
        var group = grs[i];
        var elesArray = elesByGroup[group];

        if( is.array(elesArray) ){

          for( var j = 0, jl = elesArray.length; j < jl; j++ ){
            var json = util.extend( { group: group }, elesArray[j] );

            jsons.push( json );
          }
        }
      }

      elements = new Collection(cy, jsons);
    }

    // specify options for one element
    else {
      var json = opts;
      elements = (new Element( cy, json )).collection();
    }

    return elements;
  },

  remove: function(collection){
    if( is.elementOrCollection(collection) ){
      collection = collection;
    } else if( is.string(collection) ){
      var selector = collection;
      collection = this.$( selector );
    }

    return collection.remove();
  },

  load: function(elements, onload, ondone){
    var cy = this;

    cy.notifications(false);

    // remove old elements
    var oldEles = cy.elements();
    if( oldEles.length > 0 ){
      oldEles.remove();
    }

    if( elements != null ){
      if( is.plainObject(elements) || is.array(elements) ){
        cy.add( elements );
      }
    }

    cy.one('layoutready', function(e){
      cy.notifications(true);
      cy.trigger(e); // we missed this event by turning notifications off, so pass it on

      cy.notify({
        type: 'load',
        collection: cy.elements()
      });

      cy.one('load', onload);
      cy.trigger('load');
    }).one('layoutstop', function(){
      cy.one('done', ondone);
      cy.trigger('done');
    });

    var layoutOpts = util.extend({}, cy._private.options.layout);
    layoutOpts.eles = cy.$();

    cy.layout( layoutOpts );

    return this;
  }
};

module.exports = corefn;

},{"../collection":23,"../collection/element":19,"../extensions/renderer/null":73,"../is":77,"../util":94,"../window":100}],31:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('../define');
var util = _dereq_('../util');
var is = _dereq_('../is');

var corefn = ({

  // pull in animation functions
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop(),

  addToAnimationPool: function( eles ){
    var cy = this;

    if( !cy.styleEnabled() ){ return; } // save cycles when no style used

    cy._private.aniEles.merge( eles );
  },

  stopAnimationLoop: function(){
    this._private.animationsRunning = false;
  },

  startAnimationLoop: function(){
    var cy = this;

    cy._private.animationsRunning = true;

    if( !cy.styleEnabled() ){ return; } // save cycles when no style used

    // NB the animation loop will exec in headless environments if style enabled
    // and explicit cy.destroy() is necessary to stop the loop

    function globalAnimationStep(){
      if( !cy._private.animationsRunning ){ return; }

      util.requestAnimationFrame(function(now){
        handleElements(now);
        globalAnimationStep();
      });
    }

    globalAnimationStep(); // first call

    function handleElements( now ){
      var eles = cy._private.aniEles;
      var doneEles = [];

      function handleElement( ele, isCore ){
        var _p = ele._private;
        var current = _p.animation.current;
        var queue = _p.animation.queue;
        var ranAnis = false;

        // if nothing currently animating, get something from the queue
        if( current.length === 0 ){
          var next = queue.shift();

          if( next ){
            current.push( next );
          }
        }

        var callbacks = function( callbacks ){
          for( var j = callbacks.length - 1; j >= 0; j-- ){
            var cb = callbacks[j];

            cb();
          }

          callbacks.splice( 0, callbacks.length );
        };

        // step and remove if done
        for( var i = current.length - 1; i >= 0; i-- ){
          var ani = current[i];
          var ani_p = ani._private;

          if( ani_p.stopped ){
            current.splice( i, 1 );

            ani_p.hooked = false;
            ani_p.playing = false;
            ani_p.started = false;

            callbacks( ani_p.frames );

            continue;
          }

          if( !ani_p.playing && !ani_p.applying ){ continue; }

          // an apply() while playing shouldn't do anything
          if( ani_p.playing && ani_p.applying ){
            ani_p.applying = false;
          }

          if( !ani_p.started ){
            startAnimation( ele, ani, now );
          }

          step( ele, ani, now, isCore );

          if( ani_p.applying ){
            ani_p.applying = false;
          }

          callbacks( ani_p.frames );

          if( ani.completed() ){
            current.splice(i, 1);

            ani_p.hooked = false;
            ani_p.playing = false;
            ani_p.started = false;

            callbacks( ani_p.completes );
          }

          ranAnis = true;
        }

        if( !isCore && current.length === 0 && queue.length === 0 ){
          doneEles.push( ele );
        }

        return ranAnis;
      } // handleElement

      // handle all eles
      var ranEleAni = false;
      for( var e = 0; e < eles.length; e++ ){
        var ele = eles[e];
        var handledThisEle = handleElement( ele );

        ranEleAni = ranEleAni || handledThisEle;
      } // each element

      var ranCoreAni = handleElement( cy, true );

      // notify renderer
      if( ranEleAni || ranCoreAni ){
        var toNotify;

        if( eles.length > 0 ){
          var updatedEles = eles.updateCompoundBounds();
          toNotify = updatedEles.length > 0 ? eles.add( updatedEles ) : eles;
        }

        cy.notify({
          type: 'draw',
          collection: toNotify
        });
      }

      // remove elements from list of currently animating if its queues are empty
      eles.unmerge( doneEles );

    } // handleElements

    function startAnimation( self, ani, now ){
      var isCore = is.core( self );
      var isEles = !isCore;
      var ele = self;
      var style = cy._private.style;
      var ani_p = ani._private;

      if( isEles ){
        var pos = ele._private.position;

        ani_p.startPosition = ani_p.startPosition || {
          x: pos.x,
          y: pos.y
        };

        ani_p.startStyle = ani_p.startStyle || style.getValueStyle( ele );
      }

      if( isCore ){
        var pan = cy._private.pan;

        ani_p.startPan = ani_p.startPan || {
          x: pan.x,
          y: pan.y
        };

        ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;
      }

      ani_p.started = true;
      ani_p.startTime = now - ani_p.progress * ani_p.duration;
    }

    function step( self, ani, now, isCore ){
      var style = cy._private.style;
      var isEles = !isCore;
      var _p = self._private;
      var ani_p = ani._private;
      var pEasing = ani_p.easing;
      var startTime = ani_p.startTime;

      if( !ani_p.easingImpl ){

        if( pEasing == null ){ // use default
          ani_p.easingImpl = easings['linear'];

        } else { // then define w/ name
          var easingVals;

          if( is.string( pEasing ) ){
            var easingProp = style.parse('transition-timing-function', pEasing);

            easingVals = easingProp.value;

          } else { // then assume preparsed array
            easingVals = pEasing;
          }

          var name, args;

          if( is.string( easingVals ) ){
            name = easingVals;
            args = [];
          } else {
            name = easingVals[1];
            args = easingVals.slice(2).map(function(n){ return +n; });
          }

          if( args.length > 0 ){ // create with args
            if( name === 'spring' ){
              args.push( ani_p.duration ); // need duration to generate spring
            }

            ani_p.easingImpl = easings[ name ].apply( null, args );
          } else { // static impl by name
            ani_p.easingImpl = easings[ name ];
          }
        }

      }

      var easing = ani_p.easingImpl;
      var percent;

      if( ani_p.duration === 0 ){
        percent = 1;
      } else {
        percent = (now - startTime) / ani_p.duration;
      }

      if( ani_p.applying ){
        percent = ani_p.progress;
      }

      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      if( ani_p.delay == null ){ // then update

        var startPos = ani_p.startPosition;
        var endPos = ani_p.position;
        var pos = _p.position;
        if( endPos && isEles ){
          if( valid( startPos.x, endPos.x ) ){
            pos.x = ease( startPos.x, endPos.x, percent, easing );
          }

          if( valid( startPos.y, endPos.y ) ){
            pos.y = ease( startPos.y, endPos.y, percent, easing );
          }
        }

        var startPan = ani_p.startPan;
        var endPan = ani_p.pan;
        var pan = _p.pan;
        var animatingPan = endPan != null && isCore;
        if( animatingPan ){
          if( valid( startPan.x, endPan.x ) ){
            pan.x = ease( startPan.x, endPan.x, percent, easing );
          }

          if( valid( startPan.y, endPan.y ) ){
            pan.y = ease( startPan.y, endPan.y, percent, easing );
          }

          self.trigger('pan');
        }

        var startZoom = ani_p.startZoom;
        var endZoom = ani_p.zoom;
        var animatingZoom = endZoom != null && isCore;
        if( animatingZoom ){
          if( valid( startZoom, endZoom ) ){
            _p.zoom = ease( startZoom, endZoom, percent, easing );
          }

          self.trigger('zoom');
        }

        if( animatingPan || animatingZoom ){
          self.trigger('viewport');
        }

        var props = ani_p.style;
        if( props && isEles ){

          for( var i = 0; i < props.length; i++ ){
            var prop = props[i];
            var name = prop.name;
            var end = prop;

            var start = ani_p.startStyle[ name ];
            var easedVal = ease( start, end, percent, easing );

            style.overrideBypass( self, name, easedVal );
          } // for props

        } // if

      }

      if( is.fn(ani_p.step) ){
        ani_p.step.apply( self, [ now ] );
      }

      ani_p.progress = percent;

      return percent;
    }

    function valid(start, end){
      if( start == null || end == null ){
        return false;
      }

      if( is.number(start) && is.number(end) ){
        return true;
      } else if( (start) && (end) ){
        return true;
      }

      return false;
    }

    // assumes p0 = 0, p3 = 1
    function evalCubicBezier( p1, p2, t ){
      var one_t = 1 - t;
      var tsq = t*t;

      return ( 3 * one_t * one_t * t * p1 ) + ( 3 * one_t * tsq * p2 ) + tsq * t;
    }

    function cubicBezier( p1, p2 ){
      return function( start, end, percent ){
        return start + (end - start) * evalCubicBezier( p1, p2, percent );
      };
    }

    /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
    /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
       then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
    var generateSpringRK4 = (function () {
        function springAccelerationForState (state) {
            return (-state.tension * state.x) - (state.friction * state.v);
        }

        function springEvaluateStateWithDerivative (initialState, dt, derivative) {
            var state = {
                x: initialState.x + derivative.dx * dt,
                v: initialState.v + derivative.dv * dt,
                tension: initialState.tension,
                friction: initialState.friction
            };

            return { dx: state.v, dv: springAccelerationForState(state) };
        }

        function springIntegrateState (state, dt) {
            var a = {
                    dx: state.v,
                    dv: springAccelerationForState(state)
                },
                b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
                c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
                d = springEvaluateStateWithDerivative(state, dt, c),
                dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
                dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

            state.x = state.x + dxdt * dt;
            state.v = state.v + dvdt * dt;

            return state;
        }

        return function springRK4Factory (tension, friction, duration) {

            var initState = {
                    x: -1,
                    v: 0,
                    tension: null,
                    friction: null
                },
                path = [0],
                time_lapsed = 0,
                tolerance = 1 / 10000,
                DT = 16 / 1000,
                have_duration, dt, last_state;

            tension = parseFloat(tension) || 500;
            friction = parseFloat(friction) || 20;
            duration = duration || null;

            initState.tension = tension;
            initState.friction = friction;

            have_duration = duration !== null;

            /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
            if (have_duration) {
                /* Run the simulation without a duration. */
                time_lapsed = springRK4Factory(tension, friction);
                /* Compute the adjusted time delta. */
                dt = time_lapsed / duration * DT;
            } else {
                dt = DT;
            }

            while (true) {
                /* Next/step function .*/
                last_state = springIntegrateState(last_state || initState, dt);
                /* Store the position. */
                path.push(1 + last_state.x);
                time_lapsed += 16;
                /* If the change threshold is reached, break. */
                if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
                    break;
                }
            }

            /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
               computed path and returns a snapshot of the position according to a given percentComplete. */
            return !have_duration ? time_lapsed : function(percentComplete) { return path[ (percentComplete * (path.length - 1)) | 0 ]; };
        };
    }());

    var easings = {
      'linear': function( start, end, percent ){
        return start + (end - start) * percent;
      },

      // default easings
      'ease': cubicBezier( 0.25, 0.1, 0.25, 1 ),
      'ease-in': cubicBezier( 0.42, 0, 1, 1 ),
      'ease-out': cubicBezier( 0, 0, 0.58, 1 ),
      'ease-in-out': cubicBezier( 0.42, 0, 0.58, 1 ),

      // sine
      'ease-in-sine': cubicBezier( 0.47, 0, 0.745, 0.715 ),
      'ease-out-sine': cubicBezier( 0.39, 0.575, 0.565, 1 ),
      'ease-in-out-sine': cubicBezier( 0.445, 0.05, 0.55, 0.95 ),

      // quad
      'ease-in-quad': cubicBezier( 0.55, 0.085, 0.68, 0.53 ),
      'ease-out-quad': cubicBezier( 0.25, 0.46, 0.45, 0.94 ),
      'ease-in-out-quad': cubicBezier( 0.455, 0.03, 0.515, 0.955 ),

      // cubic
      'ease-in-cubic': cubicBezier( 0.55, 0.055, 0.675, 0.19 ),
      'ease-out-cubic': cubicBezier( 0.215, 0.61, 0.355, 1 ),
      'ease-in-out-cubic': cubicBezier( 0.645, 0.045, 0.355, 1 ),

      // quart
      'ease-in-quart': cubicBezier( 0.895, 0.03, 0.685, 0.22 ),
      'ease-out-quart': cubicBezier( 0.165, 0.84, 0.44, 1 ),
      'ease-in-out-quart': cubicBezier( 0.77, 0, 0.175, 1 ),

      // quint
      'ease-in-quint': cubicBezier( 0.755, 0.05, 0.855, 0.06 ),
      'ease-out-quint': cubicBezier( 0.23, 1, 0.32, 1 ),
      'ease-in-out-quint': cubicBezier( 0.86, 0, 0.07, 1 ),

      // expo
      'ease-in-expo': cubicBezier( 0.95, 0.05, 0.795, 0.035 ),
      'ease-out-expo': cubicBezier( 0.19, 1, 0.22, 1 ),
      'ease-in-out-expo': cubicBezier( 1, 0, 0, 1 ),

      // circ
      'ease-in-circ': cubicBezier( 0.6, 0.04, 0.98, 0.335 ),
      'ease-out-circ': cubicBezier( 0.075, 0.82, 0.165, 1 ),
      'ease-in-out-circ': cubicBezier( 0.785, 0.135, 0.15, 0.86 ),


      // user param easings...

      'spring': function( tension, friction, duration ){
        var spring = generateSpringRK4( tension, friction, duration );

        return function( start, end, percent ){
          return start + (end - start) * spring( percent );
        };
      },

      'cubic-bezier': function( x1, y1, x2, y2 ){
        return cubicBezier( x1, y1, x2, y2 );
      }
    };

    function ease( startProp, endProp, percent, easingFn ){
      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      var start, end;

      if( startProp.pfValue != null || startProp.value != null ){
        start = startProp.pfValue != null ? startProp.pfValue : startProp.value;
      } else {
        start = startProp;
      }

      if( endProp.pfValue != null || endProp.value != null ){
        end = endProp.pfValue != null ? endProp.pfValue : endProp.value;
      } else {
        end = endProp;
      }

      if( is.number(start) && is.number(end) ){
        return easingFn( start, end, percent );

      } else if( is.array(start) && is.array(end) ){
        var easedArr = [];

        for( var i = 0; i < end.length; i++ ){
          var si = start[i];
          var ei = end[i];

          if( si != null && ei != null ){
            var val = easingFn(si, ei, percent);

            if( startProp.roundValue ){ val = Math.round( val ); }

            easedArr.push( val );
          } else {
            easedArr.push( ei );
          }
        }

        return easedArr;
      }

      return undefined;
    }

  }

});

module.exports = corefn;

},{"../define":41,"../is":77,"../util":94}],32:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('../define');

var corefn = ({
  on: define.on(), // .on( events [, selector] [, data], handler)
  one: define.on({ unbindSelfOnTrigger: true }),
  once: define.on({ unbindAllBindersOnTrigger: true }),
  off: define.off(), // .off( events [, selector] [, handler] )
  trigger: define.trigger() // .trigger( events [, extraParams] )
});

define.eventAliasesOn( corefn );

module.exports = corefn;

},{"../define":41}],33:[function(_dereq_,module,exports){
'use strict';

var corefn = ({

  png: function( options ){
    var renderer = this._private.renderer;
    options = options || {};

    return renderer.png( options );
  },

  jpg: function( options ){
    var renderer = this._private.renderer;
    options = options || {};

    options.bg = options.bg || '#fff';

    return renderer.jpg( options );
  }

});

corefn.jpeg = corefn.jpg;

module.exports = corefn;

},{}],34:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_('../window');
var util = _dereq_('../util');
var Collection = _dereq_('../collection');
var is = _dereq_('../is');
var Promise = _dereq_('../promise');
var define = _dereq_('../define');

var Core = function( opts ){
  if( !(this instanceof Core) ){
    return new Core(opts);
  }
  var cy = this;

  opts = util.extend({}, opts);

  var container = opts.container;

  // allow for passing a wrapped jquery object
  // e.g. cytoscape({ container: $('#cy') })
  if( container && !is.htmlElement( container ) && is.htmlElement( container[0] ) ){
    container = container[0];
  }

  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
  reg = reg || {};

  if( reg && reg.cy ){
    reg.cy.destroy();

    reg = {}; // old instance => replace reg completely
  }

  var readies = reg.readies = reg.readies || [];

  if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy
  reg.cy = cy;

  var head = window !== undefined && container !== undefined && !opts.headless;
  var options = opts;
  options.layout = util.extend( { name: head ? 'grid' : 'null' }, options.layout );
  options.renderer = util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );

  var defVal = function( def, val, altVal ){
    if( val !== undefined ){
      return val;
    } else if( altVal !== undefined ){
      return altVal;
    } else {
      return def;
    }
  };

  var _p = this._private = {
    container: container, // html dom ele container
    ready: false, // whether ready has been triggered
    initrender: false, // has initrender has been triggered
    options: options, // cached options
    elements: [], // array of elements
    id2index: {}, // element id => index in elements array
    listeners: [], // list of listeners
    onRenders: [], // rendering listeners
    aniEles: Collection(this), // elements being animated
    scratch: {}, // scratch object for core
    layout: null,
    renderer: null,
    notificationsEnabled: true, // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: defVal(true, options.zoomingEnabled),
    userZoomingEnabled: defVal(true, options.userZoomingEnabled),
    panningEnabled: defVal(true, options.panningEnabled),
    userPanningEnabled: defVal(true, options.userPanningEnabled),
    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
    autolock: defVal(false, options.autolock, options.autolockNodes),
    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
    autounselectify: defVal(false, options.autounselectify),
    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
    zoom: is.number(options.zoom) ? options.zoom : 1,
    pan: {
      x: is.plainObject(options.pan) && is.number(options.pan.x) ? options.pan.x : 0,
      y: is.plainObject(options.pan) && is.number(options.pan.y) ? options.pan.y : 0
    },
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: false,
    deferredExecQueue: []
  };

  // set selection type
  var selType = options.selectionType;
  if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){
    // then set default

    _p.selectionType = 'single';
  } else {
    _p.selectionType = selType;
  }

  // init zoom bounds
  if( is.number(options.minZoom) && is.number(options.maxZoom) && options.minZoom < options.maxZoom ){
    _p.minZoom = options.minZoom;
    _p.maxZoom = options.maxZoom;
  } else if( is.number(options.minZoom) && options.maxZoom === undefined ){
    _p.minZoom = options.minZoom;
  } else if( is.number(options.maxZoom) && options.minZoom === undefined ){
    _p.maxZoom = options.maxZoom;
  }

  var loadExtData = function( next ){
    var anyIsPromise = false;

    for( var i = 0; i < extData.length; i++ ){
      var datum = extData[i];

      if( is.promise(datum) ){
        anyIsPromise = true;
        break;
      }
    }

    if( anyIsPromise ){
      return Promise.all( extData ).then( next ); // load all data asynchronously, then exec rest of init
    } else {
      next( extData ); // exec synchronously for convenience
    }
  };

  // create the renderer
  cy.initRenderer( util.extend({
    hideEdgesOnViewport: options.hideEdgesOnViewport,
    hideLabelsOnViewport: options.hideLabelsOnViewport,
    textureOnViewport: options.textureOnViewport,
    wheelSensitivity: is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
    motionBlur: options.motionBlur === undefined ? true : options.motionBlur, // on by default
    motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
    pixelRatio: is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : undefined,
    desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
    touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
  }, options.renderer) );

  var extData = [ options.style, options.elements ];
  loadExtData(function( thens ){
    var initStyle = thens[0];
    var initEles = thens[1];

    // init style
    if( _p.styleEnabled ){
      cy.setStyle( initStyle );
    }

    // trigger the passed function for the `initrender` event
    if( options.initrender ){
      cy.on('initrender', options.initrender);
      cy.on('initrender', function(){
        _p.initrender = true;
      });
    }

    // initial load
    cy.load(initEles, function(){ // onready
      cy.startAnimationLoop();
      _p.ready = true;

      // if a ready callback is specified as an option, the bind it
      if( is.fn( options.ready ) ){
        cy.on('ready', options.ready);
      }

      // bind all the ready handlers registered before creating this instance
      for( var i = 0; i < readies.length; i++ ){
        var fn = readies[i];
        cy.on('ready', fn);
      }
      if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc

      cy.trigger('ready');
    }, options.done);

  });
};

var corefn = Core.prototype; // short alias

util.extend(corefn, {
  instanceString: function(){
    return 'core';
  },

  isReady: function(){
    return this._private.ready;
  },

  ready: function( fn ){
    if( this.isReady() ){
      this.trigger('ready', [], fn); // just calls fn as though triggered via ready event
    } else {
      this.on('ready', fn);
    }

    return this;
  },

  initrender: function(){
    return this._private.initrender;
  },

  destroy: function(){
    var cy = this;

    cy.stopAnimationLoop();

    cy.notify({ type: 'destroy' }); // destroy the renderer

    var domEle = cy.container();
    if( domEle ){
      domEle._cyreg = null;

      while( domEle.childNodes.length > 0 ){
        domEle.removeChild( domEle.childNodes[0] );
      }
    }

    return cy;
  },

  getElementById: function( id ){
    var index = this._private.id2index[ id ];
    if( index !== undefined ){
      return this._private.elements[ index ];
    }

    // worst case, return an empty collection
    return Collection( this );
  },

  selectionType: function(){
    return this._private.selectionType;
  },

  hasCompoundNodes: function(){
    return this._private.hasCompoundNodes;
  },

  styleEnabled: function(){
    return this._private.styleEnabled;
  },

  addToPool: function( eles ){
    var elements = this._private.elements;
    var id2index = this._private.id2index;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];

      var id = ele._private.data.id;
      var index = id2index[ id ];
      var alreadyInPool = index !== undefined;

      if( !alreadyInPool ){
        index = elements.length;
        elements.push( ele );
        id2index[ id ] = index;
        ele._private.index = index;
      }
    }

    return this; // chaining
  },

  removeFromPool: function( eles ){
    var elements = this._private.elements;
    var id2index = this._private.id2index;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];

      var id = ele._private.data.id;
      var index = id2index[ id ];
      var inPool = index !== undefined;

      if( inPool ){
        this._private.id2index[ id ] = undefined;
        elements.splice(index, 1);

        // adjust the index of all elements past this index
        for( var j = index; j < elements.length; j++ ){
          var jid = elements[j]._private.data.id;
          id2index[ jid ]--;
          elements[j]._private.index--;
        }
      }
    }
  },

  container: function(){
    return this._private.container;
  },

  options: function(){
    return util.copy( this._private.options );
  },

  json: function( obj ){
    var cy = this;
    var _p = cy._private;

    if( is.plainObject(obj) ){ // set

      cy.startBatch();

      if( obj.elements ){
        var idInJson = {};

        var updateEles = function( jsons, gr ){
          for( var i = 0; i < jsons.length; i++ ){
            var json = jsons[i];
            var id = json.data.id;
            var ele = cy.getElementById( id );

            idInJson[ id ] = true;

            if( ele.length !== 0 ){ // existing element should be updated
              ele.json( json );
            } else { // otherwise should be added
              if( gr ){
                cy.add( util.extend({ group: gr }, json) );
              } else {
                cy.add( json );
              }
            }
          }
        };

        if( is.array(obj.elements) ){ // elements: []
          updateEles( obj.elements );

        } else { // elements: { nodes: [], edges: [] }
          var grs = ['nodes', 'edges'];
          for( var i = 0; i < grs.length; i++ ){
            var gr = grs[i];
            var elements = obj.elements[ gr ];

            if( is.array(elements) ){
              updateEles( elements, gr );
            }
          }
        }

        // elements not specified in json should be removed
        cy.elements().stdFilter(function( ele ){
          return !idInJson[ ele.id() ];
        }).remove();
      }

      if( obj.style ){
        cy.style( obj.style );
      }

      if( obj.zoom != null && obj.zoom !== _p.zoom ){
        cy.zoom( obj.zoom );
      }

      if( obj.pan ){
        if( obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y ){
          cy.pan( obj.pan );
        }
      }

      var fields = [
        'minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled',
        'panningEnabled', 'userPanningEnabled',
        'boxSelectionEnabled',
        'autolock', 'autoungrabify', 'autounselectify'
      ];

      for( var i = 0; i < fields.length; i++ ){
        var f = fields[i];

        if( obj[f] != null ){
          cy[f]( obj[f] );
        }
      }

      cy.endBatch();

      return this; // chaining
    } else if( obj === undefined ){ // get
      var json = {};

      json.elements = {};
      cy.elements().each(function(i, ele){
        var group = ele.group();

        if( !json.elements[group] ){
          json.elements[group] = [];
        }

        json.elements[group].push( ele.json() );
      });

      if( this._private.styleEnabled ){
        json.style = cy.style().json();
      }

      json.zoomingEnabled = cy._private.zoomingEnabled;
      json.userZoomingEnabled = cy._private.userZoomingEnabled;
      json.zoom = cy._private.zoom;
      json.minZoom = cy._private.minZoom;
      json.maxZoom = cy._private.maxZoom;
      json.panningEnabled = cy._private.panningEnabled;
      json.userPanningEnabled = cy._private.userPanningEnabled;
      json.pan = util.copy( cy._private.pan );
      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
      json.renderer = util.copy( cy._private.options.renderer );
      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
      json.hideLabelsOnViewport = cy._private.options.hideLabelsOnViewport;
      json.textureOnViewport = cy._private.options.textureOnViewport;
      json.wheelSensitivity = cy._private.options.wheelSensitivity;
      json.motionBlur = cy._private.options.motionBlur;

      return json;
    }
  },

  scratch: define.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  }),

  removeScratch: define.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true
  })

});

[
  _dereq_('./add-remove'),
  _dereq_('./animation'),
  _dereq_('./events'),
  _dereq_('./export'),
  _dereq_('./layout'),
  _dereq_('./notification'),
  _dereq_('./renderer'),
  _dereq_('./search'),
  _dereq_('./style'),
  _dereq_('./viewport')
].forEach(function( props ){
  util.extend( corefn, props );
});

module.exports = Core;

},{"../collection":23,"../define":41,"../is":77,"../promise":80,"../util":94,"../window":100,"./add-remove":30,"./animation":31,"./events":32,"./export":33,"./layout":35,"./notification":36,"./renderer":37,"./search":38,"./style":39,"./viewport":40}],35:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

var corefn = ({

  layout: function( params ){
    var layout = this._private.prevLayout = ( params == null ? this._private.prevLayout : this.makeLayout( params ) );

    layout.run();

    return this; // chaining
  },

  makeLayout: function( options ){
    var cy = this;

    if( options == null ){
      util.error('Layout options must be specified to make a layout');
      return;
    }

    if( options.name == null ){
      util.error('A `name` must be specified to make a layout');
      return;
    }

    var name = options.name;
    var Layout = cy.extension('layout', name);

    if( Layout == null ){
      util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');
      return;
    }

    var eles;
    if( is.string( options.eles ) ){
      eles = cy.$( options.eles );
    } else {
      eles = options.eles != null ? options.eles : cy.$();
    }

    var layout = new Layout( util.extend({}, options, {
      cy: cy,
      eles: eles
    }) );

    return layout;
  }

});

corefn.createLayout = corefn.makeLayout;

module.exports = corefn;

},{"../is":77,"../util":94}],36:[function(_dereq_,module,exports){
'use strict';

var corefn = ({
  notify: function( params ){
    var _p = this._private;

    if( _p.batchingNotify ){
      var bEles = _p.batchNotifyEles;
      var bTypes = _p.batchNotifyTypes;

      if( params.collection ){
        bEles.merge( params.collection );
      }

      if( !bTypes.ids[ params.type ] ){
        bTypes.push( params.type );
      }

      return; // notifications are disabled during batching
    }

    if( !_p.notificationsEnabled ){ return; } // exit on disabled

    var renderer = this.renderer();

    renderer.notify(params);
  },

  notifications: function( bool ){
    var p = this._private;

    if( bool === undefined ){
      return p.notificationsEnabled;
    } else {
      p.notificationsEnabled = bool ? true : false;
    }
  },

  noNotifications: function( callback ){
    this.notifications(false);
    callback();
    this.notifications(true);
  },

  startBatch: function(){
    var _p = this._private;

    if( _p.batchCount == null ){
      _p.batchCount = 0;
    }

    if( _p.batchCount === 0 ){
      _p.batchingStyle = _p.batchingNotify = true;
      _p.batchStyleEles = this.collection();
      _p.batchNotifyEles = this.collection();
      _p.batchNotifyTypes = [];

      _p.batchNotifyTypes.ids = {};
    }

    _p.batchCount++;

    return this;
  },

  endBatch: function(){
    var _p = this._private;

    _p.batchCount--;

    if( _p.batchCount === 0 ){
      // update style for dirty eles
      _p.batchingStyle = false;
      _p.batchStyleEles.updateStyle();

      // notify the renderer of queued eles and event types
      _p.batchingNotify = false;
      this.notify({
        type: _p.batchNotifyTypes,
        collection: _p.batchNotifyEles
      });
    }

    return this;
  },

  batch: function( callback ){
    this.startBatch();
    callback();
    this.endBatch();

    return this;
  },

  // for backwards compatibility
  batchData: function( map ){
    var cy = this;

    return this.batch(function(){
      for( var id in map ){
        var data = map[id];
        var ele = cy.getElementById( id );

        ele.data( data );
      }
    });
  }
});

module.exports = corefn;

},{}],37:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');

var corefn = ({

  renderTo: function( context, zoom, pan, pxRatio ){
    var r = this._private.renderer;

    r.renderTo( context, zoom, pan, pxRatio );
    return this;
  },

  renderer: function(){
    return this._private.renderer;
  },

  forceRender: function(){
    this.notify({
      type: 'draw'
    });

    return this;
  },

  resize: function(){
    this.notify({
      type: 'resize'
    });

    this.trigger('resize');

    return this;
  },

  initRenderer: function( options ){
    var cy = this;

    var RendererProto = cy.extension('renderer', options.name);
    if( RendererProto == null ){
      util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);
      return;
    }

    var rOpts = util.extend({}, options, {
      cy: cy
    });
    var renderer = cy._private.renderer = new RendererProto( rOpts );

    renderer.init( rOpts );

  },

  triggerOnRender: function(){
    var cbs = this._private.onRenders;

    for( var i = 0; i < cbs.length; i++ ){
      var cb = cbs[i];

      cb();
    }

    return this;
  },

  onRender: function( cb ){
    this._private.onRenders.push( cb );

    return this;
  },

  offRender: function( fn ){
    var cbs = this._private.onRenders;

    if( fn == null ){ // unbind all
      this._private.onRenders = [];
      return this;
    }

    for( var i = 0; i < cbs.length; i++ ){ // unbind specified
      var cb = cbs[i];

      if( fn === cb ){
        cbs.splice( i, 1 );
        break;
      }
    }

    return this;
  }

});

corefn.invalidateDimensions = corefn.resize;

module.exports = corefn;

},{"../util":94}],38:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var Collection = _dereq_('../collection');

var corefn = ({

  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function( eles, opts ){

    if( is.string( eles ) ){
      return this.$( eles );

    } else if( is.elementOrCollection( eles ) ){
      return eles.collection();

    } else if( is.array( eles ) ){
      return Collection( this, eles, opts );
    }

    return Collection( this );
  },

  nodes: function( selector ){
    var nodes = this.$(function(){
      return this.isNode();
    });

    if( selector ){
      return nodes.filter( selector );
    }

    return nodes;
  },

  edges: function( selector ){
    var edges = this.$(function(){
      return this.isEdge();
    });

    if( selector ){
      return edges.filter( selector );
    }

    return edges;
  },

  // search the graph like jQuery
  $: function( selector ){
    var eles = new Collection( this, this._private.elements );

    if( selector ){
      return eles.filter( selector );
    }

    return eles;
  }

});

// aliases
corefn.elements = corefn.filter = corefn.$;

module.exports = corefn;

},{"../collection":23,"../is":77}],39:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var Style = _dereq_('../style');

var corefn = ({

  style: function( newStyle ){
    if( newStyle ){
      var s = this.setStyle( newStyle );

      s.update();
    }

    return this._private.style;
  },

  setStyle: function( style ){
    var _p = this._private;

    if( is.stylesheet(style) ){
      _p.style = style.generateStyle(this);

    } else if( is.array(style) ) {
      _p.style = Style.fromJson(this, style);

    } else if( is.string(style) ){
      _p.style = Style.fromString(this, style);

    } else {
      _p.style = Style( this );
    }

    return _p.style;
  }
});

module.exports = corefn;

},{"../is":77,"../style":86}],40:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');

var corefn = ({

  autolock: function(bool){
    if( bool !== undefined ){
      this._private.autolock = bool ? true : false;
    } else {
      return this._private.autolock;
    }

    return this; // chaining
  },

  autoungrabify: function(bool){
    if( bool !== undefined ){
      this._private.autoungrabify = bool ? true : false;
    } else {
      return this._private.autoungrabify;
    }

    return this; // chaining
  },

  autounselectify: function(bool){
    if( bool !== undefined ){
      this._private.autounselectify = bool ? true : false;
    } else {
      return this._private.autounselectify;
    }

    return this; // chaining
  },

  panningEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.panningEnabled = bool ? true : false;
    } else {
      return this._private.panningEnabled;
    }

    return this; // chaining
  },

  userPanningEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.userPanningEnabled = bool ? true : false;
    } else {
      return this._private.userPanningEnabled;
    }

    return this; // chaining
  },

  zoomingEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.zoomingEnabled = bool ? true : false;
    } else {
      return this._private.zoomingEnabled;
    }

    return this; // chaining
  },

  userZoomingEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.userZoomingEnabled = bool ? true : false;
    } else {
      return this._private.userZoomingEnabled;
    }

    return this; // chaining
  },

  boxSelectionEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.boxSelectionEnabled = bool ? true : false;
    } else {
      return this._private.boxSelectionEnabled;
    }

    return this; // chaining
  },

  pan: function(){
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    switch( args.length ){
    case 0: // .pan()
      return pan;

    case 1:

      if( is.string( args[0] ) ){ // .pan('x')
        dim = args[0];
        return pan[ dim ];

      } else if( is.plainObject( args[0] ) ) { // .pan({ x: 0, y: 100 })
        if( !this._private.panningEnabled ){
          return this;
        }

        dims = args[0];
        x = dims.x;
        y = dims.y;

        if( is.number(x) ){
          pan.x = x;
        }

        if( is.number(y) ){
          pan.y = y;
        }

        this.trigger('pan viewport');
      }
      break;

    case 2: // .pan('x', 100)
      if( !this._private.panningEnabled ){
        return this;
      }

      dim = args[0];
      val = args[1];

      if( (dim === 'x' || dim === 'y') && is.number(val) ){
        pan[dim] = val;
      }

      this.trigger('pan viewport');
      break;

    default:
      break; // invalid
    }

    this.notify({ // notify the renderer that the viewport changed
      type: 'viewport'
    });

    return this; // chaining
  },

  panBy: function(params){
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    if( !this._private.panningEnabled ){
      return this;
    }

    switch( args.length ){
    case 1:

      if( is.plainObject( args[0] ) ) { // .panBy({ x: 0, y: 100 })
        dims = args[0];
        x = dims.x;
        y = dims.y;

        if( is.number(x) ){
          pan.x += x;
        }

        if( is.number(y) ){
          pan.y += y;
        }

        this.trigger('pan viewport');
      }
      break;

    case 2: // .panBy('x', 100)
      dim = args[0];
      val = args[1];

      if( (dim === 'x' || dim === 'y') && is.number(val) ){
        pan[dim] += val;
      }

      this.trigger('pan viewport');
      break;

    default:
      break; // invalid
    }

    this.notify({ // notify the renderer that the viewport changed
      type: 'viewport'
    });

    return this; // chaining
  },

  fit: function( elements, padding ){
    var viewportState = this.getFitViewport( elements, padding );

    if( viewportState ){
      var _p = this._private;
      _p.zoom = viewportState.zoom;
      _p.pan = viewportState.pan;

      this.trigger('pan zoom viewport');

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });
    }

    return this; // chaining
  },

  getFitViewport: function( elements, padding ){
    if( is.number(elements) && padding === undefined ){ // elements is optional
      padding = elements;
      elements = undefined;
    }

    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
      return;
    }

    var bb;

    if( is.string(elements) ){
      var sel = elements;
      elements = this.$( sel );

    } else if( is.boundingBox(elements) ){ // assume bb
      var bbe = elements;
      bb = {
        x1: bbe.x1,
        y1: bbe.y1,
        x2: bbe.x2,
        y2: bbe.y2
      };

      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;

    } else if( !is.elementOrCollection(elements) ){
      elements = this.elements();
    }

    bb = bb || elements.boundingBox();

    var w = this.width();
    var h = this.height();
    var zoom;
    padding = is.number(padding) ? padding : 0;

    if( !isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) &&  bb.w > 0 && bb.h > 0 ){
      zoom = Math.min( (w - 2*padding)/bb.w, (h - 2*padding)/bb.h );

      // crop zoom
      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

      var pan = { // now pan to middle
        x: (w - zoom*( bb.x1 + bb.x2 ))/2,
        y: (h - zoom*( bb.y1 + bb.y2 ))/2
      };

      return {
        zoom: zoom,
        pan: pan
      };
    }

    return;
  },

  minZoom: function( zoom ){
    if( zoom === undefined ){
      return this._private.minZoom;
    } else if( is.number(zoom) ){
      this._private.minZoom = zoom;
    }

    return this;
  },

  maxZoom: function( zoom ){
    if( zoom === undefined ){
      return this._private.maxZoom;
    } else if( is.number(zoom) ){
      this._private.maxZoom = zoom;
    }

    return this;
  },

  zoom: function( params ){
    var pos; // in rendered px
    var zoom;

    if( params === undefined ){ // then get the zoom
      return this._private.zoom;

    } else if( is.number(params) ){ // then set the zoom
      zoom = params;

    } else if( is.plainObject(params) ){ // then zoom about a point
      zoom = params.level;

      if( params.position ){
        var p = params.position;
        var pan = this._private.pan;
        var z = this._private.zoom;

        pos = { // convert to rendered px
          x: p.x * z + pan.x,
          y: p.y * z + pan.y
        };
      } else if( params.renderedPosition ){
        pos = params.renderedPosition;
      }

      if( pos && !this._private.panningEnabled ){
        return this; // panning disabled
      }
    }

    if( !this._private.zoomingEnabled ){
      return this; // zooming disabled
    }

    if( !is.number(zoom) || ( pos && (!is.number(pos.x) || !is.number(pos.y)) ) ){
      return this; // can't zoom with invalid params
    }

    // crop zoom
    zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
    zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

    if( pos ){ // set zoom about position
      var pan1 = this._private.pan;
      var zoom1 = this._private.zoom;
      var zoom2 = zoom;

      var pan2 = {
        x: -zoom2/zoom1 * (pos.x - pan1.x) + pos.x,
        y: -zoom2/zoom1 * (pos.y - pan1.y) + pos.y
      };

      this._private.zoom = zoom;
      this._private.pan = pan2;

      var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;
      this.trigger(' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );

    } else { // just set the zoom
      this._private.zoom = zoom;
      this.trigger('zoom viewport');
    }

    this.notify({ // notify the renderer that the viewport changed
      type: 'viewport'
    });

    return this; // chaining
  },

  viewport: function( opts ){
    var _p = this._private;
    var zoomDefd = true;
    var panDefd = true;
    var events = []; // to trigger
    var zoomFailed = false;
    var panFailed = false;

    if( !opts ){ return this; }
    if( !is.number(opts.zoom) ){ zoomDefd = false; }
    if( !is.plainObject(opts.pan) ){ panDefd = false; }
    if( !zoomDefd && !panDefd ){ return this; }

    if( zoomDefd ){
      var z = opts.zoom;

      if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){
        zoomFailed = true;

      } else {
        _p.zoom = z;

        events.push('zoom');
      }
    }

    if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){
      var p = opts.pan;

      if( is.number(p.x) ){
        _p.pan.x = p.x;
        panFailed = false;
      }

      if( is.number(p.y) ){
        _p.pan.y = p.y;
        panFailed = false;
      }

      if( !panFailed ){
        events.push('pan');
      }
    }

    if( events.length > 0 ){
      events.push('viewport');
      this.trigger( events.join(' ') );

      this.notify({
        type: 'viewport'
      });
    }

    return this; // chaining
  },

  center: function( elements ){
    var pan = this.getCenterPan( elements );

    if( pan ){
      this._private.pan = pan;

      this.trigger('pan viewport');

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });
    }

    return this; // chaining
  },

  getCenterPan: function( elements, zoom ){
    if( !this._private.panningEnabled ){
      return;
    }

    if( is.string(elements) ){
      var selector = elements;
      elements = this.elements( selector );
    } else if( !is.elementOrCollection(elements) ){
      elements = this.elements();
    }

    var bb = elements.boundingBox();
    var w = this.width();
    var h = this.height();
    zoom = zoom === undefined ? this._private.zoom : zoom;

    var pan = { // middle
      x: (w - zoom*( bb.x1 + bb.x2 ))/2,
      y: (h - zoom*( bb.y1 + bb.y2 ))/2
    };

    return pan;
  },

  reset: function(){
    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
      return this;
    }

    this.viewport({
      pan: { x: 0, y: 0 },
      zoom: 1
    });

    return this; // chaining
  },

  width: function(){
    var container = this._private.container;

    if( container ){
      return container.clientWidth;
    }

    return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
  },

  height: function(){
    var container = this._private.container;

    if( container ){
      return container.clientHeight;
    }

    return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
  },

  extent: function(){
    var pan = this._private.pan;
    var zoom = this._private.zoom;
    var rb = this.renderedExtent();

    var b = {
      x1: ( rb.x1 - pan.x )/zoom,
      x2: ( rb.x2 - pan.x )/zoom,
      y1: ( rb.y1 - pan.y )/zoom,
      y2: ( rb.y2 - pan.y )/zoom
    };

    b.w = b.x2 - b.x1;
    b.h = b.y2 - b.y1;

    return b;
  },

  renderedExtent: function(){
    var width = this.width();
    var height = this.height();

    return {
      x1: 0,
      y1: 0,
      x2: width,
      y2: height,
      w: width,
      h: height
    };
  }
});

// aliases
corefn.centre = corefn.center;

// backwards compatibility
corefn.autolockNodes = corefn.autolock;
corefn.autoungrabifyNodes = corefn.autoungrabify;

module.exports = corefn;

},{"../is":77}],41:[function(_dereq_,module,exports){
'use strict';

// use this module to cherry pick functions into your prototype
// (useful for functions shared between the core and collections, for example)

// e.g.
// var foo = define.foo({ /* params... */ })

var util = _dereq_('./util');
var is = _dereq_('./is');
var Selector = _dereq_('./selector');
var Promise = _dereq_('./promise');
var Event = _dereq_('./event');
var Animation = _dereq_('./animation');

var define = {

  // access data field
  data: function( params ){
    var defaults = {
      field: 'data',
      bindingEvent: 'data',
      allowBinding: false,
      allowSetting: false,
      allowGetting: false,
      settingEvent: 'data',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      immutableKeys: {}, // key => true if immutable
      updateStyle: false,
      onSet: function( self ){},
      canSet: function( self ){ return true; }
    };
    params = util.extend({}, defaults, params);

    return function dataImpl( name, value ){
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var single = selfIsArrayLike ? self[0] : self;

      // .data('foo', ...)
      if( is.string(name) ){ // set or get property

        // .data('foo')
        if( p.allowGetting && value === undefined ){ // get

          var ret;
          if( single ){
            ret = single._private[ p.field ][ name ];
          }
          return ret;

        // .data('foo', 'bar')
        } else if( p.allowSetting && value !== undefined ) { // set
          var valid = !p.immutableKeys[name];
          if( valid ){
            for( var i = 0, l = all.length; i < l; i++ ){
              if( p.canSet( all[i] ) ){
                all[i]._private[ p.field ][ name ] = value;
              }
            }

            // update mappers if asked
            if( p.updateStyle ){ self.updateStyle(); }

            // call onSet callback
            p.onSet( self );

            if( p.settingTriggersEvent ){
              self[ p.triggerFnName ]( p.settingEvent );
            }
          }
        }

      // .data({ 'foo': 'bar' })
      } else if( p.allowSetting && is.plainObject(name) ){ // extend
        var obj = name;
        var k, v;

        for( k in obj ){
          v = obj[ k ];

          var valid = !p.immutableKeys[k];
          if( valid ){
            for( var i = 0, l = all.length; i < l; i++ ){
              if( p.canSet( all[i] ) ){
                all[i]._private[ p.field ][ k ] = v;
              }
            }
          }
        }

        // update mappers if asked
        if( p.updateStyle ){ self.updateStyle(); }

        // call onSet callback
        p.onSet( self );

        if( p.settingTriggersEvent ){
          self[ p.triggerFnName ]( p.settingEvent );
        }

      // .data(function(){ ... })
      } else if( p.allowBinding && is.fn(name) ){ // bind to event
        var fn = name;
        self.bind( p.bindingEvent, fn );

      // .data()
      } else if( p.allowGetting && name === undefined ){ // get whole object
        var ret;
        if( single ){
          ret = single._private[ p.field ];
        }
        return ret;
      }

      return self; // maintain chainability
    }; // function
  }, // data

  // remove data field
  removeData: function( params ){
    var defaults = {
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: false,
      immutableKeys: {} // key => true if immutable
    };
    params = util.extend({}, defaults, params);

    return function removeDataImpl( names ){
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      // .removeData('foo bar')
      if( is.string(names) ){ // then get the list of keys, and delete them
        var keys = names.split(/\s+/);
        var l = keys.length;

        for( var i = 0; i < l; i++ ){ // delete each non-empty key
          var key = keys[i];
          if( is.emptyString(key) ){ continue; }

          var valid = !p.immutableKeys[ key ]; // not valid if immutable
          if( valid ){
            for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
              all[ i_a ]._private[ p.field ][ key ] = undefined;
            }
          }
        }

        if( p.triggerEvent ){
          self[ p.triggerFnName ]( p.event );
        }

      // .removeData()
      } else if( names === undefined ){ // then delete all keys

        for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
          var _privateFields = all[ i_a ]._private[ p.field ];

          for( var key in _privateFields ){
            var validKeyToDelete = !p.immutableKeys[ key ];

            if( validKeyToDelete ){
              _privateFields[ key ] = undefined;
            }
          }
        }

        if( p.triggerEvent ){
          self[ p.triggerFnName ]( p.event );
        }
      }

      return self; // maintain chaining
    }; // function
  }, // removeData

  // event function reusable stuff
  event: {
    regex: /(\w+)(\.\w+)?/, // regex for matching event strings (e.g. "click.namespace")
    optionalTypeRegex: /(\w+)?(\.\w+)?/,
    falseCallback: function(){ return false; }
  },

  // event binding
  on: function( params ){
    var defaults = {
      unbindSelfOnTrigger: false,
      unbindAllBindersOnTrigger: false
    };
    params = util.extend({}, defaults, params);

    return function onImpl(events, selector, data, callback){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var eventsIsString = is.string(events);
      var p = params;

      if( is.plainObject(selector) ){ // selector is actually data
        callback = data;
        data = selector;
        selector = undefined;
      } else if( is.fn(selector) || selector === false ){ // selector is actually callback
        callback = selector;
        data = undefined;
        selector = undefined;
      }

      if( is.fn(data) || data === false ){ // data is actually callback
        callback = data;
        data = undefined;
      }

      // if there isn't a callback, we can't really do anything
      // (can't speak for mapped events arg version)
      if( !(is.fn(callback) || callback === false) && eventsIsString ){
        return self; // maintain chaining
      }

      if( eventsIsString ){ // then convert to map
        var map = {};
        map[ events ] = callback;
        events = map;
      }

      for( var evts in events ){
        callback = events[evts];
        if( callback === false ){
          callback = define.event.falseCallback;
        }

        if( !is.fn(callback) ){ continue; }

        evts = evts.split(/\s+/);
        for( var i = 0; i < evts.length; i++ ){
          var evt = evts[i];
          if( is.emptyString(evt) ){ continue; }

          var match = evt.match( define.event.regex ); // type[.namespace]

          if( match ){
            var type = match[1];
            var namespace = match[2] ? match[2] : undefined;

            var listener = {
              callback: callback, // callback to run
              data: data, // extra data in eventObj.data
              delegated: selector ? true : false, // whether the evt is delegated
              selector: selector, // the selector to match for delegated events
              selObj: new Selector(selector), // cached selector object to save rebuilding
              type: type, // the event type (e.g. 'click')
              namespace: namespace, // the event namespace (e.g. ".foo")
              unbindSelfOnTrigger: p.unbindSelfOnTrigger,
              unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,
              binders: all // who bound together
            };

            for( var j = 0; j < all.length; j++ ){
              var _p = all[j]._private;

              _p.listeners = _p.listeners || [];
              _p.listeners.push( listener );
            }
          }
        } // for events array
      } // for events map

      return self; // maintain chaining
    }; // function
  }, // on

  eventAliasesOn: function( proto ){
    var p = proto;

    p.addListener = p.listen = p.bind = p.on;
    p.removeListener = p.unlisten = p.unbind = p.off;
    p.emit = p.trigger;

    // this is just a wrapper alias of .on()
    p.pon = p.promiseOn = function( events, selector ){
      var self = this;
      var args = Array.prototype.slice.call( arguments, 0 );

      return new Promise(function( resolve, reject ){
        var callback = function( e ){
          self.off.apply( self, offArgs );

          resolve( e );
        };

        var onArgs = args.concat([ callback ]);
        var offArgs = onArgs.concat([]);

        self.on.apply( self, onArgs );
      });
    };
  },

  off: function offImpl( params ){
    var defaults = {
    };
    params = util.extend({}, defaults, params);

    return function(events, selector, callback){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var eventsIsString = is.string(events);

      if( arguments.length === 0 ){ // then unbind all

        for( var i = 0; i < all.length; i++ ){
          all[i]._private.listeners = [];
        }

        return self; // maintain chaining
      }

      if( is.fn(selector) || selector === false ){ // selector is actually callback
        callback = selector;
        selector = undefined;
      }

      if( eventsIsString ){ // then convert to map
        var map = {};
        map[ events ] = callback;
        events = map;
      }

      for( var evts in events ){
        callback = events[evts];

        if( callback === false ){
          callback = define.event.falseCallback;
        }

        evts = evts.split(/\s+/);
        for( var h = 0; h < evts.length; h++ ){
          var evt = evts[h];
          if( is.emptyString(evt) ){ continue; }

          var match = evt.match( define.event.optionalTypeRegex ); // [type][.namespace]
          if( match ){
            var type = match[1] ? match[1] : undefined;
            var namespace = match[2] ? match[2] : undefined;

            for( var i = 0; i < all.length; i++ ){ //
              var listeners = all[i]._private.listeners = all[i]._private.listeners || [];

              for( var j = 0; j < listeners.length; j++ ){
                var listener = listeners[j];
                var nsMatches = !namespace || namespace === listener.namespace;
                var typeMatches = !type || listener.type === type;
                var cbMatches = !callback || callback === listener.callback;
                var listenerMatches = nsMatches && typeMatches && cbMatches;

                // delete listener if it matches
                if( listenerMatches ){
                  listeners.splice(j, 1);
                  j--;
                }
              } // for listeners
            } // for all
          } // if match
        } // for events array

      } // for events map

      return self; // maintain chaining
    }; // function
  }, // off

  trigger: function( params ){
    var defaults = {};
    params = util.extend({}, defaults, params);

    return function triggerImpl(events, extraParams, fnToTrigger){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var eventsIsString = is.string(events);
      var eventsIsObject = is.plainObject(events);
      var eventsIsEvent = is.event(events);
      var cy = this._private.cy || ( is.core(this) ? this : null );
      var hasCompounds = cy ? cy.hasCompoundNodes() : false;

      if( eventsIsString ){ // then make a plain event object for each event name
        var evts = events.split(/\s+/);
        events = [];

        for( var i = 0; i < evts.length; i++ ){
          var evt = evts[i];
          if( is.emptyString(evt) ){ continue; }

          var match = evt.match( define.event.regex ); // type[.namespace]
          var type = match[1];
          var namespace = match[2] ? match[2] : undefined;

          events.push( {
            type: type,
            namespace: namespace
          } );
        }
      } else if( eventsIsObject ){ // put in length 1 array
        var eventArgObj = events;

        events = [ eventArgObj ];
      }

      if( extraParams ){
        if( !is.array(extraParams) ){ // make sure extra params are in an array if specified
          extraParams = [ extraParams ];
        }
      } else { // otherwise, we've got nothing
        extraParams = [];
      }

      for( var i = 0; i < events.length; i++ ){ // trigger each event in order
        var evtObj = events[i];

        for( var j = 0; j < all.length; j++ ){ // for each
          var triggerer = all[j];
          var listeners = triggerer._private.listeners = triggerer._private.listeners || [];
          var triggererIsElement = is.element(triggerer);
          var bubbleUp = triggererIsElement || params.layout;

          // create the event for this element from the event object
          var evt;

          if( eventsIsEvent ){ // then just get the object
            evt = evtObj;

            evt.cyTarget = evt.cyTarget || triggerer;
            evt.cy = evt.cy || cy;

          } else { // then we have to make one
            evt = new Event( evtObj, {
              cyTarget: triggerer,
              cy: cy,
              namespace: evtObj.namespace
            } );
          }

          // if a layout was specified, then put it in the typed event
          if( evtObj.layout ){
            evt.layout = evtObj.layout;
          }

          // if triggered by layout, put in event
          if( params.layout ){
            evt.layout = triggerer;
          }

          // create a rendered position based on the passed position
          if( evt.cyPosition ){
            var pos = evt.cyPosition;
            var zoom = cy.zoom();
            var pan = cy.pan();

            evt.cyRenderedPosition = {
              x: pos.x * zoom + pan.x,
              y: pos.y * zoom + pan.y
            };
          }

          if( fnToTrigger ){ // then override the listeners list with just the one we specified
            listeners = [{
              namespace: evt.namespace,
              type: evt.type,
              callback: fnToTrigger
            }];
          }

          for( var k = 0; k < listeners.length; k++ ){ // check each listener
            var lis = listeners[k];
            var nsMatches = !lis.namespace || lis.namespace === evt.namespace;
            var typeMatches = lis.type === evt.type;
            var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && is.element(evt.cyTarget) && lis.selObj.matches(evt.cyTarget) ) : (true); // we're not going to validate the hierarchy; that's too expensive
            var listenerMatches = nsMatches && typeMatches && targetMatches;

            if( listenerMatches ){ // then trigger it
              var args = [ evt ];
              args = args.concat( extraParams ); // add extra params to args list

              if( lis.data ){ // add on data plugged into binding
                evt.data = lis.data;
              } else { // or clear it in case the event obj is reused
                evt.data = undefined;
              }

              if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener
                listeners.splice(k, 1);
                k--;
              }

              if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders
                var binders = lis.binders;
                for( var l = 0; l < binders.length; l++ ){
                  var binder = binders[l];
                  if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it

                  var binderListeners = binder._private.listeners;
                  for( var m = 0; m < binderListeners.length; m++ ){
                    var binderListener = binderListeners[m];

                    if( binderListener === lis ){ // delete listener from list
                      binderListeners.splice(m, 1);
                      m--;
                    }
                  }
                }
              }

              // run the callback
              var context = lis.delegated ? evt.cyTarget : triggerer;
              var ret = lis.callback.apply( context, args );

              if( ret === false || evt.isPropagationStopped() ){
                // then don't bubble
                bubbleUp = false;

                if( ret === false ){
                  // returning false is a shorthand for stopping propagation and preventing the def. action
                  evt.stopPropagation();
                  evt.preventDefault();
                }
              }
            } // if listener matches
          } // for each listener

          // bubble up event for elements
          if( bubbleUp ){
            var parent = hasCompounds ? triggerer._private.parent : null;
            var hasParent = parent != null && parent.length !== 0;

            if( hasParent ){ // then bubble up to parent
              parent = parent[0];
              parent.trigger(evt);
            } else { // otherwise, bubble up to the core
              cy.trigger(evt);
            }
          }

        } // for each of all
      } // for each event

      return self; // maintain chaining
    }; // function
  }, // trigger

  animated: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function animatedImpl(){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return false; }

      var ele = all[0];

      if( ele ){
        return ele._private.animation.current.length > 0;
      }
    };
  }, // animated

  clearQueue: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function clearQueueImpl(){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      for( var i = 0; i < all.length; i++ ){
        var ele = all[i];
        ele._private.animation.queue = [];
      }

      return this;
    };
  }, // clearQueue

  delay: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function delayImpl( time, complete ){
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      return this.animate({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  }, // delay

  delayAnimation: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function delayAnimationImpl( time, complete ){
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      return this.animation({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  }, // delay

  animation: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function animationImpl( properties, params ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;
      var isCore = !selfIsArrayLike;
      var isEles = !isCore;

      if( !cy.styleEnabled() ){ return this; }

      var style = cy.style();

      properties = util.extend( {}, properties, params );

      if( properties.duration === undefined ){
        properties.duration = 400;
      }

      switch( properties.duration ){
      case 'slow':
        properties.duration = 600;
        break;
      case 'fast':
        properties.duration = 200;
        break;
      }

      var propertiesEmpty = true;
      if( properties ){ for( var i in properties ){ // jshint ignore:line
        propertiesEmpty = false;
        break;
      } }

      if( propertiesEmpty ){
        return new Animation( all[0], properties ); // nothing to animate
      }

      if( isEles ){
        properties.style = style.getPropsList( properties.style || properties.css );

        properties.css = undefined;
      }

      if( properties.renderedPosition && isEles ){
        var rpos = properties.renderedPosition;
        var pan = cy.pan();
        var zoom = cy.zoom();

        properties.position = {
          x: ( rpos.x - pan.x ) /zoom,
          y: ( rpos.y - pan.y ) /zoom
        };
      }

      // override pan w/ panBy if set
      if( properties.panBy && isCore ){
        var panBy = properties.panBy;
        var cyPan = cy.pan();

        properties.pan = {
          x: cyPan.x + panBy.x,
          y: cyPan.y + panBy.y
        };
      }

      // override pan w/ center if set
      var center = properties.center || properties.centre;
      if( center && isCore ){
        var centerPan = cy.getCenterPan( center.eles, properties.zoom );

        if( centerPan ){
          properties.pan = centerPan;
        }
      }

      // override pan & zoom w/ fit if set
      if( properties.fit && isCore ){
        var fit = properties.fit;
        var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );

        if( fitVp ){
          properties.pan = fitVp.pan;
          properties.zoom = fitVp.zoom;
        }
      }

      return new Animation( all[0], properties );
    };
  }, // animate

  animate: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function animateImpl( properties, params ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      if( params ){
        properties = util.extend( {}, properties, params );
      }

      // manually hook and run the animation
      for( var i = 0; i < all.length; i++ ){
        var ele = all[i];
        var queue = ele.animated() && (properties.queue === undefined || properties.queue);

        var ani = ele.animation( properties, (queue ? { queue: true } : undefined) );

        ani.play();
      }

      return this; // chaining
    };
  }, // animate

  stop: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function stopImpl( clearQueue, jumpToEnd ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      for( var i = 0; i < all.length; i++ ){
        var ele = all[i];
        var _p = ele._private;
        var anis = _p.animation.current;

        for( var j = 0; j < anis.length; j++ ){
          var ani = anis[j];
          var ani_p = ani._private;

          if( jumpToEnd ){
            // next iteration of the animation loop, the animation
            // will go straight to the end and be removed
            ani_p.duration = 0;
          }
        }

        // clear the queue of future animations
        if( clearQueue ){
          _p.animation.queue = [];
        }

        if( !jumpToEnd ){
          _p.animation.current = [];
        }
      }

      // we have to notify (the animation loop doesn't do it for us on `stop`)
      cy.notify({
        collection: this,
        type: 'draw'
      });

      return this;
    };
  } // stop

}; // define

module.exports = define;

},{"./animation":1,"./event":42,"./is":77,"./promise":80,"./selector":81,"./util":94}],42:[function(_dereq_,module,exports){
'use strict';

/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/

var Event = function( src, props ) {
  // Allow instantiation without the 'new' keyword
  if ( !(this instanceof Event) ) {
    return new Event( src, props );
  }

  // Event object
  if ( src && src.type ) {
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;

  // Event type
  } else {
    this.type = src;
  }

  // Put explicitly provided properties onto the event object
  if ( props ) {
    // util.extend( this, props );

    // more efficient to manually copy fields we use
    this.type = props.type !== undefined ? props.type : this.type;
    this.cy = props.cy;
    this.cyTarget = props.cyTarget;
    this.cyPosition = props.cyPosition;
    this.cyRenderedPosition = props.cyRenderedPosition;
    this.namespace = props.namespace;
    this.layout = props.layout;
    this.data = props.data;
    this.message = props.message;
  }

  // Create a timestamp if incoming event doesn't have one
  this.timeStamp = src && src.timeStamp || Date.now();
};

function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
}

// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
Event.prototype = {
  instanceString: function(){
    return 'event';
  },

  preventDefault: function() {
    this.isDefaultPrevented = returnTrue;

    var e = this.originalEvent;
    if ( !e ) {
      return;
    }

    // if preventDefault exists run it on the original event
    if ( e.preventDefault ) {
      e.preventDefault();
    }
  },

  stopPropagation: function() {
    this.isPropagationStopped = returnTrue;

    var e = this.originalEvent;
    if ( !e ) {
      return;
    }

    // if stopPropagation exists run it on the original event
    if ( e.stopPropagation ) {
      e.stopPropagation();
    }
  },

  stopImmediatePropagation: function() {
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },

  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

module.exports = Event;

},{}],43:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('./util');
var define = _dereq_('./define');
var Collection = _dereq_('./collection');
var Core = _dereq_('./core');
var incExts = _dereq_('./extensions');
var is = _dereq_('./is');

// registered extensions to cytoscape, indexed by name
var extensions = {};

// registered modules for extensions, indexed by name
var modules = {};

function setExtension( type, name, registrant ){

  var ext = registrant;

  if( type === 'core' ){
    Core.prototype[ name ] = registrant;

  } else if( type === 'collection' ){
    Collection.prototype[ name ] = registrant;

  } else if( type === 'layout' ){
    // fill in missing layout functions in the prototype

    var Layout = function( options ){
      this.options = options;

      registrant.call( this, options );

      // make sure layout has _private for use w/ std apis like .on()
      if( !is.plainObject(this._private) ){
        this._private = {};
      }

      this._private.cy = options.cy;
      this._private.listeners = [];
    };

    var layoutProto = Layout.prototype = Object.create( registrant.prototype );

    var optLayoutFns = [];

    for( var i = 0; i < optLayoutFns.length; i++ ){
      var fnName = optLayoutFns[i];

      layoutProto[fnName] = layoutProto[fnName] || function(){ return this; };
    }

    // either .start() or .run() is defined, so autogen the other
    if( layoutProto.start && !layoutProto.run ){
      layoutProto.run = function(){ this.start(); return this; };
    } else if( !layoutProto.start && layoutProto.run ){
      layoutProto.start = function(){ this.run(); return this; };
    }

    if( !layoutProto.stop ){
      layoutProto.stop = function(){
        var opts = this.options;

        if( opts && opts.animate ){
          var anis = this.animations;
          for( var i = 0; i < anis.length; i++ ){
            anis[i].stop();
          }
        }

        this.trigger('layoutstop');

        return this;
      };
    }

    if( !layoutProto.destroy ){
      layoutProto.destroy = function(){
        return this;
      };
    }

    layoutProto.on = define.on({ layout: true });
    layoutProto.one = define.on({ layout: true, unbindSelfOnTrigger: true });
    layoutProto.once = define.on({ layout: true, unbindAllBindersOnTrigger: true });
    layoutProto.off = define.off({ layout: true });
    layoutProto.trigger = define.trigger({ layout: true });

    define.eventAliasesOn( layoutProto );

    ext = Layout; // replace with our wrapped layout

  } else if( type === 'renderer' && name !== 'null' && name !== 'base' ){
    // user registered renderers inherit from base

    var bProto = getExtension( 'renderer', 'base' ).prototype;
    var rProto = registrant.prototype;

    for( var pName in bProto ){
      var pVal = bProto[ pName ];
      var existsInR = rProto[ pName ] != null;

      if( existsInR ){
        util.error('Can not register renderer `' + name + '` since it overrides `' + pName + '` in its prototype');
        return;
      }

      rProto[ pName ] = pVal; // take impl from base
    }

    bProto.clientFunctions.forEach(function( name ){
      rProto[ name ] = rProto[ name ] || function(){
        util.error('Renderer does not implement `renderer.' + name + '()` on its prototype');
      };
    });

  }

  return util.setMap({
    map: extensions,
    keys: [ type, name ],
    value: ext
  });
}

function getExtension(type, name){
  return util.getMap({
    map: extensions,
    keys: [ type, name ]
  });
}

function setModule(type, name, moduleType, moduleName, registrant){
  return util.setMap({
    map: modules,
    keys: [ type, name, moduleType, moduleName ],
    value: registrant
  });
}

function getModule(type, name, moduleType, moduleName){
  return util.getMap({
    map: modules,
    keys: [ type, name, moduleType, moduleName ]
  });
}

var extension = function(){
  // e.g. extension('renderer', 'svg')
  if( arguments.length === 2 ){
    return getExtension.apply(null, arguments);
  }

  // e.g. extension('renderer', 'svg', { ... })
  else if( arguments.length === 3 ){
    return setExtension.apply(null, arguments);
  }

  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
  else if( arguments.length === 4 ){
    return getModule.apply(null, arguments);
  }

  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
  else if( arguments.length === 5 ){
    return setModule.apply(null, arguments);
  }

  else {
    util.error('Invalid extension access syntax');
  }

};

// allows a core instance to access extensions internally
Core.prototype.extension = extension;

// included extensions
incExts.forEach(function( group ){
  group.extensions.forEach(function( ext ){
    setExtension( group.type, ext.name, ext.impl );
  });
});

module.exports = extension;

},{"./collection":23,"./core":34,"./define":41,"./extensions":44,"./is":77,"./util":94}],44:[function(_dereq_,module,exports){
'use strict';

module.exports = [
  {
    type: 'layout',
    extensions: _dereq_('./layout')
  },

  {
    type: 'renderer',
    extensions: _dereq_('./renderer')
  }
];

},{"./layout":50,"./renderer":72}],45:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');
var math = _dereq_('../../math');
var is = _dereq_('../../is');

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
  padding: 30, // padding on fit
  circle: false, // put depths in concentric circles if true, put depths top down if false
  spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  roots: undefined, // the roots of the trees
  maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function BreadthFirstLayout( options ){
  this.options = util.extend({}, defaults, options);
}

BreadthFirstLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');
  var graph = eles;

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var roots;
  if( is.elementOrCollection(options.roots) ){
    roots = options.roots;
  } else if( is.array(options.roots) ){
    var rootsArray = [];

    for( var i = 0; i < options.roots.length; i++ ){
      var id = options.roots[i];
      var ele = cy.getElementById( id );
      rootsArray.push( ele );
    }

    roots = cy.collection( rootsArray );
  } else if( is.string(options.roots) ){
    roots = cy.$( options.roots );

  } else {
    if( options.directed ){
      roots = nodes.roots();
    } else {
      var components = [];
      var unhandledNodes = nodes;

      while( unhandledNodes.length > 0 ){
        var currComp = cy.collection();

        eles.bfs({
          roots: unhandledNodes[0],
          visit: function(i, depth, node, edge, pNode){
            currComp = currComp.add( node );
          },
          directed: false
        });

        unhandledNodes = unhandledNodes.not( currComp );
        components.push( currComp );
      }

      roots = cy.collection();
      for( var i = 0; i < components.length; i++ ){
        var comp = components[i];
        var maxDegree = comp.maxDegree( false );
        var compRoots = comp.filter(function(){
          return this.degree(false) === maxDegree;
        });

        roots = roots.add( compRoots );
      }

    }
  }


  var depths = [];
  var foundByBfs = {};
  var id2depth = {};
  var prevNode = {};
  var prevEdge = {};
  var successors = {};

  // find the depths of the nodes
  graph.bfs({
    roots: roots,
    directed: options.directed,
    visit: function(i, depth, node, edge, pNode){
      var ele = this[0];
      var id = ele.id();

      if( !depths[depth] ){
        depths[depth] = [];
      }

      depths[depth].push( ele );
      foundByBfs[ id ] = true;
      id2depth[ id ] = depth;
      prevNode[ id ] = pNode;
      prevEdge[ id ] = edge;

      if( pNode ){
        var prevId = pNode.id();
        var succ = successors[ prevId ] = successors[ prevId ] || [];

        succ.push( node );
      }
    }
  });

  // check for nodes not found by bfs
  var orphanNodes = [];
  for( var i = 0; i < nodes.length; i++ ){
    var ele = nodes[i];

    if( foundByBfs[ ele.id() ] ){
      continue;
    } else {
      orphanNodes.push( ele );
    }
  }

  // assign orphan nodes a depth from their neighborhood
  var maxChecks = orphanNodes.length * 3;
  var checks = 0;
  while( orphanNodes.length !== 0 && checks < maxChecks ){
    var node = orphanNodes.shift();
    var neighbors = node.neighborhood().nodes();
    var assignedDepth = false;

    for( var i = 0; i < neighbors.length; i++ ){
      var depth = id2depth[ neighbors[i].id() ];

      if( depth !== undefined ){
        depths[depth].push( node );
        assignedDepth = true;
        break;
      }
    }

    if( !assignedDepth ){
      orphanNodes.push( node );
    }

    checks++;
  }

  // assign orphan nodes that are still left to the depth of their subgraph
  while( orphanNodes.length !== 0 ){
    var node = orphanNodes.shift();
    //var subgraph = graph.bfs( node ).path;
    var assignedDepth = false;

    // for( var i = 0; i < subgraph.length; i++ ){
    //   var depth = id2depth[ subgraph[i].id() ];

    //   if( depth !== undefined ){
    //     depths[depth].push( node );
    //     assignedDepth = true;
    //     break;
    //   }
    // }

    if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0
      if( depths.length === 0 ){
        depths.push([]);
      }

      depths[0].push( node );
    }
  }

  // assign the nodes a depth and index
  var assignDepthsToEles = function(){
    for( var i = 0; i < depths.length; i++ ){
      var eles = depths[i];

      for( var j = 0; j < eles.length; j++ ){
        var ele = eles[j];

        ele._private.scratch.breadthfirst = {
          depth: i,
          index: j
        };
      }
    }
  };
  assignDepthsToEles();


  var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth
    var edges = node.connectedEdges(function(){
      return this.data('target') === node.id();
    });
    var thisInfo = node._private.scratch.breadthfirst;
    var highestDepthOfOther = 0;
    var highestOther;
    for( var i = 0; i < edges.length; i++ ){
      var edge = edges[i];
      var otherNode = edge.source()[0];
      var otherInfo = otherNode._private.scratch.breadthfirst;

      if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){
        highestDepthOfOther = otherInfo.depth;
        highestOther = otherNode;
      }
    }

    return highestOther;
  };

   // make maximal if so set by adjusting depths
  for( var adj = 0; adj < options.maximalAdjustments; adj++ ){

    var nDepths = depths.length;
    var elesToMove = [];
    for( var i = 0; i < nDepths; i++ ){
      var depth = depths[i];

      var nDepth = depth.length;
      for( var j = 0; j < nDepth; j++ ){
        var ele = depth[j];
        var info = ele._private.scratch.breadthfirst;
        var intEle = intersectsDepth(ele);

        if( intEle ){
          info.intEle = intEle;
          elesToMove.push( ele );
        }
      }
    }

    for( var i = 0; i < elesToMove.length; i++ ){
      var ele = elesToMove[i];
      var info = ele._private.scratch.breadthfirst;
      var intEle = info.intEle;
      var intInfo = intEle._private.scratch.breadthfirst;

      depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index

      // add to end of new depth
      var newDepth = intInfo.depth + 1;
      while( newDepth > depths.length - 1 ){
        depths.push([]);
      }
      depths[ newDepth ].push( ele );

      info.depth = newDepth;
      info.index = depths[newDepth].length - 1;
    }

    assignDepthsToEles();
  }

  // find min distance we need to leave between nodes
  var minDistance = 0;
  if( options.avoidOverlap ){
    for( var i = 0; i < nodes.length; i++ ){
      var n = nodes[i];
      var nbb = n.boundingBox();
      var w = nbb.w;
      var h = nbb.h;

      minDistance = Math.max(minDistance, w, h);
    }
    minDistance *= options.spacingFactor; // just to have some nice spacing
  }

  // get the weighted percent for an element based on its connectivity to other levels
  var cachedWeightedPercent = {};
  var getWeightedPercent = function( ele ){
    if( cachedWeightedPercent[ ele.id() ] ){
      return cachedWeightedPercent[ ele.id() ];
    }

    var eleDepth = ele._private.scratch.breadthfirst.depth;
    var neighbors = ele.neighborhood().nodes().not(':parent');
    var percent = 0;
    var samples = 0;

    for( var i = 0; i < neighbors.length; i++ ){
      var neighbor = neighbors[i];
      var bf = neighbor._private.scratch.breadthfirst;
      var index = bf.index;
      var depth = bf.depth;
      var nDepth = depths[depth].length;

      if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above
        percent += index / nDepth;
        samples++;
      }
    }

    samples = Math.max(1, samples);
    percent = percent / samples;

    if( samples === 0 ){ // so lone nodes have a "don't care" state in sorting
      percent = undefined;
    }

    cachedWeightedPercent[ ele.id() ] = percent;
    return percent;
  };


  // rearrange the indices in each depth level based on connectivity

  var sortFn = function(a, b){
    var apct = getWeightedPercent( a );
    var bpct = getWeightedPercent( b );

    return apct - bpct;
  };

  for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result

    for( var i = 0; i < depths.length; i++ ){
      depths[i] = depths[i].sort( sortFn );
    }
    assignDepthsToEles(); // and update

  }

  var biggestDepthSize = 0;
  for( var i = 0; i < depths.length; i++ ){
    biggestDepthSize = Math.max( depths[i].length, biggestDepthSize );
  }

  var center = {
    x: bb.x1 + bb.w/2,
    y: bb.x1 + bb.h/2
  };

  var getPosition = function( ele, isBottomDepth ){
    var info = ele._private.scratch.breadthfirst;
    var depth = info.depth;
    var index = info.index;
    var depthSize = depths[depth].length;

    var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );
    var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );
    var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );
    radiusStepSize = Math.max( radiusStepSize, minDistance );

    if( !options.circle ){

      var epos = {
        x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
        y: (depth + 1) * distanceY
      };

      if( isBottomDepth ){
        return epos;
      }

      // var succs = successors[ ele.id() ];
      // if( succs ){
      //   epos.x = 0;
      //
      //   for( var i = 0 ; i < succs.length; i++ ){
      //     var spos = pos[ succs[i].id() ];
      //
      //     epos.x += spos.x;
      //   }
      //
      //   epos.x /= succs.length;
      // } else {
      //   //debugger;
      // }

      return epos;

    } else {
      if( options.circle ){
        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize/2 : 0);
        var theta = 2 * Math.PI / depths[depth].length * index;

        if( depth === 0 && depths[0].length === 1 ){
          radius = 1;
        }

        return {
          x: center.x + radius * Math.cos(theta),
          y: center.y + radius * Math.sin(theta)
        };

      } else {
        return {
          x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
          y: (depth + 1) * distanceY
        };
      }
    }

  };

  // get positions in reverse depth order
  var pos = {};
  for( var i = depths.length - 1; i >=0; i-- ){
    var depth = depths[i];

    for( var j = 0; j < depth.length; j++ ){
      var node = depth[j];

      pos[ node.id() ] = getPosition( node, i === depths.length - 1 );
    }
  }

  nodes.layoutPositions(this, options, function(){
    return pos[ this.id() ];
  });

  return this; // chaining
};

module.exports = BreadthFirstLayout;

},{"../../is":77,"../../math":79,"../../util":94}],46:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');
var math = _dereq_('../../math');
var is = _dereq_('../../is');

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
  radius: undefined, // the radius of the circle
  startAngle: 3/2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function CircleLayout( options ){
  this.options = util.extend({}, defaults, options);
}

CircleLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var nodes = eles.nodes().not(':parent');

  if( options.sort ){
    nodes = nodes.sort( options.sort );
  }

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var center = {
    x: bb.x1 + bb.w/2,
    y: bb.y1 + bb.h/2
  };

  var sweep = options.sweep === undefined ? 2*Math.PI - 2*Math.PI/nodes.length : options.sweep;

  var dTheta = sweep / ( Math.max(1, nodes.length - 1) );
  var r;

  var minDistance = 0;
  for( var i = 0; i < nodes.length; i++ ){
    var n = nodes[i];
    var nbb = n.boundingBox();
    var w = nbb.w;
    var h = nbb.h;

    minDistance = Math.max(minDistance, w, h);
  }

  if( is.number(options.radius) ){
    r = options.radius;
  } else if( nodes.length <= 1 ){
    r = 0;
  } else {
    r = Math.min( bb.h, bb.w )/2 - minDistance;
  }

  // calculate the radius
  if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
    minDistance *= 1.75; // just to have some nice spacing

    var dcos = Math.cos(dTheta) - Math.cos(0);
    var dsin = Math.sin(dTheta) - Math.sin(0);
    var rMin = Math.sqrt( minDistance * minDistance / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
    r = Math.max( rMin, r );
  }

  var getPos = function( i, ele ){
    var theta = options.startAngle + i * dTheta * ( clockwise ? 1 : -1 );

    var rx = r * Math.cos( theta );
    var ry = r * Math.sin( theta );
    var pos = {
      x: center.x + rx,
      y: center.y + ry
    };

    return pos;
  };

  nodes.layoutPositions( this, options, getPos );

  return this; // chaining
};

module.exports = CircleLayout;

},{"../../is":77,"../../math":79,"../../util":94}],47:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');
var math = _dereq_('../../math');

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  startAngle: 3/2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  height: undefined, // height of layout area (overrides container height)
  width: undefined, // width of layout area (overrides container width)
  concentric: function(node){ // returns numeric value for each node, placing higher nodes in levels towards the centre
    return node.degree();
  },
  levelWidth: function(nodes){ // the variation of concentric values in each level
    return nodes.maxDegree() / 4;
  },
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function ConcentricLayout( options ){
  this.options = util.extend({}, defaults, options);
}

ConcentricLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var cy = params.cy;

  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var center = {
    x: bb.x1 + bb.w/2,
    y: bb.y1 + bb.h/2
  };

  var nodeValues = []; // { node, value }
  var theta = options.startAngle;
  var maxNodeSize = 0;

  for( var i = 0; i < nodes.length; i++ ){
    var node = nodes[i];
    var value;

    // calculate the node value
    value = options.concentric.apply(node, [ node ]);
    nodeValues.push({
      value: value,
      node: node
    });

    // for style mapping
    node._private.scratch.concentric = value;
  }

  // in case we used the `concentric` in style
  nodes.updateStyle();

  // calculate max size now based on potentially updated mappers
  for( var i = 0; i < nodes.length; i++ ){
    var node = nodes[i];
    var nbb = node.boundingBox();

    maxNodeSize = Math.max( maxNodeSize, nbb.w, nbb.h );
  }

  // sort node values in descreasing order
  nodeValues.sort(function(a, b){
    return b.value - a.value;
  });

  var levelWidth = options.levelWidth( nodes );

  // put the values into levels
  var levels = [ [] ];
  var currentLevel = levels[0];
  for( var i = 0; i < nodeValues.length; i++ ){
    var val = nodeValues[i];

    if( currentLevel.length > 0 ){
      var diff = Math.abs( currentLevel[0].value - val.value );

      if( diff >= levelWidth ){
        currentLevel = [];
        levels.push( currentLevel );
      }
    }

    currentLevel.push( val );
  }

  // create positions from levels

  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

  if( !options.avoidOverlap ){ // then strictly constrain to bb
    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
    var maxR = ( Math.min(bb.w, bb.h) / 2 - minDist );
    var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );

    minDist = Math.min( minDist, rStep );
  }

  // find the metrics for each level
  var r = 0;
  for( var i = 0; i < levels.length; i++ ){
    var level = levels[i];
    var sweep = options.sweep === undefined ? 2*Math.PI - 2*Math.PI/level.length : options.sweep;
    var dTheta = level.dTheta = sweep / ( Math.max(1, level.length - 1) );

    // calculate the radius
    if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt( minDist * minDist / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping

      r = Math.max( rMin, r );
    }

    level.r = r;

    r += minDist;
  }

  if( options.equidistant ){
    var rDeltaMax = 0;
    var r = 0;

    for( var i = 0; i < levels.length; i++ ){
      var level = levels[i];
      var rDelta = level.r - r;

      rDeltaMax = Math.max( rDeltaMax, rDelta );
    }

    r = 0;
    for( var i = 0; i < levels.length; i++ ){
      var level = levels[i];

      if( i === 0 ){
        r = level.r;
      }

      level.r = r;

      r += rDeltaMax;
    }
  }

  // calculate the node positions
  var pos = {}; // id => position
  for( var i = 0; i < levels.length; i++ ){
    var level = levels[i];
    var dTheta = level.dTheta;
    var r = level.r;

    for( var j = 0; j < level.length; j++ ){
      var val = level[j];
      var theta = options.startAngle + (clockwise ? 1 : -1) * dTheta * j;

      var p = {
        x: center.x + r * Math.cos(theta),
        y: center.y + r * Math.sin(theta)
      };

      pos[ val.node.id() ] = p;
    }
  }

  // position the nodes
  nodes.layoutPositions(this, options, function(){
    var id = this.id();

    return pos[id];
  });

  return this; // chaining
};

module.exports = ConcentricLayout;

},{"../../math":79,"../../util":94}],48:[function(_dereq_,module,exports){
'use strict';

/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*/

var util = _dereq_('../../util');
var math = _dereq_('../../math');
var Thread = _dereq_('../../thread');
var is = _dereq_('../../is');

var DEBUG;

/**
 * @brief :  default layout options
 */
var defaults = {
  // Called on `layoutready`
  ready               : function() {},

  // Called on `layoutstop`
  stop                : function() {},

  // Whether to animate while running the layout
  animate             : true,

  // The layout animates only after this many milliseconds
  // (prevents flashing on fast runs)
  animationThreshold  : 250,

  // Number of iterations between consecutive screen positions update
  // (0 -> only updated on the end)
  refresh             : 20,

  // Whether to fit the network view after when done
  fit                 : true,

  // Padding on fit
  padding             : 30,

  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox         : undefined,

  // Extra spacing between components in non-compound graphs
  componentSpacing    : 100,

  // Node repulsion (non overlapping) multiplier
  nodeRepulsion       : function( node ){ return 400000; },

  // Node repulsion (overlapping) multiplier
  nodeOverlap         : 10,

  // Ideal edge (non nested) length
  idealEdgeLength     : function( edge ){ return 10; },

  // Divisor to compute edge forces
  edgeElasticity      : function( edge ){ return 100; },

  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor       : 5,

  // Gravity force (constant)
  gravity             : 80,

  // Maximum number of iterations to perform
  numIter             : 1000,

  // Initial temperature (maximum node displacement)
  initialTemp         : 200,

  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor       : 0.95,

  // Lower temperature threshold (below this point the layout will end)
  minTemp             : 1.0,

  // Whether to use threading to speed up the layout
  useMultitasking     : true
};


/**
 * @brief       : constructor
 * @arg options : object containing layout options
 */
function CoseLayout(options) {
  this.options = util.extend({}, defaults, options);

  this.options.layout = this;
}


/**
 * @brief : runs the layout
 */
CoseLayout.prototype.run = function() {
  var options = this.options;
  var cy      = options.cy;
  var layout  = this;
  var thread  = this.thread;

  if( !thread || thread.stopped() ){
    thread = this.thread = Thread({ disabled: !options.useMultitasking });
  }

  layout.stopped = false;

  layout.trigger({ type: 'layoutstart', layout: layout });

  // Set DEBUG - Global variable
  if (true === options.debug) {
    DEBUG = true;
  } else {
    DEBUG = false;
  }

  // Initialize layout info
  var layoutInfo = createLayoutInfo(cy, layout, options);

  // Show LayoutInfo contents if debugging
  if (DEBUG) {
    printLayoutInfo(layoutInfo);
  }

  // If required, randomize node positions
  // if (true === options.randomize) {
    randomizePositions(layoutInfo, cy);
  // }

  var startTime = Date.now();
  var refreshRequested = false;
  var refresh = function( rOpts ){
    rOpts = rOpts || {};

    if( refreshRequested ){
      return;
    }

    if( !rOpts.force && Date.now() - startTime < options.animationThreshold ){
      return;
    }

    refreshRequested = true;

    util.requestAnimationFrame(function(){
      refreshPositions(layoutInfo, cy, options);

      // Fit the graph if necessary
      if (true === options.fit) {
        cy.fit( options.padding );
      }

      refreshRequested = false;

      if( rOpts.next ){ rOpts.next(); }
    });
  };

  thread.on('message', function( e ){
    var layoutNodes = e.message;

    layoutInfo.layoutNodes = layoutNodes;
    refresh();
  });

  thread.pass({
    layoutInfo: layoutInfo,
    options: {
      animate: options.animate,
      refresh: options.refresh,
      componentSpacing: options.componentSpacing,
      nodeOverlap: options.nodeOverlap,
      nestingFactor: options.nestingFactor,
      gravity: options.gravity,
      numIter: options.numIter,
      initialTemp: options.initialTemp,
      coolingFactor: options.coolingFactor,
      minTemp: options.minTemp
    }
  }).run(function( pass ){
    var layoutInfo = pass.layoutInfo;
    var options = pass.options;
    var stopped = false;

    /**
     * @brief          : Performs one iteration of the physical simulation
     * @arg layoutInfo : LayoutInfo object already initialized
     * @arg cy         : Cytoscape object
     * @arg options    : Layout options
     */
    var step = function(layoutInfo, options, step) {
      // var s = "\n\n###############################";
      // s += "\nSTEP: " + step;
      // s += "\n###############################\n";
      // logDebug(s);

      // Calculate node repulsions
      calculateNodeForces(layoutInfo, options);
      // Calculate edge forces
      calculateEdgeForces(layoutInfo, options);
      // Calculate gravity forces
      calculateGravityForces(layoutInfo, options);
      // Propagate forces from parent to child
      propagateForces(layoutInfo, options);
      // Update positions based on calculated forces
      updatePositions(layoutInfo, options);
    };

    /**
     * @brief : Computes the node repulsion forces
     */
    var calculateNodeForces = function(layoutInfo, options) {
      // Go through each of the graphs in graphSet
      // Nodes only repel each other if they belong to the same graph
      // var s = 'calculateNodeForces';
      // logDebug(s);
      for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
        var graph    = layoutInfo.graphSet[i];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Now get all the pairs of nodes
        // Only get each pair once, (A, B) = (B, A)
        for (var j = 0; j < numNodes; j++) {
          var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];

          for (var k = j + 1; k < numNodes; k++) {
            var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];

            nodeRepulsion(node1, node2, layoutInfo, options);
          }
        }
      }
    };

    /**
     * @brief : Compute the node repulsion forces between a pair of nodes
     */
    var nodeRepulsion = function(node1, node2, layoutInfo, options) {
      // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

      var cmptId1 = node1.cmptId;
      var cmptId2 = node2.cmptId;

      if( cmptId1 !== cmptId2 && !layoutInfo.isCompound ){ return; }

      // Get direction of line connecting both node centers
      var directionX = node2.positionX - node1.positionX;
      var directionY = node2.positionY - node1.positionY;
      // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

      // If both centers are the same, apply a random force
      if (0 === directionX && 0 === directionY) {
        // s += "\nNodes have the same position.";
        return; // TODO could be improved with random force
      }

      var overlap = nodesOverlap(node1, node2, directionX, directionY);

      if (overlap > 0) {
        // s += "\nNodes DO overlap.";
        // s += "\nOverlap: " + overlap;
        // If nodes overlap, repulsion force is proportional
        // to the overlap
        var force    = options.nodeOverlap * overlap;

        // Compute the module and components of the force vector
        var distance = Math.sqrt(directionX * directionX + directionY * directionY);
        // s += "\nDistance: " + distance;
        var forceX   = force * directionX / distance;
        var forceY   = force * directionY / distance;

      } else {
        // s += "\nNodes do NOT overlap.";
        // If there's no overlap, force is inversely proportional
        // to squared distance

        // Get clipping points for both nodes
        var point1 = findClippingPoint(node1, directionX, directionY);
        var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);

        // Use clipping points to compute distance
        var distanceX   = point2.x - point1.x;
        var distanceY   = point2.y - point1.y;
        var distanceSqr = distanceX * distanceX + distanceY * distanceY;
        var distance    = Math.sqrt(distanceSqr);
        // s += "\nDistance: " + distance;

        // Compute the module and components of the force vector
        var force  = ( node1.nodeRepulsion + node2.nodeRepulsion ) / distanceSqr;
        var forceX = force * distanceX / distance;
        var forceY = force * distanceY / distance;
      }

      // Apply force
      if( !node1.isLocked ){
        node1.offsetX -= forceX;
        node1.offsetY -= forceY;
      }

      if( !node2.isLocked ){
        node2.offsetX += forceX;
        node2.offsetY += forceY;
      }

      // s += "\nForceX: " + forceX + " ForceY: " + forceY;
      // logDebug(s);

      return;
    };

    /**
     * @brief  : Determines whether two nodes overlap or not
     * @return : Amount of overlapping (0 => no overlap)
     */
    var nodesOverlap = function(node1, node2, dX, dY) {

      if (dX > 0) {
        var overlapX = node1.maxX - node2.minX;
      } else {
        var overlapX = node2.maxX - node1.minX;
      }

      if (dY > 0) {
        var overlapY = node1.maxY - node2.minY;
      } else {
        var overlapY = node2.maxY - node1.minY;
      }

      if (overlapX >= 0 && overlapY >= 0) {
        return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
      } else {
        return 0;
      }
    };

    /**
     * @brief : Finds the point in which an edge (direction dX, dY) intersects
     *          the rectangular bounding box of it's source/target node
     */
    var findClippingPoint = function(node, dX, dY) {

      // Shorcuts
      var X = node.positionX;
      var Y = node.positionY;
      var H = node.height || 1;
      var W = node.width || 1;
      var dirSlope     = dY / dX;
      var nodeSlope    = H / W;

      // var s = 'Computing clipping point of node ' + node.id +
      //   " . Height:  " + H + ", Width: " + W +
      //   "\nDirection " + dX + ", " + dY;
      //
      // Compute intersection
      var res = {};
      do {
        // Case: Vertical direction (up)
        if (0 === dX && 0 < dY) {
          res.x = X;
          // s += "\nUp direction";
          res.y = Y + H / 2;
          break;
        }

        // Case: Vertical direction (down)
        if (0 === dX && 0 > dY) {
          res.x = X;
          res.y = Y + H / 2;
          // s += "\nDown direction";
          break;
        }

        // Case: Intersects the right border
        if (0 < dX &&
        -1 * nodeSlope <= dirSlope &&
        dirSlope <= nodeSlope) {
          res.x = X + W / 2;
          res.y = Y + (W * dY / 2 / dX);
          // s += "\nRightborder";
          break;
        }

        // Case: Intersects the left border
        if (0 > dX &&
        -1 * nodeSlope <= dirSlope &&
        dirSlope <= nodeSlope) {
          res.x = X - W / 2;
          res.y = Y - (W * dY / 2 / dX);
          // s += "\nLeftborder";
          break;
        }

        // Case: Intersects the top border
        if (0 < dY &&
        ( dirSlope <= -1 * nodeSlope ||
          dirSlope >= nodeSlope )) {
          res.x = X + (H * dX / 2 / dY);
          res.y = Y + H / 2;
          // s += "\nTop border";
          break;
        }

        // Case: Intersects the bottom border
        if (0 > dY &&
        ( dirSlope <= -1 * nodeSlope ||
          dirSlope >= nodeSlope )) {
          res.x = X - (H * dX / 2 / dY);
          res.y = Y - H / 2;
          // s += "\nBottom border";
          break;
        }

      } while (false);

      // s += "\nClipping point found at " + res.x + ", " + res.y;
      // logDebug(s);
      return res;
    };

    /**
     * @brief : Calculates all edge forces
     */
    var calculateEdgeForces = function(layoutInfo, options) {
      // Iterate over all edges
      for (var i = 0; i < layoutInfo.edgeSize; i++) {
        // Get edge, source & target nodes
        var edge     = layoutInfo.layoutEdges[i];
        var sourceIx = layoutInfo.idToIndex[edge.sourceId];
        var source   = layoutInfo.layoutNodes[sourceIx];
        var targetIx = layoutInfo.idToIndex[edge.targetId];
        var target   = layoutInfo.layoutNodes[targetIx];

        // Get direction of line connecting both node centers
        var directionX = target.positionX - source.positionX;
        var directionY = target.positionY - source.positionY;

        // If both centers are the same, do nothing.
        // A random force has already been applied as node repulsion
        if (0 === directionX && 0 === directionY) {
        return;
        }

        // Get clipping points for both nodes
        var point1 = findClippingPoint(source, directionX, directionY);
        var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);


        var lx = point2.x - point1.x;
        var ly = point2.y - point1.y;
        var l  = Math.sqrt(lx * lx + ly * ly);

        var force  = Math.pow(edge.idealLength - l, 2) / edge.elasticity;

        if (0 !== l) {
          var forceX = force * lx / l;
          var forceY = force * ly / l;
        } else {
          var forceX = 0;
          var forceY = 0;
        }

        // Add this force to target and source nodes
        if( !source.isLocked ){
          source.offsetX += forceX;
          source.offsetY += forceY;
        }

        if( !target.isLocked ){
          target.offsetX -= forceX;
          target.offsetY -= forceY;
        }

        // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
        // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
        // logDebug(s);
      }
    };

    /**
     * @brief : Computes gravity forces for all nodes
     */
    var calculateGravityForces = function(layoutInfo, options) {
      var distThreshold = 1;

      // var s = 'calculateGravityForces';
      // logDebug(s);
      for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
        var graph    = layoutInfo.graphSet[i];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Compute graph center
        if (0 === i) {
          var centerX   = layoutInfo.clientHeight / 2;
          var centerY   = layoutInfo.clientWidth  / 2;
        } else {
          // Get Parent node for this graph, and use its position as center
          var temp    = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
          var parent  = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
          var centerX = parent.positionX;
          var centerY = parent.positionY;
        }
        // s = "Center found at: " + centerX + ", " + centerY;
        // logDebug(s);

        // Apply force to all nodes in graph
        for (var j = 0; j < numNodes; j++) {
          var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
          // s = "Node: " + node.id;

          if( node.isLocked ){ continue; }

          var dx = centerX - node.positionX;
          var dy = centerY - node.positionY;
          var d  = Math.sqrt(dx * dx + dy * dy);
          if (d > distThreshold) {
            var fx = options.gravity * dx / d;
            var fy = options.gravity * dy / d;
            node.offsetX += fx;
            node.offsetY += fy;
            // s += ": Applied force: " + fx + ", " + fy;
          } else {
            // s += ": skypped since it's too close to center";
          }
          // logDebug(s);
        }
      }
    };

    /**
     * @brief          : This function propagates the existing offsets from
     *                   parent nodes to its descendents.
     * @arg layoutInfo : layoutInfo Object
     * @arg cy         : cytoscape Object
     * @arg options    : Layout options
     */
    var propagateForces = function(layoutInfo, options) {
      // Inline implementation of a queue, used for traversing the graph in BFS order
      var queue = [];
      var start = 0;   // Points to the start the queue
      var end   = -1;  // Points to the end of the queue

      // logDebug('propagateForces');

      // Start by visiting the nodes in the root graph
      queue.push.apply(queue, layoutInfo.graphSet[0]);
      end += layoutInfo.graphSet[0].length;

      // Traverse the graph, level by level,
      while (start <= end) {
        // Get the node to visit and remove it from queue
        var nodeId    = queue[start++];
        var nodeIndex = layoutInfo.idToIndex[nodeId];
        var node      = layoutInfo.layoutNodes[nodeIndex];
        var children  = node.children;

        // We only need to process the node if it's compound
        if (0 < children.length && !node.isLocked) {
          var offX = node.offsetX;
          var offY = node.offsetY;

          // var s = "Propagating offset from parent node : " + node.id +
          //   ". OffsetX: " + offX + ". OffsetY: " + offY;
          // s += "\n Children: " + children.toString();
          // logDebug(s);

          for (var i = 0; i < children.length; i++) {
            var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
            // Propagate offset
            childNode.offsetX += offX;
            childNode.offsetY += offY;
            // Add children to queue to be visited
            queue[++end] = children[i];
          }

          // Reset parent offsets
          node.offsetX = 0;
          node.offsetY = 0;
        }

      }
    };

    /**
     * @brief : Updates the layout model positions, based on
     *          the accumulated forces
     */
    var updatePositions = function(layoutInfo, options) {
      // var s = 'Updating positions';
      // logDebug(s);

      // Reset boundaries for compound nodes
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length) {
          // logDebug("Resetting boundaries of compound node: " + n.id);
          n.maxX = undefined;
          n.minX = undefined;
          n.maxY = undefined;
          n.minY = undefined;
        }
      }

      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length || n.isLocked) {
          // No need to set compound or locked node position
          // logDebug("Skipping position update of node: " + n.id);
          continue;
        }
        // s = "Node: " + n.id + " Previous position: (" +
        // n.positionX + ", " + n.positionY + ").";

        // Limit displacement in order to improve stability
        var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
        n.positionX += tempForce.x;
        n.positionY += tempForce.y;
        n.offsetX = 0;
        n.offsetY = 0;
        n.minX    = n.positionX - n.width;
        n.maxX    = n.positionX + n.width;
        n.minY    = n.positionY - n.height;
        n.maxY    = n.positionY + n.height;
        // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
        // logDebug(s);

        // Update ancestry boudaries
        updateAncestryBoundaries(n, layoutInfo);
      }

      // Update size, position of compund nodes
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        if ( 0 < n.children.length && !n.isLocked ) {
          n.positionX = (n.maxX + n.minX) / 2;
          n.positionY = (n.maxY + n.minY) / 2;
          n.width     = n.maxX - n.minX;
          n.height    = n.maxY - n.minY;
          // s = "Updating position, size of compound node " + n.id;
          // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
          // s += "\nWidth: " + n.width + ", Height: " + n.height;
          // logDebug(s);
        }
      }
    };

    /**
     * @brief : Limits a force (forceX, forceY) to be not
     *          greater (in modulo) than max.
     8          Preserves force direction.
     */
    var limitForce = function(forceX, forceY, max) {
      // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
      var force = Math.sqrt(forceX * forceX + forceY * forceY);

      if (force > max) {
        var res = {
        x : max * forceX / force,
        y : max * forceY / force
        };

      } else {
        var res = {
        x : forceX,
        y : forceY
        };
      }

      // s += ".\nResult: (" + res.x + ", " + res.y + ")";
      // logDebug(s);

      return res;
    };

    /**
     * @brief : Function used for keeping track of compound node
     *          sizes, since they should bound all their subnodes.
     */
    var updateAncestryBoundaries = function(node, layoutInfo) {
      // var s = "Propagating new position/size of node " + node.id;
      var parentId = node.parentId;
      if (null == parentId) {
        // If there's no parent, we are done
        // s += ". No parent node.";
        // logDebug(s);
        return;
      }

      // Get Parent Node
      var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
      var flag = false;

      // MaxX
      if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
        p.maxX = node.maxX + p.padRight;
        flag = true;
        // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
      }

      // MinX
      if (null == p.minX || node.minX - p.padLeft < p.minX) {
        p.minX = node.minX - p.padLeft;
        flag = true;
        // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
      }

      // MaxY
      if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
        p.maxY = node.maxY + p.padBottom;
        flag = true;
        // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
      }

      // MinY
      if (null == p.minY || node.minY - p.padTop < p.minY) {
        p.minY = node.minY - p.padTop;
        flag = true;
        // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
      }

      // If updated boundaries, propagate changes upward
      if (flag) {
        // logDebug(s);
        return updateAncestryBoundaries(p, layoutInfo);
      }

      // s += ". No changes in boundaries/position of parent node " + p.id;
      // logDebug(s);
      return;
    };

    var separateComponents = function(layutInfo, options){
      var nodes = layoutInfo.layoutNodes;
      var components = [];

      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var cid = node.cmptId;
        var component = components[ cid ] = components[ cid ] || [];

        component.push( node );
      }

      var totalA = 0;

      for( var i = 0; i < components.length; i++ ){
        var c = components[i];
        c.x1 = Infinity;
        c.x2 = -Infinity;
        c.y1 = Infinity;
        c.y2 = -Infinity;

        for( var j = 0; j < c.length; j++ ){
          var n = c[j];

          c.x1 = Math.min( c.x1, n.positionX - n.width/2 );
          c.x2 = Math.max( c.x2, n.positionX + n.width/2 );
          c.y1 = Math.min( c.y1, n.positionY - n.height/2 );
          c.y2 = Math.max( c.y2, n.positionY + n.height/2 );
        }

        c.w = c.x2 - c.x1;
        c.h = c.y2 - c.y1;

        totalA += c.w * c.h;
      }

      components.sort(function( c1, c2 ){
        return c2.w*c2.h - c1.w*c1.h;
      });

      var x = 0;
      var y = 0;
      var usedW = 0;
      var rowH = 0;
      var maxRowW = Math.sqrt( totalA ) * layoutInfo.clientWidth / layoutInfo.clientHeight;

      for( var i = 0; i < components.length; i++ ){
        var c = components[i];

        for( var j = 0; j < c.length; j++ ){
          var n = c[j];

          if( !n.isLocked ){
            n.positionX += x;
            n.positionY += y;
          }
        }

        x += c.w + options.componentSpacing;
        usedW += c.w + options.componentSpacing;
        rowH = Math.max( rowH, c.h );

        if( usedW > maxRowW ){
          y += rowH + options.componentSpacing;
          x = 0;
          usedW = 0;
          rowH = 0;
        }
      }
    };

    var mainLoop = function(i){
      if( stopped ){
        // logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
      }

      // Do one step in the phisical simulation
      step(layoutInfo, options, i);

      // Update temperature
      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
      // logDebug("New temperature: " + layoutInfo.temperature);

      if (layoutInfo.temperature < options.minTemp) {
        // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
      }

      return true;
    };

    var i = 0;
    var loopRet;

    do {
      var f = 0;

      while( f < options.refresh && i < options.numIter ){
        var loopRet = mainLoop(i);
        if( !loopRet ){ break; }

        f++;
        i++;
      }

      if( options.animate ){
        broadcast( layoutInfo.layoutNodes ); // jshint ignore:line
      }

    } while ( loopRet && i + 1 < options.numIter );

    separateComponents( layoutInfo, options );

    return layoutInfo;
  }).then(function( layoutInfoUpdated ){
    layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions

    thread.stop();
    done();
  });

  var done = function(){
    refresh({ 
      force: true,
      next: function(){
        // Layout has finished
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      }
    });
  };

  return this; // chaining
};


/**
 * @brief : called on continuous layouts to stop them before they finish
 */
CoseLayout.prototype.stop = function(){
  this.stopped = true;

  if( this.thread ){
    this.thread.stop();
  }

  this.trigger('layoutstop');

  return this; // chaining
};

CoseLayout.prototype.destroy = function(){
  if( this.thread ){
    this.thread.stop();
  }

  return this; // chaining
};


/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */
var createLayoutInfo = function(cy, layout, options) {
  // Shortcut
  var edges = options.eles.edges();
  var nodes = options.eles.nodes();

  var layoutInfo   = {
    isCompound   : cy.hasCompoundNodes(),
    layoutNodes  : [],
    idToIndex    : {},
    nodeSize     : nodes.size(),
    graphSet     : [],
    indexToGraph : [],
    layoutEdges  : [],
    edgeSize     : edges.size(),
    temperature  : options.initialTemp,
    clientWidth  : cy.width(),
    clientHeight : cy.width(),
    boundingBox  : math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
                     x1: 0, y1: 0, w: cy.width(), h: cy.height()
                   } )
  };

  var components = options.eles.components();
  var id2cmptId = {};

  for( var i = 0; i < components.length; i++ ){
    var component = components[i];

    for( var j = 0; j < component.length; j++ ){
      var node = component[j];

      id2cmptId[ node.id() ] = i;
    }
  }

  // Iterate over all nodes, creating layout nodes
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = nodes[i];
    var nbb = n.boundingBox();

    var tempNode        = {};
    tempNode.isLocked   = n.locked();
    tempNode.id         = n.data('id');
    tempNode.parentId   = n.data('parent');
    tempNode.cmptId     = id2cmptId[ n.id() ];
    tempNode.children   = [];
    tempNode.positionX  = n.position('x');
    tempNode.positionY  = n.position('y');
    tempNode.offsetX    = 0;
    tempNode.offsetY    = 0;
    tempNode.height     = nbb.w;
    tempNode.width      = nbb.h;
    tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;
    tempNode.minX       = tempNode.positionX - tempNode.width  / 2;
    tempNode.maxY       = tempNode.positionY + tempNode.height / 2;
    tempNode.minY       = tempNode.positionY - tempNode.height / 2;
    tempNode.padLeft    = parseFloat( n.style('padding-left') );
    tempNode.padRight   = parseFloat( n.style('padding-right') );
    tempNode.padTop     = parseFloat( n.style('padding-top') );
    tempNode.padBottom  = parseFloat( n.style('padding-bottom') );

    // forces
    tempNode.nodeRepulsion = is.fn( options.nodeRepulsion ) ? options.nodeRepulsion.call( n, n ) : options.nodeRepulsion;

    // Add new node
    layoutInfo.layoutNodes.push(tempNode);
    // Add entry to id-index map
    layoutInfo.idToIndex[tempNode.id] = i;
  }

  // Inline implementation of a queue, used for traversing the graph in BFS order
  var queue = [];
  var start = 0;   // Points to the start the queue
  var end   = -1;  // Points to the end of the queue

  var tempGraph = [];

  // Second pass to add child information and
  // initialize queue for hierarchical traversal
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    var p_id = n.parentId;
    // Check if node n has a parent node
    if (null != p_id) {
    // Add node Id to parent's list of children
    layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
    } else {
    // If a node doesn't have a parent, then it's in the root graph
    queue[++end] = n.id;
    tempGraph.push(n.id);
    }
  }

  // Add root graph to graphSet
  layoutInfo.graphSet.push(tempGraph);

  // Traverse the graph, level by level,
  while (start <= end) {
    // Get the node to visit and remove it from queue
    var node_id  = queue[start++];
    var node_ix  = layoutInfo.idToIndex[node_id];
    var node     = layoutInfo.layoutNodes[node_ix];
    var children = node.children;
    if (children.length > 0) {
    // Add children nodes as a new graph to graph set
    layoutInfo.graphSet.push(children);
    // Add children to que queue to be visited
    for (var i = 0; i < children.length; i++) {
      queue[++end] = children[i];
    }
    }
  }

  // Create indexToGraph map
  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    for (var j = 0; j < graph.length; j++) {
    var index = layoutInfo.idToIndex[graph[j]];
    layoutInfo.indexToGraph[index] = i;
    }
  }

  // Iterate over all edges, creating Layout Edges
  for (var i = 0; i < layoutInfo.edgeSize; i++) {
    var e = edges[i];
    var tempEdge = {};
    tempEdge.id       = e.data('id');
    tempEdge.sourceId = e.data('source');
    tempEdge.targetId = e.data('target');

    // Compute ideal length
    var idealLength = is.fn( options.idealEdgeLength ) ? options.idealEdgeLength.call( e, e ) : options.idealEdgeLength;
    var elasticity = is.fn( options.edgeElasticity ) ? options.edgeElasticity.call( e, e ) : options.edgeElasticity;

    // Check if it's an inter graph edge
    var sourceIx    = layoutInfo.idToIndex[tempEdge.sourceId];
    var targetIx    = layoutInfo.idToIndex[tempEdge.targetId];
    var sourceGraph = layoutInfo.indexToGraph[sourceIx];
    var targetGraph = layoutInfo.indexToGraph[targetIx];

    if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);

      // Compute sum of node depths, relative to lca graph
      var lcaGraph = layoutInfo.graphSet[lca];
      var depth    = 0;

      // Source depth
      var tempNode = layoutInfo.layoutNodes[sourceIx];
      while ( -1 === lcaGraph.indexOf(tempNode.id) ) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // Target depth
      tempNode = layoutInfo.layoutNodes[targetIx];
      while ( -1 === lcaGraph.indexOf(tempNode.id) ) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
        //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
        //  ". Depth: " + depth);

      // Update idealLength
      idealLength *= depth * options.nestingFactor;
    }

    tempEdge.idealLength = idealLength;
    tempEdge.elasticity = elasticity;

    layoutInfo.layoutEdges.push(tempEdge);
  }

  // Finally, return layoutInfo object
  return layoutInfo;
};


/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 */
var findLCA = function(node1, node2, layoutInfo) {
  // Find their common ancester, starting from the root graph
  var res = findLCA_aux(node1, node2, 0, layoutInfo);
  if (2 > res.count) {
    // If aux function couldn't find the common ancester,
    // then it is the root graph
    return 0;
  } else {
    return res.graph;
  }
};


/**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 */
var findLCA_aux = function(node1, node2, graphIx, layoutInfo) {
  var graph = layoutInfo.graphSet[graphIx];
  // If both nodes belongs to graphIx
  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
    return {count:2, graph:graphIx};
  }

  // Make recursive calls for all subgraphs
  var c = 0;
  for (var i = 0; i < graph.length; i++) {
    var nodeId   = graph[i];
    var nodeIx   = layoutInfo.idToIndex[nodeId];
    var children = layoutInfo.layoutNodes[nodeIx].children;

    // If the node has no child, skip it
    if (0 === children.length) {
    continue;
    }

    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
    var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
    if (0 === result.count) {
    // Neither node1 nor node2 are present in this subgraph
    continue;
    } else if (1 === result.count) {
    // One of (node1, node2) is present in this subgraph
    c++;
    if (2 === c) {
      // We've already found both nodes, no need to keep searching
      break;
    }
    } else {
    // Both nodes are present in this subgraph
    return result;
    }
  }

  return {count:c, graph:graphIx};
};


/**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 */
var printLayoutInfo = function(layoutInfo) {
  /* jshint ignore:start */

  if (!DEBUG) {
    return;
  }
  console.debug("layoutNodes:");
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    var s =
    "\nindex: "     + i +
    "\nId: "        + n.id +
    "\nChildren: "  + n.children.toString() +
    "\nparentId: "  + n.parentId  +
    "\npositionX: " + n.positionX +
    "\npositionY: " + n.positionY +
    "\nOffsetX: " + n.offsetX +
    "\nOffsetY: " + n.offsetY +
    "\npadLeft: " + n.padLeft +
    "\npadRight: " + n.padRight +
    "\npadTop: " + n.padTop +
    "\npadBottom: " + n.padBottom;

    console.debug(s);
  }

  console.debug('idToIndex');
  for (var i in layoutInfo.idToIndex) {
    console.debug("Id: " + i + "\nIndex: " + layoutInfo.idToIndex[i]);
  }

  console.debug('Graph Set');
  var set = layoutInfo.graphSet;
  for (var i = 0; i < set.length; i ++) {
    console.debug("Set : " + i + ": " + set[i].toString());
  }

  var s = 'IndexToGraph';
  for (var i = 0; i < layoutInfo.indexToGraph.length; i ++) {
    s += "\nIndex : " + i + " Graph: "+ layoutInfo.indexToGraph[i];
  }
  console.debug(s);

  s = 'Layout Edges';
  for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {
    var e = layoutInfo.layoutEdges[i];
    s += "\nEdge Index: " + i + " ID: " + e.id +
    " SouceID: " + e.sourceId + " TargetId: " + e.targetId +
    " Ideal Length: " + e.idealLength;
  }
  console.debug(s);

  s =  "nodeSize: " + layoutInfo.nodeSize;
  s += "\nedgeSize: " + layoutInfo.edgeSize;
  s += "\ntemperature: " + layoutInfo.temperature;
  console.debug(s);

  return;
  /* jshint ignore:end */
};


/**
 * @brief : Randomizes the position of all nodes
 */
var randomizePositions = function(layoutInfo, cy) {
  var width     = layoutInfo.clientWidth;
  var height    = layoutInfo.clientHeight;

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    // No need to randomize compound nodes or locked nodes
    if ( 0 === n.children.length && !n.isLocked ) {
      n.positionX = Math.random() * width;
      n.positionY = Math.random() * height;
    }
  }
};


/**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */
var refreshPositions = function(layoutInfo, cy, options) {
  // var s = 'Refreshing positions';
  // logDebug(s);

  var layout = options.layout;
  var nodes = options.eles.nodes();
  var bb = layoutInfo.boundingBox;
  var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };

  if( options.boundingBox ){
    nodes.forEach(function( node ){
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

      coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );
      coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );

      coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );
      coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );
    });

    coseBB.w = coseBB.x2 - coseBB.x1;
    coseBB.h = coseBB.y2 - coseBB.y1;
  }

  nodes.positions(function(i, ele) {
    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
    // s = "Node: " + lnode.id + ". Refreshed position: (" +
    // lnode.positionX + ", " + lnode.positionY + ").";
    // logDebug(s);

    if( options.boundingBox ){ // then add extra bounding box constraint
      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

      return {
        x: bb.x1 + pctX * bb.w,
        y: bb.y1 + pctY * bb.h
      };
    } else {
      return {
        x: lnode.positionX,
        y: lnode.positionY
      };
    }
  });

  // Trigger layoutReady only on first call
  if (true !== layoutInfo.ready) {
    // s = 'Triggering layoutready';
    // logDebug(s);
    layoutInfo.ready = true;
    layout.one('layoutready', options.ready);
    layout.trigger({ type: 'layoutready', layout: this });
  }
};

/**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */
// var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };

module.exports = CoseLayout;

},{"../../is":77,"../../math":79,"../../thread":92,"../../util":94}],49:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');
var math = _dereq_('../../math');

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // padding used on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
  condense: false, // uses all available space on false, uses minimal space on true
  rows: undefined, // force num of rows in the grid
  cols: undefined, // force num of columns in the grid
  position: function( node ){}, // returns { row, col } for element
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function GridLayout( options ){
  this.options = util.extend({}, defaults, options);
}

GridLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  if( options.sort ){
    nodes = nodes.sort( options.sort );
  }

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  if( bb.h === 0 || bb.w === 0){
    nodes.layoutPositions(this, options, function(){
      return { x: bb.x1, y: bb.y1 };
    });

  } else {

    // width/height * splits^2 = cells where splits is number of times to split width
    var cells = nodes.size();
    var splits = Math.sqrt( cells * bb.h/bb.w );
    var rows = Math.round( splits );
    var cols = Math.round( bb.w/bb.h * splits );

    var small = function(val){
      if( val == null ){
        return Math.min(rows, cols);
      } else {
        var min = Math.min(rows, cols);
        if( min == rows ){
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var large = function(val){
      if( val == null ){
        return Math.max(rows, cols);
      } else {
        var max = Math.max(rows, cols);
        if( max == rows ){
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var oRows = options.rows;
    var oCols = options.cols != null ? options.cols : options.columns;

    // if rows or columns were set in options, use those values
    if( oRows != null && oCols != null ){
      rows = oRows;
      cols = oCols;
    } else if( oRows != null && oCols == null ){
      rows = oRows;
      cols = Math.ceil( cells / rows );
    } else if( oRows == null && oCols != null ){
      cols = oCols;
      rows = Math.ceil( cells / cols );
    }

    // otherwise use the automatic values and adjust accordingly

    // if rounding was up, see if we can reduce rows or columns
    else if( cols * rows > cells ){
      var sm = small();
      var lg = large();

      // reducing the small side takes away the most cells, so try it first
      if( (sm - 1) * lg >= cells ){
        small(sm - 1);
      } else if( (lg - 1) * sm >= cells ){
        large(lg - 1);
      }
    } else {

      // if rounding was too low, add rows or columns
      while( cols * rows < cells ){
        var sm = small();
        var lg = large();

        // try to add to larger side first (adds less in multiplication)
        if( (lg + 1) * sm >= cells ){
          large(lg + 1);
        } else {
          small(sm + 1);
        }
      }
    }

    var cellWidth = bb.w / cols;
    var cellHeight = bb.h / rows;

    if( options.condense ){
      cellWidth = 0;
      cellHeight = 0;
    }

    if( options.avoidOverlap ){
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var pos = node._private.position;

        if( pos.x == null || pos.y == null ){ // for bb
          pos.x = 0;
          pos.y = 0;
        }

        var nbb = node.boundingBox();
        var p = options.avoidOverlapPadding;

        var w = nbb.w + p;
        var h = nbb.h + p;

        cellWidth = Math.max( cellWidth, w );
        cellHeight = Math.max( cellHeight, h );
      }
    }

    var cellUsed = {}; // e.g. 'c-0-2' => true

    var used = function(row, col){
      return cellUsed['c-' + row + '-' + col] ? true : false;
    };

    var use = function(row, col){
      cellUsed['c-' + row + '-' + col] = true;
    };

    // to keep track of current cell position
    var row = 0;
    var col = 0;
    var moveToNextCell = function(){
      col++;
      if( col >= cols ){
        col = 0;
        row++;
      }
    };

    // get a cache of all the manual positions
    var id2manPos = {};
    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];
      var rcPos = options.position( node );

      if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd
        var pos = {
          row: rcPos.row,
          col: rcPos.col
        };

        if( pos.col === undefined ){ // find unused col
          pos.col = 0;

          while( used(pos.row, pos.col) ){
            pos.col++;
          }
        } else if( pos.row === undefined ){ // find unused row
          pos.row = 0;

          while( used(pos.row, pos.col) ){
            pos.row++;
          }
        }

        id2manPos[ node.id() ] = pos;
        use( pos.row, pos.col );
      }
    }

    var getPos = function(i, element){
      var x, y;

      if( element.locked() || element.isFullAutoParent() ){
        return false;
      }

      // see if we have a manual position set
      var rcPos = id2manPos[ element.id() ];
      if( rcPos ){
        x = rcPos.col * cellWidth + cellWidth/2 + bb.x1;
        y = rcPos.row * cellHeight + cellHeight/2 + bb.y1;

      } else { // otherwise set automatically

        while( used(row, col) ){
          moveToNextCell();
        }

        x = col * cellWidth + cellWidth/2 + bb.x1;
        y = row * cellHeight + cellHeight/2 + bb.y1;
        use( row, col );

        moveToNextCell();
      }

      return { x: x, y: y };

    };

    nodes.layoutPositions( this, options, getPos );
  }

  return this; // chaining

};

module.exports = GridLayout;

},{"../../math":79,"../../util":94}],50:[function(_dereq_,module,exports){
'use strict';

module.exports = [
  { name: 'breadthfirst', impl: _dereq_('./breadthfirst') },
  { name: 'circle', impl: _dereq_('./circle') },
  { name: 'concentric',impl: _dereq_('./concentric') },
  { name: 'cose', impl: _dereq_('./cose') },
  { name: 'grid', impl: _dereq_('./grid') },
  { name: 'null', impl: _dereq_('./null') },
  { name: 'preset', impl: _dereq_('./preset') },
  { name: 'random', impl: _dereq_('./random') }
];

},{"./breadthfirst":45,"./circle":46,"./concentric":47,"./cose":48,"./grid":49,"./null":51,"./preset":52,"./random":53}],51:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');

// default layout options
var defaults = {
  ready: function(){}, // on layoutready
  stop: function(){} // on layoutstop
};

// constructor
// options : object containing layout options
function NullLayout( options ){
  this.options = util.extend({}, defaults, options);
}

// runs the layout
NullLayout.prototype.run = function(){
  var options = this.options;
  var eles = options.eles; // elements to consider in the layout
  var layout = this;

  // cy is automatically populated for us in the constructor
  var cy = options.cy; // jshint ignore:line

  layout.trigger('layoutstart');

  // puts all nodes at (0, 0)
  eles.nodes().positions(function(){
    return {
      x: 0,
      y: 0
    };
  });

  // trigger layoutready when each node has had its position set at least once
  layout.one('layoutready', options.ready);
  layout.trigger('layoutready');

  // trigger layoutstop when the layout stops (e.g. finishes)
  layout.one('layoutstop', options.stop);
  layout.trigger('layoutstop');

  return this; // chaining
};

// called on continuous layouts to stop them before they finish
NullLayout.prototype.stop = function(){
  return this; // chaining
};

module.exports = NullLayout;

},{"../../util":94}],52:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');
var is = _dereq_('../../is');

var defaults = {
  positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: undefined, // the zoom level to set (prob want fit = false if set)
  pan: undefined, // the pan level to set (prob want fit = false if set)
  fit: true, // whether to fit to viewport
  padding: 30, // padding on fit
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function PresetLayout( options ){
  this.options = util.extend({}, defaults, options);
}

PresetLayout.prototype.run = function(){
  var options = this.options;
  var eles = options.eles;

  var nodes = eles.nodes();
  var posIsFn = is.fn( options.positions );

  function getPosition(node){
    if( options.positions == null ){
      return null;
    }

    if( posIsFn ){
      return options.positions.apply( node, [ node ] );
    }

    var pos = options.positions[node._private.data.id];

    if( pos == null ){
      return null;
    }

    return pos;
  }

  nodes.layoutPositions(this, options, function(i, node){
    var position = getPosition(node);

    if( node.locked() || position == null ){
      return false;
    }

    return position;
  });

  return this; // chaining
};

module.exports = PresetLayout;

},{"../../is":77,"../../util":94}],53:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');
var math = _dereq_('../../math');

var defaults = {
  fit: true, // whether to fit to viewport
  padding: 30, // fit padding
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function RandomLayout( options ){
  this.options = util.extend({}, defaults, options);
}

RandomLayout.prototype.run = function(){
  var options = this.options;
  var cy = options.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var getPos = function( i, node ){
    return {
      x: bb.x1 + Math.round( Math.random() * bb.w ),
      y: bb.y1 + Math.round( Math.random() * bb.h )
    };
  };

  nodes.layoutPositions( this, options, getPos );

  return this; // chaining
};

module.exports = RandomLayout;

},{"../../math":79,"../../util":94}],54:[function(_dereq_,module,exports){
'use strict';

var math = _dereq_('../../../math');
var is = _dereq_('../../../is');
var util = _dereq_('../../../util');

var BRp = {};

BRp.arrowShapeHeight = 0.3;

BRp.registerArrowShapes = function(){
  var arrowShapes = this.arrowShapes = {};
  var renderer = this;

  // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function( x, y, size, angle, translation, padding ){
    var x1 = translation.x - size/2 - padding;
    var x2 = translation.x + size/2 + padding;
    var y1 = translation.y - size/2 - padding;
    var y2 = translation.y + size/2 + padding;

    var inside = (x1 <= x && x <= x2) && (y1 <= y && y <= y2);

    return inside;
  };

  var transform = function( x, y, size, angle, translation ){
    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);

    var xScaled = xRotated * size;
    var yScaled = yRotated * size;

    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;

    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  var transformPoints = function( pts, size, angle, translation ){
    var retPts = [];

    for( var i = 0; i < pts.length; i += 2 ){
      var x = pts[i];
      var y = pts[i + 1];

      retPts.push( transform(x, y, size, angle, translation) );
    }

    return retPts;
  };

  var pointsToArr = function( pts ){
    var ret = [];

    for( var i = 0; i < pts.length; i++ ){
      var p = pts[i];

      ret.push( p.x, p.y );
    }

    return ret;
  };

  var defineArrowShape = function( name, defn ){
    if( is.string(defn) ){
      defn = arrowShapes[ defn ];
    }

    arrowShapes[ name ] = util.extend( {
      name: name,

      points: [
        -0.15, -0.3,
        0.15, -0.3,
        0.15, 0.3,
        -0.15, 0.3
      ],

      collide: function( x, y, size, angle, translation, padding ){
        var points = pointsToArr( transformPoints( this.points, size + 2*padding, angle, translation ) );
        var inside = math.pointInsidePolygonPoints( x, y, points );

        return inside;
      },

      roughCollide: bbCollide,

      draw: function( context, size, angle, translation ){
        var points = transformPoints( this.points, size, angle, translation );

        renderer.arrowShapeImpl('polygon')( context, points );
      },

      spacing: function( edge ){
        return 0;
      },

      gap: function( edge ){
        return edge._private.style['width'].pfValue * 2;
      }
    }, defn );
  };

  defineArrowShape( 'none', {
    collide: util.falsify,

    roughCollide: util.falsify,

    draw: util.noop,

    spacing: util.zeroify,

    gap: util.zeroify
  } );

  defineArrowShape( 'triangle', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3
    ]
  } );

  defineArrowShape( 'arrow', 'triangle' );

  defineArrowShape( 'triangle-backcurve', {
    points: arrowShapes['triangle'].points,

    controlPoint: [ 0, -0.15 ],

    roughCollide: bbCollide,

    draw: function( context, size, angle, translation ){
      var ptsTrans = transformPoints( this.points, size, angle, translation );
      var ctrlPt = this.controlPoint;
      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, ptsTrans, ctrlPtTrans );
    },

    gap: function( edge ){
      return edge._private.style['width'].pfValue;
    }
  } );


  defineArrowShape( 'triangle-tee', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    pointsTee: [
      -0.15, -0.4,
      -0.15, -0.5,
      0.15, -0.5,
      0.15, -0.4
    ],

    collide: function( x, y, size, angle, translation, padding ){
      var triPts = pointsToArr( transformPoints( this.points, size + 2*padding, angle, translation ) );
      var teePts = pointsToArr( transformPoints( this.pointsTee, size + 2*padding, angle, translation ) );

      var inside = math.pointInsidePolygonPoints( x, y, triPts ) || math.pointInsidePolygonPoints( x, y, teePts );

      return inside;
    },

    draw: function( context, size, angle, translation ){
      var triPts = transformPoints( this.points, size, angle, translation );
      var teePts = transformPoints( this.pointsTee, size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, triPts, teePts );
    }
  } );

  defineArrowShape( 'vee', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      0, -0.15
    ],

    gap: function( edge ){
      return edge._private.style['width'].pfValue;
    }
  } );

  defineArrowShape( 'half-triangle-overshot', {
    points: [
      0, -0.25,
      -0.5, -0.25,
      0.5, 0.25
    ],

    leavePathOpen: true,

    matchEdgeWidth: true
  } );

  defineArrowShape( 'circle', {
    radius: 0.15,

    collide: function( x, y, size, angle, translation, padding ){
      var t = translation;
      var inside = ( Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2*padding) * this.radius, 2) );

      return inside;
    },

    draw: function( context, size, angle, translation ){
      renderer.arrowShapeImpl( this.name )( context, translation.x, translation.y, this.radius * size );
    },

    spacing: function( edge ){
      return renderer.getArrowWidth(edge._private.style['width'].pfValue)
        * this.radius;
    }
  } );

  defineArrowShape( 'inhibitor', {
    points: [
      -0.25, 0,
      -0.25, -0.1,
      0.25, -0.1,
      0.25, 0
    ],

    spacing: function( edge ){
      return 1;
    },

    gap: function( edge ){
      return 1;
    }
  } );

  defineArrowShape( 'tee', 'inhibitor' );

  defineArrowShape( 'square', {
    points: [
      -0.15, 0.00,
      0.15, 0.00,
      0.15, -0.3,
      -0.15, -0.3
    ]
  } );

  defineArrowShape( 'diamond', {
    points: [
      -0.15, -0.15,
      0, -0.3,
      0.15, -0.15,
      0, 0
    ],

    gap: function( edge ){
      return edge._private.style['width'].pfValue;
    }
  } );

};

module.exports = BRp;

},{"../../../is":77,"../../../math":79,"../../../util":94}],55:[function(_dereq_,module,exports){
'use strict';

var BRp = {};

var delEleCache = function( r ){
  r.eleEache = null;
};

var getEleCache = function( r ){
  if( !r.eleEache ){
    r.eleEache = {
      nodes: r.cy.nodes(),
      edges: r.cy.edges()
    };
  }

  return r.eleEache;
};

BRp.getCachedElements = function(){
  return getEleCache( this );
};

BRp.getCachedNodes = function(){
  return getEleCache( this ).nodes;
};

BRp.getCachedEdges = function(){
  return getEleCache( this ).edges;
};

BRp.updateElementsCache = function(){
  var r = this;

  delEleCache( r );

  return getEleCache( r );
};

module.exports = BRp;

},{}],56:[function(_dereq_,module,exports){
'use strict';

var math = _dereq_('../../../math');
var is = _dereq_('../../../is');
var zIndexSort = _dereq_('../../../collection/zsort');

var BRp = {};

// Project mouse
BRp.projectIntoViewport = function(clientX, clientY) {
  var offsets = this.findContainerClientCoords();
  var offsetLeft = offsets[0];
  var offsetTop = offsets[1];

  var x = clientX - offsetLeft;
  var y = clientY - offsetTop;

  x -= this.cy.pan().x; y -= this.cy.pan().y; x /= this.cy.zoom(); y /= this.cy.zoom();
  return [x, y];
};

BRp.findContainerClientCoords = function() {
  var container = this.container;

  var bb = this.containerBB = this.containerBB || container.getBoundingClientRect();

  return [bb.left, bb.top, bb.right - bb.left, bb.bottom - bb.top];
};

BRp.invalidateContainerClientCoordsCache = function(){
  this.containerBB = null;
};

// Find nearest element
BRp.findNearestElement = function(x, y, visibleElementsOnly, isTouch){
  var self = this;
  var r = this;
  var eles = r.getCachedZSortedEles();
  var near = [];
  var zoom = r.cy.zoom();
  var hasCompounds = r.cy.hasCompoundNodes();
  var edgeThreshold = (isTouch ? 24 : 8) / zoom;
  var nodeThreshold = (isTouch ? 8 : 2) / zoom;
  var labelThreshold = (isTouch ? 8 : 2) / zoom;

  function checkNode(node){
    var _p = node._private;

    if( _p.style['events'].strValue === 'no' ){ return; }

    var width = node.outerWidth() + 2*nodeThreshold;
    var height = node.outerHeight() + 2*nodeThreshold;
    var hw = width/2;
    var hh = height/2;
    var pos = _p.position;

    if(
      pos.x - hw <= x && x <= pos.x + hw // bb check x
        &&
      pos.y - hh <= y && y <= pos.y + hh // bb check y
    ){
      var visible = !visibleElementsOnly || ( node.visible() && !node.transparent() );

      // exit early if invisible edge and must be visible
      if( visibleElementsOnly && !visible ){
        return;
      }

      var shape = r.nodeShapes[ self.getNodeShape(node) ];

      if(
        shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)
      ){
        near.push( node );
      }

    }
  }

  function checkEdge(edge){
    var _p = edge._private;

    if( _p.style['events'].strValue === 'no' ){ return; }

    var rs = _p.rscratch;
    var style = _p.style;
    var width = style['width'].pfValue/2 + edgeThreshold; // more like a distance radius from centre
    var widthSq = width * width;
    var width2 = width * 2;
    var src = _p.source;
    var tgt = _p.target;
    var inEdgeBB = false;
    var sqDist;

    // exit early if invisible edge and must be visible
    var passedVisibilityCheck;
    var passesVisibilityCheck = function(){
      if( passedVisibilityCheck !== undefined ){
        return passedVisibilityCheck;
      }

      if( !visibleElementsOnly ){
        passedVisibilityCheck = true;
        return true;
      }

      var visible = edge.visible() && !edge.transparent();
      if( visible ){
        passedVisibilityCheck = true;
        return true;
      }

      passedVisibilityCheck = false;
      return false;
    };

    if( rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack' ){
      var pts = rs.allpts;

      for( var i = 0; i + 3 < pts.length; i += 2 ){
        if(
          (inEdgeBB = math.inLineVicinity(x, y, pts[i], pts[i+1], pts[i+2], pts[i+3], width2))
            && passesVisibilityCheck() &&
          widthSq > ( sqDist = math.sqDistanceToFiniteLine(x, y, pts[i], pts[i+1], pts[i+2], pts[i+3]) )
        ){
          near.push( edge );
        }
      }

    } else if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
      var pts = rs.allpts;
      for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
        if(
          (inEdgeBB = math.inBezierVicinity(x, y, pts[i], pts[i+1], pts[i+2], pts[i+3], pts[i+4], pts[i+5], width2))
            && passesVisibilityCheck() &&
          (widthSq > (sqDist = math.sqDistanceToQuadraticBezier(x, y, pts[i], pts[i+1], pts[i+2], pts[i+3], pts[i+4], pts[i+5])) )
        ){
          near.push( edge );
        }
      }
    }

    // if we're close to the edge but didn't hit it, maybe we hit its arrows
    if( inEdgeBB && passesVisibilityCheck() && near.length === 0 || near[near.length - 1] !== edge ){
      var src = src || _p.source;
      var tgt = tgt || _p.target;

      var eWidth = style['width'].pfValue;
      var arSize = self.getArrowWidth( eWidth );

      var arrows = [
        { name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle },
        { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle },
        { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle },
        { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }
      ];

      for( var i = 0; i < arrows.length; i++ ){
        var ar = arrows[i];
        var shape = r.arrowShapes[ style[ar.name+'-arrow-shape'].value ];

        if(
          shape.roughCollide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold)
           &&
          shape.collide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold)
        ){
          near.push( edge );
          break;
        }
      }
    }

    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
    if( hasCompounds &&  near.length > 0 && near[ near.length - 1 ] === edge ){
      checkNode( src );
      checkNode( tgt );
    }
  }

  function checkLabel(ele){
    var _p = ele._private;
    var th = labelThreshold;

    if( _p.style['text-events'].strValue === 'no' ){ return; }

    // adjust bb w/ angle
    if( _p.group === 'edges' && _p.style['edge-text-rotation'].strValue === 'autorotate' ){

      var rstyle = _p.rstyle;
      var lw = rstyle.labelWidth + 2*th;
      var lh = rstyle.labelHeight + 2*th;
      var lx = rstyle.labelX;
      var ly = rstyle.labelY;

      var theta = _p.rscratch.labelAngle;
      var cos = Math.cos( theta );
      var sin = Math.sin( theta );

      var rotate = function( x, y ){
        x = x - lx;
        y = y - ly;

        return {
          x: x*cos - y*sin + lx,
          y: x*sin + y*cos + ly
        };
      };

      var lx1 = lx - lw/2;
      var lx2 = lx + lw/2;
      var ly1 = ly - lh/2;
      var ly2 = ly + lh/2;

      var px1y1 = rotate( lx1, ly1 );
      var px1y2 = rotate( lx1, ly2 );
      var px2y1 = rotate( lx2, ly1 );
      var px2y2 = rotate( lx2, ly2 );

      var points = [
        px1y1.x, px1y1.y,
        px2y1.x, px2y1.y,
        px2y2.x, px2y2.y,
        px1y2.x, px1y2.y
      ];

      if( math.pointInsidePolygonPoints( x, y, points ) ){
        near.push( ele );
      }

    } else {
      var bb = ele.boundingBox({
        includeLabels: true,
        includeNodes: false,
        includeEdges: false
      });

      // adjust bb w/ threshold
      bb.x1 -= th;
      bb.y1 -= th;
      bb.x2 += th;
      bb.y2 += th;
      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;

      if( math.inBoundingBox( bb, x, y ) ){
        near.push( ele );
      }
    }

  }

  for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence
    var ele = eles[i];
    var _p = ele._private;

    if( near.length > 0 ){ break; } // since we check in z-order, first found is top and best result => exit early

    if( _p.group === 'nodes' ){
      checkNode( ele );

    } else  { // then edge
      checkEdge( ele );
    }

    checkLabel( ele );

  }


  if( near.length > 0 ){
    return near[ near.length - 1 ];
  } else {
    return null;
  }
};

// 'Give me everything from this box'
BRp.getAllInBox = function(x1, y1, x2, y2) {
  var nodes = this.getCachedNodes();
  var edges = this.getCachedEdges();
  var box = [];

  var x1c = Math.min(x1, x2);
  var x2c = Math.max(x1, x2);
  var y1c = Math.min(y1, y2);
  var y2c = Math.max(y1, y2);

  x1 = x1c;
  x2 = x2c;
  y1 = y1c;
  y2 = y2c;

  var boxBb = math.makeBoundingBox({
    x1: x1, y1: y1,
    x2: x2, y2: y2
  });

  for ( var i = 0; i < nodes.length; i++ ){
    var node = nodes[i];
    var nodeBb = node.boundingBox({
      includeNodes: true,
      includeEdges: false,
      includeLabels: false
    });

    if( math.boundingBoxesIntersect(boxBb, nodeBb) ){
      box.push(nodes[i]);
    }
  }

  for( var e = 0; e < edges.length; e++ ){
    var edge = edges[e];
    var _p = edge._private;
    var rs = _p.rscratch;

    if( rs.startX != null && rs.startY != null && !math.inBoundingBox( boxBb, rs.startX, rs.startY ) ){ continue; }
    if( rs.endX != null && rs.endY != null && !math.inBoundingBox( boxBb, rs.endX, rs.endY ) ){ continue; }

    if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack' ){

      var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
      var allInside = true;

      for( var i = 0; i < pts.length; i++ ){
        if( !math.pointInBoundingBox( boxBb, pts[i] ) ){
          allInside = false;
          break;
        }
      }

      if( allInside ){
        box.push( edge );
      }

    } else if( rs.edgeType === 'haystack' || rs.edgeType === 'straight' ){
      box.push( edge );
    }

  }

  return box;
};


/**
 * Returns the shape of the given node. If the height or width of the given node
 * is set to auto, the node is considered to be a compound.
 *
 * @param node          a node
 * @return {String}     shape of the node
 */
BRp.getNodeShape = function( node ){
  var r = this;
  var style = node._private.style;
  var shape = style['shape'].value;

  if( node.isParent() ){
    if( shape === 'rectangle' || shape === 'roundrectangle' ){
      return shape;
    } else {
      return 'rectangle';
    }
  }

  if( shape === 'polygon' ){
    var points = style['shape-polygon-points'].value;

    return r.nodeShapes.makePolygon( points ).name;
  }

  return shape;
};

BRp.updateCachedZSortedEles = function(){
  this.getCachedZSortedEles( true );
};

BRp.getCachedZSortedEles = function( forceRecalc ){
  var lastNodes = this.lastZOrderCachedNodes;
  var lastEdges = this.lastZOrderCachedEdges;
  var nodes = this.getCachedNodes();
  var edges = this.getCachedEdges();
  var eles = [];

  if( forceRecalc || !lastNodes || !lastEdges || lastNodes !== nodes || lastEdges !== edges ){
    //console.time('cachezorder')

    for( var i = 0; i < nodes.length; i++ ){
      var n = nodes[i];

      if( n.animated() || (n.visible() && !n.transparent()) ){
        eles.push( n );
      }
    }

    for( var i = 0; i < edges.length; i++ ){
      var e = edges[i];

      if( e.animated() || (e.visible() && !e.transparent()) ){
        eles.push( e );
      }
    }

    eles.sort( zIndexSort );
    this.cachedZSortedEles = eles;
    //console.log('make cache')

    //console.timeEnd('cachezorder')
  } else {
    eles = this.cachedZSortedEles;
    //console.log('read cache')
  }

  this.lastZOrderCachedNodes = nodes;
  this.lastZOrderCachedEdges = edges;

  return eles;
};

function pushBezierPts(edge, pts){
  var qbezierAt = function( p1, p2, p3, t ){ return math.qbezierAt(p1, p2, p3, t); };
  var _p = edge._private;
  var bpts = _p.rstyle.bezierPts;

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.05 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.05 )
  });

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.25 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.25 )
  });

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.4 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.4 )
  });

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.5 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.5 )
  });

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.6 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.6 )
  });

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.75 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.75 )
  });

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.95 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.95 )
  });
}

BRp.projectLines = function( edge ){
  var _p = edge._private;
  var rs = _p.rscratch;
  var et = rs.edgeType;

  if( et === 'multibezier' ||  et === 'bezier' ||  et === 'self' ||  et === 'compound' ){
    var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line

    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
      pushBezierPts( edge, rs.allpts.slice(i, i+6) );
    }
  } else if(  et === 'segments' ){
    var lpts = _p.rstyle.linePts = [];

    for( var i = 0; i + 1 < rs.allpts.length; i += 2 ){
      lpts.push({
        x: rs.allpts[i],
        y: rs.allpts[i+1]
      });
    }
  } else if( et === 'haystack' ){
    var hpts = rs.haystackPts;

    _p.rstyle.haystackPts = [
      { x: hpts[0], y: hpts[1] },
      { x: hpts[2], y: hpts[3] }
    ];
  }
};

BRp.projectBezier = BRp.projectLines;

BRp.recalculateNodeLabelProjection = function( node ){
  var content = node._private.style['label'].strValue;
  if( !content || content.match(/^\s+$/) ){ return; }

  var textX, textY;
  var nodeWidth = node.outerWidth();
  var nodeHeight = node.outerHeight();
  var nodePos = node._private.position;
  var textHalign = node._private.style['text-halign'].strValue;
  var textValign = node._private.style['text-valign'].strValue;
  var rs = node._private.rscratch;
  var rstyle = node._private.rstyle;

  switch( textHalign ){
    case 'left':
      textX = nodePos.x - nodeWidth / 2;
      break;

    case 'right':
      textX = nodePos.x + nodeWidth / 2;
      break;

    default: // e.g. center
      textX = nodePos.x;
  }

  switch( textValign ){
    case 'top':
      textY = nodePos.y - nodeHeight / 2;
      break;

    case 'bottom':
      textY = nodePos.y + nodeHeight / 2;
      break;

    default: // e.g. middle
      textY = nodePos.y;
  }

  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;

  this.applyLabelDimensions( node );
};

BRp.recalculateEdgeLabelProjection = function( edge ){
  var content = edge._private.style['label'].strValue;
  if( !content || content.match(/^\s+$/) ){ return; }

  var textX, textY;
  var _p = edge._private;
  var rs = _p.rscratch;
  //var style = _p.style;
  var rstyle = _p.rstyle;

  textX = rs.midX;
  textY = rs.midY;

  // add center point to style so bounding box calculations can use it
  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;

  this.applyLabelDimensions( edge );
};

BRp.applyLabelDimensions = function( ele ){
  var rs = ele._private.rscratch;
  var rstyle = ele._private.rstyle;

  var text = this.getLabelText( ele );
  var labelDims = this.calculateLabelDimensions( ele, text );

  rstyle.labelWidth = labelDims.width;
  rs.labelWidth = labelDims.width;

  rstyle.labelHeight = labelDims.height;
  rs.labelHeight = labelDims.height;
};

BRp.getLabelText = function( ele ){
  var style = ele._private.style;
  var text = ele._private.style['label'].strValue;
  var textTransform = style['text-transform'].value;
  var rscratch = ele._private.rscratch;

  if (textTransform == 'none') {
  } else if (textTransform == 'uppercase') {
    text = text.toUpperCase();
  } else if (textTransform == 'lowercase') {
    text = text.toLowerCase();
  }

  if( style['text-wrap'].value === 'wrap' ){
    //console.log('wrap');

    // save recalc if the label is the same as before
    if( rscratch.labelWrapKey === rscratch.labelKey ){
      // console.log('wrap cache hit');
      return rscratch.labelWrapCachedText;
    }
    // console.log('wrap cache miss');

    var lines = text.split('\n');
    var maxW = style['text-max-width'].pfValue;
    var wrappedLines = [];

    for( var l = 0; l < lines.length; l++ ){
      var line = lines[l];
      var lineDims = this.calculateLabelDimensions( ele, line, 'line=' + line );
      var lineW = lineDims.width;

      if( lineW > maxW ){ // line is too long
        var words = line.split(/\s+/); // NB: assume collapsed whitespace into single space
        var subline = '';

        for( var w = 0; w < words.length; w++ ){
          var word = words[w];
          var testLine = subline.length === 0 ? word : subline + ' ' + word;
          var testDims = this.calculateLabelDimensions( ele, testLine, 'testLine=' + testLine );
          var testW = testDims.width;

          if( testW <= maxW ){ // word fits on current line
            subline += word + ' ';
          } else { // word starts new line
            wrappedLines.push( subline );
            subline = word + ' ';
          }
        }

        // if there's remaining text, put it in a wrapped line
        if( !subline.match(/^\s+$/) ){
          wrappedLines.push( subline );
        }
      } else { // line is already short enough
        wrappedLines.push( line );
      }
    } // for

    rscratch.labelWrapCachedLines = wrappedLines;
    rscratch.labelWrapCachedText = text = wrappedLines.join('\n');
    rscratch.labelWrapKey = rscratch.labelKey;

    // console.log(text)
  } // if wrap

  return text;
};

BRp.calculateLabelDimensions = function( ele, text, extraKey ){
  var r = this;
  var style = ele._private.style;
  var fStyle = style['font-style'].strValue;
  var size = style['font-size'].pfValue + 'px';
  var family = style['font-family'].strValue;
  // var variant = style['font-variant'].strValue;
  var weight = style['font-weight'].strValue;

  var cacheKey = ele._private.labelKey;

  if( extraKey ){
    cacheKey += '$@$' + extraKey;
  }

  var cache = r.labelDimCache || (r.labelDimCache = {});

  if( cache[cacheKey] ){
    return cache[cacheKey];
  }

  var div = this.labelCalcDiv;

  if( !div ){
    div = this.labelCalcDiv = document.createElement('div');
    document.body.appendChild( div );
  }

  var ds = div.style;

  // from ele style
  ds.fontFamily = family;
  ds.fontStyle = fStyle;
  ds.fontSize = size;
  // ds.fontVariant = variant;
  ds.fontWeight = weight;

  // forced style
  ds.position = 'absolute';
  ds.left = '-9999px';
  ds.top = '-9999px';
  ds.zIndex = '-1';
  ds.visibility = 'hidden';
  ds.pointerEvents = 'none';
  ds.padding = '0';
  ds.lineHeight = '1';

  if( style['text-wrap'].value === 'wrap' ){
    ds.whiteSpace = 'pre'; // so newlines are taken into account
  } else {
    ds.whiteSpace = 'normal';
  }

  // put label content in div
  div.textContent = text;

  cache[cacheKey] = {
    width: div.clientWidth,
    height: div.clientHeight
  };

  return cache[cacheKey];
};

BRp.recalculateRenderedStyle = function( eles ){
  var edges = [];
  var nodes = [];
  var handledEdge = {};

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var _p = ele._private;
    var style = _p.style;
    var rs = _p.rscratch;
    var rstyle = _p.rstyle;
    var id = _p.data.id;
    var bbStyleSame = rs.boundingBoxKey != null && _p.boundingBoxKey === rs.boundingBoxKey;
    var labelStyleSame = rs.labelKey != null && _p.labelKey === rs.labelKey;
    var styleSame = bbStyleSame && labelStyleSame;

    if( _p.group === 'nodes' ){
      var pos = _p.position;
      var posSame = rstyle.nodeX != null && rstyle.nodeY != null && pos.x === rstyle.nodeX && pos.y === rstyle.nodeY;
      var wSame = rstyle.nodeW != null && rstyle.nodeW === style['width'].pfValue;
      var hSame = rstyle.nodeH != null && rstyle.nodeH === style['height'].pfValue;

      if( !posSame || !styleSame || !wSame || !hSame ){
        nodes.push( ele );
      }

      rstyle.nodeX = pos.x;
      rstyle.nodeY = pos.y;
      rstyle.nodeW = style['width'].pfValue;
      rstyle.nodeH = style['height'].pfValue;
    } else { // edges

      var srcPos = _p.source._private.position;
      var tgtPos = _p.target._private.position;
      var srcSame = rstyle.srcX != null && rstyle.srcY != null && srcPos.x === rstyle.srcX && srcPos.y === rstyle.srcY;
      var tgtSame = rstyle.tgtX != null && rstyle.tgtY != null && tgtPos.x === rstyle.tgtX && tgtPos.y === rstyle.tgtY;
      var positionsSame = srcSame && tgtSame;

      if( !positionsSame || !styleSame ){
        if( rs.edgeType === 'bezier' || rs.edgeType === 'straight' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
          if( !handledEdge[ id ] ){
            edges.push( ele );
            handledEdge[ id ] = true;

            var parallelEdges = ele.parallelEdges();
            for( var i = 0; i < parallelEdges.length; i++ ){
              var pEdge = parallelEdges[i];
              var pId = pEdge._private.data.id;

              if( !handledEdge[ pId ] ){
                edges.push( pEdge );
                handledEdge[ pId ] = true;
              }

            }
          }
        } else {
          edges.push( ele );
        }
      } // if positions diff

      // update rstyle positions
      rstyle.srcX = srcPos.x;
      rstyle.srcY = srcPos.y;
      rstyle.tgtX = tgtPos.x;
      rstyle.tgtY = tgtPos.y;

    } // if edges

    rs.boundingBoxKey = _p.boundingBoxKey;
    rs.labelKey = _p.labelKey;
  }

  this.recalculateEdgeProjections( edges );
  this.recalculateLabelProjections( nodes, edges );
};

BRp.recalculateLabelProjections = function( nodes, edges ){
  for( var i = 0; i < nodes.length; i++ ){
    this.recalculateNodeLabelProjection( nodes[i] );
  }

  for( var i = 0; i < edges.length; i++ ){
    this.recalculateEdgeLabelProjection( edges[i] );
  }
};

BRp.recalculateEdgeProjections = function( edges ){
  this.findEdgeControlPoints( edges );
};


// Find edge control points
BRp.findEdgeControlPoints = function(edges) {
  if( !edges || edges.length === 0 ){ return; }

  var r = this;
  var cy = r.cy;
  var hasCompounds = cy.hasCompoundNodes();
  var hashTable = {};
  var pairIds = [];
  var haystackEdges = [];
  var autorotateEdges = [];

  // create a table of edge (src, tgt) => list of edges between them
  var pairId;
  for (var i = 0; i < edges.length; i++){
    var edge = edges[i];
    var _p = edge._private;
    var data = _p.data;
    var style = _p.style;
    var curveStyle = style['curve-style'].value;
    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

    // ignore edges who are not to be displayed
    // they shouldn't take up space
    if( style.display.value === 'none' ){
      continue;
    }

    if( style['edge-text-rotation'].strValue === 'autorotate' ){
      autorotateEdges.push( edge );
    }

    if( curveStyle === 'haystack' ){
      haystackEdges.push( edge );
      continue;
    }

    var srcId = data.source;
    var tgtId = data.target;

    pairId = srcId > tgtId ?
      tgtId + '$-$' + srcId :
      srcId + '$-$' + tgtId ;

    if( edgeIsUnbundled ){
      pairId = 'unbundled' + '$-$' + data.id;
    }

    if( hashTable[pairId] == null ){
      hashTable[pairId] = [];
      pairIds.push( pairId );
    }

    hashTable[pairId].push( edge );

    if( edgeIsUnbundled ){
      hashTable[pairId].hasUnbundled = true;
    }
  }

  var src, tgt, src_p, tgt_p, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;
  var vectorNormInverse;
  var badBezier;

  // for each pair (src, tgt), create the ctrl pts
  // Nested for loop is OK; total number of iterations for both loops = edgeCount
  for (var p = 0; p < pairIds.length; p++) {
    pairId = pairIds[p];
    var pairEdges = hashTable[pairId];

    // for each pair id, the edges should be sorted by index
    pairEdges.sort(function(edge1, edge2){
      return edge1._private.index - edge2._private.index;
    });

    src = pairEdges[0]._private.source;
    tgt = pairEdges[0]._private.target;

    src_p = src._private;
    tgt_p = tgt._private;

    // make sure src/tgt distinction is consistent
    // (src/tgt in this case are just for ctrlpts and don't actually have to be true src/tgt)
    if( src_p.data.id > tgt_p.data.id ){
      var temp = src;
      src = tgt;
      tgt = temp;
    }

    srcPos = src_p.position;
    tgtPos = tgt_p.position;

    srcW = src.outerWidth();
    srcH = src.outerHeight();

    tgtW = tgt.outerWidth();
    tgtH = tgt.outerHeight();

    srcShape = r.nodeShapes[ this.getNodeShape(src) ];
    tgtShape = r.nodeShapes[ this.getNodeShape(tgt) ];

    badBezier = false;


    if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){

      // pt outside src shape to calc distance/displacement from src to tgt
      var srcOutside = srcShape.intersectLine(
        srcPos.x,
        srcPos.y,
        srcW,
        srcH,
        tgtPos.x,
        tgtPos.y,
        0
      );

      // pt outside tgt shape to calc distance/displacement from src to tgt
      var tgtOutside = tgtShape.intersectLine(
        tgtPos.x,
        tgtPos.y,
        tgtW,
        tgtH,
        srcPos.x,
        srcPos.y,
        0
      );

      var midptSrcPts = {
        x1: srcOutside[0],
        x2: tgtOutside[0],
        y1: srcOutside[1],
        y2: tgtOutside[1]
      };

      var dy = ( tgtOutside[1] - srcOutside[1] );
      var dx = ( tgtOutside[0] - srcOutside[0] );
      var l = Math.sqrt( dx*dx + dy*dy );

      var vector = {
        x: dx,
        y: dy
      };

      var vectorNorm = {
        x: vector.x/l,
        y: vector.y/l
      };
      vectorNormInverse = {
        x: -vectorNorm.y,
        y: vectorNorm.x
      };


      // if src intersection is inside tgt or tgt intersection is inside src, then no ctrl pts to draw
      if(
        tgtShape.checkPoint( srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y )  ||
        srcShape.checkPoint( tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y )
      ){
        vectorNormInverse = {};
        badBezier = true;
      }

    }

    var edge;
    var edge_p;
    var rs;

    for (var i = 0; i < pairEdges.length; i++) {
      edge = pairEdges[i];
      edge_p = edge._private;
      rs = edge_p.rscratch;

      var edgeIndex1 = rs.lastEdgeIndex;
      var edgeIndex2 = i;

      var numEdges1 = rs.lastNumEdges;
      var numEdges2 = pairEdges.length;

      var eStyle = edge_p.style;
      var style = eStyle;
      var curveStyle = eStyle['curve-style'].value;
      var ctrlptDists = eStyle['control-point-distances'];
      var ctrlptWs = eStyle['control-point-weights'];
      var bezierN = ctrlptDists && ctrlptWs ? Math.min( ctrlptDists.value.length, ctrlptWs.value.length ) : 1;
      var stepSize = eStyle['control-point-step-size'].pfValue;
      var ctrlptDist = ctrlptDists !== undefined ? ctrlptDists.pfValue[0] : undefined;
      var ctrlptWeight = ctrlptWs.value[0];
      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

      var swappedDirection = edge_p.source !== src;

      if( swappedDirection && edgeIsUnbundled ){
        ctrlptDist *= -1;
      }

      var srcX1 = rs.lastSrcCtlPtX;
      var srcX2 = srcPos.x;
      var srcY1 = rs.lastSrcCtlPtY;
      var srcY2 = srcPos.y;
      var srcW1 = rs.lastSrcCtlPtW;
      var srcW2 = src.outerWidth();
      var srcH1 = rs.lastSrcCtlPtH;
      var srcH2 = src.outerHeight();

      var tgtX1 = rs.lastTgtCtlPtX;
      var tgtX2 = tgtPos.x;
      var tgtY1 = rs.lastTgtCtlPtY;
      var tgtY2 = tgtPos.y;
      var tgtW1 = rs.lastTgtCtlPtW;
      var tgtW2 = tgt.outerWidth();
      var tgtH1 = rs.lastTgtCtlPtH;
      var tgtH2 = tgt.outerHeight();

      var width1 = rs.lastW;
      var width2 = eStyle['control-point-step-size'].pfValue;

      if( badBezier ){
        rs.badBezier = true;
      } else {
        rs.badBezier = false;
      }

      if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2
      &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2
      &&  width1 === width2
      &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){
        // console.log('edge ctrl pt cache HIT')
        continue; // then the control points haven't changed and we can skip calculating them
      } else {
        rs.lastSrcCtlPtX = srcX2;
        rs.lastSrcCtlPtY = srcY2;
        rs.lastSrcCtlPtW = srcW2;
        rs.lastSrcCtlPtH = srcH2;
        rs.lastTgtCtlPtX = tgtX2;
        rs.lastTgtCtlPtY = tgtY2;
        rs.lastTgtCtlPtW = tgtW2;
        rs.lastTgtCtlPtH = tgtH2;
        rs.lastEdgeIndex = edgeIndex2;
        rs.lastNumEdges = numEdges2;
        rs.lastWidth = width2;
        // console.log('edge ctrl pt cache MISS')
      }

      if( src === tgt ){
        // Self-edge

        rs.edgeType = 'self';

        var j = i;
        var loopDist = stepSize;

        if( edgeIsUnbundled ){
          j = 0;
          loopDist = ctrlptDist;
        }

        rs.ctrlpts = [
          srcPos.x,
          srcPos.y - (1 + Math.pow(srcH, 1.12) / 100) * loopDist * (j / 3 + 1),

          srcPos.x - (1 + Math.pow(srcW, 1.12) / 100) * loopDist * (j / 3 + 1),
          srcPos.y
        ];

      } else if(
        hasCompounds &&
        ( src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild() ) &&
        ( src.parents().anySame(tgt) || tgt.parents().anySame(src) )
      ){
        // Compound edge

        rs.edgeType = 'compound';

        // because the line approximation doesn't apply for compound beziers
        // (loop/self edges are already elided b/c of cheap src==tgt check)
        rs.badBezier = false;

        var j = i;
        var loopDist = stepSize;

        if( edgeIsUnbundled ){
          j = 0;
          loopDist = ctrlptDist;
        }

        var loopW = 50;

        var loopaPos = {
          x: srcPos.x - srcW/2,
          y: srcPos.y - srcH/2
        };

        var loopbPos = {
          x: tgtPos.x - tgtW/2,
          y: tgtPos.y - tgtH/2
        };

        var loopPos = {
          x: Math.min( loopaPos.x, loopbPos.x ),
          y: Math.min( loopaPos.y, loopbPos.y )
        };

        // avoids cases with impossible beziers
        var minCompoundStretch = 0.5;
        var compoundStretchA = Math.max( minCompoundStretch, Math.log(srcW * 0.01) );
        var compoundStretchB = Math.max( minCompoundStretch, Math.log(tgtW * 0.01) );

        rs.ctrlpts = [
          loopPos.x,
          loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,

          loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,
          loopPos.y
        ];

      } else if( curveStyle === 'segments' ){
        // Segments (multiple straight lines)

        rs.edgeType = 'segments';
        rs.segpts = [];

        var segmentWs = eStyle['segment-weights'].pfValue;
        var segmentDs = eStyle['segment-distances'].pfValue;
        var segmentsN = Math.min( segmentWs.length, segmentDs.length );

        for( var s = 0; s < segmentsN; s++ ){
          var w = segmentWs[s];
          var d = segmentDs[s];

          // d = swappedDirection ? -d : d;
          //
          // d = Math.abs(d);

          // var w1 = !swappedDirection ? (1 - w) : w;
          // var w2 = !swappedDirection ? w : (1 - w);

          var w1 = (1 - w);
          var w2 = w;

          var adjustedMidpt = {
            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,
            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2
          };

          rs.segpts.push(
            adjustedMidpt.x + vectorNormInverse.x * d,
            adjustedMidpt.y + vectorNormInverse.y * d
          );
        }

      // Straight edge
      } else if (
        pairEdges.length % 2 === 1
        && i === Math.floor(pairEdges.length / 2)
        && !edgeIsUnbundled
      ){

        rs.edgeType = 'straight';

      } else {
        // (Multi)bezier

        var multi = edgeIsUnbundled;

        rs.edgeType = multi ? 'multibezier' : 'bezier';
        rs.ctrlpts = [];

        for( var b = 0; b < bezierN; b++ ){
          var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
          var manctrlptDist;
          var sign = math.signum( normctrlptDist );

          if( multi ){
            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size
            ctrlptWeight = ctrlptWs.value[b];
          }

          if( edgeIsUnbundled ){ // multi or single unbundled
            manctrlptDist = ctrlptDist;
          } else {
            manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
          }

          var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;

          var w1 = !swappedDirection || edgeIsUnbundled ? (1 - ctrlptWeight) : ctrlptWeight;
          var w2 = !swappedDirection || edgeIsUnbundled ? ctrlptWeight : (1 - ctrlptWeight);

          var adjustedMidpt = {
            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,
            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2
          };

          rs.ctrlpts.push(
            adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint,
            adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint
          );
        }

      }

      // find endpts for edge
      this.findEndpoints( edge );

      var badStart = !is.number( rs.startX ) || !is.number( rs.startY );
      var badAStart = !is.number( rs.arrowStartX ) || !is.number( rs.arrowStartY );
      var badEnd = !is.number( rs.endX ) || !is.number( rs.endY );
      var badAEnd = !is.number( rs.arrowEndX ) || !is.number( rs.arrowEndY );

      var minCpADistFactor = 3;
      var arrowW = this.getArrowWidth( eStyle['width'].pfValue ) * this.arrowShapeHeight;
      var minCpADist = minCpADistFactor * arrowW;

      if( rs.edgeType === 'bezier' ){
        var startACpDist = math.distance( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY } );
        var closeStartACp = startACpDist < minCpADist;
        var endACpDist = math.distance( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY } );
        var closeEndACp = endACpDist < minCpADist;

        var overlapping = false;

        if( badStart || badAStart || closeStartACp ){
          overlapping = true;

          // project control point along line from src centre to outside the src shape
          // (otherwise intersection will yield nothing)
          var cpD = { // delta
            x: rs.ctrlpts[0] - srcPos.x,
            y: rs.ctrlpts[1] - srcPos.y
          };
          var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
          var cpM = { // normalised delta
            x: cpD.x / cpL,
            y: cpD.y / cpL
          };
          var radius = Math.max(srcW, srcH);
          var cpProj = { // *2 radius guarantees outside shape
            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
            y: rs.ctrlpts[1] + cpM.y * 2 * radius
          };

          var srcCtrlPtIntn = srcShape.intersectLine(
            srcPos.x,
            srcPos.y,
            srcW,
            srcH,
            cpProj.x,
            cpProj.y,
            0
          );

          if( closeStartACp ){
            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
          } else {
            rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
            rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
          }
        }

        if( badEnd || badAEnd || closeEndACp ){
          overlapping = true;

          // project control point along line from tgt centre to outside the tgt shape
          // (otherwise intersection will yield nothing)
          var cpD = { // delta
            x: rs.ctrlpts[0] - tgtPos.x,
            y: rs.ctrlpts[1] - tgtPos.y
          };
          var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
          var cpM = { // normalised delta
            x: cpD.x / cpL,
            y: cpD.y / cpL
          };
          var radius = Math.max(srcW, srcH);
          var cpProj = { // *2 radius guarantees outside shape
            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
            y: rs.ctrlpts[1] + cpM.y * 2 * radius
          };

          var tgtCtrlPtIntn = tgtShape.intersectLine(
            tgtPos.x,
            tgtPos.y,
            tgtW,
            tgtH,
            cpProj.x,
            cpProj.y,
            0
          );

          if( closeEndACp ){
            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);
            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);
          } else {
            rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;
            rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
          }

        }

        if( overlapping ){
          // recalc endpts
          this.findEndpoints( edge );
        }

      }

      if( rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
        rs.allpts = [];

        rs.allpts.push( rs.startX, rs.startY );

        for( var b = 0; b+1 < rs.ctrlpts.length; b += 2 ){
          // ctrl pt itself
          rs.allpts.push( rs.ctrlpts[b], rs.ctrlpts[b+1] );

          // the midpt between ctrlpts as intermediate destination pts
          if( b + 3 < rs.ctrlpts.length ){
            rs.allpts.push( (rs.ctrlpts[b] + rs.ctrlpts[b+2])/2, (rs.ctrlpts[b+1] + rs.ctrlpts[b+3])/2 );
          }
        }

        rs.allpts.push( rs.endX, rs.endY );

        var m, mt;
        if( rs.edgeType === 'bezier' ){
          rs.midX = math.qbezierAt( rs.arrowStartX, rs.ctrlpts[0], rs.arrowEndX, 0.5 );
          rs.midY = math.qbezierAt( rs.arrowStartY, rs.ctrlpts[1], rs.arrowEndY, 0.5 );
        } else if( rs.ctrlpts.length/2 % 2 === 0 ){
          m = rs.allpts.length/2 - 1;

          rs.midX = rs.allpts[m];
          rs.midY = rs.allpts[m+1];
        } else {
          m = rs.allpts.length/2 - 3;
          mt = 0.5;

          rs.midX = math.qbezierAt( rs.allpts[m], rs.allpts[m+2], rs.allpts[m+4], mt );
          rs.midY = math.qbezierAt( rs.allpts[m+1], rs.allpts[m+3], rs.allpts[m+5], mt );
        }

      } else if( rs.edgeType === 'straight' ){
        // need to calc these after endpts
        rs.allpts = [ rs.startX, rs.startY, rs.endX, rs.endY ];

        // default midpt for labels etc
        rs.midX = ( rs.arrowStartX + rs.arrowEndX )/2;
        rs.midY = ( rs.arrowStartY + rs.arrowEndY )/2;

      } else if( rs.edgeType === 'segments' ){
        rs.allpts = [];
        rs.allpts.push( rs.startX, rs.startY );
        rs.allpts.push.apply( rs.allpts, rs.segpts );
        rs.allpts.push( rs.endX, rs.endY );

        if( rs.segpts.length % 4 === 0 ){
          var i2 = rs.segpts.length / 2;
          var i1 = i2 - 2;

          rs.midX = ( rs.segpts[i1] + rs.segpts[i2] ) / 2;
          rs.midY = ( rs.segpts[i1+1] + rs.segpts[i2+1] ) / 2;
        } else {
          var i1 = rs.segpts.length / 2 - 1;

          rs.midX = rs.segpts[i1];
          rs.midY = rs.segpts[i1+1];
        }


      }

      this.projectLines( edge );
      this.calculateArrowAngles( edge );
      this.recalculateEdgeLabelProjection( edge );

    }
  }

  for( var i = 0; i < haystackEdges.length; i++ ){
    var edge = haystackEdges[i];
    var _p = edge._private;
    var style = _p.style;
    var rscratch = _p.rscratch;
    var rs = rscratch;

    if( !rscratch.haystack ){
      var angle = Math.random() * 2 * Math.PI;

      rscratch.source = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };

      var angle = Math.random() * 2 * Math.PI;

      rscratch.target = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };

    }

    var src = _p.source;
    var tgt = _p.target;
    var srcPos = src._private.position;
    var tgtPos = tgt._private.position;
    var srcW = src.width();
    var tgtW = tgt.width();
    var srcH = src.height();
    var tgtH = tgt.height();
    var radius = style['haystack-radius'].value;
    var halfRadius = radius/2; // b/c have to half width/height

    rs.haystackPts = rs.allpts = [
      rs.source.x * srcW * halfRadius + srcPos.x,
      rs.source.y * srcH * halfRadius + srcPos.y,
      rs.target.x * tgtW * halfRadius + tgtPos.x,
      rs.target.y * tgtH * halfRadius + tgtPos.y
    ];

    rs.midX = (rs.allpts[0] + rs.allpts[2])/2;
    rs.midY = (rs.allpts[1] + rs.allpts[3])/2;

    // always override as haystack in case set to different type previously
    rscratch.edgeType = 'haystack';
    rscratch.haystack = true;

    this.projectLines( edge );
    this.calculateArrowAngles( edge );
    this.recalculateEdgeLabelProjection( edge );
  }

  for( var i = 0 ; i < autorotateEdges.length; i++ ){
    var edge = autorotateEdges[i];
    var rs = edge._private.rscratch;

    rs.labelAngle = Math.atan( rs.midDispY / rs.midDispX );
  }

  return hashTable;
};

var getAngleFromDisp = function( dispX, dispY ){
  return Math.atan2( dispY, dispX ) - Math.PI/2;
};

BRp.calculateArrowAngles = function( edge ){
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';
  var isMultibezier = rs.edgeType === 'multibezier';
  var isSegments = rs.edgeType === 'segments';
  var isCompound = rs.edgeType === 'compound';
  var isSelf = rs.edgeType === 'self';

  // Displacement gives direction for arrowhead orientation
  var dispX, dispY;
  var startX, startY, endX, endY;

  var srcPos = edge.source().position();
  var tgtPos = edge.target().position();

  if( isHaystack ){
    startX = rs.haystackPts[0];
    startY = rs.haystackPts[1];
    endX = rs.haystackPts[2];
    endY = rs.haystackPts[3];
  } else {
    startX = rs.arrowStartX;
    startY = rs.arrowStartY;
    endX = rs.arrowEndX;
    endY = rs.arrowEndY;
  }

  // source
  //

  dispX = srcPos.x - startX;
  dispY = srcPos.y - startY;

  rs.srcArrowAngle = getAngleFromDisp( dispX, dispY );

  // mid target
  //

  var midX = rs.midX;
  var midY = rs.midY;

  if( isHaystack ){
    midX = ( startX + endX )/2;
    midY = ( startY + endY )/2;
  }

  dispX = endX - startX;
  dispY = endY - startY;

  if( isSelf ){
    dispX = -1;
    dispY = 1;
  } else if( isSegments ){
    var pts = rs.allpts;

    if( pts.length / 2 % 2 === 0 ){
      var i2 = pts.length / 2;
      var i1 = i2 - 2;

      dispX = ( pts[i2] - pts[i1] );
      dispY = ( pts[i2+1] - pts[i1+1] );
    } else {
      var i2 = pts.length / 2 - 1;
      var i1 = i2 - 2;
      var i3 = i2 + 2;

      dispX = ( pts[i2] - pts[i1] );
      dispY = ( pts[i2+1] - pts[i1+1] );
    }
  } else if( isMultibezier || isCompound ){
    var pts = rs.allpts;
    var cpts = rs.ctrlpts;
    var bp0x, bp0y;
    var bp1x, bp1y;

    if( cpts.length / 2 % 2 === 0 ){
      var p0 = pts.length / 2 - 1; // startpt
      var ic = p0 + 2;
      var p1 = ic + 2;

      bp0x = math.qbezierAt( pts[p0], pts[ic], pts[p1], 0.0 );
      bp0y = math.qbezierAt( pts[p0+1], pts[ic+1], pts[p1+1], 0.0 );

      bp1x = math.qbezierAt( pts[p0], pts[ic], pts[p1], 0.0001 );
      bp1y = math.qbezierAt( pts[p0+1], pts[ic+1], pts[p1+1], 0.0001 );
    } else {
      var ic = pts.length / 2 - 1; // ctrpt
      var p0 = ic - 2; // startpt
      var p1 = ic + 2; // endpt

      bp0x = math.qbezierAt( pts[p0], pts[ic], pts[p1], 0.4999 );
      bp0y = math.qbezierAt( pts[p0+1], pts[ic+1], pts[p1+1], 0.4999 );

      bp1x = math.qbezierAt( pts[p0], pts[ic], pts[p1], 0.5 );
      bp1y = math.qbezierAt( pts[p0+1], pts[ic+1], pts[p1+1], 0.5 );
    }

    dispX = ( bp1x - bp0x );
    dispY = ( bp1y - bp0y );
  }

  rs.midtgtArrowAngle = getAngleFromDisp( dispX, dispY );

  rs.midDispX = dispX;
  rs.midDispY = dispY;

  // mid source
  //

  dispX *= -1;
  dispY *= -1;

  if( isSegments ){
    var pts = rs.allpts;

    if( pts.length / 2 % 2 === 0 ){
      // already ok
    } else {
      var i2 = pts.length / 2 - 1;
      var i3 = i2 + 2;

      dispX = -( pts[i3] - pts[i2] );
      dispY = -( pts[i3+1] - pts[i2+1] );
    }
  }

  rs.midsrcArrowAngle = getAngleFromDisp( dispX, dispY );

  // target
  //

  dispX = tgtPos.x - endX;
  dispY = tgtPos.y - endY;

  rs.tgtArrowAngle = getAngleFromDisp( dispX, dispY );
};


BRp.findEndpoints = function( edge ){
  var r = this;
  var intersect;

  var source = edge.source()[0];
  var target = edge.target()[0];

  var src_p = source._private;
  var tgt_p = target._private;

  var srcPos = src_p.position;
  var tgtPos = tgt_p.position;

  var tgtArShape = edge._private.style['target-arrow-shape'].value;
  var srcArShape = edge._private.style['source-arrow-shape'].value;

  var rs = edge._private.rscratch;

  var et = rs.edgeType;
  var bezier = et === 'bezier' || et === 'multibezier' || et === 'self' || et === 'compound';
  var multi = et !== 'bezier';
  var lines = et === 'straight' || et === 'segments';
  var segments = et === 'segments';

  var p1, p2;

  if( bezier ){
    var cpStart = [ rs.ctrlpts[0], rs.ctrlpts[1] ];
    var cpEnd = multi ? [ rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1] ] : cpStart;

    p1 = cpEnd;
    p2 = cpStart;
  } else if( lines ){
    var srcArrowFromPt = !segments ? [ tgtPos.x, tgtPos.y ] : rs.segpts.slice( 0, 2 );
    var tgtArrowFromPt = !segments ? [ srcPos.x, srcPos.y ] : rs.segpts.slice( rs.segpts.length - 2 );

    p1 = tgtArrowFromPt;
    p2 = srcArrowFromPt;
  }

  intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(
    tgtPos.x,
    tgtPos.y,
    target.outerWidth(),
    target.outerHeight(),
    p1[0],
    p1[1],
    0
  );

  var arrowEnd = math.shortenIntersection(intersect, p1,
    r.arrowShapes[tgtArShape].spacing(edge));
  var edgeEnd = math.shortenIntersection(intersect, p1,
    r.arrowShapes[tgtArShape].gap(edge));

  rs.endX = edgeEnd[0];
  rs.endY = edgeEnd[1];

  rs.arrowEndX = arrowEnd[0];
  rs.arrowEndY = arrowEnd[1];

  intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(
    srcPos.x,
    srcPos.y,
    source.outerWidth(),
    source.outerHeight(),
    p2[0],
    p2[1],
    0
  );

  var arrowStart = math.shortenIntersection(
    intersect, p2,
    r.arrowShapes[srcArShape].spacing(edge)
  );
  var edgeStart = math.shortenIntersection(
    intersect, p2,
    r.arrowShapes[srcArShape].gap(edge)
  );

  rs.startX = edgeStart[0];
  rs.startY = edgeStart[1];

  rs.arrowStartX = arrowStart[0];
  rs.arrowStartY = arrowStart[1];

  if( lines ){
    if( !is.number(rs.startX) || !is.number(rs.startY) || !is.number(rs.endX) || !is.number(rs.endY) ){
      rs.badLine = true;
    } else {
      rs.badLine = false;
    }
  }
};

BRp.getArrowWidth = BRp.getArrowHeight = function(edgeWidth) {
  var cache = this.arrowWidthCache = this.arrowWidthCache || {};

  var cachedVal = cache[edgeWidth];
  if( cachedVal ){
    return cachedVal;
  }

  cachedVal =  Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29);
  cache[edgeWidth] = cachedVal;

  return cachedVal;
};

module.exports = BRp;

},{"../../../collection/zsort":29,"../../../is":77,"../../../math":79}],57:[function(_dereq_,module,exports){
'use strict';

var BRp = {};

BRp.getCachedImage = function(url, onLoad) {
  var r = this;
  var imageCache = r.imageCache = r.imageCache || {};

  if( imageCache[url] && imageCache[url].image ){
    return imageCache[url].image;
  }

  var cache = imageCache[url] = imageCache[url] || {};

  var image = cache.image = new Image();
  image.addEventListener('load', onLoad);
  image.src = url;

  return image;
};

module.exports = BRp;

},{}],58:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../../is');
var util = _dereq_('../../../util');

var BaseRenderer = function(){};
var BR = BaseRenderer;
var BRp = BR.prototype;

BRp.clientFunctions = [ 'redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl' ];

BRp.init = function( options ){
  var r = this;

  r.options = options;

  r.cy = options.cy;

  r.container = options.cy.container();

  r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

  //--Pointer-related data
  r.hoverData = {down: null, last: null,
      downTime: null, triggerMode: null,
      dragging: false,
      initialPan: [null, null], capture: false};

  r.dragData = {possibleDragElements: []};

  r.touchData = {
      start: null, capture: false,

      // These 3 fields related to tap, taphold events
      startPosition: [null, null, null, null, null, null],
      singleTouchStartTime: null,
      singleTouchMoved: true,

      now: [null, null, null, null, null, null],
      earlier: [null, null, null, null, null, null]
  };

  r.redraws = 0;
  r.showFps = options.showFps;

  r.hideEdgesOnViewport = options.hideEdgesOnViewport;
  r.hideLabelsOnViewport = options.hideLabelsOnViewport;
  r.textureOnViewport = options.textureOnViewport;
  r.wheelSensitivity = options.wheelSensitivity;
  r.motionBlurEnabled = options.motionBlur; // on by default
  r.forcedPixelRatio = options.pixelRatio;
  r.motionBlur = true; // for initial kick off
  r.motionBlurOpacity = options.motionBlurOpacity;
  r.motionBlurTransparency = 1 - r.motionBlurOpacity;
  r.motionBlurPxRatio = 1;
  r.mbPxRBlurry = 1; //0.8;
  r.minMbLowQualFrames = 4;
  r.fullQualityMb = false;
  r.clearedForMotionBlur = [];
  r.desktopTapThreshold = options.desktopTapThreshold;
  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
  r.touchTapThreshold = options.touchTapThreshold;
  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
  r.tapholdDuration = 500;

  r.bindings = [];

  r.registerNodeShapes();
  r.registerArrowShapes();
  r.load();
};

BRp.notify = function(params) {
  var types;
  var r = this;

  if( is.array( params.type ) ){
    types = params.type;

  } else {
    types = [ params.type ];
  }

  for( var i = 0; i < types.length; i++ ){
    var type = types[i];

    switch( type ){
      case 'destroy':
        r.destroy();
        return;

      case 'add':
      case 'remove':
      case 'load':
        r.updateElementsCache();
        break;

      case 'viewport':
        r.redrawHint('select', true);
        break;

      case 'style':
        r.updateCachedZSortedEles();
        break;
    }

    if( type === 'load' || type === 'resize' ){
      r.invalidateContainerClientCoordsCache();
      r.matchCanvasSize(r.container);
    }
  } // for

  r.redrawHint('eles', true);
  r.redrawHint('drag', true);

  this.startRenderLoop();

  this.redraw();
};

BRp.destroy = function(){
  this.destroyed = true;

  this.cy.stopAnimationLoop();

  for( var i = 0; i < this.bindings.length; i++ ){
    var binding = this.bindings[i];
    var b = binding;

    b.target.removeEventListener(b.event, b.handler, b.useCapture);
  }

  if( this.removeObserver ){
    this.removeObserver.disconnect();
  }

  if( this.labelCalcDiv ){
    try{
      document.body.removeChild(this.labelCalcDiv);
    } catch(e){
      // ie10 issue #1014
    }
  }
};

[
  _dereq_('./arrow-shapes'),
  _dereq_('./cached-eles'),
  _dereq_('./coord-ele-math'),
  _dereq_('./images'),
  _dereq_('./load-listeners'),
  _dereq_('./node-shapes'),
  _dereq_('./redraw')
].forEach(function( props ){
  util.extend( BRp, props );
});

module.exports = BR;

},{"../../../is":77,"../../../util":94,"./arrow-shapes":54,"./cached-eles":55,"./coord-ele-math":56,"./images":57,"./load-listeners":59,"./node-shapes":60,"./redraw":61}],59:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../../is');
var util = _dereq_('../../../util');
var Event = _dereq_('../../../event');
var Collection = _dereq_('../../../collection');

var BRp = {};

BRp.registerBinding = function(target, event, handler, useCapture){
  this.bindings.push({
    target: target,
    event: event,
    handler: handler,
    useCapture: useCapture
  });

  target.addEventListener(event, handler, useCapture);
};

BRp.nodeIsDraggable = function(node) {
  if (node._private.style['opacity'].value !== 0
    && node._private.style['visibility'].value == 'visible'
    && node._private.style['display'].value == 'element'
    && !node.locked()
    && node.grabbable() ) {

    return true;
  }

  return false;
};

BRp.load = function() {
  var r = this;

  var triggerEvents = function( target, names, e, props ){
    if( target == null ){
      target = r.cy;
    }

    for( var i = 0; i < names.length; i++ ){
      var name = names[i];

      var event = Event( e, util.extend({ type: name }, props) );
      target.trigger( event );
    }
  };

  var isMultSelKeyDown = function( e ){
    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
  };

  var getDragListIds = function(opts){
    var listHasId;

    if( opts.addToList && r.cy.hasCompoundNodes() ){ // only needed for compound graphs
      if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist
        opts.addToList.hasId = {};

        for( var i = 0; i < opts.addToList.length; i++ ){
          var ele = opts.addToList[i];

          opts.addToList.hasId[ ele.id() ] = true;
        }
      }

      listHasId = opts.addToList.hasId;
    }

    return listHasId || {};
  };

  // helper function to determine which child nodes and inner edges
  // of a compound node to be dragged as well as the grabbed and selected nodes
  var addDescendantsToDrag = function(node, opts){
    if( !node._private.cy.hasCompoundNodes() ){
      return;
    }

    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

    var listHasId = getDragListIds( opts );

    var innerNodes = node.descendants();

    for( var i = 0; i < innerNodes.size(); i++ ){
      var iNode = innerNodes[i];
      var _p = iNode._private;

      if( opts.inDragLayer ){
        _p.rscratch.inDragLayer = true;
      }

      if( opts.addToList && !listHasId[ iNode.id() ] ){
        opts.addToList.push( iNode );
        listHasId[ iNode.id() ] = true;

        _p.grabbed = true;
      }

      var edges = _p.edges;
      for( var j = 0; opts.inDragLayer && j < edges.length; j++ ){
        edges[j]._private.rscratch.inDragLayer = true;
      }
    }
  };

  // adds the given nodes, and its edges to the drag layer
  var addNodeToDrag = function(node, opts){

    var _p = node._private;
    var listHasId = getDragListIds( opts );

    if( opts.inDragLayer ){
      _p.rscratch.inDragLayer = true;
    }

    if( opts.addToList && !listHasId[ node.id() ] ){
      opts.addToList.push( node );
      listHasId[ node.id() ] = true;

      _p.grabbed = true;
    }

    var edges = _p.edges;
    for( var i = 0; opts.inDragLayer && i < edges.length; i++ ){
      edges[i]._private.rscratch.inDragLayer = true;
    }

    addDescendantsToDrag( node, opts ); // always add to drag

    // also add nodes and edges related to the topmost ancestor
    updateAncestorsInDragLayer( node, {
      inDragLayer: opts.inDragLayer
    } );
  };

  var freeDraggedElements = function( draggedElements ){
    if( !draggedElements ){ return; }

    for (var i=0; i < draggedElements.length; i++) {

      var dEi_p = draggedElements[i]._private;

      if(dEi_p.group === 'nodes') {
        dEi_p.rscratch.inDragLayer = false;
        dEi_p.grabbed = false;

        var sEdges = dEi_p.edges;
        for( var j = 0; j < sEdges.length; j++ ){ sEdges[j]._private.rscratch.inDragLayer = false; }

        // for compound nodes, also remove related nodes and edges from the drag layer
        updateAncestorsInDragLayer(draggedElements[i], { inDragLayer: false });

      } else if( dEi_p.group === 'edges' ){
        dEi_p.rscratch.inDragLayer = false;
      }

    }
  };

  // helper function to determine which ancestor nodes and edges should go
  // to the drag layer (or should be removed from drag layer).
  var updateAncestorsInDragLayer = function(node, opts) {

    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

    // find top-level parent
    var parent = node;

    if( !node._private.cy.hasCompoundNodes() ){
      return;
    }

    while( parent.parent().nonempty() ){
      parent = parent.parent()[0];
    }

    // no parent node: no nodes to add to the drag layer
    if( parent == node ){
      return;
    }

    var nodes = parent.descendants()
      .merge( parent )
      .unmerge( node )
      .unmerge( node.descendants() )
    ;

    var edges = nodes.connectedEdges();

    var listHasId = getDragListIds( opts );

    for( var i = 0; i < nodes.size(); i++ ){
      if( opts.inDragLayer !== undefined ){
        nodes[i]._private.rscratch.inDragLayer = opts.inDragLayer;
      }

      if( opts.addToList && !listHasId[ nodes[i].id() ] ){
        opts.addToList.push( nodes[i] );
        listHasId[ nodes[i].id() ] = true;

        nodes[i]._private.grabbed = true;
      }
    }

    for( var j = 0; opts.inDragLayer !== undefined && j < edges.length; j++ ) {
      edges[j]._private.rscratch.inDragLayer = opts.inDragLayer;
    }
  };

  if( typeof MutationObserver !== 'undefined' ){
    r.removeObserver = new MutationObserver(function( mutns ){
      for( var i = 0; i < mutns.length; i++ ){
        var mutn = mutns[i];
        var rNodes = mutn.removedNodes;

        if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){
          var rNode = rNodes[j];

          if( rNode === r.container ){
            r.destroy();
            break;
          }
        } }
      }
    });

    if( r.container.parentNode ){
      r.removeObserver.observe( r.container.parentNode, { childList: true } );
    }
  } else {
    r.registerBinding(r.container, 'DOMNodeRemoved', function(e){
      r.destroy();
    });
  }



  // auto resize
  r.registerBinding(window, 'resize', util.debounce( function(e) {
    r.invalidateContainerClientCoordsCache();

    r.matchCanvasSize(r.container);
    r.redrawHint('eles', true);
    r.redraw();
  }, 100 ) );

  var invalCtnrBBOnScroll = function(domEle){
    r.registerBinding(domEle, 'scroll', function(e){
      r.invalidateContainerClientCoordsCache();
    } );
  };

  var bbCtnr = r.cy.container();

  for( ;; ){

    invalCtnrBBOnScroll( bbCtnr );

    if( bbCtnr.parentNode ){
      bbCtnr = bbCtnr.parentNode;
    } else {
      break;
    }

  }

  // stop right click menu from appearing on cy
  r.registerBinding(r.container, 'contextmenu', function(e){
    e.preventDefault();
  });

  var inBoxSelection = function(){
    return r.selection[4] !== 0;
  };

  // Primary key
  r.registerBinding(r.container, 'mousedown', function(e) {
    e.preventDefault();
    r.hoverData.capture = true;
    r.hoverData.which = e.which;

    var cy = r.cy;
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var select = r.selection;
    var near = r.findNearestElement(pos[0], pos[1], true, false);
    var draggedElements = r.dragData.possibleDragElements;

    r.hoverData.mdownPos = pos;

    var checkForTaphold = function(){
      r.hoverData.tapholdCancelled = false;

      clearTimeout( r.hoverData.tapholdTimeout );

      r.hoverData.tapholdTimeout = setTimeout(function(){

        if( r.hoverData.tapholdCancelled ){
          return;
        } else {
          var ele = r.hoverData.down;

          if( ele ){
            ele.trigger( Event(e, {
              type: 'taphold',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );
          } else {
            cy.trigger( Event(e, {
              type: 'taphold',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );
          }
        }

      }, r.tapholdDuration);
    };

    // Right click button
    if( e.which == 3 ){

      r.hoverData.cxtStarted = true;

      var cxtEvt = Event(e, {
        type: 'cxttapstart',
        cyPosition: { x: pos[0], y: pos[1] }
      });

      if( near ){
        near.activate();
        near.trigger( cxtEvt );

        r.hoverData.down = near;
      } else {
        cy.trigger( cxtEvt );
      }

      r.hoverData.downTime = (new Date()).getTime();
      r.hoverData.cxtDragged = false;

    // Primary button
    } else if (e.which == 1) {

      if( near ){
        near.activate();
      }

      // Element dragging
      {
        // If something is under the cursor and it is draggable, prepare to grab it
        if (near != null) {

          if( r.nodeIsDraggable(near) ){

            var grabEvent = Event(e, {
              type: 'grab',
              cyPosition: { x: pos[0], y: pos[1] }
            });

            if ( near.isNode() && !near.selected() ){

              draggedElements = r.dragData.possibleDragElements = [];
              addNodeToDrag( near, { addToList: draggedElements } );

              near.trigger(grabEvent);

            } else if ( near.isNode() && near.selected() ){
              draggedElements = r.dragData.possibleDragElements = [  ];

              var selectedNodes = cy.$(function(){ return this.isNode() && this.selected(); });

              for( var i = 0; i < selectedNodes.length; i++ ){

                // Only add this selected node to drag if it is draggable, eg. has nonzero opacity
                if( r.nodeIsDraggable( selectedNodes[i] ) ){
                  addNodeToDrag( selectedNodes[i], { addToList: draggedElements } );
                }
              }

              near.trigger( grabEvent );
            }

            r.redrawHint('eles', true);
            r.redrawHint('drag', true);

          }

        }

        r.hoverData.down = near;
        r.hoverData.downTime = (new Date()).getTime();
      }

      triggerEvents( near, ['mousedown', 'tapstart', 'vmousedown'], e, {
        cyPosition: { x: pos[0], y: pos[1] }
      } );

      if ( near == null ) {
        select[4] = 1;

        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint('select', true);

        r.redraw();
      } else if( near.isEdge() ){
        select[4] = 1; // for future pan
      }

      checkForTaphold();

    }

    // Initialize selection box coordinates
    select[0] = select[2] = pos[0];
    select[1] = select[3] = pos[1];

  }, false);

  r.registerBinding(window, 'mousemove', function(e) {
    var preventDefault = false;
    var capture = r.hoverData.capture;

    // save cycles if mouse events aren't to be captured
    if ( !capture ){
      var containerPageCoords = r.findContainerClientCoords();

      if (e.clientX > containerPageCoords[0] && e.clientX < containerPageCoords[0] + r.canvasWidth
        && e.clientY > containerPageCoords[1] && e.clientY < containerPageCoords[1] + r.canvasHeight
      ) {
        // inside container bounds so OK
      } else {
        return;
      }

      var cyContainer = r.container;
      var target = e.target;
      var tParent = target.parentNode;
      var containerIsTarget = false;

      while( tParent ){
        if( tParent === cyContainer ){
          containerIsTarget = true;
          break;
        }

        tParent = tParent.parentNode;
      }

      if( !containerIsTarget ){ return; } // if target is outisde cy container, then this event is not for us
    }

    var cy = r.cy;
    var zoom = cy.zoom();
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var select = r.selection;

    var near = null;
    if( !r.hoverData.draggingEles ){
      near = r.findNearestElement(pos[0], pos[1], true, false);
    }
    var last = r.hoverData.last;
    var down = r.hoverData.down;

    var disp = [pos[0] - select[2], pos[1] - select[3]];

    var draggedElements = r.dragData.possibleDragElements;

    var dx = select[2] - select[0];
    var dx2 = dx * dx;
    var dy = select[3] - select[1];
    var dy2 = dy * dy;
    var dist2 = dx2 + dy2;
    var rdist2 = dist2 * zoom * zoom;

    var multSelKeyDown = isMultSelKeyDown( e );

    r.hoverData.tapholdCancelled = true;

    var updateDragDelta = function(){
      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

      if( dragDelta.length === 0 ){
        dragDelta.push( disp[0] );
        dragDelta.push( disp[1] );
      } else {
        dragDelta[0] += disp[0];
        dragDelta[1] += disp[1];
      }
    };


    preventDefault = true;

    triggerEvents( near, ['mousemove', 'vmousemove', 'tapdrag'], e, {
      cyPosition: { x: pos[0], y: pos[1] }
    } );

    // trigger context drag if rmouse down
    if( r.hoverData.which === 3 ){
      var cxtEvt = Event(e, {
        type: 'cxtdrag',
        cyPosition: { x: pos[0], y: pos[1] }
      });

      if( down ){
        down.trigger( cxtEvt );
      } else {
        cy.trigger( cxtEvt );
      }

      r.hoverData.cxtDragged = true;

      if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){

        if( r.hoverData.cxtOver ){
          r.hoverData.cxtOver.trigger( Event(e, {
            type: 'cxtdragout',
            cyPosition: { x: pos[0], y: pos[1] }
          }) );
        }

        r.hoverData.cxtOver = near;

        if( near ){
          near.trigger( Event(e, {
            type: 'cxtdragover',
            cyPosition: { x: pos[0], y: pos[1] }
          }) );
        }

      }

    // Check if we are drag panning the entire graph
    } else if (r.hoverData.dragging) {
      preventDefault = true;

      if( cy.panningEnabled() && cy.userPanningEnabled() ){
        var deltaP;

        if( r.hoverData.justStartedPan ){
          var mdPos = r.hoverData.mdownPos;

          deltaP = {
            x: ( pos[0] - mdPos[0] ) * zoom,
            y: ( pos[1] - mdPos[1] ) * zoom
          };

          r.hoverData.justStartedPan = false;

        } else {
          deltaP = {
            x: disp[0] * zoom,
            y: disp[1] * zoom
          };

        }

        cy.panBy( deltaP );

        r.hoverData.dragged = true;
      }

      // Needs reproject due to pan changing viewport
      pos = r.projectIntoViewport(e.clientX, e.clientY);

    // Checks primary button down & out of time & mouse not moved much
    } else if(
        select[4] == 1 && (down == null || down.isEdge())
    ){

      if( !r.hoverData.dragging && cy.boxSelectionEnabled() && ( multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled() ) ){
        r.data.bgActivePosistion = undefined;
        r.hoverData.selecting = true;

        r.redrawHint('select', true);
        r.redraw();

      } else if( !r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled() ){
        r.hoverData.dragging = true;
        r.hoverData.justStartedPan = true;
        select[4] = 0;

        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint('select', true);
        r.redraw();
      }

      if( down && down.isEdge() && down.active() ){ down.unactivate(); }

    } else {
      if( down && down.isEdge() && down.active() ){ down.unactivate(); }

      if (near != last) {

        if (last) {
          triggerEvents( last, ['mouseout', 'tapdragout'], e, {
            cyPosition: { x: pos[0], y: pos[1] }
          } );
        }

        if (near) {
          triggerEvents( near, ['mouseover', 'tapdragover'], e, {
            cyPosition: { x: pos[0], y: pos[1] }
          } );
        }

        r.hoverData.last = near;
      }

      if( down && down.isNode() && r.nodeIsDraggable(down) ){

        if( rdist2 >= r.desktopTapThreshold2 ){ // then drag

          var justStartedDrag = !r.dragData.didDrag;

          if( justStartedDrag ) {
            r.redrawHint('eles', true);
          }

          r.dragData.didDrag = true; // indicate that we actually did drag the node

          var toTrigger = [];

          for( var i = 0; i < draggedElements.length; i++ ){
            var dEle = draggedElements[i];

            // now, add the elements to the drag layer if not done already
            if( !r.hoverData.draggingEles ){
              addNodeToDrag( dEle, { inDragLayer: true } );
            }

            // Locked nodes not draggable, as well as non-visible nodes
            if( dEle.isNode() && r.nodeIsDraggable(dEle) && dEle.grabbed() ){
              var dPos = dEle._private.position;

              toTrigger.push( dEle );

              if( is.number(disp[0]) && is.number(disp[1]) ){
                var updatePos = !dEle.isParent();

                if( updatePos ){
                  dPos.x += disp[0];
                  dPos.y += disp[1];
                }

                if( justStartedDrag ){
                  var dragDelta = r.hoverData.dragDelta;

                  if( updatePos && is.number(dragDelta[0]) && is.number(dragDelta[1]) ){
                    dPos.x += dragDelta[0];
                    dPos.y += dragDelta[1];
                  }
                }
              }

            }
          }

          r.hoverData.draggingEles = true;

          var tcol = (Collection(cy, toTrigger));

          tcol.updateCompoundBounds();
          tcol.trigger('position drag');

          r.redrawHint('drag', true);
          r.redraw();

        } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
          updateDragDelta();
        }
      }

      // prevent the dragging from triggering text selection on the page
      preventDefault = true;
    }

    select[2] = pos[0]; select[3] = pos[1];

    if( preventDefault ){
      if(e.stopPropagation) e.stopPropagation();
        if(e.preventDefault) e.preventDefault();
        return false;
      }
  }, false);

  r.registerBinding(window, 'mouseup', function(e) {
    var capture = r.hoverData.capture;
    if (!capture) { return; }
    r.hoverData.capture = false;

    var cy = r.cy; var pos = r.projectIntoViewport(e.clientX, e.clientY); var select = r.selection;
    var near = r.findNearestElement(pos[0], pos[1], true, false);
    var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;
    var multSelKeyDown = isMultSelKeyDown( e );

    if( r.data.bgActivePosistion ){
      r.redrawHint('select', true);
      r.redraw();
    }

    r.hoverData.tapholdCancelled = true;

    r.data.bgActivePosistion = undefined; // not active bg now

    if( down ){
      down.unactivate();
    }

    if( r.hoverData.which === 3 ){
      var cxtEvt = Event(e, {
        type: 'cxttapend',
        cyPosition: { x: pos[0], y: pos[1] }
      });

      if( down ){
        down.trigger( cxtEvt );
      } else {
        cy.trigger( cxtEvt );
      }

      if( !r.hoverData.cxtDragged ){
        var cxtTap = Event(e, {
          type: 'cxttap',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( down ){
          down.trigger( cxtTap );
        } else {
          cy.trigger( cxtTap );
        }
      }

      r.hoverData.cxtDragged = false;
      r.hoverData.which = null;

    } else if( r.hoverData.which === 1 ) {

      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
      if ( (down == null) // not mousedown on node
        && !r.dragData.didDrag // didn't move the node around
        && !r.hoverData.selecting // not box selection
        && !r.hoverData.dragged // didn't pan
        && !isMultSelKeyDown( e )
      ) {

        cy.$(function(){
          return this.selected();
        }).unselect();

        if (draggedElements.length > 0) {
          r.redrawHint('eles', true);
        }

        r.dragData.possibleDragElements = draggedElements = [];
      }

      triggerEvents( near, ['mouseup', 'tapend', 'vmouseup'], e, {
        cyPosition: { x: pos[0], y: pos[1] }
      } );

      if(
        !r.dragData.didDrag // didn't move a node around
        && !r.hoverData.dragged // didn't pan
      ){
        triggerEvents( near, ['click', 'tap', 'vclick'], e, {
          cyPosition: { x: pos[0], y: pos[1] }
        } );
      }

      // Single selection
      if( near == down && !r.dragData.didDrag && !r.hoverData.selecting ){
        if( near != null && near._private.selectable ){

          if( r.hoverData.dragging ){
            // if panning, don't change selection state
          } else if( cy.selectionType() === 'additive' || multSelKeyDown ){
            if( near.selected() ){
              near.unselect();
            } else {
              near.select();
            }
          } else {
            if( !multSelKeyDown ){
              cy.$(':selected').unmerge( near ).unselect();
              near.select();
            }
          }

          r.redrawHint('eles', true);
        }
      }

      if ( r.hoverData.selecting ) {
        var newlySelected = [];
        var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

        r.redrawHint('select', true);

        if( box.length > 0 ) {
          r.redrawHint('eles', true);
        }

        for( var i = 0; i < box.length; i++ ){
          if( box[i]._private.selectable ){
            newlySelected.push( box[i] );
          }
        }

        var newlySelCol = Collection( cy, newlySelected );

        if( cy.selectionType() === 'additive' ){
          newlySelCol.select();
        } else {
          if( !multSelKeyDown ){
            cy.$(':selected').unmerge( newlySelCol ).unselect();
          }

          newlySelCol.select();
        }

        // always need redraw in case eles unselectable
        r.redraw();

      }

      // Cancel drag pan
      if( r.hoverData.dragging ){
        r.hoverData.dragging = false;

        r.redrawHint('select', true);
        r.redrawHint('eles', true);

        r.redraw();
      }

      if (!select[4]) {


        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        freeDraggedElements( draggedElements );

        if( down ){ down.trigger('free'); }
      }

    } // else not right mouse

    select[4] = 0; r.hoverData.down = null;

    r.hoverData.cxtStarted = false;
    r.hoverData.draggingEles = false;
    r.hoverData.selecting = false;
    r.dragData.didDrag = false;
    r.hoverData.dragged = false;
    r.hoverData.dragDelta = [];

  }, false);

  var wheelHandler = function(e) {


    if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom

    var cy = r.cy;
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var rpos = [pos[0] * cy.zoom() + cy.pan().x,
                  pos[1] * cy.zoom() + cy.pan().y];

    if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom
      e.preventDefault();
      return;
    }

    if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){
      e.preventDefault();

      r.data.wheelZooming = true;
      clearTimeout( r.data.wheelTimeout );
      r.data.wheelTimeout = setTimeout(function(){
        r.data.wheelZooming = false;

        r.redrawHint('eles', true);
        r.redraw();
      }, 150);

      var diff = e.deltaY / -250 || e.wheelDeltaY / 1000 || e.wheelDelta / 1000;
      diff = diff * r.wheelSensitivity;

      var needsWheelFix = e.deltaMode === 1;
      if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows
        diff *= 33;
      }

      cy.zoom({
        level: cy.zoom() * Math.pow(10, diff),
        renderedPosition: { x: rpos[0], y: rpos[1] }
      });
    }

  };

  // Functions to help with whether mouse wheel should trigger zooming
  // --
  r.registerBinding(r.container, 'wheel', wheelHandler, true);

  // disable nonstandard wheel events
  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

  r.registerBinding(window, 'scroll', function(e){
    r.scrollingPage = true;

    clearTimeout( r.scrollingPageTimeout );
    r.scrollingPageTimeout = setTimeout(function(){
      r.scrollingPage = false;
    }, 250);
  }, true);

  // Functions to help with handling mouseout/mouseover on the Cytoscape container
        // Handle mouseout on Cytoscape container
  r.registerBinding(r.container, 'mouseout', function(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);

    r.cy.trigger(Event(e, {
      type: 'mouseout',
      cyPosition: { x: pos[0], y: pos[1] }
    }));
  }, false);

  r.registerBinding(r.container, 'mouseover', function(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);

    r.cy.trigger(Event(e, {
      type: 'mouseover',
      cyPosition: { x: pos[0], y: pos[1] }
    }));
  }, false);

  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
  var center1, modelCenter1; // center point on start pinch to zoom
  var offsetLeft, offsetTop;
  var containerWidth, containerHeight;
  var twoFingersStartInside;

  var distance = function(x1, y1, x2, y2){
    return Math.sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
  };

  var distanceSq = function(x1, y1, x2, y2){
    return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);
  };

  var touchstartHandler;
  r.registerBinding(r.container, 'touchstart', touchstartHandler = function(e) {
    r.touchData.capture = true;
    r.data.bgActivePosistion = undefined;

    var cy = r.cy;
    var nodes = r.getCachedNodes();
    var edges = r.getCachedEdges();
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
    if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
    if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }


    // record starting points for pinch-to-zoom
    if( e.touches[1] ){

      // anything in the set of dragged eles should be released
      var release = function( eles ){
        for( var i = 0; i < eles.length; i++ ){
          eles[i]._private.grabbed = false;
          eles[i]._private.rscratch.inDragLayer = false;
          if( eles[i].active() ){ eles[i].unactivate(); }
        }
      };
      release(nodes);
      release(edges);

      var offsets = r.findContainerClientCoords();
      offsetLeft = offsets[0];
      offsetTop = offsets[1];
      containerWidth = offsets[2];
      containerHeight = offsets[3];

      f1x1 = e.touches[0].clientX - offsetLeft;
      f1y1 = e.touches[0].clientY - offsetTop;

      f2x1 = e.touches[1].clientX - offsetLeft;
      f2y1 = e.touches[1].clientY - offsetTop;

      twoFingersStartInside =
           0 <= f1x1 && f1x1 <= containerWidth
        && 0 <= f2x1 && f2x1 <= containerWidth
        && 0 <= f1y1 && f1y1 <= containerHeight
        && 0 <= f2y1 && f2y1 <= containerHeight
      ;

      var pan = cy.pan();
      var zoom = cy.zoom();

      distance1 = distance( f1x1, f1y1, f2x1, f2y1 );
      distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );
      center1 = [ (f1x1 + f2x1)/2, (f1y1 + f2y1)/2 ];
      modelCenter1 = [
        (center1[0] - pan.x) / zoom,
        (center1[1] - pan.y) / zoom
      ];

      // consider context tap
      var cxtDistThreshold = 200;
      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
      if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){

        var near1 = r.findNearestElement(now[0], now[1], true, true);
        var near2 = r.findNearestElement(now[2], now[3], true, true);

        if( near1 && near1.isNode() ){
          near1.activate().trigger( Event(e, {
            type: 'cxttapstart',
            cyPosition: { x: now[0], y: now[1] }
          }) );
          r.touchData.start = near1;

        } else if( near2 && near2.isNode() ){
          near2.activate().trigger( Event(e, {
            type: 'cxttapstart',
            cyPosition: { x: now[0], y: now[1] }
          }) );
          r.touchData.start = near2;

        } else {
          cy.trigger( Event(e, {
            type: 'cxttapstart',
            cyPosition: { x: now[0], y: now[1] }
          }) );
          r.touchData.start = null;
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxt = true;
        r.touchData.cxtDragged = false;
        r.data.bgActivePosistion = undefined;

        r.redraw();
        return;

      }

    }

    if (e.touches[2]) {

    } else if (e.touches[1]) {

    } else if (e.touches[0]) {
      var near = r.findNearestElement(now[0], now[1], true, true);

      if (near != null) {
        near.activate();

        r.touchData.start = near;

        if( near.isNode() && r.nodeIsDraggable(near) ){

          var draggedEles = r.dragData.touchDragEles = [];

          r.redrawHint('eles', true);
          r.redrawHint('drag', true);

          if( near.selected() ){
            // reset drag elements, since near will be added again

            var selectedNodes = cy.$(function(){
              return this.isNode() && this.selected();
            });

            for( var k = 0; k < selectedNodes.length; k++ ){
              var selectedNode = selectedNodes[k];

              if( r.nodeIsDraggable(selectedNode) ){
                addNodeToDrag( selectedNode, { addToList: draggedEles } );
              }
            }
          } else {
            addNodeToDrag( near, { addToList: draggedEles } );
          }

          near.trigger( Event(e, {
            type: 'grab',
            cyPosition: { x: now[0], y: now[1] }
          }) );
        }
      }

      triggerEvents( near, ['touchstart', 'tapstart', 'vmousedown'], e, {
        cyPosition: { x: now[0], y: now[1] }
      } );

      if (near == null) {
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint('select', true);
        r.redraw();
      }


      // Tap, taphold
      // -----

      for (var i=0; i<now.length; i++) {
        earlier[i] = now[i];
        r.touchData.startPosition[i] = now[i];
      }

      r.touchData.singleTouchMoved = false;
      r.touchData.singleTouchStartTime = +new Date();

      clearTimeout( r.touchData.tapholdTimeout );
      r.touchData.tapholdTimeout = setTimeout(function() {
        if(
            r.touchData.singleTouchMoved === false
            && !r.pinching // if pinching, then taphold unselect shouldn't take effect
            && !r.touchData.selecting // box selection shouldn't allow taphold through
        ){
          triggerEvents( r.touchData.start, ['taphold'], e, {
            cyPosition: { x: now[0], y: now[1] }
          } );

          if (!r.touchData.start) {
            cy.$(':selected').unselect();
          }

        }
      }, r.tapholdDuration);
    }

  }, false);

  var touchmoveHandler;
  r.registerBinding(window, 'touchmove', touchmoveHandler = function(e) {

    var select = r.selection;
    var capture = r.touchData.capture;
    var cy = r.cy;
    var now = r.touchData.now; var earlier = r.touchData.earlier;
    var zoom = cy.zoom();

    if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
    if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
    if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

    var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }
    var startPos = r.touchData.startPosition;
    var dx = now[0] - startPos[0];
    var dx2 = dx * dx;
    var dy = now[1] - startPos[1];
    var dy2 = dy * dy;
    var dist2 = dx2 + dy2;
    var rdist2 = dist2 * zoom * zoom;

    // context swipe cancelling
    if( capture && r.touchData.cxt ){
      e.preventDefault();

      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
      var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      var factorSq = distance2Sq / distance1Sq;

      var distThreshold = 150;
      var distThresholdSq = distThreshold * distThreshold;
      var factorThreshold = 1.5;
      var factorThresholdSq = factorThreshold * factorThreshold;

      // cancel ctx gestures if the distance b/t the fingers increases
      if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){
        r.touchData.cxt = false;
        if( r.touchData.start ){ r.touchData.start.unactivate(); r.touchData.start = null; }
        r.data.bgActivePosistion = undefined;
        r.redrawHint('select', true);

        var cxtEvt = Event(e, {
          type: 'cxttapend',
          cyPosition: { x: now[0], y: now[1] }
        });
        if( r.touchData.start ){
          r.touchData.start.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }
      }

    }

    // context swipe
    if( capture && r.touchData.cxt ){
      var cxtEvt = Event(e, {
        type: 'cxtdrag',
        cyPosition: { x: now[0], y: now[1] }
      });
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      if( r.touchData.start ){
        r.touchData.start.trigger( cxtEvt );
      } else {
        cy.trigger( cxtEvt );
      }

      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
      r.touchData.cxtDragged = true;

      var near = r.findNearestElement(now[0], now[1], true, true);

      if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){

        if( r.touchData.cxtOver ){
          r.touchData.cxtOver.trigger( Event(e, {
            type: 'cxtdragout',
            cyPosition: { x: now[0], y: now[1] }
          }) );
        }

        r.touchData.cxtOver = near;

        if( near ){
          near.trigger( Event(e, {
            type: 'cxtdragover',
            cyPosition: { x: now[0], y: now[1] }
          }) );

        }

      }

    // box selection
    } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){
      e.preventDefault();

      r.data.bgActivePosistion = undefined;

      this.lastThreeTouch = +new Date();
      r.touchData.selecting = true;

      r.redrawHint('select', true);

      if( !select || select.length === 0 || select[0] === undefined ){
        select[0] = (now[0] + now[2] + now[4])/3;
        select[1] = (now[1] + now[3] + now[5])/3;
        select[2] = (now[0] + now[2] + now[4])/3 + 1;
        select[3] = (now[1] + now[3] + now[5])/3 + 1;
      } else {
        select[2] = (now[0] + now[2] + now[4])/3;
        select[3] = (now[1] + now[3] + now[5])/3;
      }

      select[4] = 1;
      r.touchData.selecting = true;

      r.redraw();

    // pinch to zoom
    } else if ( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ) { // two fingers => pinch to zoom
      e.preventDefault();

      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      var draggedEles = r.dragData.touchDragEles;
      if( draggedEles ){
        r.redrawHint('drag', true);

        for( var i = 0; i < draggedEles.length; i++ ){
          draggedEles[i]._private.grabbed = false;
          draggedEles[i]._private.rscratch.inDragLayer = false;
        }
      }

      // (x2, y2) for fingers 1 and 2
      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;


      var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
      var factor = distance2 / distance1;

      if( factor != 1 && twoFingersStartInside){
        // delta finger1
        var df1x = f1x2 - f1x1;
        var df1y = f1y2 - f1y1;

        // delta finger 2
        var df2x = f2x2 - f2x1;
        var df2y = f2y2 - f2y1;

        // translation is the normalised vector of the two fingers movement
        // i.e. so pinching cancels out and moving together pans
        var tx = (df1x + df2x)/2;
        var ty = (df1y + df2y)/2;

        // adjust factor by the speed multiplier
        // var speed = 1.5;
        // if( factor > 1 ){
        //   factor = (factor - 1) * speed + 1;
        // } else {
        //   factor = 1 - (1 - factor) * speed;
        // }

        // now calculate the zoom
        var zoom1 = cy.zoom();
        var zoom2 = zoom1 * factor;
        var pan1 = cy.pan();

        // the model center point converted to the current rendered pos
        var ctrx = modelCenter1[0] * zoom1 + pan1.x;
        var ctry = modelCenter1[1] * zoom1 + pan1.y;

        var pan2 = {
          x: -zoom2/zoom1 * (ctrx - pan1.x - tx) + ctrx,
          y: -zoom2/zoom1 * (ctry - pan1.y - ty) + ctry
        };

        // remove dragged eles
        if( r.touchData.start ){
          var draggedEles = r.dragData.touchDragEles;

          if( draggedEles ){ for( var i = 0; i < draggedEles.length; i++ ){
            var dEi_p = draggedEles[i]._private;

            dEi_p.grabbed = false;
            dEi_p.rscratch.inDragLayer = false;
          } }

          var start_p = r.touchData.start._private;
          start_p.active = false;
          start_p.grabbed = false;
          start_p.rscratch.inDragLayer = false;

          r.redrawHint('drag', true);

          r.touchData.start
            .trigger('free')
            .trigger('unactivate')
          ;
        }

        cy.viewport({
          zoom: zoom2,
          pan: pan2,
          cancelOnFailedZoom: true
        });

        distance1 = distance2;
        f1x1 = f1x2;
        f1y1 = f1y2;
        f2x1 = f2x2;
        f2y1 = f2y2;

        r.pinching = true;
      }

      // Re-project
      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

    } else if (e.touches[0]) {
      var start = r.touchData.start;
      var last = r.touchData.last;
      var near = near || r.findNearestElement(now[0], now[1], true, true);

      if( start != null ){
        e.preventDefault();
      }

      // dragging nodes
      if( start != null && start._private.group == 'nodes' && r.nodeIsDraggable(start) ){

        if( rdist2 >= r.touchTapThreshold2 ){ // then dragging can happen
          var draggedEles = r.dragData.touchDragEles;
          var justStartedDrag = !r.dragData.didDrag;

          for( var k = 0; k < draggedEles.length; k++ ){
            var draggedEle = draggedEles[k];

            if( justStartedDrag ){
              addNodeToDrag( draggedEle, { inDragLayer: true } );
            }

            if( r.nodeIsDraggable(draggedEle) && draggedEle.isNode() && draggedEle.grabbed() ){
              r.dragData.didDrag = true;
              var dPos = draggedEle._private.position;
              var updatePos = !draggedEle.isParent();

              if( updatePos && is.number(disp[0]) && is.number(disp[1]) ){
                dPos.x += disp[0];
                dPos.y += disp[1];
              }

              if( justStartedDrag ){
                r.redrawHint('eles', true);

                var dragDelta = r.touchData.dragDelta;

                if( updatePos && is.number(dragDelta[0]) && is.number(dragDelta[1]) ){
                  dPos.x += dragDelta[0];
                  dPos.y += dragDelta[1];
                }

              }
            }
          }

          var tcol = Collection(cy, draggedEles);

          tcol.updateCompoundBounds();
          tcol.trigger('position drag');

          r.hoverData.draggingEles = true;

          r.redrawHint('drag', true);

          if(
               r.touchData.startPosition[0] == earlier[0]
            && r.touchData.startPosition[1] == earlier[1]
          ){

            r.redrawHint('eles', true);
          }

          r.redraw();
        } else { // otherise keep track of drag delta for later
          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

          if( dragDelta.length === 0 ){
            dragDelta.push( disp[0] );
            dragDelta.push( disp[1] );
          } else {
            dragDelta[0] += disp[0];
            dragDelta[1] += disp[1];
          }
        }
      }

      // touchmove
      {
        triggerEvents( (start || near), ['touchmove', 'tapdrag', 'vmousemove'], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );

        if (near != last) {
          if (last) { last.trigger(Event(e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } })); }
          if (near) { near.trigger(Event(e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } })); }
        }

        r.touchData.last = near;
      }

      // check to cancel taphold
      for (var i=0;i<now.length;i++) {
        if( now[i]
          && r.touchData.startPosition[i]
          && rdist2 > r.touchTapThreshold2 ){

          r.touchData.singleTouchMoved = true;
        }
      }

      // panning
      if(
          capture
          && ( start == null || start.isEdge() )
          && cy.panningEnabled() && cy.userPanningEnabled()
      ){

        e.preventDefault();

        if( r.swipePanning ){
          cy.panBy({
            x: disp[0] * zoom,
            y: disp[1] * zoom
          });

        } else if( rdist2 >= r.touchTapThreshold2 ){
          r.swipePanning = true;

          cy.panBy({
            x: dx * zoom,
            y: dy * zoom
          });

          if( start ){
            start.unactivate();

            if( !r.data.bgActivePosistion ){
              r.data.bgActivePosistion = {
                x: now[0],
                y: now[1]
              };
            }

            r.redrawHint('select', true);

            r.touchData.start = null;
          }
        }

        // Re-project
        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
        now[0] = pos[0]; now[1] = pos[1];
      }
    }

    for (var j=0; j<now.length; j++) { earlier[j] = now[j]; }
    //r.redraw();

  }, false);

  var touchcancelHandler;
  r.registerBinding(window, 'touchcancel', touchcancelHandler = function(e) {
    var start = r.touchData.start;

    r.touchData.capture = false;

    if( start ){
      start.unactivate();
    }
  });

  var touchendHandler;
  r.registerBinding(window, 'touchend', touchendHandler = function(e) {
    var start = r.touchData.start;

    var capture = r.touchData.capture;

    if( capture ){
      r.touchData.capture = false;

      e.preventDefault();
    } else {
      return;
    }

    var select = r.selection;

    r.swipePanning = false;
    r.hoverData.draggingEles = false;

    var cy = r.cy;
    var zoom = cy.zoom();
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
    if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
    if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

    if( start ){
      start.unactivate();
    }

    var ctxTapend;
    if( r.touchData.cxt ){
      ctxTapend = Event(e, {
        type: 'cxttapend',
        cyPosition: { x: now[0], y: now[1] }
      });

      if( start ){
        start.trigger( ctxTapend );
      } else {
        cy.trigger( ctxTapend );
      }

      if( !r.touchData.cxtDragged ){
        var ctxTap = Event(e, {
          type: 'cxttap',
          cyPosition: { x: now[0], y: now[1] }
        });

        if( start ){
          start.trigger( ctxTap );
        } else {
          cy.trigger( ctxTap );
        }

      }

      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
      r.touchData.cxt = false;
      r.touchData.start = null;

      r.redraw();
      return;
    }

    // no more box selection if we don't have three fingers
    if( !e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting ){
      r.touchData.selecting = false;

      var newlySelected = [];
      var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

      select[0] = undefined;
      select[1] = undefined;
      select[2] = undefined;
      select[3] = undefined;
      select[4] = 0;

      r.redrawHint('select', true);

      for( var i = 0; i< box.length; i++ ) {
        if( box[i]._private.selectable ){
          newlySelected.push( box[i] );
        }
      }

      var newlySelCol = Collection( cy, newlySelected );

      newlySelCol.select();

      if( newlySelCol.length > 0 ) {
        r.redrawHint('eles', true);
      } else {
        r.redraw();
      }
    }

    var updateStartStyle = false;

    if( start != null ){
      start._private.active = false;
      updateStartStyle = true;
      start.unactivate();
    }

    if (e.touches[2]) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
    } else if (e.touches[1]) {

    } else if (e.touches[0]) {

    // Last touch released
    } else if (!e.touches[0]) {

      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      var draggedEles = r.dragData.touchDragEles;

      if (start != null ) {

        var startWasGrabbed = start._private.grabbed;

        freeDraggedElements( draggedEles );

        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        if( startWasGrabbed ){
          start.trigger('free');
        }

        triggerEvents( start, ['touchend', 'tapend', 'vmouseup'], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );

        start.unactivate();

        r.touchData.start = null;

      } else {
        var near = r.findNearestElement(now[0], now[1], true, true);

        triggerEvents( near, ['touchend', 'tapend', 'vmouseup'], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );

      }

      var dx = r.touchData.startPosition[0] - now[0];
      var dx2 = dx * dx;
      var dy = r.touchData.startPosition[1] - now[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
      if (start != null
          && !r.dragData.didDrag // didn't drag nodes around
          && start._private.selectable
          && rdist2 < r.touchTapThreshold2
          && !r.pinching // pinch to zoom should not affect selection
      ) {

        if( cy.selectionType() === 'single' ){
          cy.$(':selected').unmerge( start ).unselect();
          start.select();
        } else {
          if( start.selected() ){
            start.unselect();
          } else {
            start.select();
          }
        }

        updateStartStyle = true;


        r.redrawHint('eles', true);
      }

      // Tap event, roughly same as mouse click event for touch
      if( !r.touchData.singleTouchMoved ){
        triggerEvents( start, ['tap', 'vclick'], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );
      }

      r.touchData.singleTouchMoved = true;
    }

    for( var j = 0; j < now.length; j++ ){ earlier[j] = now[j]; }

    r.dragData.didDrag = false; // reset for next mousedown

    if( e.touches.length === 0 ){
      r.touchData.dragDelta = [];
    }

    if( updateStartStyle && start ){
      start.updateStyle(false);
    }

    if( e.touches.length < 2 ){
      r.pinching = false;
      r.redrawHint('eles', true);
      r.redraw();
    }

    //r.redraw();

  }, false);

  // fallback compatibility layer for ms pointer events
  if( typeof TouchEvent === 'undefined' ){

    var pointers = [];

    var makeTouch = function( e ){
      return {
        clientX: e.clientX,
        clientY: e.clientY,
        force: 1,
        identifier: e.pointerId,
        pageX: e.pageX,
        pageY: e.pageY,
        radiusX: e.width/2,
        radiusY: e.height/2,
        screenX: e.screenX,
        screenY: e.screenY,
        target: e.target
      };
    };

    var makePointer = function( e ){
      return {
        event: e,
        touch: makeTouch(e)
      };
    };

    var addPointer = function( e ){
      pointers.push( makePointer(e) );
    };

    var removePointer = function( e ){
      for( var i = 0; i < pointers.length; i++ ){
        var p = pointers[i];

        if( p.event.pointerId === e.pointerId ){
          pointers.splice( i, 1 );
          return;
        }
      }
    };

    var updatePointer = function( e ){
      var p = pointers.filter(function( p ){
        return p.event.pointerId === e.pointerId;
      })[0];

      p.event = e;
      p.touch = makeTouch(e);
    };

    var addTouchesToEvent = function( e ){
      e.touches = pointers.map(function( p ){
        return p.touch;
      });
    };

    var pointerIsMouse = function( e ){
      return e.pointerType === 'mouse' || e.pointerType === 4;
    };

    r.registerBinding(r.container, 'pointerdown', function(e){
      if( pointerIsMouse(e) ){ return; } // mouse already handled

      e.preventDefault();

      addPointer( e );

      addTouchesToEvent( e );
      touchstartHandler( e );
    });

    r.registerBinding(r.container, 'pointerup', function(e){
      if( pointerIsMouse(e) ){ return; } // mouse already handled

      removePointer( e );

      addTouchesToEvent( e );
      touchendHandler( e );
    });

    r.registerBinding(r.container, 'pointercancel', function(e){
      if( pointerIsMouse(e) ){ return; } // mouse already handled

      removePointer( e );

      addTouchesToEvent( e );
      touchcancelHandler( e );
    });

    r.registerBinding(r.container, 'pointermove', function(e){
      if( pointerIsMouse(e) ){ return; } // mouse already handled

      e.preventDefault();

      updatePointer( e );

      addTouchesToEvent( e );
      touchmoveHandler( e );
    });

  }
};

module.exports = BRp;

},{"../../../collection":23,"../../../event":42,"../../../is":77,"../../../util":94}],60:[function(_dereq_,module,exports){
'use strict';

var math = _dereq_('../../../math');

var BRp = {};

BRp.registerNodeShapes = function(){
  var nodeShapes = this.nodeShapes = {};
  var renderer = this;

  nodeShapes['ellipse'] = {
    name: 'ellipse',

    draw: function( context, centerX, centerY, width, height ){
      renderer.nodeShapeImpl( this.name )( context, centerX, centerY, width, height );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.intersectLineEllipse(
        x, y,
        nodeX,
        nodeY,
        width / 2 + padding,
        height / 2 + padding)
      ;
    },

    checkPoint: function( x, y, padding, width, height, centerX, centerY ){
      x -= centerX;
      y -= centerY;

      x /= (width / 2 + padding);
      y /= (height / 2 + padding);

      return x*x + y*y <= 1;
    }
  };

  function generatePolygon( name, points ){
    return ( nodeShapes[name] = {
      name: name,

      points: points,

      draw: function( context, centerX, centerY, width, height ){
        renderer.nodeShapeImpl('polygon')( context, centerX, centerY, width, height, this.points );
      },

      intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
        return math.polygonIntersectLine(
            x, y,
            this.points,
            nodeX,
            nodeY,
            width / 2, height / 2,
            padding)
          ;
      },

      checkPoint: function( x, y, padding, width, height, centerX, centerY ){
        return math.pointInsidePolygon(x, y, nodeShapes[name].points,
          centerX, centerY, width, height, [0, -1], padding)
        ;
      }
    } );
  }

  generatePolygon( 'triangle', math.generateUnitNgonPointsFitToSquare(3, 0) );

  generatePolygon( 'square', math.generateUnitNgonPointsFitToSquare(4, 0) );
  nodeShapes['rectangle'] = nodeShapes['square'];

  nodeShapes['roundrectangle'] = {
    name: 'roundrectangle',

    points: math.generateUnitNgonPointsFitToSquare(4, 0),

    draw: function( context, centerX, centerY, width, height ){
      renderer.nodeShapeImpl( this.name )( context, centerX, centerY, width, height );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.roundRectangleIntersectLine(
        x, y,
        nodeX,
        nodeY,
        width, height,
        padding)
      ;
    },

    // Looks like the width passed into this function is actually the total width / 2
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY ){

      var cornerRadius = math.getRoundRectangleRadius(width, height);

      // Check hBox
      if (math.pointInsidePolygon(x, y, this.points,
        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding) ){
        return true;
      }

      // Check vBox
      if (math.pointInsidePolygon(x, y, this.points,
        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding) ){
        return true;
      }

      var checkInEllipse = function( x, y, centerX, centerY, width, height, padding ){
        x -= centerX;
        y -= centerY;

        x /= (width / 2 + padding);
        y /= (height / 2 + padding);

        return (x*x + y*y <= 1);
      };


      // Check top left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding) ){

        return true;
      }

      // Check top right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding) ){

        return true;
      }

      // Check bottom right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding) ){

        return true;
      }

      // Check bottom left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding) ){

        return true;
      }

      return false;
    }
  };

  generatePolygon( 'diamond', [
    0, 1,
    1, 0,
    0, -1,
    -1, 0
  ] );

  generatePolygon( 'pentagon', math.generateUnitNgonPointsFitToSquare(5, 0) );

  generatePolygon( 'hexagon', math.generateUnitNgonPointsFitToSquare(6, 0) );

  generatePolygon( 'heptagon', math.generateUnitNgonPointsFitToSquare(7, 0) );

  generatePolygon( 'octagon', math.generateUnitNgonPointsFitToSquare(8, 0) );

  var star5Points = new Array(20);
  {
    var outerPoints = math.generateUnitNgonPoints(5, 0);
    var innerPoints = math.generateUnitNgonPoints(5, Math.PI / 5);

    // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;

    for (var i=0;i<innerPoints.length/2;i++ ){
      innerPoints[i*2] *= innerRadius;
      innerPoints[i*2+1] *= innerRadius;
    }

    for (var i=0;i<20/4;i++ ){
      star5Points[i*4] = outerPoints[i*2];
      star5Points[i*4+1] = outerPoints[i*2+1];

      star5Points[i*4+2] = innerPoints[i*2];
      star5Points[i*4+3] = innerPoints[i*2+1];
    }
  }

  star5Points = math.fitPolygonToSquare( star5Points );

  generatePolygon( 'star', star5Points );

  generatePolygon( 'vee', [
    -1, -1,
    0, -0.333,
    1, -1,
    0, 1
  ] );

  generatePolygon( 'rhomboid', [
    -1, -1,
    0.333, -1,
    1, 1,
    -0.333, 1
  ] );

  nodeShapes.makePolygon = function( points ){

    // use caching on user-specified polygons so they are as fast as native shapes

    var key = points.join('$');
    var name = 'polygon-' + key;
    var shape;

    if( (shape = nodeShapes[name]) ){ // got cached shape
      return shape;
    }

    // create and cache new shape
    return generatePolygon( name, points );
  };

};

module.exports = BRp;

},{"../../../math":79}],61:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../../util');

var BRp = {};

BRp.timeToRender = function(){
  return this.redrawTotalTime / this.redrawCount;
};

var minRedrawLimit = 1000/60; // people can't see much better than 60fps
var maxRedrawLimit = 1000;  // don't cap max b/c it's more important to be responsive than smooth

BRp.redraw = function( options ){
  options = options || util.staticEmptyObject();

  var r = this;
  var forcedContext = options.forcedContext;

  if( r.averageRedrawTime === undefined ){ r.averageRedrawTime = 0; }
  if( r.lastRedrawTime === undefined ){ r.lastRedrawTime = 0; }

  var redrawLimit = r.lastRedrawTime; // estimate the ideal redraw limit based on how fast we can draw
  redrawLimit = minRedrawLimit > redrawLimit ? minRedrawLimit : redrawLimit;
  redrawLimit = redrawLimit < maxRedrawLimit ? redrawLimit : maxRedrawLimit;

  if( r.lastDrawTime === undefined ){ r.lastDrawTime = 0; }

  var nowTime = Date.now();
  var timeElapsed = nowTime - r.lastDrawTime;
  var callAfterLimit = timeElapsed >= redrawLimit;

  if( !forcedContext ){
    if( !callAfterLimit || r.currentlyDrawing ){
      r.skipFrame = true;
      return;
    }
  }

  r.requestedFrame = true;
  r.currentlyDrawing = true;
  r.renderOptions = options;
};

BRp.startRenderLoop = function(){
  var r = this;

  var renderFn = function(){
    if( r.destroyed ){ return; }

    if( r.requestedFrame && !r.skipFrame ){
      var startTime = util.performanceNow();

      r.render( r.renderOptions );

      var endTime = r.lastRedrawTime = util.performanceNow();

      if( r.averageRedrawTime === undefined ){
        r.averageRedrawTime = endTime - startTime;
      }

      if( r.redrawCount === undefined ){
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if( r.redrawTotalTime === undefined ){
        r.redrawTotalTime = 0;
      }

      var duration = endTime - startTime;

      r.redrawTotalTime += duration;
      r.lastRedrawTime = duration;

      // use a weighted average with a bias from the previous average so we don't spike so easily
      r.averageRedrawTime = r.averageRedrawTime/2 + duration/2;

      r.requestedFrame = false;
    }

    r.skipFrame = false;

    util.requestAnimationFrame( renderFn );
  };

  util.requestAnimationFrame( renderFn );

};

module.exports = BRp;

},{"../../../util":94}],62:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

var impl;

CRp.arrowShapeImpl = function( name ){
  return ( impl || (impl = {
    'polygon': function( context, points ){
      for( var i = 0; i < points.length; i++ ){
        var pt = points[i];

        context.lineTo( pt.x, pt.y );
      }
    },

    'triangle-backcurve': function( context, points, controlPoint ){
      var firstPt;

      for( var i = 0; i < points.length; i++ ){
        var pt = points[i];

        if( i === 0 ){
          firstPt = pt;
        }

        context.lineTo( pt.x, pt.y );
      }

      context.quadraticCurveTo( controlPoint.x, controlPoint.y, firstPt.x, firstPt.y );
    },

    'triangle-tee': function( context, trianglePoints, teePoints ){
      var triPts = trianglePoints;
      for( var i = 0; i < triPts.length; i++ ){
        var pt = triPts[i];

        context.lineTo( pt.x, pt.y );
      }

      var teePts = teePoints;
      var firstTeePt = teePoints[0];
      context.moveTo( firstTeePt.x, firstTeePt.y );

      for( var i = 0; i < teePts.length; i++ ){
        var pt = teePts[i];

        context.lineTo( pt.x, pt.y );
      }
    },

    'circle': function( context, rx, ry, r ){
      context.arc(rx, ry, r, 0, Math.PI * 2, false);
    }
  }) )[ name ];
};

module.exports = CRp;

},{}],63:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

CRp.drawEdge = function(context, edge, drawOverlayInstead) {
  var rs = edge._private.rscratch;
  var usePaths = this.usePaths();

  // if bezier ctrl pts can not be calculated, then die
  if( rs.badBezier || rs.badLine || isNaN( rs.allpts[0] ) ){ // iNaN in case edge is impossible and browser bugs (e.g. safari)
    return;
  }

  var style = edge._private.style;

  // Edge line width
  if (style['width'].pfValue <= 0) {
    return;
  }

  var overlayPadding = style['overlay-padding'].pfValue;
  var overlayOpacity = style['overlay-opacity'].value;
  var overlayColor = style['overlay-color'].value;

  // Edge color & opacity
  if( drawOverlayInstead ){

    if( overlayOpacity === 0 ){ // exit early if no overlay
      return;
    }

    this.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
    context.lineCap = 'round';

    if( rs.edgeType == 'self' && !usePaths ){
      context.lineCap = 'butt';
    }

  } else {
    var lineColor = style['line-color'].value;

    this.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], style.opacity.value);

    context.lineCap = 'butt';
  }

  var edgeWidth = style['width'].pfValue + (drawOverlayInstead ? 2 * overlayPadding : 0);
  var lineStyle = drawOverlayInstead ? 'solid' : style['line-style'].value;
  context.lineWidth = edgeWidth;

  var shadowBlur = style['shadow-blur'].pfValue;
  var shadowOpacity = style['shadow-opacity'].value;
  var shadowColor = style['shadow-color'].value;
  var shadowOffsetX = style['shadow-offset-x'].pfValue;
  var shadowOffsetY = style['shadow-offset-y'].pfValue;

  this.shadowStyle(context,  shadowColor, drawOverlayInstead ? 0 : shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);

  this.drawEdgePath(
    edge,
    context,
    rs.allpts,
    lineStyle,
    edgeWidth
  );

  this.drawArrowheads(context, edge, drawOverlayInstead);

  this.shadowStyle(context, 'transparent', 0); // reset for next guy

};


CRp.drawEdgePath = function(edge, context, pts, type, width) {
  var rs = edge._private.rscratch;
  var canvasCxt = context;
  var path;
  var pathCacheHit = false;
  var usePaths = this.usePaths();

  if( usePaths ){
    var pathCacheKey = pts.join('$');
    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

    if( keyMatches ){
      path = context = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = context = new Path2D();
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if( canvasCxt.setLineDash ){ // for very outofdate browsers
    switch( type ){
      case 'dotted':
        canvasCxt.setLineDash([ 1, 1 ]);
        break;

      case 'dashed':
        canvasCxt.setLineDash([ 6, 3 ]);
        break;

      case 'solid':
        canvasCxt.setLineDash([ ]);
        break;
    }
  }

  if( !pathCacheHit ){
    if( context.beginPath ){ context.beginPath(); }
    context.moveTo( pts[0], pts[1] );

    switch( rs.edgeType ){
      case 'bezier':
      case 'self':
      case 'compound':
      case 'multibezier':
        if( !rs.badBezier ){
          for( var i = 2; i + 3 < pts.length; i += 4 ){
            context.quadraticCurveTo( pts[i], pts[i+1], pts[i+2], pts[i+3] );
          }
        }
        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        if( !rs.badLine ){
          for( var i = 2; i + 1 < pts.length; i += 2 ){
            context.lineTo( pts[i], pts[i+1] );
          }
        }
        break;
    }
  }

  context = canvasCxt;
  if( usePaths ){
    context.stroke( path );
  } else {
    context.stroke();
  }

  // reset any line dashes
  if( context.setLineDash ){ // for very outofdate browsers
    context.setLineDash([ ]);
  }

};

CRp.drawArrowheads = function(context, edge, drawOverlayInstead) {
  if( drawOverlayInstead ){ return; } // don't do anything for overlays

  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';

  if( !isHaystack ){
    this.drawArrowhead( context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle );
  }

  this.drawArrowhead( context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle );

  this.drawArrowhead( context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle );

  if( !isHaystack ){
    this.drawArrowhead( context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle );
  }
};

CRp.drawArrowhead = function( context, edge, prefix, x, y, angle ){
  if( isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null ){ return; }

  var self = this;
  var style = edge._private.style;
  var arrowShape = style[prefix + '-arrow-shape'].value;

  if( arrowShape === 'none' ){
    return;
  }

  var gco = context.globalCompositeOperation;

  var arrowClearFill = style[prefix + '-arrow-fill'].value === 'hollow' ? 'both' : 'filled';
  var arrowFill = style[prefix + '-arrow-fill'].value;

  if( arrowShape === 'half-triangle-overshot' ){
    arrowFill = 'hollow';
    arrowClearFill = 'hollow';
  }

  if( style.opacity.value !== 1 || arrowFill === 'hollow' ){ // then extra clear is needed
    context.globalCompositeOperation = 'destination-out';

    self.fillStyle(context, 255, 255, 255, 1);
    self.strokeStyle(context, 255, 255, 255, 1);

    self.drawArrowShape( edge, prefix, context,
      arrowClearFill, style['width'].pfValue, style[prefix + '-arrow-shape'].value,
      x, y, angle
    );

    context.globalCompositeOperation = gco;
  } // otherwise, the opaque arrow clears it for free :)

  var color = style[prefix + '-arrow-color'].value;
  self.fillStyle(context, color[0], color[1], color[2], style.opacity.value);
  self.strokeStyle(context, color[0], color[1], color[2], style.opacity.value);

  self.drawArrowShape( edge, prefix, context,
    arrowFill, style['width'].pfValue, style[prefix + '-arrow-shape'].value,
    x, y, angle
  );
};

CRp.drawArrowShape = function(edge, arrowType, context, fill, edgeWidth, shape, x, y, angle) {
  var r = this;
  var usePaths = this.usePaths();
  var rs = edge._private.rscratch;
  var pathCacheHit = false;
  var path;
  var canvasContext = context;
  var translation = { x: x, y: y };
  var size = this.getArrowWidth( edgeWidth );
  var shapeImpl = r.arrowShapes[shape];

  if( usePaths ){
    var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
    rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
    rs.arrowPathCache = rs.arrowPathCache || {};

    var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;
    if( alreadyCached ){
      path = context = rs.arrowPathCache[arrowType];
      pathCacheHit = true;
    } else {
      path = context = new Path2D();
      rs.arrowPathCacheKey[arrowType] = pathCacheKey;
      rs.arrowPathCache[arrowType] = path;
    }
  }

  if( context.beginPath ){ context.beginPath(); }

  if( !pathCacheHit ){
    shapeImpl.draw(context, size, angle, translation);
  }

  if( !shapeImpl.leavePathOpen && context.closePath ){
    context.closePath();
  }

  context = canvasContext;

  if( fill === 'filled' || fill === 'both' ){
    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }
  }

  if( fill === 'hollow' || fill === 'both' ){
    context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );
    context.lineJoin = 'miter';

    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }

  }
};

module.exports = CRp;

},{}],64:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

CRp.safeDrawImage = function( context, img, ix, iy, iw, ih, x, y, w, h ){
  var r = this;

  try {
    context.drawImage( img, ix, iy, iw, ih, x, y, w, h );
  } catch(e){
    r.data.canvasNeedsRedraw[r.NODE] = true;
    r.data.canvasNeedsRedraw[r.DRAG] = true;

    r.drawingImage = true;

    r.redraw();
  }
};

CRp.drawInscribedImage = function(context, img, node) {
  var r = this;
  var nodeX = node._private.position.x;
  var nodeY = node._private.position.y;
  var style = node._private.style;
  var fit = style['background-fit'].value;
  var xPos = style['background-position-x'];
  var yPos = style['background-position-y'];
  var repeat = style['background-repeat'].value;
  var nodeW = node.width();
  var nodeH = node.height();
  var rs = node._private.rscratch;
  var clip = style['background-clip'].value;
  var shouldClip = clip === 'node';
  var imgOpacity = style['background-image-opacity'].value;

  var imgW = img.width || img.cachedW;
  var imgH = img.height || img.cachedH;

  // workaround for broken browsers like ie
  if( null == imgW || null == imgH ){
    document.body.appendChild( img );

    imgW = img.cachedW = img.width || img.offsetWidth;
    imgH = img.cachedH = img.height || img.offsetHeight;

    document.body.removeChild( img );
  }

  var w = imgW;
  var h = imgH;

  var bgW = style['background-width'];
  if( bgW.value !== 'auto' ){
    if( bgW.units === '%' ){
      w = bgW.value/100 * nodeW;
    } else {
      w = bgW.pfValue;
    }
  }

  var bgH = style['background-height'];
  if( bgH.value !== 'auto' ){
    if( bgH.units === '%' ){
      h = bgH.value/100 * nodeH;
    } else {
      h = bgH.pfValue;
    }
  }

  if( w === 0 || h === 0 ){
    return; // no point in drawing empty image (and chrome is broken in this case)
  }

  if( fit === 'contain' ){
    var scale = Math.min( nodeW/w, nodeH/h );

    w *= scale;
    h *= scale;

  } else if( fit === 'cover' ){
    var scale = Math.max( nodeW/w, nodeH/h );

    w *= scale;
    h *= scale;
  }

  var x = (nodeX - nodeW/2); // left
  if( xPos.units === '%' ){
    x += (nodeW - w) * xPos.value/100;
  } else {
    x += xPos.pfValue;
  }

  var y = (nodeY - nodeH/2); // top
  if( yPos.units === '%' ){
    y += (nodeH - h) * yPos.value/100;
  } else {
    y += yPos.pfValue;
  }

  if( rs.pathCache ){
    x -= nodeX;
    y -= nodeY;

    nodeX = 0;
    nodeY = 0;
  }

  var gAlpha = context.globalAlpha;

  context.globalAlpha = imgOpacity;

  if( repeat === 'no-repeat' ){

    if( shouldClip ){
      context.save();

      if( rs.pathCache ){
        context.clip( rs.pathCache );
      } else {
        r.nodeShapes[r.getNodeShape(node)].draw(
          context,
          nodeX, nodeY,
          nodeW, nodeH);

        context.clip();
      }
    }

    r.safeDrawImage( context, img, 0, 0, imgW, imgH, x, y, w, h );

    if( shouldClip ){
      context.restore();
    }
  } else {
    var pattern = context.createPattern( img, repeat );
    context.fillStyle = pattern;

    r.nodeShapes[r.getNodeShape(node)].draw(
        context,
        nodeX, nodeY,
        nodeW, nodeH);

      context.translate(x, y);
      context.fill();
      context.translate(-x, -y);
  }

  context.globalAlpha = gAlpha;

};

module.exports = CRp;

},{}],65:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../../is');

var CRp = {};

// Draw edge text
CRp.drawEdgeText = function(context, edge) {
  var text = edge._private.style['label'].strValue;

  if( !text || text.match(/^\s+$/) ){
    return;
  }

  if( this.hideEdgesOnViewport && (this.dragData.didDrag || this.pinching || this.hoverData.dragging || this.data.wheel || this.swipePanning) ){ return; } // save cycles on pinching

  var computedSize = edge._private.style['font-size'].pfValue * edge.cy().zoom();
  var minSize = edge._private.style['min-zoomed-font-size'].pfValue;

  if( computedSize < minSize ){
    return;
  }

  // Calculate text draw position

  context.textAlign = 'center';
  context.textBaseline = 'middle';

  var rs = edge._private.rscratch;
  if( !is.number( rs.labelX ) || !is.number( rs.labelY ) ){ return; } // no pos => label can't be rendered

  var style = edge._private.style;
  var autorotate = style['edge-text-rotation'].strValue === 'autorotate';
  var theta;

  if( autorotate ){
    theta = rs.labelAngle;

    context.translate(rs.labelX, rs.labelY);
    context.rotate(theta);

    this.drawText(context, edge, 0, 0);

    context.rotate(-theta);
    context.translate(-rs.labelX, -rs.labelY);
  } else {
    this.drawText(context, edge, rs.labelX, rs.labelY);
  }

};

// Draw node text
CRp.drawNodeText = function(context, node) {
  var text = node._private.style['label'].strValue;

  if ( !text || text.match(/^\s+$/) ) {
    return;
  }

  var computedSize = node._private.style['font-size'].pfValue * node.cy().zoom();
  var minSize = node._private.style['min-zoomed-font-size'].pfValue;

  if( computedSize < minSize ){
    return;
  }

  // this.recalculateNodeLabelProjection( node );

  var textHalign = node._private.style['text-halign'].strValue;
  var textValign = node._private.style['text-valign'].strValue;
  var rs = node._private.rscratch;
  if( !is.number( rs.labelX ) || !is.number( rs.labelY ) ){ return; } // no pos => label can't be rendered

  switch( textHalign ){
    case 'left':
      context.textAlign = 'right';
      break;

    case 'right':
      context.textAlign = 'left';
      break;

    default: // e.g. center
      context.textAlign = 'center';
  }

  switch( textValign ){
    case 'top':
      context.textBaseline = 'bottom';
      break;

    case 'bottom':
      context.textBaseline = 'top';
      break;

    default: // e.g. center
      context.textBaseline = 'middle';
  }

  this.drawText(context, node, rs.labelX, rs.labelY);
};

CRp.getFontCache = function(context){
  var cache;

  this.fontCaches = this.fontCaches || [];

  for( var i = 0; i < this.fontCaches.length; i++ ){
    cache = this.fontCaches[i];

    if( cache.context === context ){
      return cache;
    }
  }

  cache = {
    context: context
  };
  this.fontCaches.push(cache);

  return cache;
};

// set up canvas context with font
// returns transformed text string
CRp.setupTextStyle = function( context, element ){
  // Font style
  var parentOpacity = element.effectiveOpacity();
  var style = element._private.style;
  var labelStyle = style['font-style'].strValue;
  var labelSize = style['font-size'].pfValue + 'px';
  var labelFamily = style['font-family'].strValue;
  var labelWeight = style['font-weight'].strValue;
  var opacity = style['text-opacity'].value * style['opacity'].value * parentOpacity;
  var outlineOpacity = style['text-outline-opacity'].value * opacity;
  var color = style['color'].value;
  var outlineColor = style['text-outline-color'].value;
  var shadowBlur = style['text-shadow-blur'].pfValue;
  var shadowOpacity = style['text-shadow-opacity'].value;
  var shadowColor = style['text-shadow-color'].value;
  var shadowOffsetX = style['text-shadow-offset-x'].pfValue;
  var shadowOffsetY = style['text-shadow-offset-y'].pfValue;

  var fontCacheKey = element._private.fontKey;
  var cache = this.getFontCache(context);

  if( cache.key !== fontCacheKey ){
    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

    cache.key = fontCacheKey;
  }

  var text = this.getLabelText( element );

  // Calculate text draw position based on text alignment

  // so text outlines aren't jagged
  context.lineJoin = 'round';

  this.fillStyle(context, color[0], color[1], color[2], opacity);

  this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);

  this.shadowStyle(context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);

  return text;
};

function roundRect(ctx, x, y, width, height, radius) {
  var radius = radius || 5;
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  ctx.fill();
}

// Draw text
CRp.drawText = function(context, element, textX, textY) {
  var _p = element._private;
  var style = _p.style;
  var rstyle = _p.rstyle;
  var rscratch = _p.rscratch;
  var parentOpacity = element.effectiveOpacity();
  if( parentOpacity === 0 || style['text-opacity'].value === 0){ return; }

  var text = this.setupTextStyle( context, element );
  var halign = style['text-halign'].value;
  var valign = style['text-valign'].value;

  if( element.isEdge() ){
    halign = 'center';
    valign = 'center';
  }

  if( element.isNode() ){
    var pLeft = style['padding-left'].pfValue;
    var pRight = style['padding-right'].pfValue;
    var pTop = style['padding-top'].pfValue;
    var pBottom = style['padding-bottom'].pfValue;

    textX += pLeft/2;
    textX -= pRight/2;

    textY += pTop/2;
    textY -= pBottom/2;
  }

  if ( text != null && !isNaN(textX) && !isNaN(textY)) {
    var backgroundOpacity = style['text-background-opacity'].value;
    var borderOpacity = style['text-border-opacity'].value;
    var textBorderWidth = style['text-border-width'].pfValue;

    if( backgroundOpacity > 0 || (textBorderWidth > 0 && borderOpacity > 0) ){
      var margin = 4 + textBorderWidth/2;

      if (element.isNode()) {
        //Move textX, textY to include the background margins
        if (valign === 'top') {
          textY -= margin;
        } else if (valign === 'bottom') {
          textY += margin;
        }
        if (halign === 'left') {
          textX -= margin;
        } else if (halign === 'right') {
          textX += margin;
        }
      }

      var bgWidth = rstyle.labelWidth;
      var bgHeight = rstyle.labelHeight;
      var bgX = textX;

      if (halign) {
        if (halign == 'center') {
          bgX = bgX - bgWidth / 2;
        } else if (halign == 'left') {
          bgX = bgX- bgWidth;
        }
      }

      var bgY = textY;

      if (element.isNode()) {
        if (valign == 'top') {
           bgY = bgY - bgHeight;
        } else if (valign == 'center') {
          bgY = bgY- bgHeight / 2;
        }
      } else {
        bgY = bgY - bgHeight / 2;
      }

      if (style['edge-text-rotation'].strValue === 'autorotate') {
        textY = 0;
        bgWidth += 4;
        bgX = textX - bgWidth / 2;
        bgY = textY - bgHeight / 2;
      } else {
        // Adjust with border width & margin
        bgX -= margin;
        bgY -= margin;
        bgHeight += margin*2;
        bgWidth += margin*2;
      }

      if( backgroundOpacity > 0 ){
        var textFill = context.fillStyle;
        var textBackgroundColor = style['text-background-color'].value;

        context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
        var styleShape = style['text-background-shape'].strValue;
        if (styleShape == 'roundrectangle') {
          roundRect(context, bgX, bgY, bgWidth, bgHeight, 2);
        } else {
          context.fillRect(bgX,bgY,bgWidth,bgHeight);
        }
        context.fillStyle = textFill;
      }

      if( textBorderWidth > 0 && borderOpacity > 0 ){
        var textStroke = context.strokeStyle;
        var textLineWidth = context.lineWidth;
        var textBorderColor = style['text-border-color'].value;
        var textBorderStyle = style['text-border-style'].value;

        context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
        context.lineWidth = textBorderWidth;

        if( context.setLineDash ){ // for very outofdate browsers
          switch( textBorderStyle ){
            case 'dotted':
              context.setLineDash([ 1, 1 ]);
              break;
            case 'dashed':
              context.setLineDash([ 4, 2 ]);
              break;
            case 'double':
              context.lineWidth = textBorderWidth/4; // 50% reserved for white between the two borders
              context.setLineDash([ ]);
              break;
            case 'solid':
              context.setLineDash([ ]);
              break;
          }
        }

        context.strokeRect(bgX,bgY,bgWidth,bgHeight);

        if( textBorderStyle === 'double' ){
          var whiteWidth = textBorderWidth/2;

          context.strokeRect(bgX+whiteWidth,bgY+whiteWidth,bgWidth-whiteWidth*2,bgHeight-whiteWidth*2);
        }

        if( context.setLineDash ){ // for very outofdate browsers
          context.setLineDash([ ]);
        }
        context.lineWidth = textLineWidth;
        context.strokeStyle = textStroke;
      }

    }

    var lineWidth = 2  * style['text-outline-width'].pfValue; // *2 b/c the stroke is drawn centred on the middle

    if( lineWidth > 0 ){
      context.lineWidth = lineWidth;
    }

    if( style['text-wrap'].value === 'wrap' ){
      var lines = rscratch.labelWrapCachedLines;
      var lineHeight = rstyle.labelHeight / lines.length;

      switch( valign ){
        case 'top':
          textY -= (lines.length - 1) * lineHeight;
          break;

        case 'bottom':
          // nothing required
          break;

        default:
        case 'center':
          textY -= (lines.length - 1) * lineHeight / 2;
      }

      for( var l = 0; l < lines.length; l++ ){
        if( lineWidth > 0 ){
          context.strokeText( lines[l], textX, textY );
        }

        context.fillText( lines[l], textX, textY );

        textY += lineHeight;
      }

    } else {
      if( lineWidth > 0 ){
        context.strokeText( text, textX, textY );
      }

      context.fillText( text, textX, textY );
    }


    this.shadowStyle(context, 'transparent', 0); // reset for next guy
  }
};


module.exports = CRp;

},{"../../../is":77}],66:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../../is');

var CRp = {};

// Draw node
CRp.drawNode = function(context, node, drawOverlayInstead) {

  var r = this;
  var nodeWidth, nodeHeight;
  var style = node._private.style;
  var rs = node._private.rscratch;
  var _p = node._private;
  var pos = _p.position;

  if( !is.number(pos.x) || !is.number(pos.y) ){
    return; // can't draw node with undefined position
  }

  var usePaths = this.usePaths();
  var canvasContext = context;
  var path;
  var pathCacheHit = false;

  var overlayPadding = style['overlay-padding'].pfValue;
  var overlayOpacity = style['overlay-opacity'].value;
  var overlayColor = style['overlay-color'].value;

  if( drawOverlayInstead && overlayOpacity === 0 ){ // exit early if drawing overlay but none to draw
    return;
  }

  var parentOpacity = node.effectiveOpacity();
  if( parentOpacity === 0 ){ return; }

  nodeWidth = node.width() + style['padding-left'].pfValue + style['padding-right'].pfValue;
  nodeHeight = node.height() + style['padding-top'].pfValue + style['padding-bottom'].pfValue;

  context.lineWidth = style['border-width'].pfValue;

  if( drawOverlayInstead === undefined || !drawOverlayInstead ){

    var url = style['background-image'].value[2] ||
      style['background-image'].value[1];
    var image;

    if (url !== undefined) {

      // get image, and if not loaded then ask to redraw when later loaded
      image = this.getCachedImage(url, function(){
        r.data.canvasNeedsRedraw[r.NODE] = true;
        r.data.canvasNeedsRedraw[r.DRAG] = true;

        r.drawingImage = true;

        r.redraw();
      });

      var prevBging = _p.backgrounding;
      _p.backgrounding = !image.complete;

      if( prevBging !== _p.backgrounding ){ // update style b/c :backgrounding state changed
        node.updateStyle( false );
      }
    }

    // Node color & opacity

    var bgColor = style['background-color'].value;
    var borderColor = style['border-color'].value;
    var borderStyle = style['border-style'].value;

    this.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], style['background-opacity'].value * parentOpacity);

    this.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], style['border-opacity'].value * parentOpacity);

    var shadowBlur = style['shadow-blur'].pfValue;
    var shadowOpacity = style['shadow-opacity'].value;
    var shadowColor = style['shadow-color'].value;
    var shadowOffsetX = style['shadow-offset-x'].pfValue;
    var shadowOffsetY = style['shadow-offset-y'].pfValue;

    this.shadowStyle(context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);

    context.lineJoin = 'miter'; // so borders are square with the node shape

    if( context.setLineDash ){ // for very outofdate browsers
      switch( borderStyle ){
        case 'dotted':
          context.setLineDash([ 1, 1 ]);
          break;

        case 'dashed':
          context.setLineDash([ 4, 2 ]);
          break;

        case 'solid':
        case 'double':
          context.setLineDash([ ]);
          break;
      }
    }


    var styleShape = style['shape'].strValue;

    if( usePaths ){
      var pathCacheKey = styleShape + '$' + nodeWidth +'$' + nodeHeight;

      context.translate( pos.x, pos.y );

      if( rs.pathCacheKey === pathCacheKey ){
        path = context = rs.pathCache;
        pathCacheHit = true;
      } else {
        path = context = new Path2D();
        rs.pathCacheKey = pathCacheKey;
        rs.pathCache = path;
      }
    }

    if( !pathCacheHit ){

      var npos = pos;

      if( usePaths ){
        npos = {
          x: 0,
          y: 0
        };
      }

      r.nodeShapes[this.getNodeShape(node)].draw(
            context,
            npos.x,
            npos.y,
            nodeWidth,
            nodeHeight);
    }

    context = canvasContext;

    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }

    this.shadowStyle(context, 'transparent', 0); // reset for next guy

    if (url !== undefined) {
      if( image.complete ){
        this.drawInscribedImage(context, image, node);
      }
    }

    var darkness = style['background-blacken'].value;
    var borderWidth = style['border-width'].pfValue;

    if( this.hasPie(node) ){
      this.drawPie( context, node, parentOpacity );

      // redraw path for blacken and border
      if( darkness !== 0 || borderWidth !== 0 ){

        if( !usePaths ){
          r.nodeShapes[this.getNodeShape(node)].draw(
              context,
              pos.x,
              pos.y,
              nodeWidth,
              nodeHeight);
        }
      }
    }

    if( darkness > 0 ){
      this.fillStyle(context, 0, 0, 0, darkness);

      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }

    } else if( darkness < 0 ){
      this.fillStyle(context, 255, 255, 255, -darkness);

      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }
    }

    // Border width, draw border
    if (borderWidth > 0) {

      if( usePaths ){
        context.stroke( path );
      } else {
        context.stroke();
      }

      if( borderStyle === 'double' ){
        context.lineWidth = style['border-width'].pfValue/3;

        var gco = context.globalCompositeOperation;
        context.globalCompositeOperation = 'destination-out';

        if( usePaths ){
          context.stroke( path );
        } else {
          context.stroke();
        }

        context.globalCompositeOperation = gco;
      }

    }

    if( usePaths ){
      context.translate( -pos.x, -pos.y );
    }

    // reset in case we changed the border style
    if( context.setLineDash ){ // for very outofdate browsers
      context.setLineDash([ ]);
    }

  // draw the overlay
  } else {

    if( overlayOpacity > 0 ){
      this.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);

      r.nodeShapes['roundrectangle'].draw(
        context,
        node._private.position.x,
        node._private.position.y,
        nodeWidth + overlayPadding * 2,
        nodeHeight + overlayPadding * 2
      );

      context.fill();
    }
  }

};

// does the node have at least one pie piece?
CRp.hasPie = function(node){
  node = node[0]; // ensure ele ref

  return node._private.hasPie;
};

CRp.drawPie = function( context, node, nodeOpacity ){
  node = node[0]; // ensure ele ref

  var _p = node._private;
  var cyStyle = node.cy().style();
  var style = _p.style;
  var pieSize = style['pie-size'];
  var nodeW = node.width();
  var nodeH = node.height();
  var x = _p.position.x;
  var y = _p.position.y;
  var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node
  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
  var usePaths = this.usePaths();

  if( usePaths ){
    x = 0;
    y = 0;
  }

  if( pieSize.units === '%' ){
    radius = radius * pieSize.value / 100;
  } else if( pieSize.pfValue !== undefined ){
    radius = pieSize.pfValue / 2;
  }

  for( var i = 1; i <= cyStyle.pieBackgroundN; i++ ){ // 1..N
    var size = style['pie-' + i + '-background-size'].value;
    var color = style['pie-' + i + '-background-color'].value;
    var opacity = style['pie-' + i + '-background-opacity'].value * nodeOpacity;
    var percent = size / 100; // map integer range [0, 100] to [0, 1]

    // percent can't push beyond 1
    if( percent + lastPercent > 1 ){
      percent = 1 - lastPercent;
    }

    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
    var angleDelta = 2 * Math.PI * percent;
    var angleEnd = angleStart + angleDelta;

    // ignore if
    // - zero size
    // - we're already beyond the full circle
    // - adding the current slice would go beyond the full circle
    if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){
      continue;
    }

    context.beginPath();
    context.moveTo(x, y);
    context.arc( x, y, radius, angleStart, angleEnd );
    context.closePath();

    this.fillStyle(context, color[0], color[1], color[2], opacity);

    context.fill();

    lastPercent += percent;
  }

};


module.exports = CRp;

},{"../../../is":77}],67:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

var util = _dereq_('../../../util');
var math = _dereq_('../../../math');

var motionBlurDelay = 100;

// var isFirefox = typeof InstallTrigger !== 'undefined';

CRp.getPixelRatio = function(){
  var context = this.data.contexts[0];

  if( this.forcedPixelRatio != null ){
    return this.forcedPixelRatio;
  }

  var backingStore = context.backingStorePixelRatio ||
    context.webkitBackingStorePixelRatio ||
    context.mozBackingStorePixelRatio ||
    context.msBackingStorePixelRatio ||
    context.oBackingStorePixelRatio ||
    context.backingStorePixelRatio || 1;

  return (window.devicePixelRatio || 1) / backingStore;
};

CRp.paintCache = function(context){
  var caches = this.paintCaches = this.paintCaches || [];
  var needToCreateCache = true;
  var cache;

  for(var i = 0; i < caches.length; i++ ){
    cache = caches[i];

    if( cache.context === context ){
      needToCreateCache = false;
      break;
    }
  }

  if( needToCreateCache ){
    cache = {
      context: context
    };
    caches.push( cache );
  }

  return cache;
};

CRp.fillStyle = function(context, r, g, b, a){
  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.fillStyle !== fillStyle ){
  //   context.fillStyle = cache.fillStyle = fillStyle;
  // }
};

CRp.strokeStyle = function(context, r, g, b, a){
  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.strokeStyle !== strokeStyle ){
  //   context.strokeStyle = cache.strokeStyle = strokeStyle;
  // }
};

CRp.shadowStyle = function(context, color, opacity, blur, offsetX, offsetY){
  var zoom = this.cy.zoom();

  var cache = this.paintCache(context);

  // don't make expensive changes to the shadow style if it's not used
  if( cache.shadowOpacity === 0 && opacity === 0 ){
    return;
  }

  cache.shadowOpacity = opacity;

  if (opacity > 0) {
    context.shadowBlur = blur * zoom;
    context.shadowColor = "rgba(" + color[0] + "," + color[1] + "," + color[2] + "," + opacity + ")";
    context.shadowOffsetX = offsetX * zoom;
    context.shadowOffsetY = offsetY * zoom;
  } else {
    context.shadowBlur = 0;
    context.shadowColor = "transparent";
  }
};

// Resize canvas
CRp.matchCanvasSize = function(container) {
  var r = this;
  var data = r.data;
  var width = container.clientWidth;
  var height = container.clientHeight;
  var pixelRatio = r.getPixelRatio();
  var mbPxRatio = r.motionBlurPxRatio;

  if(
    container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] ||
    container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]
  ){
    pixelRatio = mbPxRatio;
  }

  var canvasWidth = width * pixelRatio;
  var canvasHeight = height * pixelRatio;
  var canvas;

  if( canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight ){
    return; // save cycles if same
  }

  r.fontCaches = null; // resizing resets the style

  var canvasContainer = data.canvasContainer;
  canvasContainer.style.width = width + 'px';
  canvasContainer.style.height = height + 'px';

  for (var i = 0; i < r.CANVAS_LAYERS; i++) {

    canvas = data.canvases[i];

    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {

      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
    }
  }

  for (var i = 0; i < r.BUFFER_COUNT; i++) {

    canvas = data.bufferCanvases[i];

    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {

      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
    }
  }

  r.textureMult = 1;
  if( pixelRatio <= 1 ){
    canvas = data.bufferCanvases[ r.TEXTURE_BUFFER ];

    r.textureMult = 2;
    canvas.width = canvasWidth * r.textureMult;
    canvas.height = canvasHeight * r.textureMult;
  }

  r.canvasWidth = canvasWidth;
  r.canvasHeight = canvasHeight;

};

CRp.renderTo = function( cxt, zoom, pan, pxRatio ){
  this.render({
    forcedContext: cxt,
    forcedZoom: zoom,
    forcedPan: pan,
    drawAllLayers: true,
    forcedPxRatio: pxRatio
  });
};

CRp.render = function( options ) {
  options = options || util.staticEmptyObject();

  var forcedContext = options.forcedContext;
  var drawAllLayers = options.drawAllLayers;
  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
  var forcedZoom = options.forcedZoom;
  var forcedPan = options.forcedPan;
  var r = this;
  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
  var cy = r.cy; var data = r.data;
  var needDraw = data.canvasNeedsRedraw;
  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
  var mbPxRatio = r.motionBlurPxRatio;
  var hasCompoundNodes = cy.hasCompoundNodes();
  var inNodeDragGesture = r.hoverData.draggingEles;
  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
  var motionBlurFadeEffect = motionBlur;

  if( !forcedContext && r.motionBlurTimeout ){
    clearTimeout( r.motionBlurTimeout );
  }

  if( motionBlur ){
    if( r.mbFrames == null ){
      r.mbFrames = 0;
    }

    if( !r.drawingImage ){ // image loading frames don't count towards motion blur blurry frames
      r.mbFrames++;
    }

    if( r.mbFrames < 3 ){ // need several frames before even high quality motionblur
      motionBlurFadeEffect = false;
    }

    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
    if( r.mbFrames > r.minMbLowQualFrames ){
      //r.fullQualityMb = false;
      r.motionBlurPxRatio = r.mbPxRBlurry;
    }
  }

  if( r.clearingMotionBlur ){
    r.motionBlurPxRatio = 1;
  }

  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
  // because a rogue async texture frame would clear needDraw
  if( r.textureDrawLastFrame && !textureDraw ){
    needDraw[r.NODE] = true;
    needDraw[r.SELECT_BOX] = true;
  }

  var edges = r.getCachedEdges();
  var coreStyle = cy.style()._private.coreStyle;

  var zoom = cy.zoom();
  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
  var pan = cy.pan();
  var effectivePan = {
    x: pan.x,
    y: pan.y
  };

  var vp = {
    zoom: zoom,
    pan: {
      x: pan.x,
      y: pan.y
    }
  };
  var prevVp = r.prevViewport;
  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;

  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
  if( !viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes) ){
    r.motionBlurPxRatio = 1;
  }

  if( forcedPan ){
    effectivePan = forcedPan;
  }

  // apply pixel ratio

  effectiveZoom *= pixelRatio;
  effectivePan.x *= pixelRatio;
  effectivePan.y *= pixelRatio;

  var eles = {
    drag: {
      nodes: [],
      edges: [],
      eles: []
    },
    nondrag: {
      nodes: [],
      edges: [],
      eles: []
    }
  };

  function mbclear( context, x, y, w, h ){
    var gco = context.globalCompositeOperation;

    context.globalCompositeOperation = 'destination-out';
    r.fillStyle( context, 255, 255, 255, r.motionBlurTransparency );
    context.fillRect(x, y, w, h);

    context.globalCompositeOperation = gco;
  }

  function setContextTransform(context, clear){
    var ePan, eZoom, w, h;

    if( !r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG]) ){
      ePan = {
        x: pan.x * mbPxRatio,
        y: pan.y * mbPxRatio
      };

      eZoom = zoom * mbPxRatio;

      w = r.canvasWidth * mbPxRatio;
      h = r.canvasHeight * mbPxRatio;
    } else {
      ePan = effectivePan;
      eZoom = effectiveZoom;

      w = r.canvasWidth;
      h = r.canvasHeight;
    }

    context.setTransform(1, 0, 0, 1, 0, 0);

    if( clear === 'motionBlur' ){
      mbclear(context, 0, 0, w, h);
    } else if( !forcedContext && (clear === undefined || clear) ){
      context.clearRect(0, 0, w, h);
    }

    if( !drawAllLayers ){
      context.translate( ePan.x, ePan.y );
      context.scale( eZoom, eZoom );
    }
    if( forcedPan ){
      context.translate( forcedPan.x, forcedPan.y );
    }
    if( forcedZoom ){
      context.scale( forcedZoom, forcedZoom );
    }
  }

  if( !textureDraw ){
    r.textureDrawLastFrame = false;
  }

  if( textureDraw ){
    r.textureDrawLastFrame = true;

    var bb;

    if( !r.textureCache ){
      r.textureCache = {};

      bb = r.textureCache.bb = cy.elements().boundingBox();

      r.textureCache.texture = r.data.bufferCanvases[ r.TEXTURE_BUFFER ];

      var cxt = r.data.bufferContexts[ r.TEXTURE_BUFFER ];

      cxt.setTransform(1, 0, 0, 1, 0, 0);
      cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);

      r.render({
        forcedContext: cxt,
        drawOnlyNodeLayer: true,
        forcedPxRatio: pixelRatio * r.textureMult
      });

      var vp = r.textureCache.viewport = {
        zoom: cy.zoom(),
        pan: cy.pan(),
        width: r.canvasWidth,
        height: r.canvasHeight
      };

      vp.mpan = {
        x: (0 - vp.pan.x)/vp.zoom,
        y: (0 - vp.pan.y)/vp.zoom
      };
    }

    needDraw[r.DRAG] = false;
    needDraw[r.NODE] = false;

    var context = data.contexts[r.NODE];

    var texture = r.textureCache.texture;
    var vp = r.textureCache.viewport;
    bb = r.textureCache.bb;

    context.setTransform(1, 0, 0, 1, 0, 0);

    if( motionBlur ){
      mbclear(context, 0, 0, vp.width, vp.height);
    } else {
      context.clearRect(0, 0, vp.width, vp.height);
    }

    var outsideBgColor = coreStyle['outside-texture-bg-color'].value;
    var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;
    r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );
    context.fillRect( 0, 0, vp.width, vp.height );

    var zoom = cy.zoom();

    setContextTransform( context, false );

    context.clearRect( vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );
    context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );

  } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it
    r.textureCache = null;
  }

  var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);
  var hideEdges = r.hideEdgesOnViewport && vpManip;
  var hideLabels = r.hideLabelsOnViewport && vpManip;

  if (needDraw[r.DRAG] || needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer) {
    if( hideEdges ){
    } else {
      r.findEdgeControlPoints(edges);
    }

    var zEles = r.getCachedZSortedEles();
    var extent = cy.extent();

    for (var i = 0; i < zEles.length; i++) {
      var ele = zEles[i];
      var list;
      var bb = forcedContext ? null : ele.boundingBox();
      var insideExtent = forcedContext ? true : math.boundingBoxesIntersect( extent, bb );

      if( !insideExtent ){ continue; } // no need to render

      if ( ele._private.rscratch.inDragLayer ) {
        list = eles.drag;
      } else {
        list = eles.nondrag;
      }

      list.eles.push( ele );
    }

  }


  function drawElements( list, context ){
    var eles = list.eles;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];

      if( ele.isNode() ){
        r.drawNode(context, ele);

        if( !hideLabels ){
          r.drawNodeText(context, ele);
        }

        r.drawNode(context, ele, true);
      } else if( !hideEdges ) {
        r.drawEdge(context, ele);

        if( !hideLabels ){
          r.drawEdgeText(context, ele);
        }

        r.drawEdge(context, ele, true);
      }


    }

  }

  var needMbClear = [];

  needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;
  if( needMbClear[r.NODE] ){ r.clearedForMotionBlur[r.NODE] = true; }

  needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;
  if( needMbClear[r.DRAG] ){ r.clearedForMotionBlur[r.DRAG] = true; }

  if( needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE] ){
    var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] : data.contexts[r.NODE] );
    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;

    setContextTransform( context, clear );
    drawElements(eles.nondrag, context);

    if( !drawAllLayers && !motionBlur ){
      needDraw[r.NODE] = false;
    }
  }

  if ( !drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG]) ) {
    var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ] : data.contexts[r.DRAG] );

    setContextTransform( context, motionBlur && !useBuffer ? 'motionBlur' : undefined );
    drawElements(eles.drag, context);

    if( !drawAllLayers && !motionBlur ){
      needDraw[r.DRAG] = false;
    }
  }

  if( r.showFps || (!drawOnlyNodeLayer && (needDraw[r.SELECT_BOX] && !drawAllLayers)) ) {
    var context = forcedContext || data.contexts[r.SELECT_BOX];

    setContextTransform( context );

    if( r.selection[4] == 1 && ( r.hoverData.selecting || r.touchData.selecting ) ){
      var zoom = r.cy.zoom();
      var borderWidth = coreStyle['selection-box-border-width'].value / zoom;

      context.lineWidth = borderWidth;
      context.fillStyle = "rgba("
        + coreStyle['selection-box-color'].value[0] + ","
        + coreStyle['selection-box-color'].value[1] + ","
        + coreStyle['selection-box-color'].value[2] + ","
        + coreStyle['selection-box-opacity'].value + ")";

      context.fillRect(
        r.selection[0],
        r.selection[1],
        r.selection[2] - r.selection[0],
        r.selection[3] - r.selection[1]);

      if (borderWidth > 0) {
        context.strokeStyle = "rgba("
          + coreStyle['selection-box-border-color'].value[0] + ","
          + coreStyle['selection-box-border-color'].value[1] + ","
          + coreStyle['selection-box-border-color'].value[2] + ","
          + coreStyle['selection-box-opacity'].value + ")";

        context.strokeRect(
          r.selection[0],
          r.selection[1],
          r.selection[2] - r.selection[0],
          r.selection[3] - r.selection[1]);
      }
    }

    if( data.bgActivePosistion && !r.hoverData.selecting ){
      var zoom = r.cy.zoom();
      var pos = data.bgActivePosistion;

      context.fillStyle = "rgba("
        + coreStyle['active-bg-color'].value[0] + ","
        + coreStyle['active-bg-color'].value[1] + ","
        + coreStyle['active-bg-color'].value[2] + ","
        + coreStyle['active-bg-opacity'].value + ")";

      context.beginPath();
      context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pfValue / zoom, 0, 2 * Math.PI);
      context.fill();
    }

    var timeToRender = r.lastRedrawTime;
    if( r.showFps && timeToRender ){
      timeToRender = Math.round( timeToRender );
      var fps = Math.round(1000/timeToRender);

      context.setTransform(1, 0, 0, 1, 0, 0);

      context.fillStyle = 'rgba(255, 0, 0, 0.75)';
      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
      context.lineWidth = 1;
      context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);

      var maxFps = 60;
      context.strokeRect(0, 30, 250, 20);
      context.fillRect(0, 30, 250 * Math.min(fps/maxFps, 1), 20);
    }

    if( !drawAllLayers ){
      needDraw[r.SELECT_BOX] = false;
    }
  }

  // motionblur: blit rendered blurry frames
  if( motionBlur && mbPxRatio !== 1 ){
    var cxtNode = data.contexts[r.NODE];
    var txtNode = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ];

    var cxtDrag = data.contexts[r.DRAG];
    var txtDrag = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ];

    var drawMotionBlur = function( cxt, txt, needClear ){
      cxt.setTransform(1, 0, 0, 1, 0, 0);

      if( needClear || !motionBlurFadeEffect ){
        cxt.clearRect( 0, 0, r.canvasWidth, r.canvasHeight );
      } else {
        mbclear( cxt, 0, 0, r.canvasWidth, r.canvasHeight );
      }

      var pxr = mbPxRatio;

      cxt.drawImage(
        txt, // img
        0, 0, // sx, sy
        r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
        0, 0, // x, y
        r.canvasWidth, r.canvasHeight // w, h
      );
    };

    if( needDraw[r.NODE] || needMbClear[r.NODE] ){
      drawMotionBlur( cxtNode, txtNode, needMbClear[r.NODE] );
      needDraw[r.NODE] = false;
    }

    if( needDraw[r.DRAG] || needMbClear[r.DRAG] ){
      drawMotionBlur( cxtDrag, txtDrag, needMbClear[r.DRAG] );
      needDraw[r.DRAG] = false;
    }
  }

  r.currentlyDrawing = false;

  r.prevViewport = vp;

  if( r.clearingMotionBlur ){
    r.clearingMotionBlur = false;
    r.motionBlurCleared = true;
    r.motionBlur = true;
  }

  if( motionBlur ){
    r.motionBlurTimeout = setTimeout(function(){
      r.motionBlurTimeout = null;

      r.clearedForMotionBlur[r.NODE] = false;
      r.clearedForMotionBlur[r.DRAG] = false;
      r.motionBlur = false;
      r.clearingMotionBlur = !textureDraw;
      r.mbFrames = 0;

      needDraw[r.NODE] = true;
      needDraw[r.DRAG] = true;

      r.redraw();
    }, motionBlurDelay);
  }

  r.drawingImage = false;


  if( !forcedContext && !r.initrender ){
    r.initrender = true;
    cy.trigger('initrender');
  }

  if( !forcedContext ){
    cy.triggerOnRender();
  }

};

module.exports = CRp;

},{"../../../math":79,"../../../util":94}],68:[function(_dereq_,module,exports){
'use strict';

  var math = _dereq_('../../../math');

  var CRp = {};

  // @O Polygon drawing
  CRp.drawPolygonPath = function(
    context, x, y, width, height, points) {

    var halfW = width / 2;
    var halfH = height / 2;

    if( context.beginPath ){ context.beginPath(); }

    context.moveTo( x + halfW * points[0], y + halfH * points[1] );

    for (var i = 1; i < points.length / 2; i++) {
      context.lineTo( x + halfW * points[i * 2], y + halfH * points[i * 2 + 1] );
    }

    context.closePath();
  };

  // Round rectangle drawing
  CRp.drawRoundRectanglePath = function(
    context, x, y, width, height, radius) {

    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var cornerRadius = math.getRoundRectangleRadius(width, height);

    if( context.beginPath ){ context.beginPath(); }

    // Start at top middle
    context.moveTo(x, y - halfHeight);
    // Arc from middle top to right side
    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);
    // Arc from right side to bottom
    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
    // Arc from bottom to left side
    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
    // Arc from left side to topBorder
    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);
    // Join line
    context.lineTo(x, y - halfHeight);


    context.closePath();
  };

  var sin0 = Math.sin(0);
  var cos0 = Math.cos(0);

  var sin = {};
  var cos = {};

  var ellipseStepSize = Math.PI / 40;

  for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
    sin[i] = Math.sin(i);
    cos[i] = Math.cos(i);
  }

  CRp.drawEllipsePath = function(context, centerX, centerY, width, height){
    if( context.beginPath ){ context.beginPath(); }

    if( context.ellipse ){
      context.ellipse( centerX, centerY, width/2, height/2, 0, 0, 2*Math.PI );
    } else {
      var xPos, yPos;
      var rw = width/2;
      var rh = height/2;
      for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
        xPos = centerX - (rw * sin[i]) * sin0 + (rw * cos[i]) * cos0;
        yPos = centerY + (rh * cos[i]) * sin0 + (rh * sin[i]) * cos0;

        if (i === 0) {
          context.moveTo(xPos, yPos);
        } else {
          context.lineTo(xPos, yPos);
        }
      }
    }

    context.closePath();
  };

module.exports = CRp;

},{"../../../math":79}],69:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../../is');

var CRp = {};

CRp.createBuffer = function(w, h) {
  var buffer = document.createElement('canvas');
  buffer.width = w;
  buffer.height = h;

  return [buffer, buffer.getContext('2d')];
};

CRp.bufferCanvasImage = function( options ){
  var cy = this.cy;
  var bb = cy.elements().boundingBox();
  var width = options.full ? Math.ceil(bb.w) : this.container.clientWidth;
  var height = options.full ? Math.ceil(bb.h) : this.container.clientHeight;
  var scale = 1;

  if( options.scale !== undefined ){
    width *= options.scale;
    height *= options.scale;

    scale = options.scale;
  } else if( is.number(options.maxWidth) || is.number(options.maxHeight) ){
    var maxScaleW = Infinity;
    var maxScaleH = Infinity;

    if( is.number(options.maxWidth) ){
      maxScaleW = scale * options.maxWidth / width;
    }

    if( is.number(options.maxHeight) ){
      maxScaleH = scale * options.maxHeight / height;
    }

    scale = Math.min( maxScaleW, maxScaleH );

    width *= scale;
    height *= scale;
  }

  var buffCanvas = document.createElement('canvas');

  buffCanvas.width = width;
  buffCanvas.height = height;

  buffCanvas.style.width = width + 'px';
  buffCanvas.style.height = height + 'px';

  var buffCxt = buffCanvas.getContext('2d');

  // Rasterize the layers, but only if container has nonzero size
  if (width > 0 && height > 0) {

    buffCxt.clearRect( 0, 0, width, height );

    if( options.bg ){
      buffCxt.fillStyle = options.bg;
      buffCxt.rect( 0, 0, width, height );
      buffCxt.fill();
    }

    buffCxt.globalCompositeOperation = 'source-over';

    if( options.full ){ // draw the full bounds of the graph
      this.render({
        forcedContext: buffCxt,
        drawAllLayers: true,
        forcedZoom: scale,
        forcedPan: { x: -bb.x1*scale, y: -bb.y1*scale },
        forcedPxRatio: 1
      });
    } else { // draw the current view
      var cyPan = cy.pan();
      var pan = {
        x: cyPan.x * scale,
        y: cyPan.y * scale
      };
      var zoom = cy.zoom() * scale;

      this.render({
        forcedContext: buffCxt,
        drawAllLayers: true,
        forcedZoom: zoom,
        forcedPan: pan,
        forcedPxRatio: 1
      });
    }
  }

  return buffCanvas;
};

CRp.png = function( options ){
  return this.bufferCanvasImage( options ).toDataURL('image/png');
};

CRp.jpg = function( options ){
  return this.bufferCanvasImage( options ).toDataURL('image/jpeg');
};

module.exports = CRp;

},{"../../../is":77}],70:[function(_dereq_,module,exports){
/*
The canvas renderer was written by Yue Dong.

Modifications tracked on Github.
*/

'use strict';

var util = _dereq_('../../../util');
var is = _dereq_('../../../is');

var CR = CanvasRenderer;
var CRp = CanvasRenderer.prototype;

CRp.CANVAS_LAYERS = 3;
//
CRp.SELECT_BOX = 0;
CRp.DRAG = 1;
CRp.NODE = 2;

CRp.BUFFER_COUNT = 3;
//
CRp.TEXTURE_BUFFER = 0;
CRp.MOTIONBLUR_BUFFER_NODE = 1;
CRp.MOTIONBLUR_BUFFER_DRAG = 2;

function CanvasRenderer(options) {
  var r = this;

  r.data = {
    canvases: new Array(CRp.CANVAS_LAYERS),
    contexts: new Array(CRp.CANVAS_LAYERS),
    canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),

    bufferCanvases: new Array(CRp.BUFFER_COUNT),
    bufferContexts: new Array(CRp.CANVAS_LAYERS)
  };

  r.data.canvasContainer = document.createElement('div');
  var containerStyle = r.data.canvasContainer.style;
  r.data.canvasContainer.setAttribute('style', '-webkit-tap-highlight-color: rgba(0,0,0,0);');
  containerStyle.position = 'relative';
  containerStyle.zIndex = '0';
  containerStyle.overflow = 'hidden';

  var container = options.cy.container();
  container.appendChild( r.data.canvasContainer );
  container.setAttribute('style', ( container.getAttribute('style') || '' ) + '-webkit-tap-highlight-color: rgba(0,0,0,0);');

  for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {
    var canvas = r.data.canvases[i] = document.createElement('canvas');
    r.data.contexts[i] = canvas.getContext('2d');
    canvas.setAttribute( 'style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + ( is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : '' ) );
    canvas.style.position = 'absolute';
    canvas.setAttribute('data-id', 'layer' + i);
    canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);
    r.data.canvasContainer.appendChild(canvas);

    r.data.canvasNeedsRedraw[i] = false;
  }
  r.data.topCanvas = r.data.canvases[0];

  r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');
  r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');
  r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');

  for (var i = 0; i < CRp.BUFFER_COUNT; i++) {
    r.data.bufferCanvases[i] = document.createElement('canvas');
    r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');
    r.data.bufferCanvases[i].style.position = 'absolute';
    r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
    r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
    r.data.bufferCanvases[i].style.visibility = 'hidden';
    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
  }

  r.pathsEnabled = true;
}

CRp.redrawHint = function( group, bool ){
  var r = this;

  switch( group ){
    case 'eles':
      r.data.canvasNeedsRedraw[ CRp.NODE ] = bool;
      break;
    case 'drag':
      r.data.canvasNeedsRedraw[ CRp.DRAG ] = bool;
      break;
    case 'select':
      r.data.canvasNeedsRedraw[ CRp.SELECT_BOX ] = bool;
      break;
  }
};

// whether to use Path2D caching for drawing
var pathsImpld = typeof Path2D !== 'undefined';

CRp.path2dEnabled = function( on ){
  if( on === undefined ){
    return this.pathsEnabled;
  }

  this.pathsEnabled = on ? true : false;
};

CRp.usePaths = function(){
  return pathsImpld && this.pathsEnabled;
};

[
  _dereq_('./arrow-shapes'),
  _dereq_('./drawing-edges'),
  _dereq_('./drawing-images'),
  _dereq_('./drawing-label-text'),
  _dereq_('./drawing-nodes'),
  _dereq_('./drawing-redraw'),
  _dereq_('./drawing-shapes'),
  _dereq_('./export-image'),
  _dereq_('./node-shapes')
].forEach(function( props ){
  util.extend( CRp, props );
});

module.exports = CR;

},{"../../../is":77,"../../../util":94,"./arrow-shapes":62,"./drawing-edges":63,"./drawing-images":64,"./drawing-label-text":65,"./drawing-nodes":66,"./drawing-redraw":67,"./drawing-shapes":68,"./export-image":69,"./node-shapes":71}],71:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

var impl;

CRp.nodeShapeImpl = function( name ){
  var self = this;

  return ( impl || (impl = {
    'ellipse': function( context, centerX, centerY, width, height ){
      self.drawEllipsePath( context, centerX, centerY, width, height );
    },

    'polygon': function( context, centerX, centerY, width, height, points ){
      self.drawPolygonPath( context, centerX, centerY, width, height, points );
    },

    'roundrectangle': function( context, centerX, centerY, width, height ){
      self.drawRoundRectanglePath( context, centerX, centerY, width, height, 10 );
    }
  }) )[ name ];
};

module.exports = CRp;

},{}],72:[function(_dereq_,module,exports){
'use strict';

module.exports = [
  { name: 'null', impl: _dereq_('./null') },
  { name: 'base', impl: _dereq_('./base') },
  { name: 'canvas', impl: _dereq_('./canvas') }
];

},{"./base":58,"./canvas":70,"./null":73}],73:[function(_dereq_,module,exports){
'use strict';

function NullRenderer(options){
  this.options = options;
  this.notifications = 0; // for testing
}

var noop = function(){};

NullRenderer.prototype = {
  recalculateRenderedStyle: noop,
  notify: function(){ this.notifications++; },
  init: noop
};

module.exports = NullRenderer;

},{}],74:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('./is');
var util = _dereq_('./util');
var Thread = _dereq_('./thread');
var Promise = _dereq_('./promise');
var define = _dereq_('./define');

var Fabric = function( N ){
  if( !(this instanceof Fabric) ){
    return new Fabric( N );
  }

  this._private = {
    pass: []
  };

  var defN = 4;

  if( is.number(N) ){
    // then use the specified number of threads
  } if( typeof navigator !== 'undefined' && navigator.hardwareConcurrency != null ){
    N = navigator.hardwareConcurrency;
  } else {
    try{
      N = _dereq_('os').cpus().length;
    } catch( err ){
      N = defN;
    }
  } // TODO could use an estimation here but would the additional expense be worth it?

  for( var i = 0; i < N; i++ ){
    this[i] = new Thread();
  }

  this.length = N;
};

var fabfn = Fabric.prototype; // short alias

util.extend(fabfn, {

  instanceString: function(){ return 'fabric'; },

  // require fn in all threads
  require: function( fn, as ){
    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];

      thread.require( fn, as );
    }

    return this;
  },

  // get a random thread
  random: function(){
    var i = Math.round( (this.length - 1) * Math.random() );
    var thread = this[i];

    return thread;
  },

  // run on random thread
  run: function( fn ){
    var pass = this._private.pass.shift();

    return this.random().pass( pass ).run( fn );
  },

  // sends a random thread a message
  message: function( m ){
    return this.random().message( m );
  },

  // send all threads a message
  broadcast: function( m ){
    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];

      thread.message( m );
    }

    return this; // chaining
  },

  // stop all threads
  stop: function(){
    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];

      thread.stop();
    }

    return this; // chaining
  },

  // pass data to be used with .spread() etc.
  pass: function( data ){
    var pass = this._private.pass;

    if( is.array(data) ){
      pass.push( data );
    } else {
      throw 'Only arrays may be used with fabric.pass()';
    }

    return this; // chaining
  },

  spreadSize: function(){
    var subsize =  Math.ceil( this._private.pass[0].length / this.length );

    subsize = Math.max( 1, subsize ); // don't pass less than one ele to each thread

    return subsize;
  },

  // split the data into slices to spread the data equally among threads
  spread: function( fn ){
    var self = this;
    var _p = self._private;
    var subsize = self.spreadSize(); // number of pass eles to handle in each thread
    var pass = _p.pass.shift().concat([]); // keep a copy
    var runPs = [];

    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];
      var slice = pass.splice( 0, subsize );

      var runP = thread.pass( slice ).run( fn );

      runPs.push( runP );

      var doneEarly = pass.length === 0;
      if( doneEarly ){ break; }
    }

    return Promise.all( runPs ).then(function( thens ){
      var postpass = [];
      var p = 0;

      // fill postpass with the total result joined from all threads
      for( var i = 0; i < thens.length; i++ ){
        var then = thens[i]; // array result from thread i

        for( var j = 0; j < then.length; j++ ){
          var t = then[j]; // array element

          postpass[ p++ ] = t;
        }
      }

      return postpass;
    });
  },

  // parallel version of array.map()
  map: function( fn ){
    var self = this;

    self.require( fn, '_$_$_fabmap' );

    return self.spread(function( split ){
      var mapped = [];
      var origResolve = resolve; // jshint ignore:line

      resolve = function( val ){ // jshint ignore:line
        mapped.push( val );
      };

      for( var i = 0; i < split.length; i++ ){
        var oldLen = mapped.length;
        var ret = _$_$_fabmap( split[i] ); // jshint ignore:line
        var nothingInsdByResolve = oldLen === mapped.length;

        if( nothingInsdByResolve ){
          mapped.push( ret );
        }
      }

      resolve = origResolve; // jshint ignore:line

      return mapped;
    });

  },

  // parallel version of array.filter()
  filter: function( fn ){
    var _p = this._private;
    var pass = _p.pass[0];

    return this.map( fn ).then(function( include ){
      var ret = [];

      for( var i = 0; i < pass.length; i++ ){
        var datum = pass[i];
        var incDatum = include[i];

        if( incDatum ){
          ret.push( datum );
        }
      }

      return ret;
    });
  },

  // sorts the passed array using a divide and conquer strategy
  sort: function( cmp ){
    var self = this;
    var P = this._private.pass[0].length;
    var subsize = this.spreadSize();

    cmp = cmp || function( a, b ){ // default comparison function
      if( a < b ){
        return -1;
      } else if( a > b ){
        return 1;
      }

      return 0;
    };

    self.require( cmp, '_$_$_cmp' );

    return self.spread(function( split ){ // sort each split normally
      var sortedSplit = split.sort( _$_$_cmp ); // jshint ignore:line
      resolve( sortedSplit ); // jshint ignore:line

    }).then(function( joined ){
      // do all the merging in the main thread to minimise data transfer

      // TODO could do merging in separate threads but would incur add'l cost of data transfer
      // for each level of the merge

      var merge = function( i, j, max ){
        // don't overflow array
        j = Math.min( j, P );
        max = Math.min( max, P );

        // left and right sides of merge
        var l = i;
        var r = j;

        var sorted = [];

        for( var k = l; k < max; k++ ){

          var eleI = joined[i];
          var eleJ = joined[j];

          if( i < r && ( j >= max || cmp(eleI, eleJ) <= 0 ) ){
            sorted.push( eleI );
            i++;
          } else {
            sorted.push( eleJ );
            j++;
          }

        }

        // in the array proper, put the sorted values
        for( var k = 0; k < sorted.length; k++ ){ // kth sorted item
          var index = l + k;

          joined[ index ] = sorted[k];
        }
      };

      for( var splitL = subsize; splitL < P; splitL *= 2 ){ // merge until array is "split" as 1

        for( var i = 0; i < P; i += 2*splitL ){
          merge( i, i + splitL, i + 2*splitL );
        }

      }

      return joined;
    });
  }


});

var defineRandomPasser = function( opts ){
  opts = opts || {};

  return function( fn, arg1 ){
    var pass = this._private.pass.shift();

    return this.random().pass( pass )[ opts.threadFn ]( fn, arg1 );
  };
};

util.extend(fabfn, {
  randomMap: defineRandomPasser({ threadFn: 'map' }),

  reduce: defineRandomPasser({ threadFn: 'reduce' }),

  reduceRight: defineRandomPasser({ threadFn: 'reduceRight' })
});

// aliases
var fn = fabfn;
fn.promise = fn.run;
fn.terminate = fn.halt = fn.stop;
fn.include = fn.require;

// pull in event apis
util.extend(fabfn, {
  on: define.on(),
  one: define.on({ unbindSelfOnTrigger: true }),
  off: define.off(),
  trigger: define.trigger()
});

define.eventAliasesOn( fabfn );

module.exports = Fabric;

},{"./define":41,"./is":77,"./promise":80,"./thread":92,"./util":94,"os":undefined}],75:[function(_dereq_,module,exports){
/*!
Ported by Xueqiao Xu <xueqiaoxu@gmail.com>;

PSF LICENSE AGREEMENT FOR PYTHON 2.7.2

1. This LICENSE AGREEMENT is between the Python Software Foundation (PSF), and the Individual or Organization (Licensee) accessing and otherwise using Python 2.7.2 software in source or binary form and its associated documentation.
2. Subject to the terms and conditions of this License Agreement, PSF hereby grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare derivative works, distribute, and otherwise use Python 2.7.2 alone or in any derivative version, provided, however, that PSFs License Agreement and PSFs notice of copyright, i.e., Copyright  2001-2012 Python Software Foundation; All Rights Reserved are retained in Python 2.7.2 alone or in any derivative version prepared by Licensee.
3. In the event Licensee prepares a derivative work that is based on or incorporates Python 2.7.2 or any part thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby agrees to include in any such work a brief summary of the changes made to Python 2.7.2.
4. PSF is making Python 2.7.2 available to Licensee on an AS IS basis. PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.7.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 2.7.2 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 2.7.2, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.
7. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between PSF and Licensee. This License Agreement does not grant permission to use PSF trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.
8. By copying, installing or otherwise using Python 2.7.2, Licensee agrees to be bound by the terms and conditions of this License Agreement.
*/

'use strict';
/* jshint ignore:start */

// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.

  If x is already in a, insert it to the right of the rightmost x.

  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.

  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define([], factory);
    } else if (typeof exports === 'object') {
      return module.exports = factory();
    } else {
      return root.Heap = factory();
    }
  })(this, function() {
    return Heap;
  });

}).call(this);

/* jshint ignore:end */

},{}],76:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_('./window');
var is = _dereq_('./is');
var Core = _dereq_('./core');
var extension = _dereq_('./extension');
var registerJquery = _dereq_('./jquery-plugin');
var Stylesheet = _dereq_('./stylesheet');
var Thread = _dereq_('./thread');
var Fabric = _dereq_('./fabric');

var cytoscape = function( options ){ // jshint ignore:line
  // if no options specified, use default
  if( options === undefined ){
    options = {};
  }

  // create instance
  if( is.plainObject( options ) ){
    return new Core( options );
  }

  // allow for registration of extensions
  else if( is.string( options ) ) {
    return extension.apply(extension, arguments);
  }
};

// replaced by build system
cytoscape.version = '2.5.5';

// try to register w/ jquery
if( window && window.jQuery ){
  registerJquery( window.jQuery, cytoscape );
}

// expose register api
cytoscape.registerJquery = function( jQuery ){
  registerJquery( jQuery, cytoscape );
};

// expose public apis (mostly for extensions)
cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;
cytoscape.thread = cytoscape.Thread = Thread;
cytoscape.fabric = cytoscape.Fabric = Fabric;

module.exports = cytoscape;

},{"./core":34,"./extension":43,"./fabric":74,"./is":77,"./jquery-plugin":78,"./stylesheet":91,"./thread":92,"./window":100}],77:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_('./window');
var navigator = window ? window.navigator : null;

var typeofstr = typeof '';
var typeofobj = typeof {};
var typeoffn = typeof function(){};
var typeofhtmlele = typeof HTMLElement;

var instanceStr = function( obj ){
  return obj && obj.instanceString && is.fn( obj.instanceString ) ? obj.instanceString() : null;
};

var is = {
  defined: function(obj){
    return obj != null; // not undefined or null
  },

  string: function(obj){
    return obj != null && typeof obj == typeofstr;
  },

  fn: function(obj){
    return obj != null && typeof obj === typeoffn;
  },

  array: function(obj){
    return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
  },

  plainObject: function(obj){
    return obj != null && typeof obj === typeofobj && !is.array(obj) && obj.constructor === Object;
  },

  object: function(obj){
    return obj != null && typeof obj === typeofobj;
  },

  number: function(obj){
    return obj != null && typeof obj === typeof 1 && !isNaN(obj);
  },

  integer: function( obj ){
    return is.number(obj) && Math.floor(obj) === obj;
  },

  bool: function(obj){
    return obj != null && typeof obj === typeof true;
  },

  htmlElement: function(obj){
    if( 'undefined' === typeofhtmlele ){
      return undefined;
    } else {
      return null != obj && obj instanceof HTMLElement;
    }
  },

  elementOrCollection: function(obj){
    return is.element(obj) || is.collection(obj);
  },

  element: function(obj){
    return instanceStr(obj) === 'collection' && obj._private.single;
  },

  collection: function(obj){
    return instanceStr(obj) === 'collection' && !obj._private.single;
  },

  core: function(obj){
    return instanceStr(obj) === 'core';
  },

  style: function(obj){
    return instanceStr(obj) === 'style';
  },

  stylesheet: function(obj){
    return instanceStr(obj) === 'stylesheet';
  },

  event: function(obj){
    return instanceStr(obj) === 'event';
  },

  thread: function(obj){
    return instanceStr(obj) === 'thread';
  },

  fabric: function(obj){
    return instanceStr(obj) === 'fabric';
  },

  emptyString: function(obj){
    if( !obj ){ // null is empty
      return true;
    } else if( is.string(obj) ){
      if( obj === '' || obj.match(/^\s+$/) ){
        return true; // empty string is empty
      }
    }

    return false; // otherwise, we don't know what we've got
  },

  nonemptyString: function(obj){
    if( obj && is.string(obj) && obj !== '' && !obj.match(/^\s+$/) ){
      return true;
    }

    return false;
  },

  domElement: function(obj){
    if( typeof HTMLElement === 'undefined' ){
      return false; // we're not in a browser so it doesn't matter
    } else {
      return obj instanceof HTMLElement;
    }
  },

  boundingBox: function(obj){
    return is.plainObject(obj) &&
      is.number(obj.x1) && is.number(obj.x2) &&
      is.number(obj.y1) && is.number(obj.y2)
    ;
  },

  promise: function(obj){
    return is.object(obj) && is.fn(obj.then);
  },

  touch: function(){
    return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );
  },

  gecko: function(){
    return typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style);
  },

  webkit: function(){
    return typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style);
  },

  chromium: function(){
    return typeof chrome !== 'undefined';
  },

  khtml: function(){
    return navigator && navigator.vendor.match(/kde/i); // probably a better way to detect this...
  },

  khtmlEtc: function(){
    return is.khtml() || is.webkit() || is.chromium();
  },

  ms: function(){
     return navigator && navigator.userAgent.match(/msie|trident|edge/i); // probably a better way to detect this...
  },

  windows: function(){
    return navigator && navigator.appVersion.match(/Win/i);
  },

  mac: function(){
    return navigator && navigator.appVersion.match(/Mac/i);
  },

  linux: function(){
    return navigator && navigator.appVersion.match(/Linux/i);
  },

  unix: function(){
    return navigator && navigator.appVersion.match(/X11/i);
  }
};

module.exports = is;

},{"./window":100}],78:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('./is');

var cyReg = function( $ele ){
  var d = $ele[0]._cyreg = $ele[0]._cyreg || {};

  return d;
};

var registerJquery = function( $, cytoscape ){
  if( !$ ){ return; } // no jquery => don't need this

  if( $.fn.cytoscape ){ return; } // already registered

  // allow calls on a jQuery selector by proxying calls to $.cytoscape
  // e.g. $("#foo").cytoscape(options) => $.cytoscape(options) on #foo
  $.fn.cytoscape = function(opts){
    var $this = $(this);

    // get object
    if( opts === 'get' ){
      return cyReg( $this ).cy;
    }

    // bind to ready
    else if( is.fn(opts) ){

      var ready = opts;
      var cy = cyReg( $this ).cy;

      if( cy && cy.isReady() ){ // already ready so just trigger now
        cy.trigger('ready', [], ready);

      } else { // not yet ready, so add to readies list
        var data = cyReg( $this );
        var readies = data.readies = data.readies || [];

        readies.push( ready );
      }

    }

    // proxy to create instance
    else if( is.plainObject(opts) ){
      return $this.each(function(){
        var options = $.extend({}, opts, {
          container: $(this)[0]
        });

        cytoscape(options);
      });
    }
  };

  // allow access to the global cytoscape object under jquery for legacy reasons
  $.cytoscape = cytoscape;

  // use short alias (cy) if not already defined
  if( $.fn.cy == null && $.cy == null ){
    $.fn.cy = $.fn.cytoscape;
    $.cy = $.cytoscape;
  }
};

module.exports = registerJquery;

},{"./is":77}],79:[function(_dereq_,module,exports){
'use strict';

var math = {};

math.signum = function(x){
  if( x > 0 ){
    return 1;
  } else if( x < 0 ){
    return -1;
  } else {
    return 0;
  }
};

math.distance = function( p1, p2 ){
  return Math.sqrt( math.sqDistance(p1, p2) );
};

math.sqDistance = function( p1, p2 ){
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;

  return dx*dx + dy*dy;
};

// from http://en.wikipedia.org/wiki/Bzier_curve#Quadratic_curves
math.qbezierAt = function(p0, p1, p2, t){
  return (1 - t)*(1 - t)*p0 + 2*(1 - t)*t*p1 + t*t*p2;
};

math.qbezierPtAt = function(p0, p1, p2, t){
  return {
    x: math.qbezierAt( p0.x, p1.x, p2.x, t ),
    y: math.qbezierAt( p0.y, p1.y, p2.y, t )
  };
};

// makes a full bb (x1, y1, x2, y2, w, h) from implicit params
math.makeBoundingBox = function( bb ){
  if( bb.x1 != null && bb.y1 != null ){
    if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x2,
        y2: bb.y2,
        w: bb.x2 - bb.x1,
        h: bb.y2 - bb.y1
      };
    } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x1 + bb.w,
        y2: bb.y1 + bb.h,
        w: bb.w,
        h: bb.h
      };
    }
  }
};

math.boundingBoxesIntersect = function( bb1, bb2 ){
  // case: one bb to right of other
  if( bb1.x1 > bb2.x2 ){ return false; }
  if( bb2.x1 > bb1.x2 ){ return false; }

  // case: one bb to left of other
  if( bb1.x2 < bb2.x1 ){ return false; }
  if( bb2.x2 < bb1.x1 ){ return false; }

  // case: one bb above other
  if( bb1.y2 < bb2.y1 ){ return false; }
  if( bb2.y2 < bb1.y1 ){ return false; }

  // case: one bb below other
  if( bb1.y1 > bb2.y2 ){ return false; }
  if( bb2.y1 > bb1.y2 ){ return false; }

  // otherwise, must have some overlap
  return true;
};

math.inBoundingBox = function( bb, x, y ){
  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
};

math.pointInBoundingBox = function( bb, pt ){
  return this.inBoundingBox( bb, pt.x, pt.y );
};

math.roundRectangleIntersectLine = function(
  x, y, nodeX, nodeY, width, height, padding) {

  var cornerRadius = this.getRoundRectangleRadius(width, height);

  var halfWidth = width / 2;
  var halfHeight = height / 2;

  // Check intersections with straight line segments
  var straightLineIntersections;

  // Top segment, left to right
  {
    var topStartX = nodeX - halfWidth + cornerRadius - padding;
    var topStartY = nodeY - halfHeight - padding;
    var topEndX = nodeX + halfWidth - cornerRadius + padding;
    var topEndY = topStartY;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Right segment, top to bottom
  {
    var rightStartX = nodeX + halfWidth + padding;
    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
    var rightEndX = rightStartX;
    var rightEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Bottom segment, left to right
  {
    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
    var bottomStartY = nodeY + halfHeight + padding;
    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
    var bottomEndY = bottomStartY;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Left segment, top to bottom
  {
    var leftStartX = nodeX - halfWidth - padding;
    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
    var leftEndX = leftStartX;
    var leftEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Check intersections with arc segments
  var arcIntersections;

  // Top Left
  {
    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      topLeftCenterX, topLeftCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0
      && arcIntersections[0] <= topLeftCenterX
      && arcIntersections[1] <= topLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  // Top Right
  {
    var topRightCenterX = nodeX + halfWidth - cornerRadius;
    var topRightCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      topRightCenterX, topRightCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0
      && arcIntersections[0] >= topRightCenterX
      && arcIntersections[1] <= topRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  // Bottom Right
  {
    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0
      && arcIntersections[0] >= bottomRightCenterX
      && arcIntersections[1] >= bottomRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  // Bottom Left
  {
    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0
      && arcIntersections[0] <= bottomLeftCenterX
      && arcIntersections[1] >= bottomLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  return []; // if nothing
};

math.inLineVicinity = function(x, y, lx1, ly1, lx2, ly2, tolerance){
  var t = tolerance;

  var x1 = Math.min(lx1, lx2);
  var x2 = Math.max(lx1, lx2);
  var y1 = Math.min(ly1, ly2);
  var y2 = Math.max(ly1, ly2);

  return x1 - t <= x && x <= x2 + t
    && y1 - t <= y && y <= y2 + t;
};

math.inBezierVicinity = function(
  x, y, x1, y1, x2, y2, x3, y3, tolerance) {

  var bb = {
    x1: Math.min( x1, x3, x2 ) - tolerance,
    x2: Math.max( x1, x3, x2 ) + tolerance,
    y1: Math.min( y1, y3, y2 ) - tolerance,
    y2: Math.max( y1, y3, y2 ) + tolerance
  };

  // if outside the rough bounding box for the bezier, then it can't be a hit
  if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){
    // console.log('bezier out of rough bb')
    return false;
  } else {
    // console.log('do more expensive check');
    return true;
  }

};

math.solveCubic = function(a, b, c, d, result) {

  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
  // r is the real component, i is the imaginary component

  // An implementation of the Cardano method from the year 1545
  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

  b /= a;
  c /= a;
  d /= a;

  var discriminant, q, r, dum1, s, t, term1, r13;

  q = (3.0 * c - (b * b)) / 9.0;
  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
  r /= 54.0;

  discriminant = q * q * q + r * r;
  result[1] = 0;
  term1 = (b / 3.0);

  if (discriminant > 0) {
    s = r + Math.sqrt(discriminant);
    s = ((s < 0) ? -Math.pow(-s, (1.0 / 3.0)) : Math.pow(s, (1.0 / 3.0)));
    t = r - Math.sqrt(discriminant);
    t = ((t < 0) ? -Math.pow(-t, (1.0 / 3.0)) : Math.pow(t, (1.0 / 3.0)));
    result[0] = -term1 + s + t;
    term1 += (s + t) / 2.0;
    result[4] = result[2] = -term1;
    term1 = Math.sqrt(3.0) * (-t + s) / 2;
    result[3] = term1;
    result[5] = -term1;
    return;
  }

  result[5] = result[3] = 0;

  if (discriminant === 0) {
    r13 = ((r < 0) ? -Math.pow(-r, (1.0 / 3.0)) : Math.pow(r, (1.0 / 3.0)));
    result[0] = -term1 + 2.0 * r13;
    result[4] = result[2] = -(r13 + term1);
    return;
  }

  q = -q;
  dum1 = q * q * q;
  dum1 = Math.acos(r / Math.sqrt(dum1));
  r13 = 2.0 * Math.sqrt(q);
  result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
  result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
  result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);

  return;
};

math.sqDistanceToQuadraticBezier = function(
  x, y, x1, y1, x2, y2, x3, y3) {

  // Find minimum distance by using the minimum of the distance
  // function between the given point and the curve

  // This gives the coefficients of the resulting cubic equation
  // whose roots tell us where a possible minimum is
  // (Coefficients are divided by 4)

  var a = 1.0 * x1*x1 - 4*x1*x2 + 2*x1*x3 + 4*x2*x2 - 4*x2*x3 + x3*x3
    + y1*y1 - 4*y1*y2 + 2*y1*y3 + 4*y2*y2 - 4*y2*y3 + y3*y3;

  var b = 1.0 * 9*x1*x2 - 3*x1*x1 - 3*x1*x3 - 6*x2*x2 + 3*x2*x3
    + 9*y1*y2 - 3*y1*y1 - 3*y1*y3 - 6*y2*y2 + 3*y2*y3;

  var c = 1.0 * 3*x1*x1 - 6*x1*x2 + x1*x3 - x1*x + 2*x2*x2 + 2*x2*x - x3*x
    + 3*y1*y1 - 6*y1*y2 + y1*y3 - y1*y + 2*y2*y2 + 2*y2*y - y3*y;

  var d = 1.0 * x1*x2 - x1*x1 + x1*x - x2*x
    + y1*y2 - y1*y1 + y1*y - y2*y;

  // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

  var roots = [];

  // Use the cubic solving algorithm
  this.solveCubic(a, b, c, d, roots);

  var zeroThreshold = 0.0000001;

  var params = [];

  for (var index = 0; index < 6; index += 2) {
    if (Math.abs(roots[index + 1]) < zeroThreshold
        && roots[index] >= 0
        && roots[index] <= 1.0) {
      params.push(roots[index]);
    }
  }

  params.push(1.0);
  params.push(0.0);

  var minDistanceSquared = -1;
  var closestParam;

  var curX, curY, distSquared;
  for (var i = 0; i < params.length; i++) {
    curX = Math.pow(1.0 - params[i], 2.0) * x1
      + 2.0 * (1 - params[i]) * params[i] * x2
      + params[i] * params[i] * x3;

    curY = Math.pow(1 - params[i], 2.0) * y1
      + 2 * (1.0 - params[i]) * params[i] * y2
      + params[i] * params[i] * y3;

    distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
    // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
    if (minDistanceSquared >= 0) {
      if (distSquared < minDistanceSquared) {
        minDistanceSquared = distSquared;
        closestParam = params[i];
      }
    } else {
      minDistanceSquared = distSquared;
      closestParam = params[i];
    }
  }

  return minDistanceSquared;
};

math.sqDistanceToFiniteLine = function(x, y, x1, y1, x2, y2) {
  var offset = [x - x1, y - y1];
  var line = [x2 - x1, y2 - y1];

  var lineSq = line[0] * line[0] + line[1] * line[1];
  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];

  var dotProduct = offset[0] * line[0] + offset[1] * line[1];
  var adjSq = dotProduct * dotProduct / lineSq;

  if (dotProduct < 0) {
    return hypSq;
  }

  if (adjSq > lineSq) {
    return (x - x2) * (x - x2) + (y - y2) * (y - y2);
  }

  return hypSq - adjSq;
};

math.pointInsidePolygonPoints = function(x, y, points){
  var x1, y1, x2, y2;
  var y3;

  // Intersect with vertical line through (x, y)
  var up = 0;
  var down = 0;
  for (var i = 0; i < points.length / 2; i++) {

    x1 = points[i * 2];
    y1 = points[i * 2 + 1];

    if (i + 1 < points.length / 2) {
      x2 = points[(i + 1) * 2];
      y2 = points[(i + 1) * 2 + 1];
    } else {
      x2 = points[(i + 1 - points.length / 2) * 2];
      y2 = points[(i + 1 - points.length / 2) * 2 + 1];
    }

    if (x1 == x && x2 == x) {

    } else if ((x1 >= x && x >= x2)
      || (x1 <= x && x <= x2)) {

      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

      if (y3 > y) {
        up++;
      }

      if (y3 < y) {
        down++;
      }

    } else {
      continue;
    }

  }

  if (up % 2 === 0) {
    return false;
  } else {
    return true;
  }
};

math.pointInsidePolygon = function(
  x, y, basePoints, centerX, centerY, width, height, direction, padding) {

  //var direction = arguments[6];
  var transformedPoints = new Array(basePoints.length);

  // Gives negative angle
  var angle;

  if( direction[0] != null ){
    angle = Math.atan(direction[1] / direction[0]);

    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
  } else {
    angle = direction;
  }

  var cos = Math.cos(-angle);
  var sin = Math.sin(-angle);

  //    console.log("base: " + basePoints);
  for (var i = 0; i < transformedPoints.length / 2; i++) {
    transformedPoints[i * 2] =
      width / 2 * (basePoints[i * 2] * cos
        - basePoints[i * 2 + 1] * sin);

    transformedPoints[i * 2 + 1] =
      height / 2 * (basePoints[i * 2 + 1] * cos
        + basePoints[i * 2] * sin);

    transformedPoints[i * 2] += centerX;
    transformedPoints[i * 2 + 1] += centerY;
  }

  var points;

  if (padding > 0) {
    var expandedLineSet = this.expandPolygon(
      transformedPoints,
      -padding);

    points = this.joinLines(expandedLineSet);
  } else {
    points = transformedPoints;
  }

  return math.pointInsidePolygonPoints( x, y, points );
};

math.joinLines = function(lineSet) {

  var vertices = new Array(lineSet.length / 2);

  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;

  for (var i = 0; i < lineSet.length / 4; i++) {
    currentLineStartX = lineSet[i * 4];
    currentLineStartY = lineSet[i * 4 + 1];
    currentLineEndX = lineSet[i * 4 + 2];
    currentLineEndY = lineSet[i * 4 + 3];

    if (i < lineSet.length / 4 - 1) {
      nextLineStartX = lineSet[(i + 1) * 4];
      nextLineStartY = lineSet[(i + 1) * 4 + 1];
      nextLineEndX = lineSet[(i + 1) * 4 + 2];
      nextLineEndY = lineSet[(i + 1) * 4 + 3];
    } else {
      nextLineStartX = lineSet[0];
      nextLineStartY = lineSet[1];
      nextLineEndX = lineSet[2];
      nextLineEndY = lineSet[3];
    }

    var intersection = this.finiteLinesIntersect(
      currentLineStartX, currentLineStartY,
      currentLineEndX, currentLineEndY,
      nextLineStartX, nextLineStartY,
      nextLineEndX, nextLineEndY,
      true);

    vertices[i * 2] = intersection[0];
    vertices[i * 2 + 1] = intersection[1];
  }

  return vertices;
};

math.expandPolygon = function(points, pad) {

  var expandedLineSet = new Array(points.length * 2);

  var currentPointX, currentPointY, nextPointX, nextPointY;

  for (var i = 0; i < points.length / 2; i++) {
    currentPointX = points[i * 2];
    currentPointY = points[i * 2 + 1];

    if (i < points.length / 2 - 1) {
      nextPointX = points[(i + 1) * 2];
      nextPointY = points[(i + 1) * 2 + 1];
    } else {
      nextPointX = points[0];
      nextPointY = points[1];
    }

    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]

    // Assume CCW polygon winding

    var offsetX = (nextPointY - currentPointY);
    var offsetY = -(nextPointX - currentPointX);

    // Normalize
    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
    var normalizedOffsetX = offsetX / offsetLength;
    var normalizedOffsetY = offsetY / offsetLength;

    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
  }

  return expandedLineSet;
};

math.intersectLineEllipse = function(
  x, y, centerX, centerY, ellipseWradius, ellipseHradius) {

  var dispX = centerX - x;
  var dispY = centerY - y;

  dispX /= ellipseWradius;
  dispY /= ellipseHradius;

  var len = Math.sqrt(dispX * dispX + dispY * dispY);

  var newLength = len - 1;

  if (newLength < 0) {
    return [];
  }

  var lenProportion = newLength / len;

  return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
};

// Returns intersections of increasing distance from line's start point
math.intersectLineCircle = function(
  x1, y1, x2, y2, centerX, centerY, radius) {

  // Calculate d, direction vector of line
  var d = [x2 - x1, y2 - y1]; // Direction vector of line
  var c = [centerX, centerY]; // Center of circle
  var f = [x1 - centerX, y1 - centerY];

  var a = d[0] * d[0] + d[1] * d[1];
  var b = 2 * (f[0] * d[0] + f[1] * d[1]);
  var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;

  var discriminant = b*b-4*a*c;

  if (discriminant < 0) {
    return [];
  }

  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);

  var tMin = Math.min(t1, t2);
  var tMax = Math.max(t1, t2);
  var inRangeParams = [];

  if (tMin >= 0 && tMin <= 1) {
    inRangeParams.push(tMin);
  }

  if (tMax >= 0 && tMax <= 1) {
    inRangeParams.push(tMax);
  }

  if (inRangeParams.length === 0) {
    return [];
  }

  var nearIntersectionX = inRangeParams[0] * d[0] + x1;
  var nearIntersectionY = inRangeParams[0] * d[1] + y1;

  if (inRangeParams.length > 1) {

    if (inRangeParams[0] == inRangeParams[1]) {
      return [nearIntersectionX, nearIntersectionY];
    } else {

      var farIntersectionX = inRangeParams[1] * d[0] + x1;
      var farIntersectionY = inRangeParams[1] * d[1] + y1;

      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
    }

  } else {
    return [nearIntersectionX, nearIntersectionY];
  }

};

math.findCircleNearPoint = function(centerX, centerY,
  radius, farX, farY) {

  var displacementX = farX - centerX;
  var displacementY = farY - centerY;
  var distance = Math.sqrt(displacementX * displacementX
    + displacementY * displacementY);

  var unitDisplacementX = displacementX / distance;
  var unitDisplacementY = displacementY / distance;

  return [centerX + unitDisplacementX * radius,
    centerY + unitDisplacementY * radius];
};

math.findMaxSqDistanceToOrigin = function(points) {
  var maxSqDistance = 0.000001;
  var sqDistance;

  for (var i = 0; i < points.length / 2; i++) {

    sqDistance = points[i * 2] * points[i * 2]
      + points[i * 2 + 1] * points[i * 2 + 1];

    if (sqDistance > maxSqDistance) {
      maxSqDistance = sqDistance;
    }
  }

  return maxSqDistance;
};

math.finiteLinesIntersect = function(
  x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {

  var ua_t = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
  var ub_t = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
  var u_b = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

  if (u_b !== 0) {
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;

    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
      return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];

    } else {
      if (!infiniteLines) {
        return [];
      } else {
        return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
      }
    }
  } else {
    if (ua_t === 0 || ub_t === 0) {

      // Parallel, coincident lines. Check if overlap

      // Check endpoint of second line
      if ([x1, x2, x4].sort()[1] === x4) {
        return [x4, y4];
      }

      // Check start point of second line
      if ([x1, x2, x3].sort()[1] === x3) {
        return [x3, y3];
      }

      // Endpoint of first line
      if ([x3, x4, x2].sort()[1] === x2) {
        return [x2, y2];
      }

      return [];
    } else {

      // Parallel, non-coincident
      return [];
    }
  }
};

math.polygonIntersectLine = function(
  x, y, basePoints, centerX, centerY, width, height, padding) {

  var intersections = [];
  var intersection;

  var transformedPoints = new Array(basePoints.length);

  for (var i = 0; i < transformedPoints.length / 2; i++) {
    transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
    transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
  }

  var points;

  if (padding > 0) {
    var expandedLineSet = math.expandPolygon(
      transformedPoints,
      -padding);

    points = math.joinLines(expandedLineSet);
  } else {
    points = transformedPoints;
  }
  // var points = transformedPoints;

  var currentX, currentY, nextX, nextY;

  for (var i = 0; i < points.length / 2; i++) {

    currentX = points[i * 2];
    currentY = points[i * 2 + 1];

    if (i < points.length / 2 - 1) {
      nextX = points[(i + 1) * 2];
      nextY = points[(i + 1) * 2 + 1];
    } else {
      nextX = points[0];
      nextY = points[1];
    }

    intersection = this.finiteLinesIntersect(
      x, y, centerX, centerY,
      currentX, currentY,
      nextX, nextY);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  return intersections;
};

math.shortenIntersection = function(
  intersection, offset, amount) {

  var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];

  var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);

  var lenRatio = (length - amount) / length;

  if (lenRatio < 0) {
    lenRatio = 0.00001;
  }

  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
};

math.generateUnitNgonPointsFitToSquare = function(sides, rotationRadians) {
  var points = math.generateUnitNgonPoints(sides, rotationRadians);
  points = math.fitPolygonToSquare(points);

  return points;
};

math.fitPolygonToSquare = function(points){
  var x, y;
  var sides = points.length/2;
  var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

  for (var i = 0; i < sides; i++) {
    x = points[2 * i];
    y = points[2 * i + 1];

    minX = Math.min( minX, x );
    maxX = Math.max( maxX, x );
    minY = Math.min( minY, y );
    maxY = Math.max( maxY, y );
  }

  // stretch factors
  var sx = 2 / (maxX - minX);
  var sy = 2 / (maxY - minY);

  for (var i = 0; i < sides; i++){
    x = points[2 * i] = points[2 * i] * sx;
    y = points[2 * i + 1] = points[2 * i + 1] * sy;

    minX = Math.min( minX, x );
    maxX = Math.max( maxX, x );
    minY = Math.min( minY, y );
    maxY = Math.max( maxY, y );
  }

  if( minY < -1 ){
    for (var i = 0; i < sides; i++){
      y = points[2 * i + 1] = points[2 * i + 1] + (-1 -minY);
    }
  }

  return points;
};

math.generateUnitNgonPoints = function(sides, rotationRadians) {

  var increment = 1.0 / sides * 2 * Math.PI;
  var startAngle = sides % 2 === 0 ?
    Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
    //    console.log(nodeShapes['square']);
  startAngle += rotationRadians;

  var points = new Array(sides * 2);

  var currentAngle, x, y;
  for (var i = 0; i < sides; i++) {
    currentAngle = i * increment + startAngle;

    x = points[2 * i] = Math.cos(currentAngle);// * (1 + i/2);
    y = points[2 * i + 1] = Math.sin(-currentAngle);//  * (1 + i/2);
  }

  return points;
};

math.getRoundRectangleRadius = function(width, height) {

  // Set the default radius, unless half of width or height is smaller than default
  return Math.min(width / 4, height / 4, 8);
};

module.exports = math;

},{}],80:[function(_dereq_,module,exports){
/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/

'use strict';

/*  promise states [Promises/A+ 2.1]  */
var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */

/*  promise object constructor  */
var api = function (executor) {
  /*  optionally support non-constructor/plain-function call  */
  if (!(this instanceof api))
    return new api(executor);

  /*  initialize object  */
  this.id           = "Thenable/1.0.7";
  this.state        = STATE_PENDING; /*  initial state  */
  this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
  this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
  this.onFulfilled  = [];            /*  initial handlers  */
  this.onRejected   = [];            /*  initial handlers  */

  /*  provide optional information-hiding proxy  */
  this.proxy = {
    then: this.then.bind(this)
  };

  /*  support optional executor function  */
  if (typeof executor === "function")
    executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
};

/*  promise API methods  */
api.prototype = {
  /*  promise resolving methods  */
  fulfill: function (value) { return deliver(this, STATE_FULFILLED, "fulfillValue", value); },
  reject:  function (value) { return deliver(this, STATE_REJECTED,  "rejectReason", value); },

  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function (onFulfilled, onRejected) {
    var curr = this;
    var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
    curr.onFulfilled.push(
      resolver(onFulfilled, next, "fulfill"));             /*  [Promises/A+ 2.2.2/2.2.6]  */
    curr.onRejected.push(
      resolver(onRejected,  next, "reject" ));             /*  [Promises/A+ 2.2.3/2.2.6]  */
    execute(curr);
    return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
  }
};

/*  deliver an action  */
var deliver = function (curr, state, name, value) {
  if (curr.state === STATE_PENDING) {
    curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
    curr[name] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
    execute(curr);
  }
  return curr;
};

/*  execute all handlers  */
var execute = function (curr) {
  if (curr.state === STATE_FULFILLED)
    execute_handlers(curr, "onFulfilled", curr.fulfillValue);
  else if (curr.state === STATE_REJECTED)
    execute_handlers(curr, "onRejected",  curr.rejectReason);
};

/*  execute particular set of handlers  */
var execute_handlers = function (curr, name, value) {
  /* global setImmediate: true */
  /* global setTimeout: true */

  /*  short-circuit processing  */
  if (curr[name].length === 0)
    return;

  /*  iterate over all handlers, exactly once  */
  var handlers = curr[name];
  curr[name] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
  var func = function () {
    for (var i = 0; i < handlers.length; i++)
      handlers[i](value);                                  /*  [Promises/A+ 2.2.5]  */
  };

  /*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
  if (typeof setImmediate === "function")
    setImmediate(func);
  else
    setTimeout(func, 0);
};

/*  generate a resolver function  */
var resolver = function (cb, next, method) {
  return function (value) {
    if (typeof cb !== "function")                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
      next[method].call(next, value);                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
    else {
      var result;
      try { result = cb(value); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
      catch (e) {
        next.reject(e);                                  /*  [Promises/A+ 2.2.7.2]  */
        return;
      }
      resolve(next, result);                               /*  [Promises/A+ 2.2.7.1]  */
    }
  };
};

/*  "Promise Resolution Procedure"  */                           /*  [Promises/A+ 2.3]  */
var resolve = function (promise, x) {
  /*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
  if (promise === x || promise.proxy === x) {
    promise.reject(new TypeError("cannot resolve promise with itself"));
    return;
  }

  /*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */
  var then;
  if ((typeof x === "object" && x !== null) || typeof x === "function") {
    try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
    catch (e) {
      promise.reject(e);                                   /*  [Promises/A+ 2.3.3.2]  */
      return;
    }
  }

  /*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */
  if (typeof then === "function") {
    var resolved = false;
    try {
      /*  call retrieved "then" method */                  /*  [Promises/A+ 2.3.3.3]  */
      then.call(x,
        /*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
        function (y) {
          if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
          if (y === x)                                 /*  [Promises/A+ 3.6]  */
            promise.reject(new TypeError("circular thenable chain"));
          else
            resolve(promise, y);
        },

        /*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
        function (r) {
          if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
          promise.reject(r);
        }
      );
    }
    catch (e) {
      if (!resolved)                                       /*  [Promises/A+ 2.3.3.3.3]  */
        promise.reject(e);                               /*  [Promises/A+ 2.3.3.3.4]  */
    }
    return;
  }

  /*  handle other values  */
  promise.fulfill(x);                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
};

// use native promises where possible
var Promise = typeof Promise === 'undefined' ? api : Promise;

// so we always have Promise.all()
Promise.all = Promise.all || function( ps ){
  return new Promise(function( resolveAll, rejectAll ){
    var vals = new Array( ps.length );
    var doneCount = 0;

    var fulfill = function( i, val ){
      vals[i] = val;
      doneCount++;

      if( doneCount === ps.length ){
        resolveAll( vals );
      }
    };

    for( var i = 0; i < ps.length; i++ ){
      (function( i ){
        var p = ps[i];
        var isPromise = p.then != null;

        if( isPromise ){
          p.then(function( val ){
            fulfill( i, val );
          }, function( err ){
            rejectAll( err );
          });
        } else {
          var val = p;
          fulfill( i, val );
        }
      })( i );
    }

  });
};

module.exports = Promise;

},{}],81:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('./is');
var util = _dereq_('./util');

var Selector = function( onlyThisGroup, selector ){

  if( !(this instanceof Selector) ){
    return new Selector(onlyThisGroup, selector);
  }

  if( selector === undefined && onlyThisGroup !== undefined ){
    selector = onlyThisGroup;
    onlyThisGroup = undefined;
  }

  var self = this;

  self._private = {
    selectorText: null,
    invalid: true
  };

  if( !selector || ( is.string(selector) && selector.match(/^\s*$/) ) ){

    if( onlyThisGroup == null ){
      // ignore
      self.length = 0;
    } else {
      self[0] = newQuery();
      self[0].group = onlyThisGroup;
      self.length = 1;
    }

  } else if( is.elementOrCollection( selector ) ){
    var collection = selector.collection();

    self[0] = newQuery();
    self[0].collection = collection;
    self.length = 1;

  } else if( is.fn( selector ) ) {
    self[0] = newQuery();
    self[0].filter = selector;
    self.length = 1;

  } else if( is.string( selector ) ){

    // the current subject in the query
    var currentSubject = null;

    // storage for parsed queries
    var newQuery = function(){
      return {
        classes: [],
        colonSelectors: [],
        data: [],
        group: null,
        ids: [],
        meta: [],

        // fake selectors
        collection: null, // a collection to match against
        filter: null, // filter function

        // these are defined in the upward direction rather than down (e.g. child)
        // because we need to go up in Selector.filter()
        parent: null, // parent query obj
        ancestor: null, // ancestor query obj
        subject: null, // defines subject in compound query (subject query obj; points to self if subject)

        // use these only when subject has been defined
        child: null,
        descendant: null
      };
    };

    // tokens in the query language
    var tokens = {
      metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in var names, etc
      comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
      boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
      string: '"(?:\\\\"|[^"])+"' + '|' + "'(?:\\\\'|[^'])+'", // string literals (used in data selectors) -- doublequotes | singlequotes
      number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
      meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)
      separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
      descendant: '\\s+',
      child: '\\s+>\\s+',
      subject: '\\$'
    };
    tokens.variable = '(?:[\\w-]|(?:\\\\'+ tokens.metaChar +'))+'; // a variable name
    tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
    tokens.className = tokens.variable; // a class name (follows variable conventions)
    tokens.id = tokens.variable; // an element id (follows variable conventions)

    // when a token like a variable has escaped meta characters, we need to clean the backslashes out
    // so that values get compared properly in Selector.filter()
    var cleanMetaChars = function(str){
      return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function(match, $1, offset, original){
        return $1;
      });
    };

    // add @ variants to comparatorOp
    var ops = tokens.comparatorOp.split('|');
    for( var i = 0; i < ops.length; i++ ){
      var op = ops[i];
      tokens.comparatorOp += '|@' + op;
    }

    // add ! variants to comparatorOp
    var ops = tokens.comparatorOp.split('|');
    for( var i = 0; i < ops.length; i++ ){
      var op = ops[i];

      if( op.indexOf('!') >= 0 ){ continue; } // skip ops that explicitly contain !
      if( op === '=' ){ continue; } // skip = b/c != is explicitly defined

      tokens.comparatorOp += '|\\!' + op;
    }

    // NOTE: add new expression syntax here to have it recognised by the parser;
    // - a query contains all adjacent (i.e. no separator in between) expressions;
    // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;
    // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
    // - when you add something here, also add to Selector.toString()
    var exprs = [
      {
        name: 'group',
        query: true,
        regex: '(node|edge|\\*)',
        populate: function( group ){
          this.group = group == "*" ? group : group + 's';
        }
      },

      {
        name: 'state',
        query: true,
        // NB: if one colon selector is a substring of another from its start, place the longer one first
        // e.g. :foobar|:foo
        regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch|:backgrounding|:nonbackgrounding)',
        populate: function( state ){
          this.colonSelectors.push( state );
        }
      },

      {
        name: 'id',
        query: true,
        regex: '\\#('+ tokens.id +')',
        populate: function( id ){
          this.ids.push( cleanMetaChars(id) );
        }
      },

      {
        name: 'className',
        query: true,
        regex: '\\.('+ tokens.className +')',
        populate: function( className ){
          this.classes.push( cleanMetaChars(className) );
        }
      },

      {
        name: 'dataExists',
        query: true,
        regex: '\\[\\s*('+ tokens.variable +')\\s*\\]',
        populate: function( variable ){
          this.data.push({
            field: cleanMetaChars(variable)
          });
        }
      },

      {
        name: 'dataCompare',
        query: true,
        regex: '\\[\\s*('+ tokens.variable +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.value +')\\s*\\]',
        populate: function( variable, comparatorOp, value ){
          var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

          if( valueIsString ){
            value = value.substring(1, value.length - 1);
          } else {
            value = parseFloat(value);
          }

          this.data.push({
            field: cleanMetaChars(variable),
            operator: comparatorOp,
            value: value
          });
        }
      },

      {
        name: 'dataBool',
        query: true,
        regex: '\\[\\s*('+ tokens.boolOp +')\\s*('+ tokens.variable +')\\s*\\]',
        populate: function( boolOp, variable ){
          this.data.push({
            field: cleanMetaChars(variable),
            operator: boolOp
          });
        }
      },

      {
        name: 'metaCompare',
        query: true,
        regex: '\\[\\[\\s*('+ tokens.meta +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.number +')\\s*\\]\\]',
        populate: function( meta, comparatorOp, number ){
          this.meta.push({
            field: cleanMetaChars(meta),
            operator: comparatorOp,
            value: parseFloat(number)
          });
        }
      },

      {
        name: 'nextQuery',
        separator: true,
        regex: tokens.separator,
        populate: function(){
          // go on to next query
          self[++i] = newQuery();
          currentSubject = null;
        }
      },

      {
        name: 'child',
        separator: true,
        regex: tokens.child,
        populate: function(){
          // this query is the parent of the following query
          var childQuery = newQuery();
          childQuery.parent = this;
          childQuery.subject = currentSubject;

          // we're now populating the child query with expressions that follow
          self[i] = childQuery;
        }
      },

      {
        name: 'descendant',
        separator: true,
        regex: tokens.descendant,
        populate: function(){
          // this query is the ancestor of the following query
          var descendantQuery = newQuery();
          descendantQuery.ancestor = this;
          descendantQuery.subject = currentSubject;

          // we're now populating the descendant query with expressions that follow
          self[i] = descendantQuery;
        }
      },

      {
        name: 'subject',
        modifier: true,
        regex: tokens.subject,
        populate: function(){
          if( currentSubject != null && this.subject != this ){
            util.error('Redefinition of subject in selector `' + selector + '`');
            return false;
          }

          currentSubject = this;
          this.subject = this;
        }

      }
    ];

    self._private.selectorText = selector;
    var remaining = selector;
    var i = 0;

    // of all the expressions, find the first match in the remaining text
    var consumeExpr = function( expectation ){
      var expr;
      var match;
      var name;

      for( var j = 0; j < exprs.length; j++ ){
        var e = exprs[j];
        var n = e.name;

        // ignore this expression if it doesn't meet the expectation function
        if( is.fn( expectation ) && !expectation(n, e) ){ continue; }

        var m = remaining.match(new RegExp( '^' + e.regex ));

        if( m != null ){
          match = m;
          expr = e;
          name = n;

          var consumed = m[0];
          remaining = remaining.substring( consumed.length );

          break; // we've consumed one expr, so we can return now
        }
      }

      return {
        expr: expr,
        match: match,
        name: name
      };
    };

    // consume all leading whitespace
    var consumeWhitespace = function(){
      var match = remaining.match(/^\s+/);

      if( match ){
        var consumed = match[0];
        remaining = remaining.substring( consumed.length );
      }
    };

    self[0] = newQuery(); // get started

    consumeWhitespace(); // get rid of leading whitespace
    for(;;){
      var check = consumeExpr();

      if( check.expr == null ){
        util.error('The selector `'+ selector +'`is invalid');
        return;
      } else {
        var args = [];
        for(var j = 1; j < check.match.length; j++){
          args.push( check.match[j] );
        }

        // let the token populate the selector object (i.e. in self[i])
        var ret = check.expr.populate.apply( self[i], args );

        if( ret === false ){ return; } // exit if population failed
      }

      // we're done when there's nothing left to parse
      if( remaining.match(/^\s*$/) ){
        break;
      }
    }

    self.length = i + 1;

    // adjust references for subject
    for(var j = 0; j < self.length; j++){
      var query = self[j];

      if( query.subject != null ){
        // go up the tree until we reach the subject
        for(;;){
          if( query.subject == query ){ break; } // done if subject is self

          if( query.parent != null ){ // swap parent/child reference
            var parent = query.parent;
            var child = query;

            child.parent = null;
            parent.child = child;

            query = parent; // go up the tree
          } else if( query.ancestor != null ){ // swap ancestor/descendant
            var ancestor = query.ancestor;
            var descendant = query;

            descendant.ancestor = null;
            ancestor.descendant = descendant;

            query = ancestor; // go up the tree
          } else {
            util.error('When adjusting references for the selector `'+ query +'`, neither parent nor ancestor was found');
            break;
          }
        } // for

        self[j] = query.subject; // subject should be the root query
      } // if
    } // for

    // make sure for each query that the subject group matches the implicit group if any
    if( onlyThisGroup != null ){
      for(var j = 0; j < self.length; j++){
        if( self[j].group != null && self[j].group != onlyThisGroup ){
          util.error('Group `'+ self[j].group +'` conflicts with implicit group `'+ onlyThisGroup +'` in selector `'+ selector +'`');
          return;
        }

        self[j].group = onlyThisGroup; // set to implicit group
      }
    }

  } else {
    util.error('A selector must be created from a string; found ' + selector);
    return;
  }

  self._private.invalid = false;

};

var selfn = Selector.prototype;

selfn.size = function(){
  return this.length;
};

selfn.eq = function(i){
  return this[i];
};

var queryMatches = function(query, element){
  // check group
  if( query.group != null && query.group != '*' && query.group != element._private.group ){
    return false;
  }

  var cy = element.cy();

  // check colon selectors
  var allColonSelectorsMatch = true;
  for(var k = 0; k < query.colonSelectors.length; k++){
    var sel = query.colonSelectors[k];

    switch(sel){
    case ':selected':
      allColonSelectorsMatch = element.selected();
      break;
    case ':unselected':
      allColonSelectorsMatch = !element.selected();
      break;
    case ':selectable':
      allColonSelectorsMatch = element.selectable();
      break;
    case ':unselectable':
      allColonSelectorsMatch = !element.selectable();
      break;
    case ':locked':
      allColonSelectorsMatch = element.locked();
      break;
    case ':unlocked':
      allColonSelectorsMatch = !element.locked();
      break;
    case ':visible':
      allColonSelectorsMatch = element.visible();
      break;
    case ':hidden':
      allColonSelectorsMatch = !element.visible();
      break;
    case ':transparent':
      allColonSelectorsMatch = element.transparent();
      break;
    case ':grabbed':
      allColonSelectorsMatch = element.grabbed();
      break;
    case ':free':
      allColonSelectorsMatch = !element.grabbed();
      break;
    case ':removed':
      allColonSelectorsMatch = element.removed();
      break;
    case ':inside':
      allColonSelectorsMatch = !element.removed();
      break;
    case ':grabbable':
      allColonSelectorsMatch = element.grabbable();
      break;
    case ':ungrabbable':
      allColonSelectorsMatch = !element.grabbable();
      break;
    case ':animated':
      allColonSelectorsMatch = element.animated();
      break;
    case ':unanimated':
      allColonSelectorsMatch = !element.animated();
      break;
    case ':parent':
      allColonSelectorsMatch = element.isNode() && element.children().nonempty();
      break;
    case ':child':
    case ':nonorphan':
      allColonSelectorsMatch = element.isNode() && element.parent().nonempty();
      break;
    case ':orphan':
      allColonSelectorsMatch = element.isNode() && element.parent().empty();
      break;
    case ':loop':
      allColonSelectorsMatch = element.isEdge() && element.data('source') === element.data('target');
      break;
    case ':simple':
      allColonSelectorsMatch = element.isEdge() && element.data('source') !== element.data('target');
      break;
    case ':active':
      allColonSelectorsMatch = element.active();
      break;
    case ':inactive':
      allColonSelectorsMatch = !element.active();
      break;
    case ':touch':
      allColonSelectorsMatch = is.touch();
      break;
    case ':backgrounding':
      allColonSelectorsMatch = element.backgrounding();
      break;
    case ':nonbackgrounding':
      allColonSelectorsMatch = !element.backgrounding();
      break;
    }

    if( !allColonSelectorsMatch ) break;
  }
  if( !allColonSelectorsMatch ) return false;

  // check id
  var allIdsMatch = true;
  for(var k = 0; k < query.ids.length; k++){
    var id = query.ids[k];
    var actualId = element._private.data.id;

    allIdsMatch = allIdsMatch && (id == actualId);

    if( !allIdsMatch ) break;
  }
  if( !allIdsMatch ) return false;

  // check classes
  var allClassesMatch = true;
  for(var k = 0; k < query.classes.length; k++){
    var cls = query.classes[k];

    allClassesMatch = allClassesMatch && element.hasClass(cls);

    if( !allClassesMatch ) break;
  }
  if( !allClassesMatch ) return false;

  // generic checking for data/metadata
  var operandsMatch = function(params){
    var allDataMatches = true;
    for(var k = 0; k < query[params.name].length; k++){
      var data = query[params.name][k];
      var operator = data.operator;
      var value = data.value;
      var field = data.field;
      var matches;

      if( operator != null && value != null ){

        var fieldVal = params.fieldValue(field);
        var fieldStr = !is.string(fieldVal) && !is.number(fieldVal) ? '' : '' + fieldVal;
        var valStr = '' + value;

        var caseInsensitive = false;
        if( operator.indexOf('@') >= 0 ){
          fieldStr = fieldStr.toLowerCase();
          valStr = valStr.toLowerCase();

          operator = operator.replace('@', '');
          caseInsensitive = true;
        }

        var notExpr = false;
        var handledNotExpr = false;
        if( operator.indexOf('!') >= 0 ){
          operator = operator.replace('!', '');
          notExpr = true;
        }

        // if we're doing a case insensitive comparison, then we're using a STRING comparison
        // even if we're comparing numbers
        if( caseInsensitive ){
          value = valStr.toLowerCase();
          fieldVal = fieldStr.toLowerCase();
        }

        switch(operator){
        case '*=':
          matches = fieldStr.search(valStr) >= 0;
          break;
        case '$=':
          matches = new RegExp(valStr + '$').exec(fieldStr) != null;
          break;
        case '^=':
          matches = new RegExp('^' + valStr).exec(fieldStr) != null;
          break;
        case '=':
          matches = fieldVal === value;
          break;
        case '!=':
          matches = fieldVal !== value;
          break;
        case '>':
          matches = !notExpr ? fieldVal > value : fieldVal <= value;
          handledNotExpr = true;
          break;
        case '>=':
          matches = !notExpr ? fieldVal >= value : fieldVal < value;
          handledNotExpr = true;
          break;
        case '<':
          matches = !notExpr ? fieldVal < value : fieldVal >= value;
          handledNotExpr = true;
          break;
        case '<=':
          matches = !notExpr ? fieldVal <= value : fieldVal > value;
          handledNotExpr = true;
          break;
        default:
          matches = false;
          break;

        }
      } else if( operator != null ){
        switch(operator){
        case '?':
          matches = params.fieldTruthy(field);
          break;
        case '!':
          matches = !params.fieldTruthy(field);
          break;
        case '^':
          matches = params.fieldUndefined(field);
          break;
        }
      } else {
        matches = !params.fieldUndefined(field);
      }

      if( notExpr && !handledNotExpr ){
        matches = !matches;
        handledNotExpr = true;
      }

      if( !matches ){
        allDataMatches = false;
        break;
      }
    } // for

    return allDataMatches;
  }; // operandsMatch

  // check data matches
  var allDataMatches = operandsMatch({
    name: 'data',
    fieldValue: function(field){
      return element._private.data[field];
    },
    fieldRef: function(field){
      return 'element._private.data.' + field;
    },
    fieldUndefined: function(field){
      return element._private.data[field] === undefined;
    },
    fieldTruthy: function(field){
      if( element._private.data[field] ){
        return true;
      }
      return false;
    }
  });

  if( !allDataMatches ){
    return false;
  }

  // check metadata matches
  var allMetaMatches = operandsMatch({
    name: 'meta',
    fieldValue: function(field){
      return element[field]();
    },
    fieldRef: function(field){
      return 'element.' + field + '()';
    },
    fieldUndefined: function(field){
      return element[field]() == null;
    },
    fieldTruthy: function(field){
      if( element[field]() ){
        return true;
      }
      return false;
    }
  });

  if( !allMetaMatches ){
    return false;
  }

  // check collection
  if( query.collection != null ){
    var matchesAny = query.collection._private.ids[ element.id() ] != null;

    if( !matchesAny ){
      return false;
    }
  }

  // check filter function
  if( query.filter != null && element.collection().filter( query.filter ).size() === 0 ){
    return false;
  }


  // check parent/child relations
  var confirmRelations = function( query, elements ){
    if( query != null ){
      var matches = false;

      if( !cy.hasCompoundNodes() ){
        return false;
      }

      elements = elements(); // make elements functional so we save cycles if query == null

      // query must match for at least one element (may be recursive)
      for(var i = 0; i < elements.length; i++){
        if( queryMatches( query, elements[i] ) ){
          matches = true;
          break;
        }
      }

      return matches;
    } else {
      return true;
    }
  };

  if (! confirmRelations(query.parent, function(){
    return element.parent();
  }) ){ return false; }

  if (! confirmRelations(query.ancestor, function(){
    return element.parents();
  }) ){ return false; }

  if (! confirmRelations(query.child, function(){
    return element.children();
  }) ){ return false; }

  if (! confirmRelations(query.descendant, function(){
    return element.descendants();
  }) ){ return false; }

  // we've reached the end, so we've matched everything for this query
  return true;
}; // queryMatches

// filter an existing collection
selfn.filter = function(collection){
  var self = this;
  var cy = collection.cy();

  // don't bother trying if it's invalid
  if( self._private.invalid ){
    return cy.collection();
  }

  var selectorFunction = function(i, element){
    for(var j = 0; j < self.length; j++){
      var query = self[j];

      if( queryMatches(query, element) ){
        return true;
      }
    }

    return false;
  };

  if( self._private.selectorText == null ){
    selectorFunction = function(){ return true; };
  }

  var filteredCollection = collection.filter( selectorFunction );

  return filteredCollection;
}; // filter

// does selector match a single element?
selfn.matches = function(ele){
  var self = this;

  // don't bother trying if it's invalid
  if( self._private.invalid ){
    return false;
  }

  for(var j = 0; j < self.length; j++){
    var query = self[j];

    if( queryMatches(query, ele) ){
      return true;
    }
  }

  return false;
}; // filter

// ith query to string
selfn.toString = selfn.selector = function(){

  var str = '';

  var clean = function(obj, isValue){
    if( is.string(obj) ){
      return isValue ? '"' + obj + '"' : obj;
    }
    return '';
  };

  var queryToString = function(query){
    var str = '';

    if( query.subject === query ){
      str += '$';
    }

    var group = clean(query.group);
    str += group.substring(0, group.length - 1);

    for(var j = 0; j < query.data.length; j++){
      var data = query.data[j];

      if( data.value ){
        str += '[' + data.field + clean(data.operator) + clean(data.value, true) + ']';
      } else {
        str += '[' + clean(data.operator) + data.field + ']';
      }
    }

    for(var j = 0; j < query.meta.length; j++){
      var meta = query.meta[j];
      str += '[[' + meta.field + clean(meta.operator) + clean(meta.value, true) + ']]';
    }

    for(var j = 0; j < query.colonSelectors.length; j++){
      var sel = query.colonSelectors[i];
      str += sel;
    }

    for(var j = 0; j < query.ids.length; j++){
      var sel = '#' + query.ids[i];
      str += sel;
    }

    for(var j = 0; j < query.classes.length; j++){
      var sel = '.' + query.classes[j];
      str += sel;
    }

    if( query.parent != null ){
      str = queryToString( query.parent ) + ' > ' + str;
    }

    if( query.ancestor != null ){
      str = queryToString( query.ancestor ) + ' ' + str;
    }

    if( query.child != null ){
      str += ' > ' + queryToString( query.child );
    }

    if( query.descendant != null ){
      str += ' ' + queryToString( query.descendant );
    }

    return str;
  };

  for(var i = 0; i < this.length; i++){
    var query = this[i];

    str += queryToString( query );

    if( this.length > 1 && i < this.length - 1 ){
      str += ', ';
    }
  }

  return str;
};

module.exports = Selector;

},{"./is":77,"./util":94}],82:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

var styfn = {};

// (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it
styfn.apply = function( eles ){
  var self = this;

  if( self._private.newStyle ){ // clear style caches
    this._private.contextStyles = {};
    this._private.propDiffs = {};
  }

  for( var ie = 0; ie < eles.length; ie++ ){
    var ele = eles[ie];
    var cxtMeta = self.getContextMeta( ele );
    var cxtStyle = self.getContextStyle( cxtMeta );
    var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );

    self.updateTransitions( ele, app.diffProps );
    self.updateStyleHints( ele );

  } // for elements

  self._private.newStyle = false;
};

styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){
  var self = this;
  var cache = self._private.propDiffs = self._private.propDiffs || {};
  var dualCxtKey = oldCxtKey + '-' + newCxtKey;
  var cachedVal = cache[dualCxtKey];

  if( cachedVal ){
    return cachedVal;
  }

  var diffProps = [];
  var addedProp = {};

  for( var i = 0; i < self.length; i++ ){
    var cxt = self[i];
    var oldHasCxt = oldCxtKey[i] === 't';
    var newHasCxt = newCxtKey[i] === 't';
    var cxtHasDiffed = oldHasCxt !== newHasCxt;
    var cxtHasMappedProps = cxt.mappedProperties.length > 0;

    if( cxtHasDiffed || cxtHasMappedProps ){
      var props;

      if( cxtHasDiffed && cxtHasMappedProps ){
        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
      } else if( cxtHasDiffed ){
        props = cxt.properties; // need to check them all
      } else if( cxtHasMappedProps ){
        props = cxt.mappedProperties; // only need to check mapped
      }

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];
        var name = prop.name;

        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
        // is cached)
        var laterCxtOverrides = false;
        for( var k = i + 1; k < self.length; k++ ){
          var laterCxt = self[k];
          var hasLaterCxt = newCxtKey[k] === 't';

          if( !hasLaterCxt ){ continue; } // can't override unless the context is active

          laterCxtOverrides = laterCxt.properties[ prop.name ] != null;

          if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides
        }

        if( !addedProp[name] && !laterCxtOverrides ){
          addedProp[name] = true;
          diffProps.push( name );
        }
      } // for props
    } // if

  } // for contexts

  cache[ dualCxtKey ] = diffProps;
  return diffProps;
};

styfn.getContextMeta = function( ele ){
  var self = this;
  var cxtKey = '';
  var diffProps;
  var prevKey = ele._private.styleCxtKey || '';

  if( self._private.newStyle ){
    prevKey = ''; // since we need to apply all style if a fresh stylesheet
  }

  // get the cxt key
  for( var i = 0; i < self.length; i++ ){
    var context = self[i];
    var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'

    if( contextSelectorMatches ){
      cxtKey += 't';
    } else {
      cxtKey += 'f';
    }
  } // for context

  diffProps = self.getPropertiesDiff( prevKey, cxtKey );

  ele._private.styleCxtKey = cxtKey;

  return {
    key: cxtKey,
    diffPropNames: diffProps
  };
};

// gets a computed ele style object based on matched contexts
styfn.getContextStyle = function( cxtMeta ){
  var cxtKey = cxtMeta.key;
  var self = this;
  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

  // if already computed style, returned cached copy
  if( cxtStyles[cxtKey] ){ return cxtStyles[cxtKey]; }

  var style = {
    _private: {
      key: cxtKey
    }
  };

  for( var i = 0; i < self.length; i++ ){
    var cxt = self[i];
    var hasCxt = cxtKey[i] === 't';

    if( !hasCxt ){ continue; }

    for( var j = 0; j < cxt.properties.length; j++ ){
      var prop = cxt.properties[j];
      var styProp = style[ prop.name ] = prop;

      styProp.context = cxt;
    }
  }

  cxtStyles[cxtKey] = style;
  return style;
};

styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){
  var self = this;
  var diffProps = cxtMeta.diffPropNames;
  var retDiffProps = {};

  for( var i = 0; i < diffProps.length; i++ ){
    var diffPropName = diffProps[i];
    var cxtProp = cxtStyle[ diffPropName ];
    var eleProp = ele._private.style[ diffPropName ];

    // save cycles when the context prop doesn't need to be applied
    if( !cxtProp || eleProp === cxtProp ){ continue; }

    var retDiffProp = retDiffProps[ diffPropName ] = {
      prev: eleProp
    };

    self.applyParsedProperty( ele, cxtProp );

    retDiffProp.next = ele._private.style[ diffPropName ];

    if( retDiffProp.next && retDiffProp.next.bypass ){
      retDiffProp.next = retDiffProp.next.bypassed;
    }
  }

  return {
    diffProps: retDiffProps
  };
};

styfn.updateStyleHints = function(ele){
  var _p = ele._private;
  var self = this;
  var style = _p.style;

  if( ele.removed() ){ return; }

  // set whether has pie or not; for greater efficiency
  var hasPie = false;
  if( _p.group === 'nodes' && self._private.hasPie ){
    for( var i = 1; i <= self.pieBackgroundN; i++ ){ // 1..N
      var size = _p.style['pie-' + i + '-background-size'].value;

      if( size > 0 ){
        hasPie = true;
        break;
      }
    }
  }

  _p.hasPie = hasPie;

  var transform = style['text-transform'].strValue;
  var content = style['label'].strValue;
  var fStyle = style['font-style'].strValue;
  var size = style['font-size'].pfValue + 'px';
  var family = style['font-family'].strValue;
  // var variant = style['font-variant'].strValue;
  var weight = style['font-weight'].strValue;
  var valign = style['text-valign'].strValue;
  var halign = style['text-valign'].strValue;
  var oWidth = style['text-outline-width'].pfValue;
  var wrap = style['text-wrap'].strValue;
  var wrapW = style['text-max-width'].pfValue;
  _p.labelKey = fStyle +'$'+ size +'$'+ family +'$'+ weight +'$'+ content +'$'+ transform +'$'+ valign +'$'+ halign +'$'+ oWidth + '$' + wrap + '$' + wrapW;
  _p.fontKey = fStyle +'$'+ weight +'$'+ size +'$'+ family;

  var width = style['width'].pfValue;
  var height = style['height'].pfValue;
  var borderW = style['border-width'].pfValue;
  _p.boundingBoxKey = width +'$'+ height +'$'+ borderW;

  if( ele._private.group === 'edges' ){
    var cpss = style['control-point-step-size'].pfValue;
    var cpd = style['control-point-distances'] ? style['control-point-distances'].pfValue.join('_') : undefined;
    var cpw = style['control-point-weights'].value.join('_');
    var curve = style['curve-style'].strValue;
    var sd = style['segment-distances'] ? style['segment-distances'].pfValue.join('_') : undefined;
    var sw = style['segment-weights'].value.join('_');

    _p.boundingBoxKey += '$'+ cpss +'$'+ cpd +'$'+ cpw +'$'+ sd +'$'+ sw +'$'+ curve;
  }

  _p.styleKey = Date.now();
};

// apply a property to the style (for internal use)
// returns whether application was successful
//
// now, this function flattens the property, and here's how:
//
// for parsedProp:{ bypass: true, deleteBypass: true }
// no property is generated, instead the bypass property in the
// element's style is replaced by what's pointed to by the `bypassed`
// field in the bypass property (i.e. restoring the property the
// bypass was overriding)
//
// for parsedProp:{ mapped: truthy }
// the generated flattenedProp:{ mapping: prop }
//
// for parsedProp:{ bypass: true }
// the generated flattenedProp:{ bypassed: parsedProp }
styfn.applyParsedProperty = function( ele, parsedProp ){
  var self = this;
  var prop = parsedProp;
  var style = ele._private.style;
  var fieldVal, flatProp;
  var types = self.types;
  var type = self.properties[ prop.name ].type;
  var propIsBypass = prop.bypass;
  var origProp = style[ prop.name ];
  var origPropIsBypass = origProp && origProp.bypass;
  var _p = ele._private;

  // can't apply auto to width or height unless it's a parent node
  if( (parsedProp.name === 'height' || parsedProp.name === 'width') && ele.isNode() ){
    if( parsedProp.value === 'auto' && !ele.isParent() ){
      return false;
    } else if( parsedProp.value !== 'auto' && ele.isParent() ){
      prop = parsedProp = this.parse( parsedProp.name, 'auto', propIsBypass );
    }
  }

  // check if we need to delete the current bypass
  if( propIsBypass && prop.deleteBypass ){ // then this property is just here to indicate we need to delete
    var currentProp = style[ prop.name ];

    // can only delete if the current prop is a bypass and it points to the property it was overriding
    if( !currentProp ){
      return true; // property is already not defined
    } else if( currentProp.bypass && currentProp.bypassed ){ // then replace the bypass property with the original

      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
      style[ prop.name ] = currentProp.bypassed;
      return true;

    } else {
      return false; // we're unsuccessful deleting the bypass
    }
  }

  var printMappingErr = function(){
    util.error('Do not assign mappings to elements without corresponding data (e.g. ele `'+ ele.id() +'` for property `'+ prop.name +'` with data field `'+ prop.field +'`); try a `['+ prop.field +']` selector to limit scope to elements with `'+ prop.field +'` defined');
  };

  // put the property in the style objects
  switch( prop.mapped ){ // flatten the property if mapped
  case types.mapData:
  case types.mapLayoutData:
  case types.mapScratch:

    var isLayout = prop.mapped === types.mapLayoutData;
    var isScratch = prop.mapped === types.mapScratch;

    // flatten the field (e.g. data.foo.bar)
    var fields = prop.field.split(".");
    var fieldVal;

    if( isScratch || isLayout ){
      fieldVal = _p.scratch;
    } else {
      fieldVal = _p.data;
    }

    for( var i = 0; i < fields.length && fieldVal; i++ ){
      var field = fields[i];
      fieldVal = fieldVal[ field ];
    }

    var percent;
    if( !is.number(fieldVal) ){ // then keep the mapping but assume 0% for now
      percent = 0;
    } else {
      percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
    }

    // make sure to bound percent value
    if( percent < 0 ){
      percent = 0;
    } else if( percent > 1 ){
      percent = 1;
    }

    if( type.color ){
      var r1 = prop.valueMin[0];
      var r2 = prop.valueMax[0];
      var g1 = prop.valueMin[1];
      var g2 = prop.valueMax[1];
      var b1 = prop.valueMin[2];
      var b2 = prop.valueMax[2];
      var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
      var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

      var clr = [
        Math.round( r1 + (r2 - r1)*percent ),
        Math.round( g1 + (g2 - g1)*percent ),
        Math.round( b1 + (b2 - b1)*percent ),
        Math.round( a1 + (a2 - a1)*percent )
      ];

      flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
        bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
        name: prop.name,
        value: clr,
        strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
      };

    } else if( type.number ){
      var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
      flatProp = this.parse( prop.name, calcValue, prop.bypass, true );

    } else {
      return false; // can only map to colours and numbers
    }

    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
      flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, true );
    }

    if( !flatProp ){ printMappingErr(); }
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  // direct mapping
  case types.data:
  case types.layoutData:
  case types.scratch:
    var isLayout = prop.mapped === types.layoutData;
    var isScratch = prop.mapped === types.scratch;

    // flatten the field (e.g. data.foo.bar)
    var fields = prop.field.split(".");
    var fieldVal;

    if( isScratch || isLayout ){
      fieldVal = _p.scratch;
    } else {
      fieldVal = _p.data;
    }

    if( fieldVal ){ for( var i = 0; i < fields.length; i++ ){
      var field = fields[i];
      fieldVal = fieldVal[ field ];
    } }

    flatProp = this.parse( prop.name, fieldVal, prop.bypass, true );

    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
      var flatPropVal = origProp ? origProp.strValue : '';

      flatProp = this.parse( prop.name, flatPropVal, prop.bypass, true );
    }

    if( !flatProp ){ printMappingErr(); }
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  case types.fn:
    var fn = prop.value;
    var fnRetVal = fn( ele );

    flatProp = this.parse( prop.name, fnRetVal, prop.bypass, true );
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  case undefined:
    break; // just set the property

  default:
    return false; // not a valid mapping
  }

  // if the property is a bypass property, then link the resultant property to the original one
  if( propIsBypass ){
    if( origPropIsBypass ){ // then this bypass overrides the existing one
      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
    } else { // then link the orig prop to the new bypass
      prop.bypassed = origProp;
    }

    style[ prop.name ] = prop; // and set

  } else { // prop is not bypass
    if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop
      origProp.bypassed = prop;
    } else { // then just replace the old prop with the new one
      style[ prop.name ] = prop;
    }
  }

  return true;
};

// updates the visual style for all elements (useful for manual style modification after init)
styfn.update = function(){
  var cy = this._private.cy;
  var eles = cy.elements();

  eles.updateStyle();
};

// just update the functional properties (i.e. mappings) in the elements'
// styles (less expensive than recalculation)
styfn.updateMappers = function( eles ){
  var self = this;

  for( var i = 0; i < eles.length; i++ ){ // for each ele
    var ele = eles[i];
    var style = ele._private.style;

    for( var j = 0; j < self.properties.length; j++ ){ // for each prop
      var prop = self.properties[j];
      var propInStyle = style[ prop.name ];

      if( propInStyle && propInStyle.mapping ){
        var mapping = propInStyle.mapping;
        this.applyParsedProperty( ele, mapping ); // reapply the mapping property
      }
    }

    this.updateStyleHints( ele );
  }
};

// diffProps : { name => { prev, next } }
styfn.updateTransitions = function( ele, diffProps, isBypass ){
  var self = this;
  var _p = ele._private;
  var style = _p.style;
  var props = style['transition-property'].value;
  var duration = style['transition-duration'].pfValue;
  var delay = style['transition-delay'].pfValue;
  var css = {};

  if( props.length > 0 && duration > 0 ){

    // build up the style to animate towards
    var anyPrev = false;
    for( var i = 0; i < props.length; i++ ){
      var prop = props[i];
      var styProp = style[ prop ];
      var diffProp = diffProps[ prop ];

      if( !diffProp ){ continue; }

      var prevProp = diffProp.prev;
      var fromProp = prevProp;
      var toProp = diffProp.next != null ? diffProp.next : styProp;
      var diff = false;
      var initVal;
      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

      if( !fromProp ){ continue; }

      // consider px values
      if( is.number( fromProp.pfValue ) && is.number( toProp.pfValue ) ){
        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy
        initVal = fromProp.pfValue + initDt * diff;

      // consider numerical values
      } else if( is.number( fromProp.value ) && is.number( toProp.value ) ){
        diff = toProp.value - fromProp.value; // nonzero is truthy
        initVal = fromProp.value + initDt * diff;

      // consider colour values
      } else if( is.array( fromProp.value ) && is.array( toProp.value ) ){
        diff = fromProp.value[0] !== toProp.value[0]
          || fromProp.value[1] !== toProp.value[1]
          || fromProp.value[2] !== toProp.value[2]
        ;

        initVal = fromProp.strValue;
      }

      // the previous value is good for an animation only if it's different
      if( diff ){
        css[ prop ] = toProp.strValue; // to val
        this.applyBypass( ele, prop, initVal ); // from val
        anyPrev = true;
      }

    } // end if props allow ani

    // can't transition if there's nothing previous to transition from
    if( !anyPrev ){ return; }

    _p.transitioning = true;

    ele.stop();

    if( delay > 0 ){
      ele.delay( delay );
    }

    ele.animate({
      css: css
    }, {
      duration: duration,
      easing: style['transition-timing-function'].value,
      queue: false,
      complete: function(){
        if( !isBypass ){
          self.removeBypasses( ele, props );
        }

        _p.transitioning = false;
      }
    });

  } else if( _p.transitioning ){
    ele.stop();

    this.removeBypasses( ele, props );

    _p.transitioning = false;
  }
};

module.exports = styfn;

},{"../is":77,"../util":94}],83:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var util = _dereq_('../util');

var styfn = {};

// bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property
styfn.applyBypass = function( eles, name, value, updateTransitions ){
  var self = this;
  var props = [];
  var isBypass = true;

  // put all the properties (can specify one or many) in an array after parsing them
  if( name === "*" || name === "**" ){ // apply to all property names

    if( value !== undefined ){
      for( var i = 0; i < self.properties.length; i++ ){
        var prop = self.properties[i];
        var name = prop.name;

        var parsedProp = this.parse(name, value, true);

        if( parsedProp ){
          props.push( parsedProp );
        }
      }
    }

  } else if( is.string(name) ){ // then parse the single property
    var parsedProp = this.parse(name, value, true);

    if( parsedProp ){
      props.push( parsedProp );
    }
  } else if( is.plainObject(name) ){ // then parse each property
    var specifiedProps = name;
    updateTransitions = value;

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[i];
      var name = prop.name;
      var value = specifiedProps[ name ];

      if( value === undefined ){ // try camel case name too
        value = specifiedProps[ util.dash2camel(name) ];
      }

      if( value !== undefined ){
        var parsedProp = this.parse(name, value, true);

        if( parsedProp ){
          props.push( parsedProp );
        }
      }
    }
  } else { // can't do anything without well defined properties
    return false;
  }

  // we've failed if there are no valid properties
  if( props.length === 0 ){ return false; }

  // now, apply the bypass properties on the elements
  var ret = false; // return true if at least one succesful bypass applied
  for( var i = 0; i < eles.length; i++ ){ // for each ele
    var ele = eles[i];
    var style = ele._private.style;
    var diffProps = {};
    var diffProp;

    for( var j = 0; j < props.length; j++ ){ // for each prop
      var prop = props[j];

      if( updateTransitions ){
        var prevProp = style[ prop.name ];
        diffProp = diffProps[ prop.name ] = { prev: prevProp };
      }

      ret = this.applyParsedProperty( ele, prop ) || ret;

      if( updateTransitions ){
        diffProp.next = style[ prop.name ];
      }

    } // for props

    if( ret ){
      this.updateStyleHints( ele );
    }

    if( updateTransitions ){
      this.updateTransitions( ele, diffProps, isBypass );
    }
  } // for eles

  return ret;
};

// only useful in specific cases like animation
styfn.overrideBypass = function( eles, name, value ){
  name = util.camel2dash(name);

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var prop = ele._private.style[ name ];
    var type = this.properties[ name ].type;
    var isColor = type.color;
    var isMulti = type.mutiple;

    if( !prop.bypass ){ // need a bypass if one doesn't exist
      this.applyBypass( ele, name, value );
      continue;
    }

    prop.value = value;

    if( prop.pfValue != null ){
      prop.pfValue = value;
    }

    if( isColor ){
      prop.strValue = 'rgb(' + value.join(',') + ')';
    } else if( isMulti ){
      prop.strValue = value.join(' ');
    } else {
      prop.strValue = '' + value;
    }
  }
};

styfn.removeAllBypasses = function( eles, updateTransitions ){
  return this.removeBypasses( eles, this.propertyNames, updateTransitions );
};

styfn.removeBypasses = function( eles, props, updateTransitions ){
  var isBypass = true;

  for( var j = 0; j < eles.length; j++ ){
    var ele = eles[j];
    var diffProps = {};
    var style = ele._private.style;

    for( var i = 0; i < props.length; i++ ){
      var name = props[i];
      var prop = this.properties[ name ];
      var value = ''; // empty => remove bypass
      var parsedProp = this.parse(name, value, true);
      var prevProp = style[ prop.name ];
      var diffProp = diffProps[ prop.name ] = { prev: prevProp };

      this.applyParsedProperty(ele, parsedProp);

      diffProp.next = style[ prop.name ];
    } // for props

    this.updateStyleHints( ele );

    if( updateTransitions ){
      this.updateTransitions( ele, diffProps, isBypass );
    }
  } // for eles
};

module.exports = styfn;

},{"../is":77,"../util":94}],84:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_('../window');

var styfn = {};

// gets what an em size corresponds to in pixels relative to a dom element
styfn.getEmSizeInPixels = function(){
  var px = this.containerCss('font-size');

  if( px != null ){
    return parseFloat( px );
  } else {
    return 1; // for headless
  }
};

// gets css property from the core container
styfn.containerCss = function( propName ){
  var cy = this._private.cy;
  var domElement = cy.container();

  if( window && domElement && window.getComputedStyle ){
    return window.getComputedStyle(domElement).getPropertyValue( propName );
  }
};

module.exports = styfn;

},{"../window":100}],85:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

var styfn = {};

// gets the rendered style for an element
styfn.getRenderedStyle = function( ele ){
  return this.getRawStyle( ele, true );
};

// gets the raw style for an element
styfn.getRawStyle = function( ele, isRenderedVal ){
  var self = this;
  var ele = ele[0]; // insure it's an element

  if( ele ){
    var rstyle = {};

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[i];
      var val = self.getStylePropertyValue( ele, prop.name, isRenderedVal );

      if( val ){
        rstyle[ prop.name ] = val;
        rstyle[ util.dash2camel(prop.name) ] = val;
      }
    }

    return rstyle;
  }
};

styfn.getStylePropertyValue = function( ele, propName, isRenderedVal ){
  var self = this;
  var ele = ele[0]; // insure it's an element

  if( ele ){
    var style = ele._private.style;
    var prop = self.properties[ propName ];
    var type = prop.type;
    var styleProp = style[ prop.name ];
    var zoom = ele.cy().zoom();

    if( styleProp ){
      var units = styleProp.units ? type.implicitUnits || 'px' : null;
      var val = units ? [].concat( styleProp.pfValue ).map(function( pfValue ){
        return ( pfValue * (isRenderedVal ? zoom : 1) ) + units;
      }).join(' ') : styleProp.strValue;

      return val;
    }
  }
};

// gets the value style for an element (useful for things like animations)
styfn.getValueStyle = function( ele ){
  var self = this;
  var rstyle = {};
  var style;
  var isEle = is.element(ele);

  if( isEle ){
    style = ele._private.style;
  } else {
    style = ele; // just passed the style itself
  }

  if( style ){
    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[i];
      var styleProp = style[ prop.name ] || style[ util.dash2camel(prop.name) ];

      if( styleProp !== undefined ){ // then make a prop of it
        if( is.plainObject( styleProp ) ){
          styleProp = this.parse( prop.name, styleProp.strValue );
        } else {
          styleProp = this.parse( prop.name, styleProp );
        }
      }

      if( styleProp ){
        rstyle[ prop.name ] = styleProp;
        rstyle[ util.dash2camel(prop.name) ] = styleProp;
      }
    }
  }

  return rstyle;
};

styfn.getPropsList = function( propsObj ){
  var self = this;
  var rstyle = [];
  var style = propsObj;
  var props = self.properties;

  if( style ){
    for( var name in style ){
      var val = style[name];
      var prop = props[name] || props[ util.camel2dash(name) ];
      var styleProp = this.parse( prop.name, val );

      rstyle.push( styleProp );
    }
  }

  return rstyle;
};

module.exports = styfn;

},{"../is":77,"../util":94}],86:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var util = _dereq_('../util');
var Selector = _dereq_('../selector');

var Style = function( cy ){

  if( !(this instanceof Style) ){
    return new Style(cy);
  }

  if( !is.core(cy) ){
    util.error('A style must have a core reference');
    return;
  }

  this._private = {
    cy: cy,
    coreStyle: {},
    newStyle: true
  };

  this.length = 0;

  this.addDefaultStylesheet();
};

var styfn = Style.prototype;

styfn.instanceString = function(){
  return 'style';
};

// remove all contexts
styfn.clear = function(){
  for( var i = 0; i < this.length; i++ ){
    this[i] = undefined;
  }
  this.length = 0;
  this._private.newStyle = true;

  return this; // chaining
};

styfn.resetToDefault = function(){
  this.clear();
  this.addDefaultStylesheet();

  return this;
};

// builds a style object for the 'core' selector
styfn.core = function(){
  return this._private.coreStyle;
};

// create a new context from the specified selector string and switch to that context
styfn.selector = function( selectorStr ){
  // 'core' is a special case and does not need a selector
  var selector = selectorStr === 'core' ? null : new Selector( selectorStr );

  var i = this.length++; // new context means new index
  this[i] = {
    selector: selector,
    properties: [],
    mappedProperties: [],
    index: i
  };

  return this; // chaining
};

// add one or many css rules to the current context
styfn.css = function(){
  var self = this;
  var args = arguments;

  switch( args.length ){
  case 1:
    var map = args[0];

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[i];
      var mapVal = map[ prop.name ];

      if( mapVal === undefined ){
        mapVal = map[ util.dash2camel(prop.name) ];
      }

      if( mapVal !== undefined ){
        this.cssRule( prop.name, mapVal );
      }
    }

    break;

  case 2:
    this.cssRule( args[0], args[1] );
    break;

  default:
    break; // do nothing if args are invalid
  }

  return this; // chaining
};
styfn.style = styfn.css;

// add a single css rule to the current context
styfn.cssRule = function( name, value ){
  // name-value pair
  var property = this.parse( name, value );

  // add property to current context if valid
  if( property ){
    var i = this.length - 1;
    this[i].properties.push( property );
    this[i].properties[ property.name ] = property; // allow access by name as well

    if( property.name.match(/pie-(\d+)-background-size/) && property.value ){
      this._private.hasPie = true;
    }

    if( property.mapped ){
      this[i].mappedProperties.push( property );
    }

    // add to core style if necessary
    var currentSelectorIsCore = !this[i].selector;
    if( currentSelectorIsCore ){
      this._private.coreStyle[ property.name ] = property;
    }
  }

  return this; // chaining
};

// static function
Style.fromJson = function( cy, json ){
  var style = new Style( cy );

  style.fromJson( json );

  return style;
};

Style.fromString = function( cy, string ){
  return new Style( cy ).fromString( string );
};

[
  _dereq_('./apply'),
  _dereq_('./bypass'),
  _dereq_('./container'),
  _dereq_('./get-for-ele'),
  _dereq_('./json'),
  _dereq_('./string-sheet'),
  _dereq_('./properties'),
  _dereq_('./parse')
].forEach(function( props ){
  util.extend( styfn, props );
});


Style.types = styfn.types;
Style.properties = styfn.properties;

module.exports = Style;

},{"../is":77,"../selector":81,"../util":94,"./apply":82,"./bypass":83,"./container":84,"./get-for-ele":85,"./json":87,"./parse":88,"./properties":89,"./string-sheet":90}],87:[function(_dereq_,module,exports){
'use strict';

var styfn = {};

styfn.applyFromJson = function( json ){
  var style = this;

  for( var i = 0; i < json.length; i++ ){
    var context = json[i];
    var selector = context.selector;
    var props = context.style || context.css;

    style.selector( selector ); // apply selector

    for( var name in props ){
      var value = props[name];

      style.css( name, value ); // apply property
    }
  }

  return style;
};

// accessible cy.style() function
styfn.fromJson = function( json ){
  var style = this;

  style.resetToDefault();
  style.applyFromJson( json );

  return style;
};

// get json from cy.style() api
styfn.json = function(){
  var json = [];

  for( var i = this.defaultLength; i < this.length; i++ ){
    var cxt = this[i];
    var selector = cxt.selector;
    var props = cxt.properties;
    var css = {};

    for( var j = 0; j < props.length; j++ ){
      var prop = props[j];
      css[ prop.name ] = prop.strValue;
    }

    json.push({
      selector: !selector ? 'core' : selector.toString(),
      style: css
    });
  }

  return json;
};

module.exports = styfn;

},{}],88:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

var styfn = {};

// a caching layer for property parsing
styfn.parse = function( name, value, propIsBypass, propIsFlat ){
  var argHash = [ name, value, propIsBypass, propIsFlat ].join('$');
  var propCache = this.propCache = this.propCache || {};
  var ret;
  var impl = parseImpl.bind( this );

  if( !(ret = propCache[argHash]) ){
    ret = propCache[argHash] = impl( name, value, propIsBypass, propIsFlat );
  }

  // always need a copy since props are mutated later in their lifecycles
  ret = util.copy( ret );

  if( ret ){
    ret.value = util.copy( ret.value ); // because it could be an array, e.g. colour
  }

  return ret;
};

// parse a property; return null on invalid; return parsed property otherwise
// fields :
// - name : the name of the property
// - value : the parsed, native-typed value of the property
// - strValue : a string value that represents the property value in valid css
// - bypass : true iff the property is a bypass property
var parseImpl = function( name, value, propIsBypass, propIsFlat ){
  var self = this;

  name = util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

  var property = self.properties[ name ];
  var passedValue = value;
  var types = self.types;

  if( !property ){ return null; } // return null on property of unknown name
  if( value === undefined || value === null ){ return null; } // can't assign null

  // the property may be an alias
  if( property.alias ){
    property = property.pointsTo;
    name = property.name;
  }

  var valueIsString = is.string(value);
  if( valueIsString ){ // trim the value to make parsing easier
    value = value.trim();
  }

  var type = property.type;
  if( !type ){ return null; } // no type, no luck

  // check if bypass is null or empty string (i.e. indication to delete bypass property)
  if( propIsBypass && (value === '' || value === null) ){
    return {
      name: name,
      value: value,
      bypass: true,
      deleteBypass: true
    };
  }

  // check if value is a function used as a mapper
  if( is.fn(value) ){
    return {
      name: name,
      value: value,
      strValue: 'fn',
      mapped: types.fn,
      bypass: propIsBypass
    };
  }

  // check if value is mapped
  var data, mapData, layoutData, mapLayoutData, scratch, mapScratch;
  if( !valueIsString || propIsFlat ){
    // then don't bother to do the expensive regex checks

  } else if(
    ( data = new RegExp( types.data.regex ).exec( value ) ) ||
    ( layoutData = new RegExp( types.layoutData.regex ).exec( value ) ) ||
    ( scratch = new RegExp( types.scratch.regex ).exec( value ) )
  ){
    if( propIsBypass ){ return false; } // mappers not allowed in bypass

    var mapped;
    if( data ){
      mapped = types.data;
    } else if( layoutData ){
      mapped = types.layoutData;
    } else {
      mapped = types.scratch;
    }

    data = data || layoutData || scratch;

    return {
      name: name,
      value: data,
      strValue: '' + value,
      mapped: mapped,
      field: data[1],
      bypass: propIsBypass
    };

  } else if(
    ( mapData = new RegExp( types.mapData.regex ).exec( value ) ) ||
    ( mapLayoutData = new RegExp( types.mapLayoutData.regex ).exec( value ) ) ||
    ( mapScratch = new RegExp( types.mapScratch.regex ).exec( value ) )
  ){
    if( propIsBypass ){ return false; } // mappers not allowed in bypass
    if( type.multiple ){ return false; } // impossible to map to num

    var mapped;
    if( mapData ){
      mapped = types.mapData;
    } else if( mapLayoutData ){
      mapped = types.mapLayoutData;
    } else {
      mapped = types.mapScratch;
    }

    mapData = mapData || mapLayoutData || mapScratch;

    // we can map only if the type is a colour or a number
    if( !(type.color || type.number) ){ return false; }

    var valueMin = this.parse( name, mapData[4] ); // parse to validate
    if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped

    var valueMax = this.parse( name, mapData[5] ); // parse to validate
    if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped

    // check if valueMin and valueMax are the same
    if( valueMin.value === valueMax.value ){
      return false; // can't make much of a mapper without a range

    } else if( type.color ){
      var c1 = valueMin.value;
      var c2 = valueMax.value;

      var same = c1[0] === c2[0] // red
        && c1[1] === c2[1] // green
        && c1[2] === c2[2] // blue
        && ( // optional alpha
          c1[3] === c2[3] // same alpha outright
          || (
            (c1[3] == null || c1[3] === 1) // full opacity for colour 1?
            &&
            (c2[3] == null || c2[3] === 1) // full opacity for colour 2?
          )
        )
      ;

      if( same ){ return false; } // can't make a mapper without a range
    }

    return {
      name: name,
      value: mapData,
      strValue: '' + value,
      mapped: mapped,
      field: mapData[1],
      fieldMin: parseFloat( mapData[2] ), // min & max are numeric
      fieldMax: parseFloat( mapData[3] ),
      valueMin: valueMin.value,
      valueMax: valueMax.value,
      bypass: propIsBypass
    };
  }

  if( type.multiple && propIsFlat !== 'multiple' ){
    var vals;

    if( valueIsString ){
      vals = value.split(/\s+/);
    } else if( is.array(value) ){
      vals = value;
    } else {
      vals = [ value ];
    }

    if( type.evenMultiple && vals.length % 2 !== 0 ){ return null; }

    var valArr = vals.map(function( v ){
      var p = self.parse( name, v, propIsBypass, 'multiple' );

      if( p.pfValue != null ){
        return p.pfValue;
      } else {
        return p.value;
      }
    });

    return {
      name: name,
      value: valArr,
      pfValue: valArr,
      strValue: valArr.join(' '),
      bypass: propIsBypass,
      units: type.number && !type.unitless ? type.implicitUnits || 'px' : undefined
    };
  }

  // several types also allow enums
  var checkEnums = function(){
    for( var i = 0; i < type.enums.length; i++ ){
      var en = type.enums[i];

      if( en === value ){
        return {
          name: name,
          value: value,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null;
  };

  // check the type and return the appropriate object
  if( type.number ){
    var units;
    var implicitUnits = 'px'; // not set => px

    if( type.units ){ // use specified units if set
      units = type.units;
    }

    if( type.implicitUnits ){
      implicitUnits = type.implicitUnits;
    }

    if( !type.unitless ){
      if( valueIsString ){
        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
        if( units ){ unitsRegex = units; } // only allow explicit units if so set
        var match = value.match( '^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$' );

        if( match ){
          value = match[1];
          units = match[2] || implicitUnits;
        }

      } else if( !units || type.implicitUnits ) {
        units = implicitUnits; // implicitly px if unspecified
      }
    }

    value = parseFloat( value );

    // if not a number and enums not allowed, then the value is invalid
    if( isNaN(value) && type.enums === undefined ){
      return null;
    }

    // check if this number type also accepts special keywords in place of numbers
    // (i.e. `left`, `auto`, etc)
    if( isNaN(value) && type.enums !== undefined ){
      value = passedValue;

      return checkEnums();
    }

    // check if value must be an integer
    if( type.integer && !is.integer(value) ){
      return null;
    }

    // check value is within range
    if( (type.min !== undefined && value < type.min)
    || (type.max !== undefined && value > type.max)
    ){
      return null;
    }

    var ret = {
      name: name,
      value: value,
      strValue: '' + value + (units ? units : ''),
      units: units,
      bypass: propIsBypass
    };

    // normalise value in pixels
    if( type.unitless || (units !== 'px' && units !== 'em') ){
      ret.pfValue = value;
    } else {
      ret.pfValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );
    }

    // normalise value in ms
    if( units === 'ms' || units === 's' ){
      ret.pfValue = units === 'ms' ? value : 1000 * value;
    }

    // normalise value in rad
    if( units === 'deg' || units === 'rad' ){
      ret.pfValue = units === 'rad' ? value : value * Math.PI/180;
    }

    return ret;

  } else if( type.propList ) {

    var props = [];
    var propsStr = '' + value;

    if( propsStr === 'none' ){
      // leave empty

    } else { // go over each prop

      var propsSplit = propsStr.split(',');
      for( var i = 0; i < propsSplit.length; i++ ){
        var propName = propsSplit[i].trim();

        if( self.properties[propName] ){
          props.push( propName );
        }
      }

      if( props.length === 0 ){ return null; }
    }

    return {
      name: name,
      value: props,
      strValue: props.length === 0 ? 'none' : props.join(', '),
      bypass: propIsBypass
    };

  } else if( type.color ){
    var tuple = util.color2tuple( value );

    if( !tuple ){ return null; }

    return {
      name: name,
      value: tuple,
      strValue: '' + value,
      bypass: propIsBypass,
      roundValue: true
    };

  } else if( type.regex || type.regexes ){

    // first check enums
    if( type.enums ){
      var enumProp = checkEnums();

      if( enumProp ){ return enumProp; }
    }

    var regexes = type.regexes ? type.regexes : [ type.regex ];

    for( var i = 0; i < regexes.length; i++ ){
      var regex = new RegExp( regexes[i] ); // make a regex from the type string
      var m = regex.exec( value );

      if( m ){ // regex matches
        return {
          name: name,
          value: m,
          strValue: '' + value,
          bypass: propIsBypass
        };

      }
    }

    return null; // didn't match any

  } else if( type.string ){
    // just return
    return {
      name: name,
      value: value,
      strValue: '' + value,
      bypass: propIsBypass
    };

  } else if( type.enums ){ // check enums last because it's a combo type in others
    return checkEnums();

  } else {
    return null; // not a type we can handle
  }

};

module.exports = styfn;

},{"../is":77,"../util":94}],89:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');

var styfn = {};

(function(){
  var number = util.regex.number;
  var rgba = util.regex.rgbaNoBackRefs;
  var hsla = util.regex.hslaNoBackRefs;
  var hex3 = util.regex.hex3;
  var hex6 = util.regex.hex6;
  var data = function( prefix ){ return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$'; };
  var mapData = function( prefix ){
    var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;
    return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
  };

  // each visual style property has a type and needs to be validated according to it
  styfn.types = {
    time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
    percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },
    zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
    nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
    nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
    position: { enums: ['parent', 'origin'] },
    nodeSize: { number: true, min: 0, enums: ['auto', 'label'] },
    number: { number: true, unitless: true },
    numbers: { number: true, unitless: true, multiple: true },
    size: { number: true, min: 0 },
    bidirectionalSize: { number: true }, // allows negative
    bidirectionalSizes: { number: true, multiple: true }, // allows negative
    bgSize: { number: true, min: 0, allowPercent: true },
    bgWH: { number: true, min: 0, allowPercent: true, enums: ['auto'] },
    bgPos: { number: true, allowPercent: true },
    bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'] },
    bgFit: { enums: ['none', 'contain', 'cover'] },
    bgClip: { enums: ['none', 'node'] },
    color: { color: true },
    bool: { enums: ['yes', 'no'] },
    lineStyle: { enums: ['solid', 'dotted', 'dashed'] },
    borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },
    curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments'] },
    fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
    fontVariant: { enums: ['small-caps', 'normal'] },
    fontStyle: { enums: ['italic', 'normal', 'oblique'] },
    fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },
    textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },
    textTransform: { enums: ['none', 'uppercase', 'lowercase'] },
    textWrap: { enums: ['none', 'wrap'] },
    textBackgroundShape: { enums: ['rectangle', 'roundrectangle']},
    nodeShape: { enums: ['rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star', 'diamond', 'vee', 'rhomboid', 'polygon'] },
    compoundIncludeLabels: { enums: ['include', 'exclude'] },
    arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none'] },
    arrowFill: { enums: ['filled', 'hollow'] },
    display: { enums: ['element', 'none'] },
    visibility: { enums: ['hidden', 'visible'] },
    valign: { enums: ['top', 'center', 'bottom'] },
    halign: { enums: ['left', 'center', 'right'] },
    text: { string: true },
    data: { mapping: true, regex: data('data') },
    layoutData: { mapping: true, regex: data('layoutData') },
    scratch: { mapping: true, regex: data('scratch') },
    mapData: { mapping: true, regex: mapData('mapData') },
    mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },
    mapScratch: { mapping: true, regex: mapData('mapScratch') },
    fn: { mapping: true, fn: true },
    url: { regex: '^url\\s*\\(\\s*([^\\s]+)\\s*\\s*\\)|none|(.+)$' },
    propList: { propList: true },
    angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },
    textRotation: { enums: ['none', 'autorotate'] },
    polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },
    easing: {
      regexes: [
        '^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$',
        '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'
      ],
      enums: [
        'linear',
        'ease', 'ease-in', 'ease-out', 'ease-in-out',
        'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine',
        'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad',
        'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic',
        'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart',
        'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint',
        'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo',
        'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ'
      ]
    }
  };

  // define visual style properties
  var t = styfn.types;
  var props = styfn.properties = [
    // labels
    { name: 'text-valign', type: t.valign },
    { name: 'text-halign', type: t.halign },
    { name: 'color', type: t.color },
    { name: 'label', type: t.text },
    { name: 'text-outline-color', type: t.color },
    { name: 'text-outline-width', type: t.size },
    { name: 'text-outline-opacity', type: t.zeroOneNumber },
    { name: 'text-opacity', type: t.zeroOneNumber },
    { name: 'text-background-color', type: t.color },
    { name: 'text-background-opacity', type: t.zeroOneNumber },
    { name: 'text-border-opacity', type: t.zeroOneNumber },
    { name: 'text-border-color', type: t.color },
    { name: 'text-border-width', type: t.size },
    { name: 'text-border-style', type: t.borderStyle },
    { name: 'text-background-shape', type: t.textBackgroundShape},
    // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
    { name: 'text-transform', type: t.textTransform },
    { name: 'text-wrap', type: t.textWrap },
    { name: 'text-max-width', type: t.size },
    { name: 'text-events', type: t.bool },

    // { name: 'text-rotation', type: t.angle }, // TODO disabled b/c rotation breaks bounding boxes
    { name: 'font-family', type: t.fontFamily },
    { name: 'font-style', type: t.fontStyle },
    // { name: 'font-variant', type: t.fontVariant }, // not useful
    { name: 'font-weight', type: t.fontWeight },
    { name: 'font-size', type: t.size },
    { name: 'min-zoomed-font-size', type: t.size },
    { name: 'edge-text-rotation', type: t.textRotation },

    // behaviour
    { name: 'events', type: t.bool },

    // visibility
    { name: 'display', type: t.display },
    { name: 'visibility', type: t.visibility },
    { name: 'opacity', type: t.zeroOneNumber },
    { name: 'z-index', type: t.nonNegativeInt },

    // overlays
    { name: 'overlay-padding', type: t.size },
    { name: 'overlay-color', type: t.color },
    { name: 'overlay-opacity', type: t.zeroOneNumber },

    // shadows
    { name: 'shadow-blur', type: t.size },
    { name: 'shadow-color', type: t.color },
    { name: 'shadow-opacity', type: t.zeroOneNumber },
    { name: 'shadow-offset-x', type: t.bidirectionalSize },
    { name: 'shadow-offset-y', type: t.bidirectionalSize },

    // label shadows
    { name: 'text-shadow-blur', type: t.size },
    { name: 'text-shadow-color', type: t.color },
    { name: 'text-shadow-opacity', type: t.zeroOneNumber },
    { name: 'text-shadow-offset-x', type: t.bidirectionalSize },
    { name: 'text-shadow-offset-y', type: t.bidirectionalSize },

    // transition anis
    { name: 'transition-property', type: t.propList },
    { name: 'transition-duration', type: t.time },
    { name: 'transition-delay', type: t.time },
    { name: 'transition-timing-function', type: t.easing },

    // node body
    { name: 'height', type: t.nodeSize },
    { name: 'width', type: t.nodeSize },
    { name: 'shape', type: t.nodeShape },
    { name: 'shape-polygon-points', type: t.polygonPointList },
    { name: 'background-color', type: t.color },
    { name: 'background-opacity', type: t.zeroOneNumber },
    { name: 'background-blacken', type: t.nOneOneNumber },
    { name: 'padding-left', type: t.size },
    { name: 'padding-right', type: t.size },
    { name: 'padding-top', type: t.size },
    { name: 'padding-bottom', type: t.size },

    // node border
    { name: 'border-color', type: t.color },
    { name: 'border-opacity', type: t.zeroOneNumber },
    { name: 'border-width', type: t.size },
    { name: 'border-style', type: t.borderStyle },

    // node background images
    { name: 'background-image', type: t.url },
    { name: 'background-image-opacity', type: t.zeroOneNumber },
    { name: 'background-position-x', type: t.bgPos },
    { name: 'background-position-y', type: t.bgPos },
    { name: 'background-repeat', type: t.bgRepeat },
    { name: 'background-fit', type: t.bgFit },
    { name: 'background-clip', type: t.bgClip },
    { name: 'background-width', type: t.bgWH },
    { name: 'background-height', type: t.bgWH },

    // compound props
    { name: 'position', type: t.position },
    { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels },

    // edge line
    { name: 'line-style', type: t.lineStyle },
    { name: 'line-color', type: t.color },
    { name: 'curve-style', type: t.curveStyle },
    { name: 'haystack-radius', type: t.zeroOneNumber },
    { name: 'control-point-step-size', type: t.size },
    { name: 'control-point-distances', type: t.bidirectionalSizes },
    { name: 'control-point-weights', type: t.numbers },
    { name: 'segment-distances', type: t.bidirectionalSizes },
    { name: 'segment-weights', type: t.numbers },

    // these are just for the core
    { name: 'selection-box-color', type: t.color },
    { name: 'selection-box-opacity', type: t.zeroOneNumber },
    { name: 'selection-box-border-color', type: t.color },
    { name: 'selection-box-border-width', type: t.size },
    { name: 'active-bg-color', type: t.color },
    { name: 'active-bg-opacity', type: t.zeroOneNumber },
    { name: 'active-bg-size', type: t.size },
    { name: 'outside-texture-bg-color', type: t.color },
    { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }
  ];

  // define aliases
  var aliases = styfn.aliases = [
    { name: 'content', pointsTo: 'label' },
    { name: 'control-point-distance', pointsTo: 'control-point-distances' },
    { name: 'control-point-weight', pointsTo: 'control-point-weights' }
  ];

  // pie backgrounds for nodes
  styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
  props.push({ name: 'pie-size', type: t.bgSize });
  for( var i = 1; i <= styfn.pieBackgroundN; i++ ){
    props.push({ name: 'pie-'+i+'-background-color', type: t.color });
    props.push({ name: 'pie-'+i+'-background-size', type: t.percent });
    props.push({ name: 'pie-'+i+'-background-opacity', type: t.zeroOneNumber });
  }

  // edge arrows
  var arrowPrefixes = styfn.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];
  [
    { name: 'arrow-shape', type: t.arrowShape },
    { name: 'arrow-color', type: t.color },
    { name: 'arrow-fill', type: t.arrowFill }
  ].forEach(function( prop ){
    arrowPrefixes.forEach(function( prefix ){
      var name = prefix + '-' + prop.name;
      var type = prop.type;

      props.push({ name: name, type: type });
    });
  }, {});

  // list of property names
  styfn.propertyNames = props.map(function(p){ return p.name; });

  // allow access of properties by name ( e.g. style.properties.height )
  for( var i = 0; i < props.length; i++ ){
    var prop = props[i];

    props[ prop.name ] = prop; // allow lookup by name
  }

  // map aliases
  for( var i = 0; i < aliases.length; i++ ){
    var alias = aliases[i];
    var pointsToProp = props[ alias.pointsTo ];
    var aliasProp = {
      name: alias.name,
      alias: true,
      pointsTo: pointsToProp
    };

    // add alias prop for parsing
    props.push( aliasProp );

    props[ alias.name ] = aliasProp; // allow lookup by name
  }
})();

// adds the default stylesheet to the current style
styfn.addDefaultStylesheet = function(){
  // fill the style with the default stylesheet
  this
    .selector('node, edge') // common properties
      .css( util.extend( {
        'events': 'yes',
        'text-events': 'no',
        'text-valign': 'top',
        'text-halign': 'center',
        'color': '#000',
        'text-outline-color': '#000',
        'text-outline-width': 0,
        'text-outline-opacity': 1,
        'text-opacity': 1,
        'text-decoration': 'none',
        'text-transform': 'none',
        'text-wrap': 'none',
        'text-max-width': 9999,
        'text-background-color': '#000',
        'text-background-opacity': 0,
        'text-border-opacity': 0,
        'text-border-width': 0,
        'text-border-style': 'solid',
        'text-border-color':'#000',
        'text-background-shape':'rectangle',
        'font-family': 'Helvetica Neue, Helvetica, sans-serif',
        'font-style': 'normal',
        // 'font-variant': fontVariant,
        'font-weight': 'normal',
        'font-size': 16,
        'min-zoomed-font-size': 0,
        'edge-text-rotation': 'none',
        'visibility': 'visible',
        'display': 'element',
        'opacity': 1,
        'z-index': 0,
        'label': '',
        'overlay-opacity': 0,
        'overlay-color': '#000',
        'overlay-padding': 10,
        'shadow-opacity': 0,
        'shadow-color': '#000',
        'shadow-blur': 10,
        'shadow-offset-x': 0,
        'shadow-offset-y': 0,
        'text-shadow-opacity': 0,
        'text-shadow-color': '#000',
        'text-shadow-blur': 5,
        'text-shadow-offset-x': 0,
        'text-shadow-offset-y': 0,
        'transition-property': 'none',
        'transition-duration': 0,
        'transition-delay': 0,
        'transition-timing-function': 'linear',

        // node props
        'background-blacken': 0,
        'background-color': '#888',
        'background-opacity': 1,
        'background-image': 'none',
        'background-image-opacity': 1,
        'background-position-x': '50%',
        'background-position-y': '50%',
        'background-repeat': 'no-repeat',
        'background-fit': 'none',
        'background-clip': 'node',
        'background-width': 'auto',
        'background-height': 'auto',
        'border-color': '#000',
        'border-opacity': 1,
        'border-width': 0,
        'border-style': 'solid',
        'height': 30,
        'width': 30,
        'shape': 'ellipse',
        'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',

        // compound props
        'padding-top': 0,
        'padding-bottom': 0,
        'padding-left': 0,
        'padding-right': 0,
        'position': 'origin',
        'compound-sizing-wrt-labels': 'include'
      }, {
        // node pie bg
        'pie-size': '100%'
      }, [
        { name: 'pie-{{i}}-background-color', value: 'black' },
        { name: 'pie-{{i}}-background-size', value: '0%' },
        { name: 'pie-{{i}}-background-opacity', value: 1 }
      ].reduce(function( css, prop ){
        for( var i = 1; i <= styfn.pieBackgroundN; i++ ){
          var name = prop.name.replace('{{i}}', i);
          var val = prop.value;

          css[ name ] = val;
        }

        return css;
      }, {}), {
        // edge props
        'line-style': 'solid',
        'line-color': '#ddd',
        'control-point-step-size': 40,
        'control-point-weights': 0.5,
        'segment-weights': 0.5,
        'segment-distances': 20,
        'curve-style': 'bezier',
        'haystack-radius': 0.8
      }, [
        { name: 'arrow-shape', value: 'none' },
        { name: 'arrow-color', value: '#ddd' },
        { name: 'arrow-fill', value: 'filled' }
      ].reduce(function( css, prop ){
        styfn.arrowPrefixes.forEach(function( prefix ){
          var name = prefix + '-' + prop.name;
          var val = prop.value;

          css[ name ] = val;
        });

        return css;
      }, {}) ) )
    .selector('$node > node') // compound (parent) node properties
      .css({
        'width': 'auto',
        'height': 'auto',
        'shape': 'rectangle',
        'padding-top': 10,
        'padding-right': 10,
        'padding-left': 10,
        'padding-bottom': 10
      })
    .selector('edge') // just edge properties
      .css({
        'width': 1
      })
    .selector(':active')
      .css({
        'overlay-color': 'black',
        'overlay-padding': 10,
        'overlay-opacity': 0.25
      })
    .selector('core') // just core properties
      .css({
        'selection-box-color': '#ddd',
        'selection-box-opacity': 0.65,
        'selection-box-border-color': '#aaa',
        'selection-box-border-width': 1,
        'active-bg-color': 'black',
        'active-bg-opacity': 0.15,
        'active-bg-size': 30,
        'outside-texture-bg-color': '#000',
        'outside-texture-bg-opacity': 0.125
      })
  ;

  this.defaultLength = this.length;
};

module.exports = styfn;

},{"../util":94}],90:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var Selector = _dereq_('../selector');

var styfn = {};

styfn.applyFromString = function( string ){
  var self = this;
  var style = this;
  var remaining = '' + string;
  var selAndBlockStr;
  var blockRem;
  var propAndValStr;

  // remove comments from the style string
  remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

  function removeSelAndBlockFromRemaining(){
    // remove the parsed selector and block from the remaining text to parse
    if( remaining.length > selAndBlockStr.length ){
      remaining = remaining.substr( selAndBlockStr.length );
    } else {
      remaining = '';
    }
  }

  function removePropAndValFromRem(){
    // remove the parsed property and value from the remaining block text to parse
    if( blockRem.length > propAndValStr.length ){
      blockRem = blockRem.substr( propAndValStr.length );
    } else {
      blockRem = '';
    }
  }

  while(true){
    var nothingLeftToParse = remaining.match(/^\s*$/);
    if( nothingLeftToParse ){ break; }

    var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

    if( !selAndBlock ){
      util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
      break;
    }

    selAndBlockStr = selAndBlock[0];

    // parse the selector
    var selectorStr = selAndBlock[1];
    if( selectorStr !== 'core' ){
      var selector = new Selector( selectorStr );
      if( selector._private.invalid ){
        util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);

        // skip this selector and block
        removeSelAndBlockFromRemaining();
        continue;
      }
    }

    // parse the block of properties and values
    var blockStr = selAndBlock[2];
    var invalidBlock = false;
    blockRem = blockStr;
    var props = [];

    while(true){
      var nothingLeftToParse = blockRem.match(/^\s*$/);
      if( nothingLeftToParse ){ break; }

      var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

      if( !propAndVal ){
        util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
        invalidBlock = true;
        break;
      }

      propAndValStr = propAndVal[0];
      var propStr = propAndVal[1];
      var valStr = propAndVal[2];

      var prop = self.properties[ propStr ];
      if( !prop ){
        util.error('Skipping property: Invalid property name in: ' + propAndValStr);

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      var parsedProp = style.parse( propStr, valStr );

      if( !parsedProp ){
        util.error('Skipping property: Invalid property definition in: ' + propAndValStr);

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      props.push({
        name: propStr,
        val: valStr
      });
      removePropAndValFromRem();
    }

    if( invalidBlock ){
      removeSelAndBlockFromRemaining();
      break;
    }

    // put the parsed block in the style
    style.selector( selectorStr );
    for( var i = 0; i < props.length; i++ ){
      var prop = props[i];
      style.css( prop.name, prop.val );
    }

    removeSelAndBlockFromRemaining();
  }

  return style;
};

styfn.fromString = function( string ){
  var style = this;

  style.resetToDefault();
  style.applyFromString( string );

  return style;
};

module.exports = styfn;

},{"../selector":81,"../util":94}],91:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('./is');
var util = _dereq_('./util');
var Style = _dereq_('./style');

// a dummy stylesheet object that doesn't need a reference to the core
// (useful for init)
var Stylesheet = function(){
  if( !(this instanceof Stylesheet) ){
    return new Stylesheet();
  }

  this.length = 0;
};

var sheetfn = Stylesheet.prototype;

sheetfn.instanceString = function(){
  return 'stylesheet';
};

// just store the selector to be parsed later
sheetfn.selector = function( selector ){
  var i = this.length++;

  this[i] = {
    selector: selector,
    properties: []
  };

  return this; // chaining
};

// just store the property to be parsed later
sheetfn.css = function( name, value ){
  var i = this.length - 1;

  if( is.string(name) ){
    this[i].properties.push({
      name: name,
      value: value
    });
  } else if( is.plainObject(name) ){
    var map = name;

    for( var j = 0; j < Style.properties.length; j++ ){
      var prop = Style.properties[j];
      var mapVal = map[ prop.name ];

      if( mapVal === undefined ){ // also try camel case name
        mapVal = map[ util.dash2camel(prop.name) ];
      }

      if( mapVal !== undefined ){
        var name = prop.name;
        var value = mapVal;

        this[i].properties.push({
          name: name,
          value: value
        });
      }
    }
  }

  return this; // chaining
};

sheetfn.style = sheetfn.css;

// generate a real style object from the dummy stylesheet
sheetfn.generateStyle = function( cy ){
  var style = new Style(cy);

  for( var i = 0; i < this.length; i++ ){
    var context = this[i];
    var selector = context.selector;
    var props = context.properties;

    style.selector(selector); // apply selector

    for( var j = 0; j < props.length; j++ ){
      var prop = props[j];

      style.css( prop.name, prop.value ); // apply property
    }
  }

  return style;
};

module.exports = Stylesheet;

},{"./is":77,"./style":86,"./util":94}],92:[function(_dereq_,module,exports){
// cross-env thread/worker
// NB : uses (heavyweight) processes on nodejs so best not to create too many threads

'use strict';

var window = _dereq_('./window');
var util = _dereq_('./util');
var Promise = _dereq_('./promise');
var Event = _dereq_('./event');
var define = _dereq_('./define');
var is = _dereq_('./is');

var Thread = function( opts ){
  if( !(this instanceof Thread) ){
    return new Thread( opts );
  }

  var _p = this._private = {
    requires: [],
    files: [],
    queue: null,
    pass: [],
    disabled: false
  };

  if( is.plainObject(opts) ){
    if( opts.disabled != null ){
      _p.disabled = !!opts.disabled;
    }
  }

};

var thdfn = Thread.prototype; // short alias

var stringifyFieldVal = function( val ){
  var valStr = is.fn( val ) ? val.toString() : "JSON.parse('" + JSON.stringify(val) + "')";

  return valStr;
};

// allows for requires with prototypes and subobjs etc
var fnAsRequire = function( fn ){
  var req;
  var fnName;

  if( is.object(fn) && fn.fn ){ // manual fn
    req = fnAs( fn.fn, fn.name );
    fnName = fn.name;
    fn = fn.fn;
  } else if( is.fn(fn) ){ // auto fn
    req = fn.toString();
    fnName = fn.name;
  } else if( is.string(fn) ){ // stringified fn
    req = fn;
  } else if( is.object(fn) ){ // plain object
    if( fn.proto ){
      req = '';
    } else {
      req = fn.name + ' = {};';
    }

    fnName = fn.name;
    fn = fn.obj;
  }

  req += '\n';

  var protoreq = function( val, subname ){
    if( val.prototype ){
      var protoNonempty = false;
      for( var prop in val.prototype ){ protoNonempty = true; break; } // jshint ignore:line

      if( protoNonempty ){
        req += fnAsRequire( {
          name: subname,
          obj: val,
          proto: true
        }, val );
      }
    }
  };

  // pull in prototype
  if( fn.prototype && fnName != null ){

    for( var name in fn.prototype ){
      var protoStr = '';

      var val = fn.prototype[ name ];
      var valStr = stringifyFieldVal( val );
      var subname = fnName + '.prototype.' + name;

      protoStr += subname + ' = ' + valStr + ';\n';

      if( protoStr ){
        req += protoStr;
      }

      protoreq( val, subname ); // subobject with prototype
    }

  }

  // pull in properties for obj/fns
  if( !is.string(fn) ){ for( var name in fn ){
    var propsStr = '';

    if( fn.hasOwnProperty(name) ){
      var val = fn[ name ];
      var valStr = stringifyFieldVal( val );
      var subname = fnName + '["' + name + '"]';

      propsStr += subname + ' = ' + valStr + ';\n';
    }

    if( propsStr ){
      req += propsStr;
    }

    protoreq( val, subname ); // subobject with prototype
  } }

  return req;
};

var isPathStr = function( str ){
  return is.string(str) && str.match(/\.js$/);
};

util.extend(thdfn, {

  instanceString: function(){ return 'thread'; },

  require: function( fn, as ){
    var requires = this._private.requires;

    if( isPathStr(fn) ){
      this._private.files.push( fn );

      return this;
    }

    if( as ){
      if( is.fn(fn) ){
        fn = { name: as, fn: fn };
      } else {
        fn = { name: as, obj: fn };
      }
    } else {
      if( is.fn(fn) ){
        if( !fn.name ){
          throw 'The function name could not be automatically determined.  Use thread.require( someFunction, "someFunction" )';
        }

        fn = { name: fn.name, fn: fn };
      }
    }

    requires.push( fn );

    return this; // chaining
  },

  pass: function( data ){
    this._private.pass.push( data );

    return this; // chaining
  },

  run: function( fn, pass ){ // fn used like main()
    var self = this;
    var _p = this._private;
    pass = pass || _p.pass.shift();

    if( _p.stopped ){
      throw 'Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.';
    }

    if( _p.running ){
      return ( _p.queue = _p.queue.then(function(){ // inductive step
        return self.run( fn, pass );
      }) );
    }

    var useWW = window != null && !_p.disabled;
    var useNode = !window && typeof module !== 'undefined' && !_p.disabled;

    self.trigger('run');

    var runP = new Promise(function( resolve, reject ){

      _p.running = true;

      var threadTechAlreadyExists = _p.ran;

      var fnImplStr = is.string( fn ) ? fn : fn.toString();

      // worker code to exec
      var fnStr = '\n' + ( _p.requires.map(function( r ){
        return fnAsRequire( r );
      }) ).concat( _p.files.map(function( f ){
        if( useWW ){
          var wwifyFile = function( file ){
            if( file.match(/^\.\//) || file.match(/^\.\./) ){
              return window.location.origin + window.location.pathname + file;
            } else if( file.match(/^\//) ){
              return window.location.origin + '/' + file;
            }
            return file;
          };

          return 'importScripts("' + wwifyFile(f) + '");';
        } else if( useNode ) {
          return 'eval( require("fs").readFileSync("' + f + '", { encoding: "utf8" }) );';
        } else {
          throw 'External file `' + f + '` can not be required without any threading technology.';
        }
      }) ).concat([
        '( function(){',
          'var ret = (' + fnImplStr + ')(' + JSON.stringify(pass) + ');',
          'if( ret !== undefined ){ resolve(ret); }', // assume if ran fn returns defined value (incl. null), that we want to resolve to it
        '} )()\n'
      ]).join('\n');

      // because we've now consumed the requires, empty the list so we don't dupe on next run()
      _p.requires = [];
      _p.files = [];

      if( useWW ){
        var fnBlob, fnUrl;

        // add normalised thread api functions
        if( !threadTechAlreadyExists ){
          var fnPre = fnStr + '';

          fnStr = [
            'function _ref_(o){ return eval(o); };',
            'function broadcast(m){ return message(m); };', // alias
            'function message(m){ postMessage(m); };',
            'function listen(fn){',
            '  self.addEventListener("message", function(m){ ',
            '    if( typeof m === "object" && (m.data.$$eval || m.data === "$$start") ){',
            '    } else { ',
            '      fn( m.data );',
            '    }',
            '  });',
            '};',
            'self.addEventListener("message", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });',
            'function resolve(v){ postMessage({ $$resolve: v }); };',
            'function reject(v){ postMessage({ $$reject: v }); };'
          ].join('\n');

          fnStr += fnPre;

          fnBlob = new Blob([ fnStr ], {
            type: 'application/javascript'
          });
          fnUrl = window.URL.createObjectURL( fnBlob );
        }
        // create webworker and let it exec the serialised code
        var ww = _p.webworker = _p.webworker || new Worker( fnUrl );

        if( threadTechAlreadyExists ){ // then just exec new run() code
          ww.postMessage({
            $$eval: fnStr
          });
        }

        // worker messages => events
        var cb;
        ww.addEventListener('message', cb = function( m ){
          var isObject = is.object(m) && is.object( m.data );

          if( isObject && ('$$resolve' in m.data) ){
            ww.removeEventListener('message', cb); // done listening b/c resolve()

            resolve( m.data.$$resolve );
          } else if( isObject && ('$$reject' in m.data) ){
            ww.removeEventListener('message', cb); // done listening b/c reject()

            reject( m.data.$$reject );
          } else {
            self.trigger( new Event(m, { type: 'message', message: m.data }) );
          }
        }, false);

        if( !threadTechAlreadyExists ){
          ww.postMessage('$$start'); // start up the worker
        }

      } else if( useNode ){
        // create a new process

        if( !_p.child ){
          _p.child = ( _dereq_('child_process').fork( _dereq_('path').join(__dirname, 'thread-node-fork') ) );
        }

        var child = _p.child;

        // child process messages => events
        var cb;
        child.on('message', cb = function( m ){
          if( is.object(m) && ('$$resolve' in m) ){
            child.removeListener('message', cb); // done listening b/c resolve()

            resolve( m.$$resolve );
          } else if( is.object(m) && ('$$reject' in m) ){
            child.removeListener('message', cb); // done listening b/c reject()

            reject( m.$$reject );
          } else {
            self.trigger( new Event({}, { type: 'message', message: m }) );
          }
        });

        // ask the child process to eval the worker code
        child.send({
          $$eval: fnStr
        });

      } else { // use a fallback mechanism using a timeout

        var promiseResolve = resolve;
        var promiseReject = reject;

        var timer = _p.timer = _p.timer || {

          listeners: [],

          exec: function(){
            // as a string so it can't be mangled by minifiers and processors
            fnStr = [
              'function _ref_(o){ return eval(o); };',
              'function broadcast(m){ return message(m); };',
              'function message(m){ self.trigger( new Event({}, { type: "message", message: m }) ); };',
              'function listen(fn){ timer.listeners.push( fn ); };',
              'function resolve(v){ promiseResolve(v); };',
              'function reject(v){ promiseReject(v); };'
            ].join('\n') + fnStr;

            // the .run() code
            eval( fnStr ); // jshint ignore:line
          },

          message: function( m ){
            var ls = timer.listeners;

            for( var i = 0; i < ls.length; i++ ){
              var fn = ls[i];

              fn( m );
            }
          }

        };

        timer.exec();
      }

    }).then(function( v ){
      _p.running = false;
      _p.ran = true;

      self.trigger('ran');

      return v;
    });

    if( _p.queue == null ){
      _p.queue = runP; // i.e. first step of inductive promise chain (for queue)
    }

    return runP;
  },

  // send the thread a message
  message: function( m ){
    var _p = this._private;

    if( _p.webworker ){
      _p.webworker.postMessage( m );
    }

    if( _p.child ){
      _p.child.send( m );
    }

    if( _p.timer ){
      _p.timer.message( m );
    }

    return this; // chaining
  },

  stop: function(){
    var _p = this._private;

    if( _p.webworker ){
      _p.webworker.terminate();
    }

    if( _p.child ){
      _p.child.kill();
    }

    if( _p.timer ){
      // nothing we can do if we've run a timeout
    }

    _p.stopped = true;

    return this.trigger('stop'); // chaining
  },

  stopped: function(){
    return this._private.stopped;
  }

});

// turns a stringified function into a (re)named function
var fnAs = function( fn, name ){
  var fnStr = fn.toString();
  fnStr = fnStr.replace(/function\s*?\S*?\s*?\(/, 'function ' + name + '(');

  return fnStr;
};

var defineFnal = function( opts ){
  opts = opts || {};

  return function fnalImpl( fn, arg1 ){
    var fnStr = fnAs( fn, '_$_$_' + opts.name );

    this.require( fnStr );

    return this.run( [
      'function( data ){',
      '  var origResolve = resolve;',
      '  var res = [];',
      '  ',
      '  resolve = function( val ){',
      '    res.push( val );',
      '  };',
      '  ',
      '  var ret = data.' + opts.name + '( _$_$_' + opts.name + ( arguments.length > 1 ? ', ' + JSON.stringify(arg1) : '' ) + ' );',
      '  ',
      '  resolve = origResolve;',
      '  resolve( res.length > 0 ? res : ret );',
      '}'
    ].join('\n') );
  };
};

util.extend(thdfn, {
  reduce: defineFnal({ name: 'reduce' }),

  reduceRight: defineFnal({ name: 'reduceRight' }),

  map: defineFnal({ name: 'map' })
});

// aliases
var fn = thdfn;
fn.promise = fn.run;
fn.terminate = fn.halt = fn.stop;
fn.include = fn.require;

// pull in event apis
util.extend(thdfn, {
  on: define.on(),
  one: define.on({ unbindSelfOnTrigger: true }),
  off: define.off(),
  trigger: define.trigger()
});

define.eventAliasesOn( thdfn );

module.exports = Thread;

},{"./define":41,"./event":42,"./is":77,"./promise":80,"./util":94,"./window":100,"child_process":undefined,"path":undefined}],93:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');

module.exports = {
  // get [r, g, b] from #abc or #aabbcc
  hex2tuple: function( hex ){
    if( !(hex.length === 4 || hex.length === 7) || hex[0] !== "#" ){ return; }

    var shortHex = hex.length === 4;
    var r, g, b;
    var base = 16;

    if( shortHex ){
      r = parseInt( hex[1] + hex[1], base );
      g = parseInt( hex[2] + hex[2], base );
      b = parseInt( hex[3] + hex[3], base );
    } else {
      r = parseInt( hex[1] + hex[2], base );
      g = parseInt( hex[3] + hex[4], base );
      b = parseInt( hex[5] + hex[6], base );
    }

    return [r, g, b];
  },

  // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
  hsl2tuple: function( hsl ){
    var ret;
    var h, s, l, a, r, g, b;
    function hue2rgb(p, q, t){
      if(t < 0) t += 1;
      if(t > 1) t -= 1;
      if(t < 1/6) return p + (q - p) * 6 * t;
      if(t < 1/2) return q;
      if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var m = new RegExp("^" + this.regex.hsla + "$").exec(hsl);
    if( m ){

      // get hue
      h = parseInt( m[1] );
      if( h < 0 ){
        h = ( 360 - (-1*h % 360) ) % 360;
      } else if( h > 360 ){
        h = h % 360;
      }
      h /= 360; // normalise on [0, 1]

      s = parseFloat( m[2] );
      if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]
      s = s/100; // normalise on [0, 1]

      l = parseFloat( m[3] );
      if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]
      l = l/100; // normalise on [0, 1]

      a = m[4];
      if( a !== undefined ){
        a = parseFloat( a );

        if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]
      }

      // now, convert to rgb
      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
      if( s === 0 ){
        r = g = b = Math.round(l * 255); // achromatic
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = Math.round( 255 * hue2rgb(p, q, h + 1/3) );
        g = Math.round( 255 * hue2rgb(p, q, h) );
        b = Math.round( 255 * hue2rgb(p, q, h - 1/3) );
      }

      ret = [r, g, b, a];
    }

    return ret;
  },

  // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
  rgb2tuple: function( rgb ){
    var ret;

    var m = new RegExp("^" + this.regex.rgba + "$").exec(rgb);
    if( m ){
      ret = [];

      var isPct = [];
      for( var i = 1; i <= 3; i++ ){
        var channel = m[i];

        if( channel[ channel.length - 1 ] === "%" ){
          isPct[i] = true;
        }
        channel = parseFloat( channel );

        if( isPct[i] ){
          channel = channel/100 * 255; // normalise to [0, 255]
        }

        if( channel < 0 || channel > 255 ){ return; } // invalid channel value

        ret.push( Math.floor(channel) );
      }

      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
      var allArePct = isPct[1] && isPct[2] && isPct[3];
      if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is

      var alpha = m[4];
      if( alpha !== undefined ){
        alpha = parseFloat( alpha );

        if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value

        ret.push( alpha );
      }
    }

    return ret;
  },

  colorname2tuple: function( color ){
    return this.colors[ color.toLowerCase() ];
  },

  color2tuple: function( color ){
    return ( is.array(color) ? color : null )
      || this.colorname2tuple(color)
      || this.hex2tuple(color)
      || this.rgb2tuple(color)
      || this.hsl2tuple(color);
  },

  colors: {
    // special colour names
    transparent: [0, 0, 0, 0], // NB alpha === 0

    // regular colours
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    grey: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }
};

},{"../is":77}],94:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var math = _dereq_('../math');

var util = {

  falsify: function(){ return false; },

  zeroify: function(){ return 0; },

  noop: function(){},

  /* jshint ignore:start */
  error: function( msg ){
    if( console.error ){
      console.error.apply( console, arguments );

      if( console.trace ){ console.trace(); }
    } else {
      console.log.apply( console, arguments );

      if( console.trace ){ console.trace(); }
    }
  },
  /* jshint ignore:end */

  clone: function( obj ){
    return this.extend( {}, obj );
  },

  // gets a shallow copy of the argument
  copy: function( obj ){
    if( obj == null ){
      return obj;
    } if( is.array(obj) ){
      return obj.slice();
    } else if( is.plainObject(obj) ){
      return this.clone( obj );
    } else {
      return obj;
    }
  }

};

util.makeBoundingBox = math.makeBoundingBox.bind( math );

util._staticEmptyObject = {};

util.staticEmptyObject = function(){
  return util._staticEmptyObject;
};

util.extend = Object.assign != null ? Object.assign : function( tgt ){
  var args = arguments;

  for( var i = 1; i < args.length; i++ ){
    var obj = args[i];

    for( var k in obj ){
      tgt[k] = obj[k];
    }
  }

  return tgt;
};

[
  _dereq_('./colors'),
  _dereq_('./maps'),
  { memoize: _dereq_('./memoize') },
  _dereq_('./regex'),
  _dereq_('./strings'),
  _dereq_('./timing')
].forEach(function( req ){
  util.extend( util, req );
});

module.exports = util;

},{"../is":77,"../math":79,"./colors":93,"./maps":95,"./memoize":96,"./regex":97,"./strings":98,"./timing":99}],95:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');

module.exports = {
  // has anything been set in the map
  mapEmpty: function( map ){
    var empty = true;

    if( map != null ){
      for(var i in map){ // jshint ignore:line
        empty = false;
        break;
      }
    }

    return empty;
  },

  // pushes to the array at the end of a map (map may not be built)
  pushMap: function( options ){
    var array = this.getMap(options);

    if( array == null ){ // if empty, put initial array
      this.setMap( this.extend({}, options, {
        value: [ options.value ]
      }) );
    } else {
      array.push( options.value );
    }
  },

  // sets the value in a map (map may not be built)
  setMap: function( options ){
    var obj = options.map;
    var key;
    var keys = options.keys;
    var l = keys.length;

    for(var i = 0; i < l; i++){
      var key = keys[i];

      if( is.plainObject( key ) ){
        this.error('Tried to set map with object key');
      }

      if( i < keys.length - 1 ){

        // extend the map if necessary
        if( obj[key] == null ){
          obj[key] = {};
        }

        obj = obj[key];
      } else {
        // set the value
        obj[key] = options.value;
      }
    }
  },

  // gets the value in a map even if it's not built in places
  getMap: function( options ){
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;

    for(var i = 0; i < l; i++){
      var key = keys[i];

      if( is.plainObject( key ) ){
        this.error('Tried to get map with object key');
      }

      obj = obj[key];

      if( obj == null ){
        return obj;
      }
    }

    return obj;
  },

  // deletes the entry in the map
  deleteMap: function( options ){
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;
    var keepChildren = options.keepChildren;

    for(var i = 0; i < l; i++){
      var key = keys[i];

      if( is.plainObject( key ) ){
        this.error('Tried to delete map with object key');
      }

      var lastKey = i === options.keys.length - 1;
      if( lastKey ){

        if( keepChildren ){ // then only delete child fields not in keepChildren
          for( var child in obj ){
            if( !keepChildren[child] ){
              obj[child] = undefined;
            }
          }
        } else {
          obj[key] = undefined;
        }

      } else {
        obj = obj[key];
      }
    }
  }
};

},{"../is":77}],96:[function(_dereq_,module,exports){
'use strict';

module.exports = function memoize( fn, keyFn ){
  var self = this;
  var cache = {};

  if( !keyFn ){
    keyFn = function(){
      if( arguments.length === 1 ){
        return arguments[0];
      }

      var args = [];

      for( var i = 0; i < arguments.length; i++ ){
        args.push( arguments[i] );
      }

      return args.join('$');
    };
  }

  return function memoizedFn(){
    var args = arguments;
    var ret;
    var k = keyFn.apply( self, args );

    if( !(ret = cache[k]) ){
      ret = cache[k] = fn.apply( self, args );
    }

    return ret;
  };
};

},{}],97:[function(_dereq_,module,exports){
'use strict';

var number = "(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))";

var rgba = "rgb[a]?\\(("+ number +"[%]?)\\s*,\\s*("+ number +"[%]?)\\s*,\\s*("+ number +"[%]?)(?:\\s*,\\s*("+ number +"))?\\)";
var rgbaNoBackRefs = "rgb[a]?\\((?:"+ number +"[%]?)\\s*,\\s*(?:"+ number +"[%]?)\\s*,\\s*(?:"+ number +"[%]?)(?:\\s*,\\s*(?:"+ number +"))?\\)";

var hsla = "hsl[a]?\\(("+ number +")\\s*,\\s*("+ number +"[%])\\s*,\\s*("+ number +"[%])(?:\\s*,\\s*("+ number +"))?\\)";
var hslaNoBackRefs = "hsl[a]?\\((?:"+ number +")\\s*,\\s*(?:"+ number +"[%])\\s*,\\s*(?:"+ number +"[%])(?:\\s*,\\s*(?:"+ number +"))?\\)";

var hex3 = "\\#[0-9a-fA-F]{3}";
var hex6 = "\\#[0-9a-fA-F]{6}";

module.exports = {
  regex: {
    number: number,
    rgba: rgba,
    rgbaNoBackRefs: rgbaNoBackRefs,
    hsla: hsla,
    hslaNoBackRefs: hslaNoBackRefs,
    hex3: hex3,
    hex6: hex6
  }
};

},{}],98:[function(_dereq_,module,exports){
'use strict';

var memoize = _dereq_('./memoize');
var is = _dereq_('../is');

module.exports = {

  camel2dash: memoize( function( str ){
    return str.replace(/([A-Z])/g, function( v ){
      return '-' + v.toLowerCase();
    });
  } ),

  dash2camel: memoize( function( str ){
    return str.replace(/(-\w)/g, function( v ){
      return v[1].toUpperCase();
    });
  } ),

  capitalize: function(str){
    if( is.emptyString(str) ){
      return str;
    }

    return str.charAt(0).toUpperCase() + str.substring(1);
  }

};

},{"../is":77,"./memoize":96}],99:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_('../window');
var is = _dereq_('../is');
var performance = window ? window.performance : null;

var util = {};

var raf = !window ? null : ( window.requestAnimationFrame || window.mozRequestAnimationFrame ||
      window.webkitRequestAnimationFrame || window.msRequestAnimationFrame );

raf = raf || function( fn ){
  if( fn ){
    setTimeout(function(){
      fn( pnow() );
    }, 1000/60);
  }
};

util.requestAnimationFrame = function(fn){
  raf( fn );
};

var pnow = performance && performance.now ? function(){ return performance.now(); } : function(){ return Date.now(); };

util.performanceNow = pnow;

// ported lodash throttle function
util.throttle = function(func, wait, options) {
  var leading = true,
      trailing = true;

  if (options === false) {
    leading = false;
  } else if (is.plainObject(options)) {
    leading = 'leading' in options ? options.leading : leading;
    trailing = 'trailing' in options ? options.trailing : trailing;
  }
  options = options || {};
  options.leading = leading;
  options.maxWait = wait;
  options.trailing = trailing;

  return util.debounce(func, wait, options);
};

util.now = function(){
  return Date.now();
};

util.debounce = function(func, wait, options) { // ported lodash debounce function
  var util = this;
  var args,
      maxTimeoutId,
      result,
      stamp,
      thisArg,
      timeoutId,
      trailingCall,
      lastCalled = 0,
      maxWait = false,
      trailing = true;

  if (!is.fn(func)) {
    return;
  }
  wait = Math.max(0, wait) || 0;
  if (options === true) {
    var leading = true;
    trailing = false;
  } else if (is.plainObject(options)) {
    leading = options.leading;
    maxWait = 'maxWait' in options && (Math.max(wait, options.maxWait) || 0);
    trailing = 'trailing' in options ? options.trailing : trailing;
  }
  var delayed = function() {
    var remaining = wait - (util.now() - stamp);
    if (remaining <= 0) {
      if (maxTimeoutId) {
        clearTimeout(maxTimeoutId);
      }
      var isCalled = trailingCall;
      maxTimeoutId = timeoutId = trailingCall = undefined;
      if (isCalled) {
        lastCalled = util.now();
        result = func.apply(thisArg, args);
        if (!timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
      }
    } else {
      timeoutId = setTimeout(delayed, remaining);
    }
  };

  var maxDelayed = function() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    maxTimeoutId = timeoutId = trailingCall = undefined;
    if (trailing || (maxWait !== wait)) {
      lastCalled = util.now();
      result = func.apply(thisArg, args);
      if (!timeoutId && !maxTimeoutId) {
        args = thisArg = null;
      }
    }
  };

  return function() {
    args = arguments;
    stamp = util.now();
    thisArg = this;
    trailingCall = trailing && (timeoutId || !leading);

    if (maxWait === false) {
      var leadingCall = leading && !timeoutId;
    } else {
      if (!maxTimeoutId && !leading) {
        lastCalled = stamp;
      }
      var remaining = maxWait - (stamp - lastCalled),
          isCalled = remaining <= 0;

      if (isCalled) {
        if (maxTimeoutId) {
          maxTimeoutId = clearTimeout(maxTimeoutId);
        }
        lastCalled = stamp;
        result = func.apply(thisArg, args);
      }
      else if (!maxTimeoutId) {
        maxTimeoutId = setTimeout(maxDelayed, remaining);
      }
    }
    if (isCalled && timeoutId) {
      timeoutId = clearTimeout(timeoutId);
    }
    else if (!timeoutId && wait !== maxWait) {
      timeoutId = setTimeout(delayed, wait);
    }
    if (leadingCall) {
      isCalled = true;
      result = func.apply(thisArg, args);
    }
    if (isCalled && !timeoutId && !maxTimeoutId) {
      args = thisArg = null;
    }
    return result;
  };
};

module.exports = util;

},{"../is":77,"../window":100}],100:[function(_dereq_,module,exports){
module.exports = ( typeof window === 'undefined' ? null : window );

},{}]},{},[76])(76)
});


//# sourceMappingURL=cytoscape.js.map

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},"/node_modules/cytoscape/dist")

},{}],10:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.2.0
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-01-08T20:02Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//"use strict";
var arr = [];

var document = window.document;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "2.2.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		var realStringObj = obj && obj.toString();
		return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
	},

	isPlainObject: function( obj ) {

		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {

			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf( "use strict" ) === 1 ) {
				script = document.createElement( "script" );
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {

				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval

				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

// JSHint would error on this code due to the Symbol not being defined in ES5.
// Defining this global in .jshintrc would create a danger of using the global
// unguarded in another place, it seems safer to just disable JSHint for these
// three lines.
/* jshint ignore: start */
if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}
/* jshint ignore: end */

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.1
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-10-17
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, nidselect, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
					while ( i-- ) {
						groups[i] = nidselect + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( (parent = document.defaultView) && parent.top !== parent ) {
		// Support: IE 11
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( (oldCache = uniqueCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		} );

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[ 0 ] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

				// Always skip document fragments
				if ( cur.nodeType < 11 && ( pos ?
					pos.index( cur ) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector( cur, selectors ) ) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this === promise ? newDefer.promise() : this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add( function() {

					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 ||
				( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.progress( updateFunc( i, progressContexts, progressValues ) )
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
} );


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {

	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
} );

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called
		// after the browser event has already occurred.
		// Support: IE9-10 only
		// Older IE sometimes signals "interactive" too soon
		if ( document.readyState === "complete" ||
			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

			// Handle it asynchronously to allow scripts the opportunity to delay ready
			window.setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	register: function( owner, initial ) {
		var value = initial || {};

		// If it is a node unlikely to be stringify-ed or looped over
		// use plain assignment
		if ( owner.nodeType ) {
			owner[ this.expando ] = value;

		// Otherwise secure it in a non-enumerable, non-writable property
		// configurability must be true to allow the property to be
		// deleted with the delete operator
		} else {
			Object.defineProperty( owner, this.expando, {
				value: value,
				writable: true,
				configurable: true
			} );
		}
		return owner[ this.expando ];
	},
	cache: function( owner ) {

		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return an empty object.
		if ( !acceptData( owner ) ) {
			return {};
		}

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ prop ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :
			owner[ this.expando ] && owner[ this.expando ][ key ];
	},
	access: function( owner, key, value ) {
		var stored;

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase( key ) );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key === undefined ) {
			this.register( owner );

		} else {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );

				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;

			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <= 35-45+
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://code.google.com/p/chromium/issues/detail?id=378607
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data, camelKey;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// with the key as-is
				data = dataUser.get( elem, key ) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

				if ( data !== undefined ) {
					return data;
				}

				camelKey = jQuery.camelCase( key );

				// Attempt to get data from the cache
				// with the key camelized
				data = dataUser.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			camelKey = jQuery.camelCase( key );
			this.each( function() {

				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = dataUser.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				dataUser.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
					dataUser.set( this, key, value );
				}
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" ||
			!jQuery.contains( elem.ownerDocument, elem );
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() { return tween.cur(); } :
			function() { return jQuery.css( elem, prop, "" ); },
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([\w:-]+)/ );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE9
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE9-11+
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== "undefined" ?
				context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0-4.3, Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE9
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return this;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Support (at least): Chrome, IE9
		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		//
		// Support: Firefox<=42+
		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
		if ( delegateCount && cur.nodeType &&
			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push( { elem: cur, handlers: matches } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
		"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split( " " ),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
			"screenX screenY toElement" ).split( " " ),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX +
					( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
					( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY +
					( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
					( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://code.google.com/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {
	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

function manipulationTarget( elem, content ) {
	if ( jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android<4.1, PhantomJS<2
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {

	// Keep domManip exposed until 3.0 (gh-2225)
	domManip: domManip,

	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );


var iframe,
	elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */

// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		display = jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
				.appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var documentElement = document.documentElement;



( function() {
	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {
		div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );
	}

	jQuery.extend( support, {
		pixelPosition: function() {

			// This test is executed only once but we still do memoizing
			// since we can use the boxSizingReliable pre-computing.
			// No need to check if the test was already performed, though.
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {

			// Support: Android 4.0-4.3
			// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
			// since that compresses better and they're computed together anyway.
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {

			// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return reliableMarginLeftVal;
		},
		reliableMarginRight: function() {

			// Support: Android 2.3
			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// This support function is only executed once so no memoizing is needed.
			var ret,
				marginDiv = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" +
				"display:block;margin:0;border:0;padding:0";
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			documentElement.appendChild( container );

			ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

			documentElement.removeChild( container );
			div.removeChild( marginDiv );

			return ret;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE11 only
	// In IE 11 fullscreen elements inside of an iframe have
	// 100x too small dimensions (gh-1764).
	if ( document.msFullscreenElement && window.top !== window ) {

		// Support: IE11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = Math.round( elem.getBoundingClientRect()[ name ] * 100 );
		}
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = dataPriv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {

			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = dataPriv.access(
					elem,
					"olddisplay",
					defaultDisplay( elem.nodeName )
				);
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				dataPriv.set(
					elem,
					"olddisplay",
					hidden ? display : jQuery.css( elem, "display" )
				);
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
					elem.offsetWidth === 0 ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show
				// and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = dataPriv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done( function() {
				jQuery( elem ).hide();
			} );
		}
		anim.done( function() {
			var prop;

			dataPriv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		} );
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnotwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
		opt.duration : opt.duration in jQuery.fx.speeds ?
			jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	window.clearInterval( timerId );

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {

					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnotwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + getClass( elem ) + " " ).replace( rclass, " " )
					.indexOf( className ) > -1
			) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace( rreturn, "" ) :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				// Support: IE<11
				// option.value not trimmed (#14858)
				return jQuery.trim( elem.value );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ?
								!option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true

				// Previously, `originalEvent: {}` was set here, so stopPropagation call
				// would not be triggered on donor event, since in our own
				// jQuery.event.stopPropagation function we had a check for existence of
				// originalEvent.stopPropagation method, so, consequently it would be a noop.
				//
				// But now, this "simulate" function is used only for events
				// for which stopPropagation() is noop, so there is no need for that anymore.
				//
				// For the compat branch though, guard for "click" and "submit"
				// events is still used, but was moved to jQuery.event.stopPropagation function
				// because `originalEvent` should point to the original event for the constancy
				// with other events and for more focused logic
			}
		);

		jQuery.event.trigger( e, null, elem );

		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome, Safari
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// The jqXHR state
			state = 0,

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE8-11+
			// IE throws exception if url is malformed, e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE8-11+
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );

				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapAll( html.call( this, i ) );
			} );
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function() {
		return this.parent().each( function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		} ).end();
	}
} );


jQuery.expr.filters.hidden = function( elem ) {
	return !jQuery.expr.filters.visible( elem );
};
jQuery.expr.filters.visible = function( elem ) {

	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	// Use OR instead of AND as the element is not visible if either is true
	// See tickets #10406 and #13132
	return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE9
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE9
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8+
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	// Stop scripts or inline event handlers from being executed immediately
	// by using document.implementation
	context = context || ( support.createHTMLDocument ?
		document.implementation.createHTMLDocument( "" ) :
		document );

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( self, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		box = elem.getBoundingClientRect();
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			// Subtract offsetParent scroll positions
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ) -
				offsetParent.scrollTop();
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true ) -
				offsetParent.scrollLeft();
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari<7-8+, Chrome<37-44+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},
	size: function() {
		return this.length;
	}
} );

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}



var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}

return jQuery;
}));

},{}],11:[function(require,module,exports){
(function (process,Buffer){
var req = require('request')

module.exports = Nets

function Nets (opts, cb) {
  if (typeof opts === 'string') opts = { uri: opts }

  // in node, if encoding === null then response will be a Buffer. we want this to be the default
  if (!opts.hasOwnProperty('encoding')) opts.encoding = null

  // in browser, we should by default convert the arraybuffer into a Buffer
  if (process.browser && !opts.hasOwnProperty('json') && opts.encoding === null) {
    opts.responseType = 'arraybuffer'
    var originalCb = cb
    cb = bufferify
  }

  function bufferify (err, resp, body) {
    if (body) body = new Buffer(new Uint8Array(body))
    originalCb(err, resp, body)
  }

  return req(opts, cb)
}

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":8,"buffer":4,"request":12}],12:[function(require,module,exports){
"use strict";
var window = require("global/window")
var once = require("once")
var isFunction = require("is-function")
var parseHeaders = require("parse-headers")
var xtend = require("xtend")

module.exports = createXHR
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    var callback = options.callback
    if(typeof callback === "undefined"){
        throw new Error("callback argument missing")
    }
    callback = once(callback)

    function readystatechange() {
        if (xhr.readyState === 4) {
            loadFunc()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === "text" || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    var failureResponse = {
                body: undefined,
                headers: {},
                statusCode: 0,
                method: method,
                url: uri,
                rawRequest: xhr
            }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        callback(err, response, response.body)

    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data || null
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer

    if ("json" in options) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            aborted=true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr


}

function noop() {}

},{"global/window":13,"is-function":14,"once":15,"parse-headers":18,"xtend":19}],13:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],15:[function(require,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],16:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":14}],17:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],18:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":16,"trim":17}],19:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],"biojs-vis-keggviewer":[function(require,module,exports){
biojsviskegg = require('./js/app.js');
module.exports = biojsviskegg;
},{"./js/app.js":1}]},{},["biojs-vis-keggviewer"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9hcHAuanMiLCJqcy9wYXRod2F5cmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC1zbGlkZXIvZGlzdC9ib290c3RyYXAtc2xpZGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jeXRvc2NhcGUvZGlzdC9jeXRvc2NhcGUuanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL25ldHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qcyIsIm5vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL2lzLWZ1bmN0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvb25jZS9vbmNlLmpzIiwibm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy90cmltL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzIiwiaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3QrdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2bVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy9MaWJyYXJpZXNcbnZhciB4aHIgPSByZXF1aXJlKCduZXRzJyk7XG52YXIgU2xpZGVyID0gcmVxdWlyZShcImJvb3RzdHJhcC1zbGlkZXJcIik7XG5cbi8vTW9kdWxlc1xudmFyIHJlbmRlciA9IHJlcXVpcmUoJy4vcGF0aHdheXJlbmRlci5qcycpO1xuXG4vL1ByaXZhdGUgbWVtYmVyc1xudmFyIF9LRUdHQVBJID0gJ2h0dHA6Ly9yZXN0LmtlZ2cuanAvZ2V0Lyc7XG5cbnZhciBfdGFyZ2V0ID0gbnVsbCwgX3BhdGh3YXkgPSAnaHNhMDQ5MTAnLCBfcHJveHkgPSBudWxsLCBfZXhwcmVzc2lvbiA9IG51bGwsIF9jeSA9IG51bGwsIF9jb25kaXRpb25zID0gbnVsbCwgX2ludGVydmFsID0gbnVsbCwgX3NsaWRlciA9IG51bGw7XG5cbnZhciBfZmluZGVyID0gZnVuY3Rpb24oY21wLCBhcnIpe1xuICAgIHZhciB5ID0gYXJyWzBdIHx8IG51bGw7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyci5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHkgPSBjbXAoeSwgYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHk7XG59O1xuXG52YXIgX3NldEJhY2tncm91bmQgPSBmdW5jdGlvbihlbCwgYmtnKXtcbiAgICBcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2JhY2tncm91bmQ6Jytia2cpO1xuICAgIFxuICAgIHZhciBjb250ZW50ID0gZWwuaW5uZXJIVE1MO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUw9IGNvbnRlbnQ7XG59O1xuXG52YXIgX3F1ZXJ5ID0gZnVuY3Rpb24oKXtcbiAgICBcbiAgICB2YXIgdXJsID0gX0tFR0dBUEkrX3BhdGh3YXkrJy9rZ21sJztcbiAgICB1cmwgPSAodHlwZW9mIF9wcm94eSA9PT0gJ2Z1bmN0aW9uJykgPyBfcHJveHkodXJsKSA6IHVybDtcbiAgICBcbiAgICB4aHIoe1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgZW5jb2Rpbmc6IHVuZGVmaW5lZFxuICAgIH0sIFxuICAgIGZ1bmN0aW9uKGVyciwgcmVzcCwgYm9keSl7XG4gICAgICAgIFxuICAgICAgICBpZihlcnIpeyBcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTsgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBjb250YWluZXIgZGl2XG4gICAgICAgIHZhciBkaXYgPSBfdGFyZ2V0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgICAgIGRpdi5zdHlsZS50b3AgPSAwO1xuICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIFxuICAgICAgICBfY3kgPSByZW5kZXIocmVzcC5yYXdSZXF1ZXN0LnJlc3BvbnNlWE1MLCBkaXYpO1xuICAgIH0pO1xufTtcblxudmFyIF9jbGVhckV4cHJlc3Npb24gPSBmdW5jdGlvbigpe1xuICAgIHZhciBub2RlcyA9IF9jeS5ub2RlcygpO1xuICAgIGZvcih2YXIgaj0wOyBqPG5vZGVzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgZm9yKHZhciBrPTA7IGs8X2V4cHJlc3Npb24uZ2VuZXMubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgaWYobm9kZXNbal0uZGF0YSgpLmtlZ2dJZCA9PSBfZXhwcmVzc2lvbi5nZW5lc1trXSl7XG4gICAgICAgICAgICAgICAgbm9kZXNbal0uY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgbm9kZXNbal0uZGF0YSgpLmJrZ19jb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgX3BhaW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNvbmRpdGlvbil7XG4gICAgXG4gICAgXG4gICAgaWYoY29uZGl0aW9uLm5hbWUgPT0gJ25vIGNvbmRpdGlvbicpeyBcbiAgICAgICAgX2NsZWFyRXhwcmVzc2lvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHZhciBzbGlkZXIgPSBfc2xpZGVyLmdldFZhbHVlKCk7XG4gICAgICAgIFxuICAgIHZhciBtaW4gPSBzbGlkZXJbMF07XG4gICAgdmFyIG1heCA9IHNsaWRlclsxXTtcbiAgICBcbiAgICB2YXIgbm9kZXMgPSBfY3kubm9kZXMoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgX2V4cHJlc3Npb24uZ2VuZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlcy5maWx0ZXJGbihmdW5jdGlvbihlbGUpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgaWRzID0gZWxlLmRhdGEoKS5rZWdnSWQ7XG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgaWRzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihpZHNbal0udG9Mb3dlckNhc2UoKSA9PT0gX2V4cHJlc3Npb24uZ2VuZXNbaV0udG9Mb3dlckNhc2UoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICBpZihub2RlLmxlbmd0aCAhPT0gMCl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBleHAgPSBjb25kaXRpb24udmFsdWVzW2ldO1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gbm9kZS5kYXRhKCkuYmtnX2NvbG9yO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihleHAgPCBtaW4pe1xuICAgICAgICAgICAgICAgIGNvbG9yID0gX2V4cHJlc3Npb24uZG93bkNvbG9yO1xuICAgICAgICAgICAgfWVsc2UgaWYoZXhwID4gbWF4KXtcbiAgICAgICAgICAgICAgICBjb2xvciA9IF9leHByZXNzaW9uLnVwQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIGNvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBfaW5pdENvbnRyb2xCYXIgPSBmdW5jdGlvbigpe1xuICAgIFxuICAgIHZhciBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBcbiAgICB2YXIgdG9vbGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRvb2xiYXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4Ojk5OTk5OTt0b3A6MjBweDtmbG9hdDpyaWdodDtmb250LXNpemU6MC44ZW07bWFyZ2luLXJpZ2h0OiAyMHB4OycpO1xuICAgIHRvb2xiYXIuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3ZWxsIGZvcm0tZ3JvdXAnKTtcbiAgICBcbiAgICAvKlNlbGVjdCovXG4gICAgdmFyIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgIHNlbGVjdC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2Zvcm0tY29udHJvbCcpO1xuICAgIFxuICAgIF9leHByZXNzaW9uLmNvbmRpdGlvbnMudW5zaGlmdCh7bmFtZSA6ICdubyBjb25kaXRpb24nfSk7XG4gICAgXG4gICAgXG4gICAgZm9yKHZhciBpPTA7IGk8X2V4cHJlc3Npb24uY29uZGl0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlID0gX2V4cHJlc3Npb24uY29uZGl0aW9uc1tpXTtcbiAgICAgICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICBvcHQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIGUubmFtZSk7XG4gICAgICAgIG9wdC50ZXh0ID0gZS5uYW1lO1xuICAgICAgICBcbiAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG4gICAgICAgIFxuICAgICAgICBpZihlLnZhbHVlcyl7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIF9maW5kZXIoTWF0aC5tYXgsIGUudmFsdWVzKSk7XG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIF9maW5kZXIoTWF0aC5taW4sIGUudmFsdWVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLypPbiBDaGFuZ2UgRXZlbnQqL1xuICAgIHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbigpe1xuICAgICAgICBfcGFpbnRFeHByZXNzaW9uKF9leHByZXNzaW9uLmNvbmRpdGlvbnNbc2VsZWN0LnNlbGVjdGVkSW5kZXhdKTtcbiAgICB9KTtcbiAgICBcbiAgICAvKiBQbGF5IEJ1dHRvbiAqL1xuICAgIHZhciBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKCdjbGFzcycsICdnbHlwaGljb24gZ2x5cGhpY29uLXBsYXknKTtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIFxuICAgIFxuICAgIHZhciBwbGF5QnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgcGxheUJ0bi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgcGxheUJ0bi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2J0biBidG4tZGVmYXVsdCBidG4tc20gZm9ybS1jb250cm9sJyk7XG4gICAgcGxheUJ0bi5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ21hcmdpbi10b3A6NXB4O21hcmdpbi1ib3R0b206NXB4OycpO1xuICAgIHBsYXlCdG4uYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgXG4gICAgLypPbiBDbGljayBFdmVudCovXG4gICAgcGxheUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmKHNwYW4uY2xhc3NOYW1lLmxhc3RJbmRleE9mKCdnbHlwaGljb24tcGxheScpICE9IC0xKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9QbGF5XG4gICAgICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IHNwYW4uY2xhc3NOYW1lLnJlcGxhY2UoJ2dseXBoaWNvbi1wbGF5JyAsICdnbHlwaGljb24tc3RvcCcgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IChzZWxlY3Quc2VsZWN0ZWRJbmRleCA9PT0gc2VsZWN0Lmxlbmd0aCAtIDEpID8gMCA6IHNlbGVjdC5zZWxlY3RlZEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICBfcGFpbnRFeHByZXNzaW9uKF9leHByZXNzaW9uLmNvbmRpdGlvbnNbc2VsZWN0LnNlbGVjdGVkSW5kZXhdKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vU3RvcFxuICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBzcGFuLmNsYXNzTmFtZS5yZXBsYWNlKCdnbHlwaGljb24tc3RvcCcgLCAnZ2x5cGhpY29uLXBsYXknICk7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChfaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0pO1xuICAgIFxuICAgIC8qIFNsaWRlciBJbnB1dCAqL1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCdpZCcsICdzbCcpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2xpZGVyJyk7XG4gICAgXG4gICAgLyogU2xpZGVyIFN0eWxlICovXG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS5pbm5lckhUTUwgPSAnLnNsaWRlci10cmFjay1oaWdoIHsgYmFja2dyb3VuZDogJysgX2V4cHJlc3Npb24udXBDb2xvciArJzt9IC5zbGlkZXItdHJhY2stbG93IHsgYmFja2dyb3VuZDogJysgX2V4cHJlc3Npb24uZG93bkNvbG9yICsnO30nO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIFxuICAgIHRvb2xiYXIuYXBwZW5kQ2hpbGQoc2VsZWN0KTtcbiAgICB0b29sYmFyLmFwcGVuZENoaWxkKHBsYXlCdG4pO1xuICAgIHRvb2xiYXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIFxuICAgIF90YXJnZXQuYXBwZW5kQ2hpbGQodG9vbGJhcik7XG4gICAgXG4gICAgdmFyIGN1dCA9IChtYXggLSBtaW4pLzQ7XG4gICAgXG4gICAgLy9Jbml0IHNsaWRlclxuICAgIF9zbGlkZXIgPSBuZXcgU2xpZGVyKCcjc2wnLCB7bWluICA6IG1pbiwgbWF4ICA6IG1heCwgdmFsdWU6IFsgbWluICsgY3V0LCBtYXggLSBjdXQgXSwgc3RlcDowLjAxfSk7XG4gICAgX3NsaWRlci5vbignc2xpZGVTdG9wJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIF9wYWludEV4cHJlc3Npb24oX2V4cHJlc3Npb24uY29uZGl0aW9uc1tzZWxlY3Quc2VsZWN0ZWRJbmRleF0pO1xuICAgIH0pO1xufTtcblxuLy8gUHVibGljIG1lbWJlcnNcbnZhciBhcHAgPSBmdW5jdGlvbigpe307XG5cbmFwcC50YXJnZXQgPSBmdW5jdGlvbihfKXtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBfdGFyZ2V0O1xuICAgIF90YXJnZXQgPSBfO1xuICAgIHJldHVybiBhcHA7XG59O1xuXG5hcHAucGF0aHdheSA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9wYXRod2F5O1xuICAgIF9wYXRod2F5ID0gXztcbiAgICByZXR1cm4gYXBwO1xufTtcblxuYXBwLnByb3h5ID0gZnVuY3Rpb24oXyl7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX3Byb3h5O1xuICAgIF9wcm94eSA9IF87XG4gICAgcmV0dXJuIGFwcDtcbn07XG5cbmFwcC5leHByZXNzaW9uID0gZnVuY3Rpb24oXyl7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX2V4cHJlc3Npb247XG4gICAgX2V4cHJlc3Npb24gPSBfO1xuICAgIHJldHVybiBhcHA7XG59O1xuXG5hcHAuaW5pdCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoX2V4cHJlc3Npb24gIT09IG51bGwpIF9pbml0Q29udHJvbEJhcigpO1xuICAgIF9xdWVyeSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhcHA7IiwiLy9MaWJyYXJpZXNcbnZhciBjeXRvc2NhcGUgPSByZXF1aXJlKCdjeXRvc2NhcGUnKTtcblxuLy9WYXJpYWJsZXNcbnZhciBwb3NpdGlvbnMgPSB7fSwgbm9kZV9tYXAgPSB7fSwgbm9kZXMgPSBbXSwgbGlua3MgPSBbXTtcblxuZnVuY3Rpb24gX3Byb2Nlc3NFbnRyeShlbnRyeSl7XG5cbiAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgc2hhcGU6ICdyZWN0YW5nbGUnLFxuICAgICAgICBia2dfY29sb3I6ICcjOTlmZjk5JyxcbiAgICAgICAgdGV4dF92YWxpZ246ICdjZW50ZXInLFxuICAgICAgICBib3JkZXJfd2lkdGg6IDBcbiAgICB9O1xuICAgIFxuICAgIHZhciBncmFwaGljcyA9IGVudHJ5LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdncmFwaGljcycpWzBdO1xuICAgIHZhciB0eXBlID0gZW50cnkuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgdmFyIG5hbWVzID0gKGdyYXBoaWNzLmdldEF0dHJpYnV0ZSgnbmFtZScpICE9PSBudWxsKSA/IGdyYXBoaWNzLmdldEF0dHJpYnV0ZSgnbmFtZScpLnNwbGl0KCcsJykgOiBbXTtcbiAgICAgICAgXG4gICAgbm9kZS53aWR0aCA9IGdyYXBoaWNzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICBub2RlLmhlaWdodCA9IGdyYXBoaWNzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICBub2RlLmlkID0gZW50cnkuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgIG5vZGUua2VnZ0lkID0gZW50cnkuZ2V0QXR0cmlidXRlKCduYW1lJykuc3BsaXQoJyAnKTtcbiAgICBub2RlLm5hbWUgPSBuYW1lc1swXSB8fCAnJztcbiAgICBub2RlLm5hbWVzID0gbmFtZXM7XG4gICAgbm9kZS5saW5rID0gZW50cnkuZ2V0QXR0cmlidXRlKCdsaW5rJyk7XG4gICAgXG4gICAgaWYodHlwZSA9PSAnb3J0aG9sb2cnIHx8IHR5cGUgPT0gJ2dlbmUnKXtcbiAgICAgICAgICAgIG5vZGUuYm9yZGVyX3dpZHRoID0gMTtcbiAgICB9ZWxzZSBpZih0eXBlID09ICdjb21wb3VuZCcpe1xuICAgICAgICBub2RlLnNoYXBlID0gJ2VsbGlwc2UnO1xuICAgICAgICBub2RlLmJrZ19jb2xvciA9ICcjYWFhYWVlJztcbiAgICAgICAgbm9kZS50ZXh0X3ZhbGlnbiA9ICdib3R0b20nO1xuICAgIH1lbHNlIGlmKHR5cGUgPT0gJ21hcCcpe1xuICAgICAgICBub2RlLnNoYXBlID0gJ3JvdW5kcmVjdGFuZ2xlJztcbiAgICAgICAgbm9kZS5ia2dfY29sb3IgPSAnIzAwYmZmZic7XG4gICAgfWVsc2UgaWYoIHR5cGUgPT0gJ2dyb3VwJyl7XG4gICAgICAgIFxuICAgICAgICB2YXIgY29tcG9uZW50cyA9IGVudHJ5LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjb21wb25lbnQnKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbm9kZV9tYXBbY29tcG9uZW50c1tpXS5nZXRBdHRyaWJ1dGUoJ2lkJyldLmRhdGEucGFyZW50ID0gbm9kZS5pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBub2RlX21hcFtub2RlLmlkXSA9IHtkYXRhOiBub2RlfTtcbiAgICBub2Rlcy5wdXNoKG5vZGVfbWFwW25vZGUuaWRdKTtcbiAgICAgICAgICAgIFxuICAgIHBvc2l0aW9uc1tub2RlLmlkXSA9IHtcbiAgICAgICAgeCA6ICtncmFwaGljcy5nZXRBdHRyaWJ1dGUoJ3gnKSxcbiAgICAgICAgeSA6ICtncmFwaGljcy5nZXRBdHRyaWJ1dGUoJ3knKVxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBfcHJvY2Vzc1JlbGF0aW9uKHJlbCl7XG4gICAgdmFyIHR5cGUgPSByZWwuZ2V0QXR0cmlidXRlKCd0eXBlJyksIHN1YnR5cGVzID0gW107XG4gICAgXG4gICAgdmFyIHN1YnMgPSByZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N1YnR5cGUnKTtcbiAgICBmb3IodmFyIGk9MDsgaTxzdWJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHN1YiA9IHN1YnNbaV07XG4gICAgICAgIFxuICAgICAgICB2YXIgZWRnZSA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogcmVsLmdldEF0dHJpYnV0ZSgnZW50cnkxJyksXG4gICAgICAgICAgICB0YXJnZXQ6IHJlbC5nZXRBdHRyaWJ1dGUoJ2VudHJ5MicpLFxuICAgICAgICAgICAgbmFtZTogc3ViLmdldEF0dHJpYnV0ZSgnbmFtZScpLFxuICAgICAgICAgICAgcmVhY3Rpb246IHR5cGUsXG4gICAgICAgICAgICBsaW5lX3N0eWxlOiAnc29saWQnLFxuICAgICAgICAgICAgdGFyZ2V0X2Fycm93X3NoYXBlOiAnbm9uZScsXG4gICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgaWYoZWRnZS5uYW1lID09ICdtYXBsaW5rJyl7XG4gICAgICAgICAgICBlZGdlLnRhcmdldF9hcnJvd19zaGFwZSA9ICdkaWFtb25kJztcbiAgICAgICAgfWVsc2UgaWYoZWRnZS5uYW1lID09ICdpbmRpcmVjdCBlZmZlY3QnKXtcbiAgICAgICAgICAgIGVkZ2UubGluZV9zdHlsZSA9ICdkb3R0ZWQnO1xuICAgICAgICAgICAgZWRnZS50YXJnZXRfYXJyb3dfc2hhcGUgPSAnZGlhbW9uZCdcbiAgICAgICAgfWVsc2UgaWYoZWRnZS5uYW1lID09ICdzdGF0ZSBjaGFuZ2UnKXtcbiAgICAgICAgICAgIGVkZ2UubGluZV9zdHlsZSA9ICdkb3R0ZWQnO1xuICAgICAgICB9ZWxzZSBpZihlZGdlLm5hbWUgPT0gJ21pc3NpbmcgaW50ZXJhY3Rpb24nKXtcbiAgICAgICAgICAgIGVkZ2UubGluZV9zdHlsZSA9ICdkb3R0ZWQnO1xuICAgICAgICAgICAgZWRnZS50YXJnZXRfYXJyb3dfc2hhcGUgPSAndHJpYW5nbGUnO1xuICAgICAgICB9ZWxzZSBpZihlZGdlLm5hbWUgPT0gJ3Bob3NwaG9yeWxhdGlvbicpe1xuICAgICAgICAgICAgZWRnZS50YXJnZXRfYXJyb3dfc2hhcGUgPSAndHJpYW5nbGUnO1xuICAgICAgICAgICAgZWRnZS50ZXh0ID0gJ3ArJztcbiAgICAgICAgfWVsc2UgaWYoZWRnZS5uYW1lID09ICdkZXBob3NwaG9yeWxhdGlvbicpe1xuICAgICAgICAgICAgZWRnZS50YXJnZXRfYXJyb3dfc2hhcGUgPSAndHJpYW5nbGUnO1xuICAgICAgICAgICAgZWRnZS50ZXh0ID0gJ3AtJztcbiAgICAgICAgfWVsc2UgaWYoZWRnZS5uYW1lID09ICdnbHljb3N5bGF0aW9uJyl7XG4gICAgICAgICAgICBlZGdlLmxpbmVfc3R5bGUgPSAnZGFzaGVkJztcbiAgICAgICAgICAgIGVkZ2UudGFyZ2V0X2Fycm93X3NoYXBlID0gJ2NpcmNsZSc7XG4gICAgICAgIH1lbHNlIGlmKGVkZ2UubmFtZSA9PSAndWJpcXVpdGluYXRpb24nKXtcbiAgICAgICAgICAgIGVkZ2UubGluZV9zdHlsZSA9ICdkYXNoZWQnO1xuICAgICAgICAgICAgZWRnZS50YXJnZXRfYXJyb3dfc2hhcGUgPSAnY2lyY2xlJztcbiAgICAgICAgfWVsc2UgaWYoZWRnZS5uYW1lID09ICdtZXRoeWxhdGlvbicpe1xuICAgICAgICAgICAgZWRnZS5saW5lX3N0eWxlID0gJ2Rhc2hlZCc7XG4gICAgICAgICAgICBlZGdlLnRhcmdldF9hcnJvd19zaGFwZSA9ICdjaXJjbGUnO1xuICAgICAgICB9ZWxzZSBpZihlZGdlLm5hbWUgPT0gJ2FjdGl2YXRpb24nKXtcbiAgICAgICAgICAgIGVkZ2UudGFyZ2V0X2Fycm93X3NoYXBlID0gJ3RyaWFuZ2xlJztcbiAgICAgICAgfWVsc2UgaWYoZWRnZS5uYW1lID09ICdpbmhpYml0aW9uJyl7XG4gICAgICAgICAgICBlZGdlLnRhcmdldF9hcnJvd19zaGFwZSA9ICd0ZWUnO1xuICAgICAgICB9ZWxzZSBpZihlZGdlLm5hbWUgPT0gJ2V4cHJlc3Npb24nKXtcbiAgICAgICAgICAgIGVkZ2UudGFyZ2V0X2Fycm93X3NoYXBlID0gJ3RyaWFuZ2xlJztcbiAgICAgICAgfWVsc2UgaWYoZWRnZS5uYW1lID09ICdyZXByZXNzaW9uJyl7XG4gICAgICAgICAgICBlZGdlLnRhcmdldF9hcnJvd19zaGFwZSA9ICd0ZWUnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGE6ZWRnZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgfTtcbn07XG5cbnZhciByZW5kZXJQYXRod2F5ID0gZnVuY3Rpb24oZGF0YSwgdGFyZ2V0KXtcbiAgICBcbiAgICBcbiAgICBcbiAgICB2YXIgZW50cmllcyA9IGRhdGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VudHJ5Jyk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBfcHJvY2Vzc0VudHJ5KGVudHJpZXNbaV0pO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcmVscyA9IGRhdGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3JlbGF0aW9uJyk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHJlbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICBfcHJvY2Vzc1JlbGF0aW9uKHJlbHNbaV0pO1xuICAgIH1cbiAgICBcbiAgICB2YXIgY3kgPSBjeXRvc2NhcGUoe1xuICAgICAgICBjb250YWluZXI6IHRhcmdldCxcbiAgICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgICAgIG5vZGVzIDogbm9kZXMsXG4gICAgICAgICAgICBlZGdlcyA6IGxpbmtzXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiBjeXRvc2NhcGUuc3R5bGVzaGVldCgpXG4gICAgICAgICAgICAuc2VsZWN0b3IoJ25vZGUnKS5jc3Moe1xuICAgICAgICAgICAgICAgICdjb250ZW50JzogJ2RhdGEobmFtZSknLFxuICAgICAgICAgICAgICAgICd0ZXh0LXZhbGlnbic6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICd3aWR0aCc6ICAnZGF0YSh3aWR0aCknLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiAgJ2RhdGEoaGVpZ2h0KScsXG4gICAgICAgICAgICAgICAgJ3NoYXBlJzonZGF0YShzaGFwZSknLFxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJ2RhdGEoYmtnX2NvbG9yKScsXG4gICAgICAgICAgICAgICAgJ3RleHQtdmFsaWduJzogJ2RhdGEodGV4dF92YWxpZ24pJyxcbiAgICAgICAgICAgICAgICAvKidvcGFjaXR5JzogJ2RhdGEob3BhY2l0eSknLCovXG4gICAgICAgICAgICAgICAgJ2JvcmRlci1jb2xvcic6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogJ2RhdGEoYm9yZGVyX3dpZHRoKScsXG4gICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IDExLFxuICAgICAgICAgICAgICAgICd0ZXh0LXdyYXAnOiAnd3JhcCcsXG4gICAgICAgICAgICAgICAgJ3RleHQtbWF4LXdpZHRoJzogJ2RhdGEod2lkdGgpJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zZWxlY3Rvcignbm9kZScpXG4gICAgICAgICAgICAuc2VsZWN0b3IoJ2VkZ2UnKS5jc3Moe1xuICAgICAgICAgICAgICAgICdjb250ZW50JzogJ2RhdGEodGV4dCknLFxuICAgICAgICAgICAgICAgICd0YXJnZXQtYXJyb3ctc2hhcGUnOiAnZGF0YSh0YXJnZXRfYXJyb3dfc2hhcGUpJyxcbiAgICAgICAgICAgICAgICAnbGluZS1zdHlsZSc6ICdkYXRhKGxpbmVfc3R5bGUpJyxcbiAgICAgICAgICAgICAgICAnbGluZS1jb2xvcic6JyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgICd0YXJnZXQtYXJyb3ctY29sb3InOicjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICAndGV4dC12YWxpZ24nIDogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IDExXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICBuYW1lOiBcInByZXNldFwiLFxuICAgICAgICAgICAgZml0OiBmYWxzZSxcbiAgICAgICAgICAgIHBvc2l0aW9uczogcG9zaXRpb25zXG4gICAgICAgIH0scmVhZHk6ZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdLZWdnIFZpZXdlciByZWFkeScpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIGN5O1xufTtcbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyUGF0aHdheTsiLCIvKiEgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgICAgICAgICAgIFZFUlNJT04gIDYuMC42ICAgICAgICAgICAgICBcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4vKiEgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBib290c3RyYXAtc2xpZGVyLmpzXG4gKlxuICogTWFpbnRhaW5lcnM6XG4gKlx0XHRLeWxlIEtlbXBcbiAqXHRcdFx0LSBUd2l0dGVyOiBAc2VpeXJpYVxuICpcdFx0XHQtIEdpdGh1YjogIHNlaXlyaWFcbiAqXHRcdFJvaGl0IEthbGt1clxuICpcdFx0XHQtIFR3aXR0ZXI6IEBSb3ZvbHV0aW9uYXJ5XG4gKlx0XHRcdC0gR2l0aHViOiAgcm92b2x1dGlvblxuICpcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8qKlxuICogQnJpZGdldCBtYWtlcyBqUXVlcnkgd2lkZ2V0c1xuICogdjEuMC4xXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoW1wianF1ZXJ5XCJdLCBmYWN0b3J5KTtcblx0fSBlbHNlIGlmICgodHlwZW9mIG1vZHVsZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG1vZHVsZSkpID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0dmFyIGpRdWVyeTtcblx0XHR0cnkge1xuXHRcdFx0alF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdGpRdWVyeSA9IG51bGw7XG5cdFx0fVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShqUXVlcnkpO1xuXHR9IGVsc2UgaWYgKHdpbmRvdykge1xuXHRcdHdpbmRvdy5TbGlkZXIgPSBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xuXHR9XG59KShmdW5jdGlvbiAoJCkge1xuXHQvLyBSZWZlcmVuY2UgdG8gU2xpZGVyIGNvbnN0cnVjdG9yXG5cdHZhciBTbGlkZXI7XG5cblx0KGZ1bmN0aW9uICgkKSB7XG5cblx0XHQndXNlIHN0cmljdCc7XG5cblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB1dGlscyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5cdFx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5cdFx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkZWZpbml0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cblx0XHRmdW5jdGlvbiBkZWZpbmVCcmlkZ2V0KCQpIHtcblxuXHRcdFx0Ly8gYmFpbCBpZiBubyBqUXVlcnlcblx0XHRcdGlmICghJCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGFkZE9wdGlvbk1ldGhvZCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5cdFx0XHQvKipcbiAgICAqIGFkZHMgb3B0aW9uIG1ldGhvZCAtPiAkKCkucGx1Z2luKCdvcHRpb24nLCB7Li4ufSlcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFBsdWdpbkNsYXNzIC0gY29uc3RydWN0b3IgY2xhc3NcbiAgICAqL1xuXHRcdFx0ZnVuY3Rpb24gYWRkT3B0aW9uTWV0aG9kKFBsdWdpbkNsYXNzKSB7XG5cdFx0XHRcdC8vIGRvbid0IG92ZXJ3cml0ZSBvcmlnaW5hbCBvcHRpb24gbWV0aG9kXG5cdFx0XHRcdGlmIChQbHVnaW5DbGFzcy5wcm90b3R5cGUub3B0aW9uKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gb3B0aW9uIHNldHRlclxuXHRcdFx0XHRQbHVnaW5DbGFzcy5wcm90b3R5cGUub3B0aW9uID0gZnVuY3Rpb24gKG9wdHMpIHtcblx0XHRcdFx0XHQvLyBiYWlsIG91dCBpZiBub3QgYW4gb2JqZWN0XG5cdFx0XHRcdFx0aWYgKCEkLmlzUGxhaW5PYmplY3Qob3B0cykpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zID0gJC5leHRlbmQodHJ1ZSwgdGhpcy5vcHRpb25zLCBvcHRzKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gcGx1Z2luIGJyaWRnZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5cdFx0XHQvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIGxvZ2dpbmcgZXJyb3JzXG5cdFx0XHQvLyAkLmVycm9yIGJyZWFrcyBqUXVlcnkgY2hhaW5pbmdcblx0XHRcdHZhciBsb2dFcnJvciA9IHR5cGVvZiBjb25zb2xlID09PSAndW5kZWZpbmVkJyA/IG5vb3AgOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG4gICAgKiBqUXVlcnkgcGx1Z2luIGJyaWRnZSwgYWNjZXNzIG1ldGhvZHMgbGlrZSAkZWxlbS5wbHVnaW4oJ21ldGhvZCcpXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIC0gcGx1Z2luIG5hbWVcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFBsdWdpbkNsYXNzIC0gY29uc3RydWN0b3IgY2xhc3NcbiAgICAqL1xuXHRcdFx0ZnVuY3Rpb24gYnJpZGdlKG5hbWVzcGFjZSwgUGx1Z2luQ2xhc3MpIHtcblx0XHRcdFx0Ly8gYWRkIHRvIGpRdWVyeSBmbiBuYW1lc3BhY2Vcblx0XHRcdFx0JC5mbltuYW1lc3BhY2VdID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHQvLyBjYWxsIHBsdWdpbiBtZXRob2Qgd2hlbiBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRcdFx0Ly8gZ2V0IGFyZ3VtZW50cyBmb3IgbWV0aG9kXG5cdFx0XHRcdFx0XHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzW2ldO1xuXHRcdFx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoZWxlbSwgbmFtZXNwYWNlKTtcblx0XHRcdFx0XHRcdFx0aWYgKCFpbnN0YW5jZSkge1xuXHRcdFx0XHRcdFx0XHRcdGxvZ0Vycm9yKFwiY2Fubm90IGNhbGwgbWV0aG9kcyBvbiBcIiArIG5hbWVzcGFjZSArIFwiIHByaW9yIHRvIGluaXRpYWxpemF0aW9uOyBcIiArIFwiYXR0ZW1wdGVkIHRvIGNhbGwgJ1wiICsgb3B0aW9ucyArIFwiJ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoISQuaXNGdW5jdGlvbihpbnN0YW5jZVtvcHRpb25zXSkgfHwgb3B0aW9ucy5jaGFyQXQoMCkgPT09ICdfJykge1xuXHRcdFx0XHRcdFx0XHRcdGxvZ0Vycm9yKFwibm8gc3VjaCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJyBmb3IgXCIgKyBuYW1lc3BhY2UgKyBcIiBpbnN0YW5jZVwiKTtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHRyaWdnZXIgbWV0aG9kIHdpdGggYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdHZhciByZXR1cm5WYWx1ZSA9IGluc3RhbmNlW29wdGlvbnNdLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBicmVhayBsb29rIGFuZCByZXR1cm4gZmlyc3QgdmFsdWUgaWYgcHJvdmlkZWRcblx0XHRcdFx0XHRcdFx0aWYgKHJldHVyblZhbHVlICE9PSB1bmRlZmluZWQgJiYgcmV0dXJuVmFsdWUgIT09IGluc3RhbmNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyByZXR1cm4gdGhpcyBpZiBubyByZXR1cm4gdmFsdWVcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgb2JqZWN0cyA9IHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGluc3RhbmNlID0gJC5kYXRhKHRoaXMsIG5hbWVzcGFjZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChpbnN0YW5jZSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGFwcGx5IG9wdGlvbnMgJiBpbml0XG5cdFx0XHRcdFx0XHRcdFx0aW5zdGFuY2Uub3B0aW9uKG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0XHRcdGluc3RhbmNlLl9pbml0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gaW5pdGlhbGl6ZSBuZXcgaW5zdGFuY2Vcblx0XHRcdFx0XHRcdFx0XHRpbnN0YW5jZSA9IG5ldyBQbHVnaW5DbGFzcyh0aGlzLCBvcHRpb25zKTtcblx0XHRcdFx0XHRcdFx0XHQkLmRhdGEodGhpcywgbmFtZXNwYWNlLCBpbnN0YW5jZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuICQodGhpcyk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCFvYmplY3RzIHx8IG9iamVjdHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JqZWN0cztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBvYmplY3RzWzBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gYnJpZGdldCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5cdFx0XHQvKipcbiAgICAqIGNvbnZlcnRzIGEgUHJvdG90eXBpY2FsIGNsYXNzIGludG8gYSBwcm9wZXIgalF1ZXJ5IHBsdWdpblxuICAgICogICB0aGUgY2xhc3MgbXVzdCBoYXZlIGEgLl9pbml0IG1ldGhvZFxuICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSAtIHBsdWdpbiBuYW1lLCB1c2VkIGluICQoKS5wbHVnaW5OYW1lXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBQbHVnaW5DbGFzcyAtIGNvbnN0cnVjdG9yIGNsYXNzXG4gICAgKi9cblx0XHRcdCQuYnJpZGdldCA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIFBsdWdpbkNsYXNzKSB7XG5cdFx0XHRcdGFkZE9wdGlvbk1ldGhvZChQbHVnaW5DbGFzcyk7XG5cdFx0XHRcdGJyaWRnZShuYW1lc3BhY2UsIFBsdWdpbkNsYXNzKTtcblx0XHRcdH07XG5cblx0XHRcdHJldHVybiAkLmJyaWRnZXQ7XG5cdFx0fVxuXG5cdFx0Ly8gZ2V0IGpxdWVyeSBmcm9tIGJyb3dzZXIgZ2xvYmFsXG5cdFx0ZGVmaW5lQnJpZGdldCgkKTtcblx0fSkoJCk7XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiBcdFx0XHRCT09UU1RSQVAtU0xJREVSIFNPVVJDRSBDT0RFXG4gXHQqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHQoZnVuY3Rpb24gKCQpIHtcblxuXHRcdHZhciBFcnJvck1zZ3MgPSB7XG5cdFx0XHRmb3JtYXRJbnZhbGlkSW5wdXRFcnJvck1zZzogZnVuY3Rpb24gZm9ybWF0SW52YWxpZElucHV0RXJyb3JNc2coaW5wdXQpIHtcblx0XHRcdFx0cmV0dXJuIFwiSW52YWxpZCBpbnB1dCB2YWx1ZSAnXCIgKyBpbnB1dCArIFwiJyBwYXNzZWQgaW5cIjtcblx0XHRcdH0sXG5cdFx0XHRjYWxsaW5nQ29udGV4dE5vdFNsaWRlckluc3RhbmNlOiBcIkNhbGxpbmcgY29udGV4dCBlbGVtZW50IGRvZXMgbm90IGhhdmUgaW5zdGFuY2Ugb2YgU2xpZGVyIGJvdW5kIHRvIGl0LiBDaGVjayB5b3VyIGNvZGUgdG8gbWFrZSBzdXJlIHRoZSBKUXVlcnkgb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIGNhbGwgdG8gdGhlIHNsaWRlcigpIGluaXRpYWxpemVyIGlzIGNhbGxpbmcgdGhlIG1ldGhvZFwiXG5cdFx0fTtcblxuXHRcdHZhciBTbGlkZXJTY2FsZSA9IHtcblx0XHRcdGxpbmVhcjoge1xuXHRcdFx0XHR0b1ZhbHVlOiBmdW5jdGlvbiB0b1ZhbHVlKHBlcmNlbnRhZ2UpIHtcblx0XHRcdFx0XHR2YXIgcmF3VmFsdWUgPSBwZXJjZW50YWdlIC8gMTAwICogKHRoaXMub3B0aW9ucy5tYXggLSB0aGlzLm9wdGlvbnMubWluKTtcblx0XHRcdFx0XHR2YXIgc2hvdWxkQWRqdXN0V2l0aEJhc2UgPSB0cnVlO1xuXHRcdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdHZhciBtaW52LFxuXHRcdFx0XHRcdFx0ICAgIG1heHYsXG5cdFx0XHRcdFx0XHQgICAgbWlucCxcblx0XHRcdFx0XHRcdCAgICBtYXhwID0gMDtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRpZiAocGVyY2VudGFnZSA8PSB0aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zW2ldKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWludiA9IHRoaXMub3B0aW9ucy50aWNrc1tpIC0gMV07XG5cdFx0XHRcdFx0XHRcdFx0bWlucCA9IHRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnNbaSAtIDFdO1xuXHRcdFx0XHRcdFx0XHRcdG1heHYgPSB0aGlzLm9wdGlvbnMudGlja3NbaV07XG5cdFx0XHRcdFx0XHRcdFx0bWF4cCA9IHRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnNbaV07XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHBhcnRpYWxQZXJjZW50YWdlID0gKHBlcmNlbnRhZ2UgLSBtaW5wKSAvIChtYXhwIC0gbWlucCk7XG5cdFx0XHRcdFx0XHRyYXdWYWx1ZSA9IG1pbnYgKyBwYXJ0aWFsUGVyY2VudGFnZSAqIChtYXh2IC0gbWludik7XG5cdFx0XHRcdFx0XHRzaG91bGRBZGp1c3RXaXRoQmFzZSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBhZGp1c3RtZW50ID0gc2hvdWxkQWRqdXN0V2l0aEJhc2UgPyB0aGlzLm9wdGlvbnMubWluIDogMDtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBhZGp1c3RtZW50ICsgTWF0aC5yb3VuZChyYXdWYWx1ZSAvIHRoaXMub3B0aW9ucy5zdGVwKSAqIHRoaXMub3B0aW9ucy5zdGVwO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA8IHRoaXMub3B0aW9ucy5taW4pIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPiB0aGlzLm9wdGlvbnMubWF4KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0dG9QZXJjZW50YWdlOiBmdW5jdGlvbiB0b1BlcmNlbnRhZ2UodmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLm1heCA9PT0gdGhpcy5vcHRpb25zLm1pbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0dmFyIG1pbnYsXG5cdFx0XHRcdFx0XHQgICAgbWF4dixcblx0XHRcdFx0XHRcdCAgICBtaW5wLFxuXHRcdFx0XHRcdFx0ICAgIG1heHAgPSAwO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMudGlja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlIDw9IHRoaXMub3B0aW9ucy50aWNrc1tpXSkge1xuXHRcdFx0XHRcdFx0XHRcdG1pbnYgPSBpID4gMCA/IHRoaXMub3B0aW9ucy50aWNrc1tpIC0gMV0gOiAwO1xuXHRcdFx0XHRcdFx0XHRcdG1pbnAgPSBpID4gMCA/IHRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnNbaSAtIDFdIDogMDtcblx0XHRcdFx0XHRcdFx0XHRtYXh2ID0gdGhpcy5vcHRpb25zLnRpY2tzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdG1heHAgPSB0aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zW2ldO1xuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgcGFydGlhbFBlcmNlbnRhZ2UgPSAodmFsdWUgLSBtaW52KSAvIChtYXh2IC0gbWludik7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBtaW5wICsgcGFydGlhbFBlcmNlbnRhZ2UgKiAobWF4cCAtIG1pbnApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiAxMDAgKiAodmFsdWUgLSB0aGlzLm9wdGlvbnMubWluKSAvICh0aGlzLm9wdGlvbnMubWF4IC0gdGhpcy5vcHRpb25zLm1pbik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGxvZ2FyaXRobWljOiB7XG5cdFx0XHRcdC8qIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ2MjIxL2xvZ2FyaXRobWljLXNsaWRlciAqL1xuXHRcdFx0XHR0b1ZhbHVlOiBmdW5jdGlvbiB0b1ZhbHVlKHBlcmNlbnRhZ2UpIHtcblx0XHRcdFx0XHR2YXIgbWluID0gdGhpcy5vcHRpb25zLm1pbiA9PT0gMCA/IDAgOiBNYXRoLmxvZyh0aGlzLm9wdGlvbnMubWluKTtcblx0XHRcdFx0XHR2YXIgbWF4ID0gTWF0aC5sb2codGhpcy5vcHRpb25zLm1heCk7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gTWF0aC5leHAobWluICsgKG1heCAtIG1pbikgKiBwZXJjZW50YWdlIC8gMTAwKTtcblx0XHRcdFx0XHR2YWx1ZSA9IHRoaXMub3B0aW9ucy5taW4gKyBNYXRoLnJvdW5kKCh2YWx1ZSAtIHRoaXMub3B0aW9ucy5taW4pIC8gdGhpcy5vcHRpb25zLnN0ZXApICogdGhpcy5vcHRpb25zLnN0ZXA7XG5cdFx0XHRcdFx0LyogUm91bmRpbmcgdG8gdGhlIG5lYXJlc3Qgc3RlcCBjb3VsZCBleGNlZWQgdGhlIG1pbiBvclxuICAgICAgKiBtYXgsIHNvIGNsaXAgdG8gdGhvc2UgdmFsdWVzLiAqL1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA8IHRoaXMub3B0aW9ucy5taW4pIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPiB0aGlzLm9wdGlvbnMubWF4KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0dG9QZXJjZW50YWdlOiBmdW5jdGlvbiB0b1BlcmNlbnRhZ2UodmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLm1heCA9PT0gdGhpcy5vcHRpb25zLm1pbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBtYXggPSBNYXRoLmxvZyh0aGlzLm9wdGlvbnMubWF4KTtcblx0XHRcdFx0XHRcdHZhciBtaW4gPSB0aGlzLm9wdGlvbnMubWluID09PSAwID8gMCA6IE1hdGgubG9nKHRoaXMub3B0aW9ucy5taW4pO1xuXHRcdFx0XHRcdFx0dmFyIHYgPSB2YWx1ZSA9PT0gMCA/IDAgOiBNYXRoLmxvZyh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gMTAwICogKHYgLSBtaW4pIC8gKG1heCAtIG1pbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIFx0XHRcdFx0XHRcdENPTlNUUlVDVE9SXG4gIFx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdFx0U2xpZGVyID0gZnVuY3Rpb24gU2xpZGVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcblx0XHRcdGNyZWF0ZU5ld1NsaWRlci5jYWxsKHRoaXMsIGVsZW1lbnQsIG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZU5ld1NsaWRlcihlbGVtZW50LCBvcHRpb25zKSB7XG5cblx0XHRcdC8qXG4gICBcdFRoZSBpbnRlcm5hbCBzdGF0ZSBvYmplY3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGFib3V0IHRoZSBjdXJyZW50ICdzdGF0ZScgb2Ygc2xpZGVyLlxuICAgXHRcdFRoaXMgaW5jbHVkZXMgdmFsdWVzIHN1Y2ggYXMgdGhlIGB2YWx1ZWAsIGBlbmFibGVkYCwgZXRjLi4uXG4gICAqL1xuXHRcdFx0dGhpcy5fc3RhdGUgPSB7XG5cdFx0XHRcdHZhbHVlOiBudWxsLFxuXHRcdFx0XHRlbmFibGVkOiBudWxsLFxuXHRcdFx0XHRvZmZzZXQ6IG51bGwsXG5cdFx0XHRcdHNpemU6IG51bGwsXG5cdFx0XHRcdHBlcmNlbnRhZ2U6IG51bGwsXG5cdFx0XHRcdGluRHJhZzogZmFsc2UsXG5cdFx0XHRcdG92ZXI6IGZhbHNlXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KTtcblx0XHRcdH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICBcdFx0XHRcdFx0UHJvY2VzcyBPcHRpb25zXG4gICBcdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cdFx0XHR2YXIgb3B0aW9uVHlwZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25UeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgb3B0TmFtZSA9IG9wdGlvblR5cGVzW2ldO1xuXG5cdFx0XHRcdC8vIEZpcnN0IGNoZWNrIGlmIGFuIG9wdGlvbiB3YXMgcGFzc2VkIGluIHZpYSB0aGUgY29uc3RydWN0b3Jcblx0XHRcdFx0dmFyIHZhbCA9IG9wdGlvbnNbb3B0TmFtZV07XG5cdFx0XHRcdC8vIElmIG5vIGRhdGEgYXR0cmliLCB0aGVuIGNoZWNrIGRhdGEgYXRycmlidXRlc1xuXHRcdFx0XHR2YWwgPSB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJyA/IHZhbCA6IGdldERhdGFBdHRyaWIodGhpcy5lbGVtZW50LCBvcHROYW1lKTtcblx0XHRcdFx0Ly8gRmluYWxseSwgaWYgbm90aGluZyB3YXMgc3BlY2lmaWVkLCB1c2UgdGhlIGRlZmF1bHRzXG5cdFx0XHRcdHZhbCA9IHZhbCAhPT0gbnVsbCA/IHZhbCA6IHRoaXMuZGVmYXVsdE9wdGlvbnNbb3B0TmFtZV07XG5cblx0XHRcdFx0Ly8gU2V0IGFsbCBvcHRpb25zIG9uIHRoZSBpbnN0YW5jZSBvZiB0aGUgU2xpZGVyXG5cdFx0XHRcdGlmICghdGhpcy5vcHRpb25zKSB7XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5vcHRpb25zW29wdE5hbWVdID0gdmFsO1xuXHRcdFx0fVxuXG5cdFx0XHQvKlxuICAgXHRWYWxpZGF0ZSBgdG9vbHRpcF9wb3NpdGlvbmAgYWdhaW5zdCAnb3JpZW50YXRpb25gXG4gICBcdC0gaWYgYHRvb2x0aXBfcG9zaXRpb25gIGlzIGluY29tcGF0aWJsZSB3aXRoIG9yaWVudGF0aW9uLCBzd2l0aCBpdCB0byBhIGRlZmF1bHQgY29tcGF0aWJsZSB3aXRoIHNwZWNpZmllZCBgb3JpZW50YXRpb25gXG4gICBcdFx0LS0gZGVmYXVsdCBmb3IgXCJ2ZXJ0aWNhbFwiIC0+IFwicmlnaHRcIlxuICAgXHRcdC0tIGRlZmF1bHQgZm9yIFwiaG9yaXpvbnRhbFwiIC0+IFwibGVmdFwiXG4gICAqL1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICYmICh0aGlzLm9wdGlvbnMudG9vbHRpcF9wb3NpdGlvbiA9PT0gXCJ0b3BcIiB8fCB0aGlzLm9wdGlvbnMudG9vbHRpcF9wb3NpdGlvbiA9PT0gXCJib3R0b21cIikpIHtcblxuXHRcdFx0XHR0aGlzLm9wdGlvbnMudG9vbHRpcF9wb3NpdGlvbiA9IFwicmlnaHRcIjtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiAmJiAodGhpcy5vcHRpb25zLnRvb2x0aXBfcG9zaXRpb24gPT09IFwibGVmdFwiIHx8IHRoaXMub3B0aW9ucy50b29sdGlwX3Bvc2l0aW9uID09PSBcInJpZ2h0XCIpKSB7XG5cblx0XHRcdFx0dGhpcy5vcHRpb25zLnRvb2x0aXBfcG9zaXRpb24gPSBcInRvcFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXREYXRhQXR0cmliKGVsZW1lbnQsIG9wdE5hbWUpIHtcblx0XHRcdFx0dmFyIGRhdGFOYW1lID0gXCJkYXRhLXNsaWRlci1cIiArIG9wdE5hbWUucmVwbGFjZSgvXy9nLCAnLScpO1xuXHRcdFx0XHR2YXIgZGF0YVZhbFN0cmluZyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGRhdGFOYW1lKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKGRhdGFWYWxTdHJpbmcpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YVZhbFN0cmluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgXHRcdFx0XHRcdENyZWF0ZSBNYXJrdXBcbiAgIFx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdHZhciBvcmlnV2lkdGggPSB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGg7XG5cdFx0XHR2YXIgdXBkYXRlU2xpZGVyID0gZmFsc2U7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0XHR2YXIgc2xpZGVyVHJhY2tTZWxlY3Rpb247XG5cdFx0XHR2YXIgc2xpZGVyVHJhY2tMb3csIHNsaWRlclRyYWNrSGlnaDtcblx0XHRcdHZhciBzbGlkZXJNaW5IYW5kbGU7XG5cdFx0XHR2YXIgc2xpZGVyTWF4SGFuZGxlO1xuXG5cdFx0XHRpZiAodGhpcy5zbGlkZXJFbGVtKSB7XG5cdFx0XHRcdHVwZGF0ZVNsaWRlciA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKiBDcmVhdGUgZWxlbWVudHMgbmVlZGVkIGZvciBzbGlkZXIgKi9cblx0XHRcdFx0dGhpcy5zbGlkZXJFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdFx0dGhpcy5zbGlkZXJFbGVtLmNsYXNzTmFtZSA9IFwic2xpZGVyXCI7XG5cblx0XHRcdFx0LyogQ3JlYXRlIHNsaWRlciB0cmFjayBlbGVtZW50cyAqL1xuXHRcdFx0XHR2YXIgc2xpZGVyVHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0XHRzbGlkZXJUcmFjay5jbGFzc05hbWUgPSBcInNsaWRlci10cmFja1wiO1xuXG5cdFx0XHRcdHNsaWRlclRyYWNrTG93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdFx0c2xpZGVyVHJhY2tMb3cuY2xhc3NOYW1lID0gXCJzbGlkZXItdHJhY2stbG93XCI7XG5cblx0XHRcdFx0c2xpZGVyVHJhY2tTZWxlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0XHRzbGlkZXJUcmFja1NlbGVjdGlvbi5jbGFzc05hbWUgPSBcInNsaWRlci1zZWxlY3Rpb25cIjtcblxuXHRcdFx0XHRzbGlkZXJUcmFja0hpZ2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0XHRzbGlkZXJUcmFja0hpZ2guY2xhc3NOYW1lID0gXCJzbGlkZXItdHJhY2staGlnaFwiO1xuXG5cdFx0XHRcdHNsaWRlck1pbkhhbmRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0XHRcdHNsaWRlck1pbkhhbmRsZS5jbGFzc05hbWUgPSBcInNsaWRlci1oYW5kbGUgbWluLXNsaWRlci1oYW5kbGVcIjtcblx0XHRcdFx0c2xpZGVyTWluSGFuZGxlLnNldEF0dHJpYnV0ZSgncm9sZScsICdzbGlkZXInKTtcblx0XHRcdFx0c2xpZGVyTWluSGFuZGxlLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW1pbicsIHRoaXMub3B0aW9ucy5taW4pO1xuXHRcdFx0XHRzbGlkZXJNaW5IYW5kbGUuc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbWF4JywgdGhpcy5vcHRpb25zLm1heCk7XG5cblx0XHRcdFx0c2xpZGVyTWF4SGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdFx0c2xpZGVyTWF4SGFuZGxlLmNsYXNzTmFtZSA9IFwic2xpZGVyLWhhbmRsZSBtYXgtc2xpZGVyLWhhbmRsZVwiO1xuXHRcdFx0XHRzbGlkZXJNYXhIYW5kbGUuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3NsaWRlcicpO1xuXHRcdFx0XHRzbGlkZXJNYXhIYW5kbGUuc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbWluJywgdGhpcy5vcHRpb25zLm1pbik7XG5cdFx0XHRcdHNsaWRlck1heEhhbmRsZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVtYXgnLCB0aGlzLm9wdGlvbnMubWF4KTtcblxuXHRcdFx0XHRzbGlkZXJUcmFjay5hcHBlbmRDaGlsZChzbGlkZXJUcmFja0xvdyk7XG5cdFx0XHRcdHNsaWRlclRyYWNrLmFwcGVuZENoaWxkKHNsaWRlclRyYWNrU2VsZWN0aW9uKTtcblx0XHRcdFx0c2xpZGVyVHJhY2suYXBwZW5kQ2hpbGQoc2xpZGVyVHJhY2tIaWdoKTtcblxuXHRcdFx0XHQvKiBBZGQgYXJpYS1sYWJlbGxlZGJ5IHRvIGhhbmRsZSdzICovXG5cdFx0XHRcdHZhciBpc0xhYmVsbGVkYnlBcnJheSA9IEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmxhYmVsbGVkYnkpO1xuXHRcdFx0XHRpZiAoaXNMYWJlbGxlZGJ5QXJyYXkgJiYgdGhpcy5vcHRpb25zLmxhYmVsbGVkYnlbMF0pIHtcblx0XHRcdFx0XHRzbGlkZXJNaW5IYW5kbGUuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLm9wdGlvbnMubGFiZWxsZWRieVswXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzTGFiZWxsZWRieUFycmF5ICYmIHRoaXMub3B0aW9ucy5sYWJlbGxlZGJ5WzFdKSB7XG5cdFx0XHRcdFx0c2xpZGVyTWF4SGFuZGxlLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5JywgdGhpcy5vcHRpb25zLmxhYmVsbGVkYnlbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaXNMYWJlbGxlZGJ5QXJyYXkgJiYgdGhpcy5vcHRpb25zLmxhYmVsbGVkYnkpIHtcblx0XHRcdFx0XHRzbGlkZXJNaW5IYW5kbGUuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLm9wdGlvbnMubGFiZWxsZWRieSk7XG5cdFx0XHRcdFx0c2xpZGVyTWF4SGFuZGxlLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5JywgdGhpcy5vcHRpb25zLmxhYmVsbGVkYnkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogQ3JlYXRlIHRpY2tzICovXG5cdFx0XHRcdHRoaXMudGlja3MgPSBbXTtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnRpY2tzKSAmJiB0aGlzLm9wdGlvbnMudGlja3MubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMudGlja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciB0aWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdFx0XHR0aWNrLmNsYXNzTmFtZSA9ICdzbGlkZXItdGljayc7XG5cblx0XHRcdFx0XHRcdHRoaXMudGlja3MucHVzaCh0aWNrKTtcblx0XHRcdFx0XHRcdHNsaWRlclRyYWNrLmFwcGVuZENoaWxkKHRpY2spO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNsaWRlclRyYWNrU2VsZWN0aW9uLmNsYXNzTmFtZSArPSBcIiB0aWNrLXNsaWRlci1zZWxlY3Rpb25cIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNsaWRlclRyYWNrLmFwcGVuZENoaWxkKHNsaWRlck1pbkhhbmRsZSk7XG5cdFx0XHRcdHNsaWRlclRyYWNrLmFwcGVuZENoaWxkKHNsaWRlck1heEhhbmRsZSk7XG5cblx0XHRcdFx0dGhpcy50aWNrTGFiZWxzID0gW107XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy50aWNrc19sYWJlbHMpICYmIHRoaXMub3B0aW9ucy50aWNrc19sYWJlbHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHRoaXMudGlja0xhYmVsQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdFx0dGhpcy50aWNrTGFiZWxDb250YWluZXIuY2xhc3NOYW1lID0gJ3NsaWRlci10aWNrLWxhYmVsLWNvbnRhaW5lcic7XG5cblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLnRpY2tzX2xhYmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdFx0XHR2YXIgbm9UaWNrUG9zaXRpb25zU3BlY2lmaWVkID0gdGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9ucy5sZW5ndGggPT09IDA7XG5cdFx0XHRcdFx0XHR2YXIgdGlja0xhYmVsc0luZGV4ID0gdGhpcy5vcHRpb25zLnJldmVyc2VkICYmIG5vVGlja1Bvc2l0aW9uc1NwZWNpZmllZCA/IHRoaXMub3B0aW9ucy50aWNrc19sYWJlbHMubGVuZ3RoIC0gKGkgKyAxKSA6IGk7XG5cdFx0XHRcdFx0XHRsYWJlbC5jbGFzc05hbWUgPSAnc2xpZGVyLXRpY2stbGFiZWwnO1xuXHRcdFx0XHRcdFx0bGFiZWwuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnRpY2tzX2xhYmVsc1t0aWNrTGFiZWxzSW5kZXhdO1xuXG5cdFx0XHRcdFx0XHR0aGlzLnRpY2tMYWJlbHMucHVzaChsYWJlbCk7XG5cdFx0XHRcdFx0XHR0aGlzLnRpY2tMYWJlbENvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNyZWF0ZUFuZEFwcGVuZFRvb2x0aXBTdWJFbGVtZW50cyA9IGZ1bmN0aW9uIGNyZWF0ZUFuZEFwcGVuZFRvb2x0aXBTdWJFbGVtZW50cyh0b29sdGlwRWxlbSkge1xuXHRcdFx0XHRcdHZhciBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0XHRcdFx0YXJyb3cuY2xhc3NOYW1lID0gXCJ0b29sdGlwLWFycm93XCI7XG5cblx0XHRcdFx0XHR2YXIgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0XHRcdGlubmVyLmNsYXNzTmFtZSA9IFwidG9vbHRpcC1pbm5lclwiO1xuXG5cdFx0XHRcdFx0dG9vbHRpcEVsZW0uYXBwZW5kQ2hpbGQoYXJyb3cpO1xuXHRcdFx0XHRcdHRvb2x0aXBFbGVtLmFwcGVuZENoaWxkKGlubmVyKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvKiBDcmVhdGUgdG9vbHRpcCBlbGVtZW50cyAqL1xuXHRcdFx0XHR2YXIgc2xpZGVyVG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0XHRcdHNsaWRlclRvb2x0aXAuY2xhc3NOYW1lID0gXCJ0b29sdGlwIHRvb2x0aXAtbWFpblwiO1xuXHRcdFx0XHRzbGlkZXJUb29sdGlwLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcblx0XHRcdFx0Y3JlYXRlQW5kQXBwZW5kVG9vbHRpcFN1YkVsZW1lbnRzKHNsaWRlclRvb2x0aXApO1xuXG5cdFx0XHRcdHZhciBzbGlkZXJUb29sdGlwTWluID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdFx0c2xpZGVyVG9vbHRpcE1pbi5jbGFzc05hbWUgPSBcInRvb2x0aXAgdG9vbHRpcC1taW5cIjtcblx0XHRcdFx0c2xpZGVyVG9vbHRpcE1pbi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XG5cdFx0XHRcdGNyZWF0ZUFuZEFwcGVuZFRvb2x0aXBTdWJFbGVtZW50cyhzbGlkZXJUb29sdGlwTWluKTtcblxuXHRcdFx0XHR2YXIgc2xpZGVyVG9vbHRpcE1heCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0XHRcdHNsaWRlclRvb2x0aXBNYXguY2xhc3NOYW1lID0gXCJ0b29sdGlwIHRvb2x0aXAtbWF4XCI7XG5cdFx0XHRcdHNsaWRlclRvb2x0aXBNYXguc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xuXHRcdFx0XHRjcmVhdGVBbmRBcHBlbmRUb29sdGlwU3ViRWxlbWVudHMoc2xpZGVyVG9vbHRpcE1heCk7XG5cblx0XHRcdFx0LyogQXBwZW5kIGNvbXBvbmVudHMgdG8gc2xpZGVyRWxlbSAqL1xuXHRcdFx0XHR0aGlzLnNsaWRlckVsZW0uYXBwZW5kQ2hpbGQoc2xpZGVyVHJhY2spO1xuXHRcdFx0XHR0aGlzLnNsaWRlckVsZW0uYXBwZW5kQ2hpbGQoc2xpZGVyVG9vbHRpcCk7XG5cdFx0XHRcdHRoaXMuc2xpZGVyRWxlbS5hcHBlbmRDaGlsZChzbGlkZXJUb29sdGlwTWluKTtcblx0XHRcdFx0dGhpcy5zbGlkZXJFbGVtLmFwcGVuZENoaWxkKHNsaWRlclRvb2x0aXBNYXgpO1xuXG5cdFx0XHRcdGlmICh0aGlzLnRpY2tMYWJlbENvbnRhaW5lcikge1xuXHRcdFx0XHRcdHRoaXMuc2xpZGVyRWxlbS5hcHBlbmRDaGlsZCh0aGlzLnRpY2tMYWJlbENvbnRhaW5lcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBBcHBlbmQgc2xpZGVyIGVsZW1lbnQgdG8gcGFyZW50IGNvbnRhaW5lciwgcmlnaHQgYmVmb3JlIHRoZSBvcmlnaW5hbCA8aW5wdXQ+IGVsZW1lbnQgKi9cblx0XHRcdFx0cGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLnNsaWRlckVsZW0sIHRoaXMuZWxlbWVudCk7XG5cblx0XHRcdFx0LyogSGlkZSBvcmlnaW5hbCA8aW5wdXQ+IGVsZW1lbnQgKi9cblx0XHRcdFx0dGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0XHRcdH1cblx0XHRcdC8qIElmIEpRdWVyeSBleGlzdHMsIGNhY2hlIEpRIHJlZmVyZW5jZXMgKi9cblx0XHRcdGlmICgkKSB7XG5cdFx0XHRcdHRoaXMuJGVsZW1lbnQgPSAkKHRoaXMuZWxlbWVudCk7XG5cdFx0XHRcdHRoaXMuJHNsaWRlckVsZW0gPSAkKHRoaXMuc2xpZGVyRWxlbSk7XG5cdFx0XHR9XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICBcdFx0XHRcdFx0XHRTZXR1cFxuICAgXHQqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0XHRcdHRoaXMuZXZlbnRUb0NhbGxiYWNrTWFwID0ge307XG5cdFx0XHR0aGlzLnNsaWRlckVsZW0uaWQgPSB0aGlzLm9wdGlvbnMuaWQ7XG5cblx0XHRcdHRoaXMudG91Y2hDYXBhYmxlID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2g7XG5cblx0XHRcdHRoaXMudG9vbHRpcCA9IHRoaXMuc2xpZGVyRWxlbS5xdWVyeVNlbGVjdG9yKCcudG9vbHRpcC1tYWluJyk7XG5cdFx0XHR0aGlzLnRvb2x0aXBJbm5lciA9IHRoaXMudG9vbHRpcC5xdWVyeVNlbGVjdG9yKCcudG9vbHRpcC1pbm5lcicpO1xuXG5cdFx0XHR0aGlzLnRvb2x0aXBfbWluID0gdGhpcy5zbGlkZXJFbGVtLnF1ZXJ5U2VsZWN0b3IoJy50b29sdGlwLW1pbicpO1xuXHRcdFx0dGhpcy50b29sdGlwSW5uZXJfbWluID0gdGhpcy50b29sdGlwX21pbi5xdWVyeVNlbGVjdG9yKCcudG9vbHRpcC1pbm5lcicpO1xuXG5cdFx0XHR0aGlzLnRvb2x0aXBfbWF4ID0gdGhpcy5zbGlkZXJFbGVtLnF1ZXJ5U2VsZWN0b3IoJy50b29sdGlwLW1heCcpO1xuXHRcdFx0dGhpcy50b29sdGlwSW5uZXJfbWF4ID0gdGhpcy50b29sdGlwX21heC5xdWVyeVNlbGVjdG9yKCcudG9vbHRpcC1pbm5lcicpO1xuXG5cdFx0XHRpZiAoU2xpZGVyU2NhbGVbdGhpcy5vcHRpb25zLnNjYWxlXSkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMuc2NhbGUgPSBTbGlkZXJTY2FsZVt0aGlzLm9wdGlvbnMuc2NhbGVdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodXBkYXRlU2xpZGVyID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIFJlc2V0IGNsYXNzZXNcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy5zbGlkZXJFbGVtLCAnc2xpZGVyLWhvcml6b250YWwnKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy5zbGlkZXJFbGVtLCAnc2xpZGVyLXZlcnRpY2FsJyk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudG9vbHRpcCwgJ2hpZGUnKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50b29sdGlwX21pbiwgJ2hpZGUnKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50b29sdGlwX21heCwgJ2hpZGUnKTtcblxuXHRcdFx0XHQvLyBVbmRvIGV4aXN0aW5nIGlubGluZSBzdHlsZXMgZm9yIHRyYWNrXG5cdFx0XHRcdFtcImxlZnRcIiwgXCJ0b3BcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlUHJvcGVydHkodGhpcy50cmFja0xvdywgcHJvcCk7XG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlUHJvcGVydHkodGhpcy50cmFja1NlbGVjdGlvbiwgcHJvcCk7XG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlUHJvcGVydHkodGhpcy50cmFja0hpZ2gsIHByb3ApO1xuXHRcdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0XHQvLyBVbmRvIGlubGluZSBzdHlsZXMgb24gaGFuZGxlc1xuXHRcdFx0XHRbdGhpcy5oYW5kbGUxLCB0aGlzLmhhbmRsZTJdLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZSkge1xuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZVByb3BlcnR5KGhhbmRsZSwgJ2xlZnQnKTtcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVQcm9wZXJ0eShoYW5kbGUsICd0b3AnKTtcblx0XHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdFx0Ly8gVW5kbyBpbmxpbmUgc3R5bGVzIGFuZCBjbGFzc2VzIG9uIHRvb2x0aXBzXG5cdFx0XHRcdFt0aGlzLnRvb2x0aXAsIHRoaXMudG9vbHRpcF9taW4sIHRoaXMudG9vbHRpcF9tYXhdLmZvckVhY2goZnVuY3Rpb24gKHRvb2x0aXApIHtcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVQcm9wZXJ0eSh0b29sdGlwLCAnbGVmdCcpO1xuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZVByb3BlcnR5KHRvb2x0aXAsICd0b3AnKTtcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVQcm9wZXJ0eSh0b29sdGlwLCAnbWFyZ2luLWxlZnQnKTtcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVQcm9wZXJ0eSh0b29sdGlwLCAnbWFyZ2luLXRvcCcpO1xuXG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3ModG9vbHRpcCwgJ3JpZ2h0Jyk7XG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3ModG9vbHRpcCwgJ3RvcCcpO1xuXHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyh0aGlzLnNsaWRlckVsZW0sICdzbGlkZXItdmVydGljYWwnKTtcblx0XHRcdFx0dGhpcy5zdHlsZVBvcyA9ICd0b3AnO1xuXHRcdFx0XHR0aGlzLm1vdXNlUG9zID0gJ3BhZ2VZJztcblx0XHRcdFx0dGhpcy5zaXplUG9zID0gJ29mZnNldEhlaWdodCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyh0aGlzLnNsaWRlckVsZW0sICdzbGlkZXItaG9yaXpvbnRhbCcpO1xuXHRcdFx0XHR0aGlzLnNsaWRlckVsZW0uc3R5bGUud2lkdGggPSBvcmlnV2lkdGg7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcblx0XHRcdFx0dGhpcy5zdHlsZVBvcyA9ICdsZWZ0Jztcblx0XHRcdFx0dGhpcy5tb3VzZVBvcyA9ICdwYWdlWCc7XG5cdFx0XHRcdHRoaXMuc2l6ZVBvcyA9ICdvZmZzZXRXaWR0aCc7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zZXRUb29sdGlwUG9zaXRpb24oKTtcblx0XHRcdC8qIEluIGNhc2UgdGlja3MgYXJlIHNwZWNpZmllZCwgb3ZlcndyaXRlIHRoZSBtaW4gYW5kIG1heCBib3VuZHMgKi9cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy50aWNrcykgJiYgdGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLm1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHRoaXMub3B0aW9ucy50aWNrcyk7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5taW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCB0aGlzLm9wdGlvbnMudGlja3MpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMudmFsdWUpKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5yYW5nZSA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX3N0YXRlLnZhbHVlID0gdGhpcy5vcHRpb25zLnZhbHVlO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMucmFuZ2UpIHtcblx0XHRcdFx0Ly8gVXNlciB3YW50cyBhIHJhbmdlLCBidXQgdmFsdWUgaXMgbm90IGFuIGFycmF5XG5cdFx0XHRcdHRoaXMuX3N0YXRlLnZhbHVlID0gW3RoaXMub3B0aW9ucy52YWx1ZSwgdGhpcy5vcHRpb25zLm1heF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zdGF0ZS52YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy50cmFja0xvdyA9IHNsaWRlclRyYWNrTG93IHx8IHRoaXMudHJhY2tMb3c7XG5cdFx0XHR0aGlzLnRyYWNrU2VsZWN0aW9uID0gc2xpZGVyVHJhY2tTZWxlY3Rpb24gfHwgdGhpcy50cmFja1NlbGVjdGlvbjtcblx0XHRcdHRoaXMudHJhY2tIaWdoID0gc2xpZGVyVHJhY2tIaWdoIHx8IHRoaXMudHJhY2tIaWdoO1xuXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnNlbGVjdGlvbiA9PT0gJ25vbmUnKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKHRoaXMudHJhY2tMb3csICdoaWRlJyk7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKHRoaXMudHJhY2tTZWxlY3Rpb24sICdoaWRlJyk7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKHRoaXMudHJhY2tIaWdoLCAnaGlkZScpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmhhbmRsZTEgPSBzbGlkZXJNaW5IYW5kbGUgfHwgdGhpcy5oYW5kbGUxO1xuXHRcdFx0dGhpcy5oYW5kbGUyID0gc2xpZGVyTWF4SGFuZGxlIHx8IHRoaXMuaGFuZGxlMjtcblxuXHRcdFx0aWYgKHVwZGF0ZVNsaWRlciA9PT0gdHJ1ZSkge1xuXHRcdFx0XHQvLyBSZXNldCBjbGFzc2VzXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMuaGFuZGxlMSwgJ3JvdW5kIHRyaWFuZ2xlJyk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMuaGFuZGxlMiwgJ3JvdW5kIHRyaWFuZ2xlIGhpZGUnKTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy50aWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudGlja3NbaV0sICdyb3VuZCB0cmlhbmdsZSBoaWRlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGF2YWlsYWJsZUhhbmRsZU1vZGlmaWVycyA9IFsncm91bmQnLCAndHJpYW5nbGUnLCAnY3VzdG9tJ107XG5cdFx0XHR2YXIgaXNWYWxpZEhhbmRsZVR5cGUgPSBhdmFpbGFibGVIYW5kbGVNb2RpZmllcnMuaW5kZXhPZih0aGlzLm9wdGlvbnMuaGFuZGxlKSAhPT0gLTE7XG5cdFx0XHRpZiAoaXNWYWxpZEhhbmRsZVR5cGUpIHtcblx0XHRcdFx0dGhpcy5fYWRkQ2xhc3ModGhpcy5oYW5kbGUxLCB0aGlzLm9wdGlvbnMuaGFuZGxlKTtcblx0XHRcdFx0dGhpcy5fYWRkQ2xhc3ModGhpcy5oYW5kbGUyLCB0aGlzLm9wdGlvbnMuaGFuZGxlKTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy50aWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuX2FkZENsYXNzKHRoaXMudGlja3NbaV0sIHRoaXMub3B0aW9ucy5oYW5kbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3N0YXRlLm9mZnNldCA9IHRoaXMuX29mZnNldCh0aGlzLnNsaWRlckVsZW0pO1xuXHRcdFx0dGhpcy5fc3RhdGUuc2l6ZSA9IHRoaXMuc2xpZGVyRWxlbVt0aGlzLnNpemVQb3NdO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSh0aGlzLl9zdGF0ZS52YWx1ZSk7XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgIFx0XHRcdFx0QmluZCBFdmVudCBMaXN0ZW5lcnNcbiAgIFx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvLyBCaW5kIGtleWJvYXJkIGhhbmRsZXJzXG5cdFx0XHR0aGlzLmhhbmRsZTFLZXlkb3duID0gdGhpcy5fa2V5ZG93bi5iaW5kKHRoaXMsIDApO1xuXHRcdFx0dGhpcy5oYW5kbGUxLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlMUtleWRvd24sIGZhbHNlKTtcblxuXHRcdFx0dGhpcy5oYW5kbGUyS2V5ZG93biA9IHRoaXMuX2tleWRvd24uYmluZCh0aGlzLCAxKTtcblx0XHRcdHRoaXMuaGFuZGxlMi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZTJLZXlkb3duLCBmYWxzZSk7XG5cblx0XHRcdHRoaXMubW91c2Vkb3duID0gdGhpcy5fbW91c2Vkb3duLmJpbmQodGhpcyk7XG5cdFx0XHRpZiAodGhpcy50b3VjaENhcGFibGUpIHtcblx0XHRcdFx0Ly8gQmluZCB0b3VjaCBoYW5kbGVyc1xuXHRcdFx0XHR0aGlzLnNsaWRlckVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5tb3VzZWRvd24sIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2xpZGVyRWxlbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMubW91c2Vkb3duLCBmYWxzZSk7XG5cblx0XHRcdC8vIEJpbmQgd2luZG93IGhhbmRsZXJzXG5cdFx0XHR0aGlzLnJlc2l6ZSA9IHRoaXMuX3Jlc2l6ZS5iaW5kKHRoaXMpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5yZXNpemUsIGZhbHNlKTtcblxuXHRcdFx0Ly8gQmluZCB0b29sdGlwLXJlbGF0ZWQgaGFuZGxlcnNcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG9vbHRpcCA9PT0gJ2hpZGUnKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKHRoaXMudG9vbHRpcCwgJ2hpZGUnKTtcblx0XHRcdFx0dGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwX21pbiwgJ2hpZGUnKTtcblx0XHRcdFx0dGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwX21heCwgJ2hpZGUnKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnRvb2x0aXAgPT09ICdhbHdheXMnKSB7XG5cdFx0XHRcdHRoaXMuX3Nob3dUb29sdGlwKCk7XG5cdFx0XHRcdHRoaXMuX2Fsd2F5c1Nob3dUb29sdGlwID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2hvd1Rvb2x0aXAgPSB0aGlzLl9zaG93VG9vbHRpcC5iaW5kKHRoaXMpO1xuXHRcdFx0XHR0aGlzLmhpZGVUb29sdGlwID0gdGhpcy5faGlkZVRvb2x0aXAuYmluZCh0aGlzKTtcblxuXHRcdFx0XHR0aGlzLnNsaWRlckVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgdGhpcy5zaG93VG9vbHRpcCwgZmFsc2UpO1xuXHRcdFx0XHR0aGlzLnNsaWRlckVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5oaWRlVG9vbHRpcCwgZmFsc2UpO1xuXG5cdFx0XHRcdHRoaXMuaGFuZGxlMS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5zaG93VG9vbHRpcCwgZmFsc2UpO1xuXHRcdFx0XHR0aGlzLmhhbmRsZTEuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5oaWRlVG9vbHRpcCwgZmFsc2UpO1xuXG5cdFx0XHRcdHRoaXMuaGFuZGxlMi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5zaG93VG9vbHRpcCwgZmFsc2UpO1xuXHRcdFx0XHR0aGlzLmhhbmRsZTIuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5oaWRlVG9vbHRpcCwgZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQpIHtcblx0XHRcdFx0dGhpcy5lbmFibGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGlzYWJsZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIFx0XHRcdFx0SU5TVEFOQ0UgUFJPUEVSVElFUy9NRVRIT0RTXG4gIFx0LSBBbnkgbWV0aG9kcyBib3VuZCB0byB0aGUgcHJvdG90eXBlIGFyZSBjb25zaWRlcmVkXG4gIHBhcnQgb2YgdGhlIHBsdWdpbidzIGBwdWJsaWNgIGludGVyZmFjZVxuICBcdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHRcdFNsaWRlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRfaW5pdDogZnVuY3Rpb24gX2luaXQoKSB7fSwgLy8gTk9URTogTXVzdCBleGlzdCB0byBzdXBwb3J0IGJyaWRnZXRcblxuXHRcdFx0Y29uc3RydWN0b3I6IFNsaWRlcixcblxuXHRcdFx0ZGVmYXVsdE9wdGlvbnM6IHtcblx0XHRcdFx0aWQ6IFwiXCIsXG5cdFx0XHRcdG1pbjogMCxcblx0XHRcdFx0bWF4OiAxMCxcblx0XHRcdFx0c3RlcDogMSxcblx0XHRcdFx0cHJlY2lzaW9uOiAwLFxuXHRcdFx0XHRvcmllbnRhdGlvbjogJ2hvcml6b250YWwnLFxuXHRcdFx0XHR2YWx1ZTogNSxcblx0XHRcdFx0cmFuZ2U6IGZhbHNlLFxuXHRcdFx0XHRzZWxlY3Rpb246ICdiZWZvcmUnLFxuXHRcdFx0XHR0b29sdGlwOiAnc2hvdycsXG5cdFx0XHRcdHRvb2x0aXBfc3BsaXQ6IGZhbHNlLFxuXHRcdFx0XHRoYW5kbGU6ICdyb3VuZCcsXG5cdFx0XHRcdHJldmVyc2VkOiBmYWxzZSxcblx0XHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0Zm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsKSB7XG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbFswXSArIFwiIDogXCIgKyB2YWxbMV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRuYXR1cmFsX2Fycm93X2tleXM6IGZhbHNlLFxuXHRcdFx0XHR0aWNrczogW10sXG5cdFx0XHRcdHRpY2tzX3Bvc2l0aW9uczogW10sXG5cdFx0XHRcdHRpY2tzX2xhYmVsczogW10sXG5cdFx0XHRcdHRpY2tzX3NuYXBfYm91bmRzOiAwLFxuXHRcdFx0XHRzY2FsZTogJ2xpbmVhcicsXG5cdFx0XHRcdGZvY3VzOiBmYWxzZSxcblx0XHRcdFx0dG9vbHRpcF9wb3NpdGlvbjogbnVsbCxcblx0XHRcdFx0bGFiZWxsZWRieTogbnVsbFxuXHRcdFx0fSxcblxuXHRcdFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2xpZGVyRWxlbTtcblx0XHRcdH0sXG5cblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5yYW5nZSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9zdGF0ZS52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fc3RhdGUudmFsdWVbMF07XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWwsIHRyaWdnZXJTbGlkZUV2ZW50LCB0cmlnZ2VyQ2hhbmdlRXZlbnQpIHtcblx0XHRcdFx0aWYgKCF2YWwpIHtcblx0XHRcdFx0XHR2YWwgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBvbGRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRcdFx0dGhpcy5fc3RhdGUudmFsdWUgPSB0aGlzLl92YWxpZGF0ZUlucHV0VmFsdWUodmFsKTtcblx0XHRcdFx0dmFyIGFwcGx5UHJlY2lzaW9uID0gdGhpcy5fYXBwbHlQcmVjaXNpb24uYmluZCh0aGlzKTtcblxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnJhbmdlKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhdGUudmFsdWVbMF0gPSBhcHBseVByZWNpc2lvbih0aGlzLl9zdGF0ZS52YWx1ZVswXSk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhdGUudmFsdWVbMV0gPSBhcHBseVByZWNpc2lvbih0aGlzLl9zdGF0ZS52YWx1ZVsxXSk7XG5cblx0XHRcdFx0XHR0aGlzLl9zdGF0ZS52YWx1ZVswXSA9IE1hdGgubWF4KHRoaXMub3B0aW9ucy5taW4sIE1hdGgubWluKHRoaXMub3B0aW9ucy5tYXgsIHRoaXMuX3N0YXRlLnZhbHVlWzBdKSk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhdGUudmFsdWVbMV0gPSBNYXRoLm1heCh0aGlzLm9wdGlvbnMubWluLCBNYXRoLm1pbih0aGlzLm9wdGlvbnMubWF4LCB0aGlzLl9zdGF0ZS52YWx1ZVsxXSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXRlLnZhbHVlID0gYXBwbHlQcmVjaXNpb24odGhpcy5fc3RhdGUudmFsdWUpO1xuXHRcdFx0XHRcdHRoaXMuX3N0YXRlLnZhbHVlID0gW01hdGgubWF4KHRoaXMub3B0aW9ucy5taW4sIE1hdGgubWluKHRoaXMub3B0aW9ucy5tYXgsIHRoaXMuX3N0YXRlLnZhbHVlKSldO1xuXHRcdFx0XHRcdHRoaXMuX2FkZENsYXNzKHRoaXMuaGFuZGxlMiwgJ2hpZGUnKTtcblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnNlbGVjdGlvbiA9PT0gJ2FmdGVyJykge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhdGUudmFsdWVbMV0gPSB0aGlzLm9wdGlvbnMubWF4O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGF0ZS52YWx1ZVsxXSA9IHRoaXMub3B0aW9ucy5taW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5tYXggPiB0aGlzLm9wdGlvbnMubWluKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhdGUucGVyY2VudGFnZSA9IFt0aGlzLl90b1BlcmNlbnRhZ2UodGhpcy5fc3RhdGUudmFsdWVbMF0pLCB0aGlzLl90b1BlcmNlbnRhZ2UodGhpcy5fc3RhdGUudmFsdWVbMV0pLCB0aGlzLm9wdGlvbnMuc3RlcCAqIDEwMCAvICh0aGlzLm9wdGlvbnMubWF4IC0gdGhpcy5vcHRpb25zLm1pbildO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2UgPSBbMCwgMCwgMTAwXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2xheW91dCgpO1xuXHRcdFx0XHR2YXIgbmV3VmFsdWUgPSB0aGlzLm9wdGlvbnMucmFuZ2UgPyB0aGlzLl9zdGF0ZS52YWx1ZSA6IHRoaXMuX3N0YXRlLnZhbHVlWzBdO1xuXG5cdFx0XHRcdGlmICh0cmlnZ2VyU2xpZGVFdmVudCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ3NsaWRlJywgbmV3VmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUgJiYgdHJpZ2dlckNoYW5nZUV2ZW50ID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlJywge1xuXHRcdFx0XHRcdFx0b2xkVmFsdWU6IG9sZFZhbHVlLFxuXHRcdFx0XHRcdFx0bmV3VmFsdWU6IG5ld1ZhbHVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fc2V0RGF0YVZhbChuZXdWYWx1ZSk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdFx0XHQvLyBSZW1vdmUgZXZlbnQgaGFuZGxlcnMgb24gc2xpZGVyIGVsZW1lbnRzXG5cdFx0XHRcdHRoaXMuX3JlbW92ZVNsaWRlckV2ZW50SGFuZGxlcnMoKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIHNsaWRlciBmcm9tIHRoZSBET01cblx0XHRcdFx0dGhpcy5zbGlkZXJFbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zbGlkZXJFbGVtKTtcblx0XHRcdFx0LyogU2hvdyBvcmlnaW5hbCA8aW5wdXQ+IGVsZW1lbnQgKi9cblx0XHRcdFx0dGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXG5cdFx0XHRcdC8vIENsZWFyIG91dCBjdXN0b20gZXZlbnQgYmluZGluZ3Ncblx0XHRcdFx0dGhpcy5fY2xlYW5VcEV2ZW50Q2FsbGJhY2tzTWFwKCk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGRhdGEgdmFsdWVzXG5cdFx0XHRcdHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhXCIpO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBKUXVlcnkgaGFuZGxlcnMvZGF0YVxuXHRcdFx0XHRpZiAoJCkge1xuXHRcdFx0XHRcdHRoaXMuX3VuYmluZEpRdWVyeUV2ZW50SGFuZGxlcnMoKTtcblx0XHRcdFx0XHR0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ3NsaWRlcicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdFx0XHR0aGlzLl9zdGF0ZS5lbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuaGFuZGxlMS5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTtcblx0XHRcdFx0dGhpcy5oYW5kbGUyLnJlbW92ZUF0dHJpYnV0ZShcInRhYmluZGV4XCIpO1xuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyh0aGlzLnNsaWRlckVsZW0sICdzbGlkZXItZGlzYWJsZWQnKTtcblx0XHRcdFx0dGhpcy5fdHJpZ2dlcignc2xpZGVEaXNhYmxlZCcpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0ZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXRlLmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmhhbmRsZTEuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCk7XG5cdFx0XHRcdHRoaXMuaGFuZGxlMi5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy5zbGlkZXJFbGVtLCAnc2xpZGVyLWRpc2FibGVkJyk7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ3NsaWRlRW5hYmxlZCcpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0dG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zdGF0ZS5lbmFibGVkKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5lbmFibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdGlzRW5hYmxlZDogZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc3RhdGUuZW5hYmxlZDtcblx0XHRcdH0sXG5cblx0XHRcdG9uOiBmdW5jdGlvbiBvbihldnQsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdHRoaXMuX2JpbmROb25RdWVyeUV2ZW50SGFuZGxlcihldnQsIGNhbGxiYWNrKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRvZmY6IGZ1bmN0aW9uIG9mZihldnQsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdGlmICgkKSB7XG5cdFx0XHRcdFx0dGhpcy4kZWxlbWVudC5vZmYoZXZ0LCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0dGhpcy4kc2xpZGVyRWxlbS5vZmYoZXZ0LCBjYWxsYmFjayk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdW5iaW5kTm9uUXVlcnlFdmVudEhhbmRsZXIoZXZ0LCBjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuXHRcdFx0XHRpZiAoYXR0cmlidXRlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1thdHRyaWJ1dGVdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnM7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHNldEF0dHJpYnV0ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRyZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVTbGlkZXJFdmVudEhhbmRsZXJzKCk7XG5cdFx0XHRcdGNyZWF0ZU5ld1NsaWRlci5jYWxsKHRoaXMsIHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zKTtcblx0XHRcdFx0aWYgKCQpIHtcblx0XHRcdFx0XHQvLyBCaW5kIG5ldyBpbnN0YW5jZSBvZiBzbGlkZXIgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHQkLmRhdGEodGhpcy5lbGVtZW50LCAnc2xpZGVyJywgdGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRyZWxheW91dDogZnVuY3Rpb24gcmVsYXlvdXQoKSB7XG5cdFx0XHRcdHRoaXMuX2xheW91dCgpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiorXG4gICBcdFx0XHRcdEhFTFBFUlNcbiAgIFx0LSBBbnkgbWV0aG9kIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gICAtIFBsYWNlIGl0IHVuZGVybmVhdGggdGhpcyBjb21tZW50IGJsb2NrIGFuZCB3cml0ZSBpdHMgc2lnbmF0dXJlIGxpa2Ugc286XG4gICBcdCAgXHRcdFx0XHRcdF9mbk5hbWUgOiBmdW5jdGlvbigpIHsuLi59XG4gICBcdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHRcdFx0X3JlbW92ZVNsaWRlckV2ZW50SGFuZGxlcnM6IGZ1bmN0aW9uIF9yZW1vdmVTbGlkZXJFdmVudEhhbmRsZXJzKCkge1xuXHRcdFx0XHQvLyBSZW1vdmUga2V5ZG93biBldmVudCBsaXN0ZW5lcnNcblx0XHRcdFx0dGhpcy5oYW5kbGUxLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlMUtleWRvd24sIGZhbHNlKTtcblx0XHRcdFx0dGhpcy5oYW5kbGUyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlMktleWRvd24sIGZhbHNlKTtcblxuXHRcdFx0XHRpZiAodGhpcy5zaG93VG9vbHRpcCkge1xuXHRcdFx0XHRcdHRoaXMuaGFuZGxlMS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5zaG93VG9vbHRpcCwgZmFsc2UpO1xuXHRcdFx0XHRcdHRoaXMuaGFuZGxlMi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5zaG93VG9vbHRpcCwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmhpZGVUb29sdGlwKSB7XG5cdFx0XHRcdFx0dGhpcy5oYW5kbGUxLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuaGlkZVRvb2x0aXAsIGZhbHNlKTtcblx0XHRcdFx0XHR0aGlzLmhhbmRsZTIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5oaWRlVG9vbHRpcCwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHNsaWRlckVsZW1cblx0XHRcdFx0aWYgKHRoaXMuc2hvd1Rvb2x0aXApIHtcblx0XHRcdFx0XHR0aGlzLnNsaWRlckVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgdGhpcy5zaG93VG9vbHRpcCwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmhpZGVUb29sdGlwKSB7XG5cdFx0XHRcdFx0dGhpcy5zbGlkZXJFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuaGlkZVRvb2x0aXAsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNsaWRlckVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5tb3VzZWRvd24sIGZhbHNlKTtcblx0XHRcdFx0dGhpcy5zbGlkZXJFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5tb3VzZWRvd24sIGZhbHNlKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgd2luZG93IGV2ZW50IGxpc3RlbmVyXG5cdFx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucmVzaXplLCBmYWxzZSk7XG5cdFx0XHR9LFxuXHRcdFx0X2JpbmROb25RdWVyeUV2ZW50SGFuZGxlcjogZnVuY3Rpb24gX2JpbmROb25RdWVyeUV2ZW50SGFuZGxlcihldnQsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdGlmICh0aGlzLmV2ZW50VG9DYWxsYmFja01hcFtldnRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aGlzLmV2ZW50VG9DYWxsYmFja01hcFtldnRdID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5ldmVudFRvQ2FsbGJhY2tNYXBbZXZ0XS5wdXNoKGNhbGxiYWNrKTtcblx0XHRcdH0sXG5cdFx0XHRfdW5iaW5kTm9uUXVlcnlFdmVudEhhbmRsZXI6IGZ1bmN0aW9uIF91bmJpbmROb25RdWVyeUV2ZW50SGFuZGxlcihldnQsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciBjYWxsYmFja3MgPSB0aGlzLmV2ZW50VG9DYWxsYmFja01hcFtldnRdO1xuXHRcdFx0XHRpZiAoY2FsbGJhY2tzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKGNhbGxiYWNrc1tpXSA9PT0gY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X2NsZWFuVXBFdmVudENhbGxiYWNrc01hcDogZnVuY3Rpb24gX2NsZWFuVXBFdmVudENhbGxiYWNrc01hcCgpIHtcblx0XHRcdFx0dmFyIGV2ZW50TmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmV2ZW50VG9DYWxsYmFja01hcCk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnROYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBldmVudE5hbWUgPSBldmVudE5hbWVzW2ldO1xuXHRcdFx0XHRcdHRoaXMuZXZlbnRUb0NhbGxiYWNrTWFwW2V2ZW50TmFtZV0gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3Nob3dUb29sdGlwOiBmdW5jdGlvbiBfc2hvd1Rvb2x0aXAoKSB7XG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG9vbHRpcF9zcGxpdCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGlzLl9hZGRDbGFzcyh0aGlzLnRvb2x0aXAsICdpbicpO1xuXHRcdFx0XHRcdHRoaXMudG9vbHRpcF9taW4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdFx0XHR0aGlzLnRvb2x0aXBfbWF4LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwX21pbiwgJ2luJyk7XG5cdFx0XHRcdFx0dGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwX21heCwgJ2luJyk7XG5cdFx0XHRcdFx0dGhpcy50b29sdGlwLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fc3RhdGUub3ZlciA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0X2hpZGVUb29sdGlwOiBmdW5jdGlvbiBfaGlkZVRvb2x0aXAoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zdGF0ZS5pbkRyYWcgPT09IGZhbHNlICYmIHRoaXMuYWx3YXlzU2hvd1Rvb2x0aXAgIT09IHRydWUpIHtcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnRvb2x0aXAsICdpbicpO1xuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudG9vbHRpcF9taW4sICdpbicpO1xuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudG9vbHRpcF9tYXgsICdpbicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3N0YXRlLm92ZXIgPSBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRfbGF5b3V0OiBmdW5jdGlvbiBfbGF5b3V0KCkge1xuXHRcdFx0XHR2YXIgcG9zaXRpb25QZXJjZW50YWdlcztcblxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnJldmVyc2VkKSB7XG5cdFx0XHRcdFx0cG9zaXRpb25QZXJjZW50YWdlcyA9IFsxMDAgLSB0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdLCB0aGlzLm9wdGlvbnMucmFuZ2UgPyAxMDAgLSB0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdIDogdGhpcy5fc3RhdGUucGVyY2VudGFnZVsxXV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cG9zaXRpb25QZXJjZW50YWdlcyA9IFt0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdLCB0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuaGFuZGxlMS5zdHlsZVt0aGlzLnN0eWxlUG9zXSA9IHBvc2l0aW9uUGVyY2VudGFnZXNbMF0gKyAnJSc7XG5cdFx0XHRcdHRoaXMuaGFuZGxlMS5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCB0aGlzLl9zdGF0ZS52YWx1ZVswXSk7XG5cblx0XHRcdFx0dGhpcy5oYW5kbGUyLnN0eWxlW3RoaXMuc3R5bGVQb3NdID0gcG9zaXRpb25QZXJjZW50YWdlc1sxXSArICclJztcblx0XHRcdFx0dGhpcy5oYW5kbGUyLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIHRoaXMuX3N0YXRlLnZhbHVlWzFdKTtcblxuXHRcdFx0XHQvKiBQb3NpdGlvbiB0aWNrcyBhbmQgbGFiZWxzICovXG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy50aWNrcykgJiYgdGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aCA+IDApIHtcblxuXHRcdFx0XHRcdHZhciBzdHlsZVNpemUgPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cdFx0XHRcdFx0dmFyIHN0eWxlTWFyZ2luID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnID8gJ21hcmdpblRvcCcgOiAnbWFyZ2luTGVmdCc7XG5cdFx0XHRcdFx0dmFyIGxhYmVsU2l6ZSA9IHRoaXMuX3N0YXRlLnNpemUgLyAodGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMudGlja0xhYmVsQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0XHR2YXIgZXh0cmFNYXJnaW4gPSAwO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gIT09ICd2ZXJ0aWNhbCcpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnRpY2tMYWJlbENvbnRhaW5lci5zdHlsZVtzdHlsZU1hcmdpbl0gPSAtbGFiZWxTaXplIC8gMiArICdweCc7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRleHRyYU1hcmdpbiA9IHRoaXMudGlja0xhYmVsQ29udGFpbmVyLm9mZnNldEhlaWdodDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8qIENoaWRyZW4gYXJlIHBvc2l0aW9uIGFic29sdXRlLCBjYWxjdWxhdGUgaGVpZ2h0IGJ5IGZpbmRpbmcgdGhlIG1heCBvZmZzZXRIZWlnaHQgb2YgYSBjaGlsZCAqL1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy50aWNrTGFiZWxDb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLnRpY2tMYWJlbENvbnRhaW5lci5jaGlsZE5vZGVzW2ldLm9mZnNldEhlaWdodCA+IGV4dHJhTWFyZ2luKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRleHRyYU1hcmdpbiA9IHRoaXMudGlja0xhYmVsQ29udGFpbmVyLmNoaWxkTm9kZXNbaV0ub2Zmc2V0SGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2xpZGVyRWxlbS5zdHlsZS5tYXJnaW5Cb3R0b20gPSBleHRyYU1hcmdpbiArICdweCc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdFx0XHRcdHZhciBwZXJjZW50YWdlID0gdGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9uc1tpXSB8fCB0aGlzLl90b1BlcmNlbnRhZ2UodGhpcy5vcHRpb25zLnRpY2tzW2ldKTtcblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHRwZXJjZW50YWdlID0gMTAwIC0gcGVyY2VudGFnZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGhpcy50aWNrc1tpXS5zdHlsZVt0aGlzLnN0eWxlUG9zXSA9IHBlcmNlbnRhZ2UgKyAnJSc7XG5cblx0XHRcdFx0XHRcdC8qIFNldCBjbGFzcyBsYWJlbHMgdG8gZGVub3RlIHdoZXRoZXIgdGlja3MgYXJlIGluIHRoZSBzZWxlY3Rpb24gKi9cblx0XHRcdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudGlja3NbaV0sICdpbi1zZWxlY3Rpb24nKTtcblx0XHRcdFx0XHRcdGlmICghdGhpcy5vcHRpb25zLnJhbmdlKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0aW9uID09PSAnYWZ0ZXInICYmIHBlcmNlbnRhZ2UgPj0gcG9zaXRpb25QZXJjZW50YWdlc1swXSkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2FkZENsYXNzKHRoaXMudGlja3NbaV0sICdpbi1zZWxlY3Rpb24nKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0aW9uID09PSAnYmVmb3JlJyAmJiBwZXJjZW50YWdlIDw9IHBvc2l0aW9uUGVyY2VudGFnZXNbMF0pIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9hZGRDbGFzcyh0aGlzLnRpY2tzW2ldLCAnaW4tc2VsZWN0aW9uJyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocGVyY2VudGFnZSA+PSBwb3NpdGlvblBlcmNlbnRhZ2VzWzBdICYmIHBlcmNlbnRhZ2UgPD0gcG9zaXRpb25QZXJjZW50YWdlc1sxXSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9hZGRDbGFzcyh0aGlzLnRpY2tzW2ldLCAnaW4tc2VsZWN0aW9uJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLnRpY2tMYWJlbHNbaV0pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy50aWNrTGFiZWxzW2ldLnN0eWxlW3N0eWxlU2l6ZV0gPSBsYWJlbFNpemUgKyAncHgnO1xuXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gIT09ICd2ZXJ0aWNhbCcgJiYgdGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9uc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy50aWNrTGFiZWxzW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnRpY2tMYWJlbHNbaV0uc3R5bGVbdGhpcy5zdHlsZVBvc10gPSBwZXJjZW50YWdlICsgJyUnO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMudGlja0xhYmVsc1tpXS5zdHlsZVtzdHlsZU1hcmdpbl0gPSAtbGFiZWxTaXplIC8gMiArICdweCc7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy50aWNrTGFiZWxzW2ldLnN0eWxlWydtYXJnaW5MZWZ0J10gPSB0aGlzLnNsaWRlckVsZW0ub2Zmc2V0V2lkdGggKyAncHgnO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMudGlja0xhYmVsQ29udGFpbmVyLnN0eWxlWydtYXJnaW5Ub3AnXSA9IHRoaXMuc2xpZGVyRWxlbS5vZmZzZXRXaWR0aCAvIDIgKiAtMSArICdweCc7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZm9ybWF0dGVkVG9vbHRpcFZhbDtcblxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnJhbmdlKSB7XG5cdFx0XHRcdFx0Zm9ybWF0dGVkVG9vbHRpcFZhbCA9IHRoaXMub3B0aW9ucy5mb3JtYXR0ZXIodGhpcy5fc3RhdGUudmFsdWUpO1xuXHRcdFx0XHRcdHRoaXMuX3NldFRleHQodGhpcy50b29sdGlwSW5uZXIsIGZvcm1hdHRlZFRvb2x0aXBWYWwpO1xuXHRcdFx0XHRcdHRoaXMudG9vbHRpcC5zdHlsZVt0aGlzLnN0eWxlUG9zXSA9IChwb3NpdGlvblBlcmNlbnRhZ2VzWzFdICsgcG9zaXRpb25QZXJjZW50YWdlc1swXSkgLyAyICsgJyUnO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuXHRcdFx0XHRcdFx0dGhpcy5fY3NzKHRoaXMudG9vbHRpcCwgJ21hcmdpbi10b3AnLCAtdGhpcy50b29sdGlwLm9mZnNldEhlaWdodCAvIDIgKyAncHgnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5fY3NzKHRoaXMudG9vbHRpcCwgJ21hcmdpbi1sZWZ0JywgLXRoaXMudG9vbHRpcC5vZmZzZXRXaWR0aCAvIDIgKyAncHgnKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9jc3ModGhpcy50b29sdGlwLCAnbWFyZ2luLXRvcCcsIC10aGlzLnRvb2x0aXAub2Zmc2V0SGVpZ2h0IC8gMiArICdweCcpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9jc3ModGhpcy50b29sdGlwLCAnbWFyZ2luLWxlZnQnLCAtdGhpcy50b29sdGlwLm9mZnNldFdpZHRoIC8gMiArICdweCcpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBpbm5lclRvb2x0aXBNaW5UZXh0ID0gdGhpcy5vcHRpb25zLmZvcm1hdHRlcih0aGlzLl9zdGF0ZS52YWx1ZVswXSk7XG5cdFx0XHRcdFx0dGhpcy5fc2V0VGV4dCh0aGlzLnRvb2x0aXBJbm5lcl9taW4sIGlubmVyVG9vbHRpcE1pblRleHQpO1xuXG5cdFx0XHRcdFx0dmFyIGlubmVyVG9vbHRpcE1heFRleHQgPSB0aGlzLm9wdGlvbnMuZm9ybWF0dGVyKHRoaXMuX3N0YXRlLnZhbHVlWzFdKTtcblx0XHRcdFx0XHR0aGlzLl9zZXRUZXh0KHRoaXMudG9vbHRpcElubmVyX21heCwgaW5uZXJUb29sdGlwTWF4VGV4dCk7XG5cblx0XHRcdFx0XHR0aGlzLnRvb2x0aXBfbWluLnN0eWxlW3RoaXMuc3R5bGVQb3NdID0gcG9zaXRpb25QZXJjZW50YWdlc1swXSArICclJztcblxuXHRcdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2Nzcyh0aGlzLnRvb2x0aXBfbWluLCAnbWFyZ2luLXRvcCcsIC10aGlzLnRvb2x0aXBfbWluLm9mZnNldEhlaWdodCAvIDIgKyAncHgnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5fY3NzKHRoaXMudG9vbHRpcF9taW4sICdtYXJnaW4tbGVmdCcsIC10aGlzLnRvb2x0aXBfbWluLm9mZnNldFdpZHRoIC8gMiArICdweCcpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMudG9vbHRpcF9tYXguc3R5bGVbdGhpcy5zdHlsZVBvc10gPSBwb3NpdGlvblBlcmNlbnRhZ2VzWzFdICsgJyUnO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuXHRcdFx0XHRcdFx0dGhpcy5fY3NzKHRoaXMudG9vbHRpcF9tYXgsICdtYXJnaW4tdG9wJywgLXRoaXMudG9vbHRpcF9tYXgub2Zmc2V0SGVpZ2h0IC8gMiArICdweCcpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9jc3ModGhpcy50b29sdGlwX21heCwgJ21hcmdpbi1sZWZ0JywgLXRoaXMudG9vbHRpcF9tYXgub2Zmc2V0V2lkdGggLyAyICsgJ3B4Jyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvcm1hdHRlZFRvb2x0aXBWYWwgPSB0aGlzLm9wdGlvbnMuZm9ybWF0dGVyKHRoaXMuX3N0YXRlLnZhbHVlWzBdKTtcblx0XHRcdFx0XHR0aGlzLl9zZXRUZXh0KHRoaXMudG9vbHRpcElubmVyLCBmb3JtYXR0ZWRUb29sdGlwVmFsKTtcblxuXHRcdFx0XHRcdHRoaXMudG9vbHRpcC5zdHlsZVt0aGlzLnN0eWxlUG9zXSA9IHBvc2l0aW9uUGVyY2VudGFnZXNbMF0gKyAnJSc7XG5cdFx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuXHRcdFx0XHRcdFx0dGhpcy5fY3NzKHRoaXMudG9vbHRpcCwgJ21hcmdpbi10b3AnLCAtdGhpcy50b29sdGlwLm9mZnNldEhlaWdodCAvIDIgKyAncHgnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5fY3NzKHRoaXMudG9vbHRpcCwgJ21hcmdpbi1sZWZ0JywgLXRoaXMudG9vbHRpcC5vZmZzZXRXaWR0aCAvIDIgKyAncHgnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG5cdFx0XHRcdFx0dGhpcy50cmFja0xvdy5zdHlsZS50b3AgPSAnMCc7XG5cdFx0XHRcdFx0dGhpcy50cmFja0xvdy5zdHlsZS5oZWlnaHQgPSBNYXRoLm1pbihwb3NpdGlvblBlcmNlbnRhZ2VzWzBdLCBwb3NpdGlvblBlcmNlbnRhZ2VzWzFdKSArICclJztcblxuXHRcdFx0XHRcdHRoaXMudHJhY2tTZWxlY3Rpb24uc3R5bGUudG9wID0gTWF0aC5taW4ocG9zaXRpb25QZXJjZW50YWdlc1swXSwgcG9zaXRpb25QZXJjZW50YWdlc1sxXSkgKyAnJSc7XG5cdFx0XHRcdFx0dGhpcy50cmFja1NlbGVjdGlvbi5zdHlsZS5oZWlnaHQgPSBNYXRoLmFicyhwb3NpdGlvblBlcmNlbnRhZ2VzWzBdIC0gcG9zaXRpb25QZXJjZW50YWdlc1sxXSkgKyAnJSc7XG5cblx0XHRcdFx0XHR0aGlzLnRyYWNrSGlnaC5zdHlsZS5ib3R0b20gPSAnMCc7XG5cdFx0XHRcdFx0dGhpcy50cmFja0hpZ2guc3R5bGUuaGVpZ2h0ID0gMTAwIC0gTWF0aC5taW4ocG9zaXRpb25QZXJjZW50YWdlc1swXSwgcG9zaXRpb25QZXJjZW50YWdlc1sxXSkgLSBNYXRoLmFicyhwb3NpdGlvblBlcmNlbnRhZ2VzWzBdIC0gcG9zaXRpb25QZXJjZW50YWdlc1sxXSkgKyAnJSc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy50cmFja0xvdy5zdHlsZS5sZWZ0ID0gJzAnO1xuXHRcdFx0XHRcdHRoaXMudHJhY2tMb3cuc3R5bGUud2lkdGggPSBNYXRoLm1pbihwb3NpdGlvblBlcmNlbnRhZ2VzWzBdLCBwb3NpdGlvblBlcmNlbnRhZ2VzWzFdKSArICclJztcblxuXHRcdFx0XHRcdHRoaXMudHJhY2tTZWxlY3Rpb24uc3R5bGUubGVmdCA9IE1hdGgubWluKHBvc2l0aW9uUGVyY2VudGFnZXNbMF0sIHBvc2l0aW9uUGVyY2VudGFnZXNbMV0pICsgJyUnO1xuXHRcdFx0XHRcdHRoaXMudHJhY2tTZWxlY3Rpb24uc3R5bGUud2lkdGggPSBNYXRoLmFicyhwb3NpdGlvblBlcmNlbnRhZ2VzWzBdIC0gcG9zaXRpb25QZXJjZW50YWdlc1sxXSkgKyAnJSc7XG5cblx0XHRcdFx0XHR0aGlzLnRyYWNrSGlnaC5zdHlsZS5yaWdodCA9ICcwJztcblx0XHRcdFx0XHR0aGlzLnRyYWNrSGlnaC5zdHlsZS53aWR0aCA9IDEwMCAtIE1hdGgubWluKHBvc2l0aW9uUGVyY2VudGFnZXNbMF0sIHBvc2l0aW9uUGVyY2VudGFnZXNbMV0pIC0gTWF0aC5hYnMocG9zaXRpb25QZXJjZW50YWdlc1swXSAtIHBvc2l0aW9uUGVyY2VudGFnZXNbMV0pICsgJyUnO1xuXG5cdFx0XHRcdFx0dmFyIG9mZnNldF9taW4gPSB0aGlzLnRvb2x0aXBfbWluLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRcdHZhciBvZmZzZXRfbWF4ID0gdGhpcy50b29sdGlwX21heC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0XHRcdGlmIChvZmZzZXRfbWluLnJpZ2h0ID4gb2Zmc2V0X21heC5sZWZ0KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnRvb2x0aXBfbWF4LCAndG9wJyk7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRDbGFzcyh0aGlzLnRvb2x0aXBfbWF4LCAnYm90dG9tJyk7XG5cdFx0XHRcdFx0XHR0aGlzLnRvb2x0aXBfbWF4LnN0eWxlLnRvcCA9IDE4ICsgJ3B4Jztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50b29sdGlwX21heCwgJ2JvdHRvbScpO1xuXHRcdFx0XHRcdFx0dGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwX21heCwgJ3RvcCcpO1xuXHRcdFx0XHRcdFx0dGhpcy50b29sdGlwX21heC5zdHlsZS50b3AgPSB0aGlzLnRvb2x0aXBfbWluLnN0eWxlLnRvcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcmVzaXplOiBmdW5jdGlvbiBfcmVzaXplKGV2KSB7XG5cdFx0XHRcdC8qanNoaW50IHVudXNlZDpmYWxzZSovXG5cdFx0XHRcdHRoaXMuX3N0YXRlLm9mZnNldCA9IHRoaXMuX29mZnNldCh0aGlzLnNsaWRlckVsZW0pO1xuXHRcdFx0XHR0aGlzLl9zdGF0ZS5zaXplID0gdGhpcy5zbGlkZXJFbGVtW3RoaXMuc2l6ZVBvc107XG5cdFx0XHRcdHRoaXMuX2xheW91dCgpO1xuXHRcdFx0fSxcblx0XHRcdF9yZW1vdmVQcm9wZXJ0eTogZnVuY3Rpb24gX3JlbW92ZVByb3BlcnR5KGVsZW1lbnQsIHByb3ApIHtcblx0XHRcdFx0aWYgKGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkpIHtcblx0XHRcdFx0XHRlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3ApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW1lbnQuc3R5bGUucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X21vdXNlZG93bjogZnVuY3Rpb24gX21vdXNlZG93bihldikge1xuXHRcdFx0XHRpZiAoIXRoaXMuX3N0YXRlLmVuYWJsZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9zdGF0ZS5vZmZzZXQgPSB0aGlzLl9vZmZzZXQodGhpcy5zbGlkZXJFbGVtKTtcblx0XHRcdFx0dGhpcy5fc3RhdGUuc2l6ZSA9IHRoaXMuc2xpZGVyRWxlbVt0aGlzLnNpemVQb3NdO1xuXG5cdFx0XHRcdHZhciBwZXJjZW50YWdlID0gdGhpcy5fZ2V0UGVyY2VudGFnZShldik7XG5cblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5yYW5nZSkge1xuXHRcdFx0XHRcdHZhciBkaWZmMSA9IE1hdGguYWJzKHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMF0gLSBwZXJjZW50YWdlKTtcblx0XHRcdFx0XHR2YXIgZGlmZjIgPSBNYXRoLmFicyh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdIC0gcGVyY2VudGFnZSk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhdGUuZHJhZ2dlZCA9IGRpZmYxIDwgZGlmZjIgPyAwIDogMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9zdGF0ZS5kcmFnZ2VkID0gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbdGhpcy5fc3RhdGUuZHJhZ2dlZF0gPSBwZXJjZW50YWdlO1xuXHRcdFx0XHR0aGlzLl9sYXlvdXQoKTtcblxuXHRcdFx0XHRpZiAodGhpcy50b3VjaENhcGFibGUpIHtcblx0XHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMubW91c2Vtb3ZlLCBmYWxzZSk7XG5cdFx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMubW91c2V1cCwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMubW91c2Vtb3ZlKSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLm1vdXNldXApIHtcblx0XHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLm1vdXNldXAsIGZhbHNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubW91c2Vtb3ZlID0gdGhpcy5fbW91c2Vtb3ZlLmJpbmQodGhpcyk7XG5cdFx0XHRcdHRoaXMubW91c2V1cCA9IHRoaXMuX21vdXNldXAuYmluZCh0aGlzKTtcblxuXHRcdFx0XHRpZiAodGhpcy50b3VjaENhcGFibGUpIHtcblx0XHRcdFx0XHQvLyBUb3VjaDogQmluZCB0b3VjaCBldmVudHM6XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm1vdXNlbW92ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLm1vdXNldXAsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBCaW5kIG1vdXNlIGV2ZW50czpcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSwgZmFsc2UpO1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLm1vdXNldXAsIGZhbHNlKTtcblxuXHRcdFx0XHR0aGlzLl9zdGF0ZS5pbkRyYWcgPSB0cnVlO1xuXHRcdFx0XHR2YXIgbmV3VmFsdWUgPSB0aGlzLl9jYWxjdWxhdGVWYWx1ZSgpO1xuXG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ3NsaWRlU3RhcnQnLCBuZXdWYWx1ZSk7XG5cblx0XHRcdFx0dGhpcy5fc2V0RGF0YVZhbChuZXdWYWx1ZSk7XG5cdFx0XHRcdHRoaXMuc2V0VmFsdWUobmV3VmFsdWUsIGZhbHNlLCB0cnVlKTtcblxuXHRcdFx0XHR0aGlzLl9wYXVzZUV2ZW50KGV2KTtcblxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLmZvY3VzKSB7XG5cdFx0XHRcdFx0dGhpcy5fdHJpZ2dlckZvY3VzT25IYW5kbGUodGhpcy5fc3RhdGUuZHJhZ2dlZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRfdHJpZ2dlckZvY3VzT25IYW5kbGU6IGZ1bmN0aW9uIF90cmlnZ2VyRm9jdXNPbkhhbmRsZShoYW5kbGVJZHgpIHtcblx0XHRcdFx0aWYgKGhhbmRsZUlkeCA9PT0gMCkge1xuXHRcdFx0XHRcdHRoaXMuaGFuZGxlMS5mb2N1cygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoYW5kbGVJZHggPT09IDEpIHtcblx0XHRcdFx0XHR0aGlzLmhhbmRsZTIuZm9jdXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9rZXlkb3duOiBmdW5jdGlvbiBfa2V5ZG93bihoYW5kbGVJZHgsIGV2KSB7XG5cdFx0XHRcdGlmICghdGhpcy5fc3RhdGUuZW5hYmxlZCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkaXI7XG5cdFx0XHRcdHN3aXRjaCAoZXYua2V5Q29kZSkge1xuXHRcdFx0XHRcdGNhc2UgMzc6IC8vIGxlZnRcblx0XHRcdFx0XHRjYXNlIDQwOlxuXHRcdFx0XHRcdFx0Ly8gZG93blxuXHRcdFx0XHRcdFx0ZGlyID0gLTE7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDM5OiAvLyByaWdodFxuXHRcdFx0XHRcdGNhc2UgMzg6XG5cdFx0XHRcdFx0XHQvLyB1cFxuXHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghZGlyKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdXNlIG5hdHVyYWwgYXJyb3cga2V5cyBpbnN0ZWFkIG9mIGZyb20gbWluIHRvIG1heFxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLm5hdHVyYWxfYXJyb3dfa2V5cykge1xuXHRcdFx0XHRcdHZhciBpZlZlcnRpY2FsQW5kTm90UmV2ZXJzZWQgPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgIXRoaXMub3B0aW9ucy5yZXZlcnNlZDtcblx0XHRcdFx0XHR2YXIgaWZIb3Jpem9udGFsQW5kUmV2ZXJzZWQgPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyAmJiB0aGlzLm9wdGlvbnMucmV2ZXJzZWQ7XG5cblx0XHRcdFx0XHRpZiAoaWZWZXJ0aWNhbEFuZE5vdFJldmVyc2VkIHx8IGlmSG9yaXpvbnRhbEFuZFJldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRkaXIgPSAtZGlyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB2YWwgPSB0aGlzLl9zdGF0ZS52YWx1ZVtoYW5kbGVJZHhdICsgZGlyICogdGhpcy5vcHRpb25zLnN0ZXA7XG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMucmFuZ2UpIHtcblx0XHRcdFx0XHR2YWwgPSBbIWhhbmRsZUlkeCA/IHZhbCA6IHRoaXMuX3N0YXRlLnZhbHVlWzBdLCBoYW5kbGVJZHggPyB2YWwgOiB0aGlzLl9zdGF0ZS52YWx1ZVsxXV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdzbGlkZVN0YXJ0JywgdmFsKTtcblx0XHRcdFx0dGhpcy5fc2V0RGF0YVZhbCh2YWwpO1xuXHRcdFx0XHR0aGlzLnNldFZhbHVlKHZhbCwgdHJ1ZSwgdHJ1ZSk7XG5cblx0XHRcdFx0dGhpcy5fc2V0RGF0YVZhbCh2YWwpO1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdzbGlkZVN0b3AnLCB2YWwpO1xuXHRcdFx0XHR0aGlzLl9sYXlvdXQoKTtcblxuXHRcdFx0XHR0aGlzLl9wYXVzZUV2ZW50KGV2KTtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0X3BhdXNlRXZlbnQ6IGZ1bmN0aW9uIF9wYXVzZUV2ZW50KGV2KSB7XG5cdFx0XHRcdGlmIChldi5zdG9wUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0XHRldi5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZXYucHJldmVudERlZmF1bHQpIHtcblx0XHRcdFx0XHRldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV2LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG5cdFx0XHRcdGV2LnJldHVyblZhbHVlID0gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0X21vdXNlbW92ZTogZnVuY3Rpb24gX21vdXNlbW92ZShldikge1xuXHRcdFx0XHRpZiAoIXRoaXMuX3N0YXRlLmVuYWJsZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcGVyY2VudGFnZSA9IHRoaXMuX2dldFBlcmNlbnRhZ2UoZXYpO1xuXHRcdFx0XHR0aGlzLl9hZGp1c3RQZXJjZW50YWdlRm9yUmFuZ2VTbGlkZXJzKHBlcmNlbnRhZ2UpO1xuXHRcdFx0XHR0aGlzLl9zdGF0ZS5wZXJjZW50YWdlW3RoaXMuX3N0YXRlLmRyYWdnZWRdID0gcGVyY2VudGFnZTtcblx0XHRcdFx0dGhpcy5fbGF5b3V0KCk7XG5cblx0XHRcdFx0dmFyIHZhbCA9IHRoaXMuX2NhbGN1bGF0ZVZhbHVlKHRydWUpO1xuXHRcdFx0XHR0aGlzLnNldFZhbHVlKHZhbCwgdHJ1ZSwgdHJ1ZSk7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdF9hZGp1c3RQZXJjZW50YWdlRm9yUmFuZ2VTbGlkZXJzOiBmdW5jdGlvbiBfYWRqdXN0UGVyY2VudGFnZUZvclJhbmdlU2xpZGVycyhwZXJjZW50YWdlKSB7XG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMucmFuZ2UpIHtcblx0XHRcdFx0XHR2YXIgcHJlY2lzaW9uID0gdGhpcy5fZ2V0TnVtRGlnaXRzQWZ0ZXJEZWNpbWFsUGxhY2UocGVyY2VudGFnZSk7XG5cdFx0XHRcdFx0cHJlY2lzaW9uID0gcHJlY2lzaW9uID8gcHJlY2lzaW9uIC0gMSA6IDA7XG5cdFx0XHRcdFx0dmFyIHBlcmNlbnRhZ2VXaXRoQWRqdXN0ZWRQcmVjaXNpb24gPSB0aGlzLl9hcHBseVRvRml4ZWRBbmRQYXJzZUZsb2F0KHBlcmNlbnRhZ2UsIHByZWNpc2lvbik7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0YXRlLmRyYWdnZWQgPT09IDAgJiYgdGhpcy5fYXBwbHlUb0ZpeGVkQW5kUGFyc2VGbG9hdCh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdLCBwcmVjaXNpb24pIDwgcGVyY2VudGFnZVdpdGhBZGp1c3RlZFByZWNpc2lvbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhdGUucGVyY2VudGFnZVswXSA9IHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMV07XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGF0ZS5kcmFnZ2VkID0gMTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3N0YXRlLmRyYWdnZWQgPT09IDEgJiYgdGhpcy5fYXBwbHlUb0ZpeGVkQW5kUGFyc2VGbG9hdCh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdLCBwcmVjaXNpb24pID4gcGVyY2VudGFnZVdpdGhBZGp1c3RlZFByZWNpc2lvbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhdGUucGVyY2VudGFnZVsxXSA9IHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMF07XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGF0ZS5kcmFnZ2VkID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfbW91c2V1cDogZnVuY3Rpb24gX21vdXNldXAoKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fc3RhdGUuZW5hYmxlZCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy50b3VjaENhcGFibGUpIHtcblx0XHRcdFx0XHQvLyBUb3VjaDogVW5iaW5kIHRvdWNoIGV2ZW50IGhhbmRsZXJzOlxuXHRcdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5tb3VzZW1vdmUsIGZhbHNlKTtcblx0XHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5tb3VzZXVwLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVW5iaW5kIG1vdXNlIGV2ZW50IGhhbmRsZXJzOlxuXHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlLCBmYWxzZSk7XG5cdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMubW91c2V1cCwgZmFsc2UpO1xuXG5cdFx0XHRcdHRoaXMuX3N0YXRlLmluRHJhZyA9IGZhbHNlO1xuXHRcdFx0XHRpZiAodGhpcy5fc3RhdGUub3ZlciA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGlzLl9oaWRlVG9vbHRpcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB2YWwgPSB0aGlzLl9jYWxjdWxhdGVWYWx1ZSh0cnVlKTtcblxuXHRcdFx0XHR0aGlzLl9sYXlvdXQoKTtcblx0XHRcdFx0dGhpcy5fc2V0RGF0YVZhbCh2YWwpO1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdzbGlkZVN0b3AnLCB2YWwpO1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRfY2FsY3VsYXRlVmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVWYWx1ZShzbmFwVG9DbG9zZXN0VGljaykge1xuXHRcdFx0XHR2YXIgdmFsO1xuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnJhbmdlKSB7XG5cdFx0XHRcdFx0dmFsID0gW3RoaXMub3B0aW9ucy5taW4sIHRoaXMub3B0aW9ucy5tYXhdO1xuXHRcdFx0XHRcdGlmICh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdICE9PSAwKSB7XG5cdFx0XHRcdFx0XHR2YWxbMF0gPSB0aGlzLl90b1ZhbHVlKHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMF0pO1xuXHRcdFx0XHRcdFx0dmFsWzBdID0gdGhpcy5fYXBwbHlQcmVjaXNpb24odmFsWzBdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMV0gIT09IDEwMCkge1xuXHRcdFx0XHRcdFx0dmFsWzFdID0gdGhpcy5fdG9WYWx1ZSh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdKTtcblx0XHRcdFx0XHRcdHZhbFsxXSA9IHRoaXMuX2FwcGx5UHJlY2lzaW9uKHZhbFsxXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbCA9IHRoaXMuX3RvVmFsdWUodGhpcy5fc3RhdGUucGVyY2VudGFnZVswXSk7XG5cdFx0XHRcdFx0dmFsID0gcGFyc2VGbG9hdCh2YWwpO1xuXHRcdFx0XHRcdHZhbCA9IHRoaXMuX2FwcGx5UHJlY2lzaW9uKHZhbCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc25hcFRvQ2xvc2VzdFRpY2spIHtcblx0XHRcdFx0XHR2YXIgbWluID0gW3ZhbCwgSW5maW5pdHldO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgZGlmZiA9IE1hdGguYWJzKHRoaXMub3B0aW9ucy50aWNrc1tpXSAtIHZhbCk7XG5cdFx0XHRcdFx0XHRpZiAoZGlmZiA8PSBtaW5bMV0pIHtcblx0XHRcdFx0XHRcdFx0bWluID0gW3RoaXMub3B0aW9ucy50aWNrc1tpXSwgZGlmZl07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtaW5bMV0gPD0gdGhpcy5vcHRpb25zLnRpY2tzX3NuYXBfYm91bmRzKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbWluWzBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9LFxuXHRcdFx0X2FwcGx5UHJlY2lzaW9uOiBmdW5jdGlvbiBfYXBwbHlQcmVjaXNpb24odmFsKSB7XG5cdFx0XHRcdHZhciBwcmVjaXNpb24gPSB0aGlzLm9wdGlvbnMucHJlY2lzaW9uIHx8IHRoaXMuX2dldE51bURpZ2l0c0FmdGVyRGVjaW1hbFBsYWNlKHRoaXMub3B0aW9ucy5zdGVwKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2FwcGx5VG9GaXhlZEFuZFBhcnNlRmxvYXQodmFsLCBwcmVjaXNpb24pO1xuXHRcdFx0fSxcblx0XHRcdF9nZXROdW1EaWdpdHNBZnRlckRlY2ltYWxQbGFjZTogZnVuY3Rpb24gX2dldE51bURpZ2l0c0FmdGVyRGVjaW1hbFBsYWNlKG51bSkge1xuXHRcdFx0XHR2YXIgbWF0Y2ggPSAoJycgKyBudW0pLm1hdGNoKC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC8pO1xuXHRcdFx0XHRpZiAoIW1hdGNoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KDAsIChtYXRjaFsxXSA/IG1hdGNoWzFdLmxlbmd0aCA6IDApIC0gKG1hdGNoWzJdID8gK21hdGNoWzJdIDogMCkpO1xuXHRcdFx0fSxcblx0XHRcdF9hcHBseVRvRml4ZWRBbmRQYXJzZUZsb2F0OiBmdW5jdGlvbiBfYXBwbHlUb0ZpeGVkQW5kUGFyc2VGbG9hdChudW0sIHRvRml4ZWRJbnB1dCkge1xuXHRcdFx0XHR2YXIgdHJ1bmNhdGVkTnVtID0gbnVtLnRvRml4ZWQodG9GaXhlZElucHV0KTtcblx0XHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQodHJ1bmNhdGVkTnVtKTtcblx0XHRcdH0sXG5cdFx0XHQvKlxuICAgXHRDcmVkaXRzIHRvIE1pa2UgU2FtdWVsIGZvciB0aGUgZm9sbG93aW5nIG1ldGhvZCFcbiAgIFx0U291cmNlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNDU0NTE4L2phdmFzY3JpcHQtaG93LXRvLXJldHJpZXZlLXRoZS1udW1iZXItb2YtZGVjaW1hbHMtb2YtYS1zdHJpbmctbnVtYmVyXG4gICAqL1xuXHRcdFx0X2dldFBlcmNlbnRhZ2U6IGZ1bmN0aW9uIF9nZXRQZXJjZW50YWdlKGV2KSB7XG5cdFx0XHRcdGlmICh0aGlzLnRvdWNoQ2FwYWJsZSAmJiAoZXYudHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IGV2LnR5cGUgPT09ICd0b3VjaG1vdmUnKSkge1xuXHRcdFx0XHRcdGV2ID0gZXYudG91Y2hlc1swXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBldmVudFBvc2l0aW9uID0gZXZbdGhpcy5tb3VzZVBvc107XG5cdFx0XHRcdHZhciBzbGlkZXJPZmZzZXQgPSB0aGlzLl9zdGF0ZS5vZmZzZXRbdGhpcy5zdHlsZVBvc107XG5cdFx0XHRcdHZhciBkaXN0YW5jZVRvU2xpZGUgPSBldmVudFBvc2l0aW9uIC0gc2xpZGVyT2Zmc2V0O1xuXHRcdFx0XHQvLyBDYWxjdWxhdGUgd2hhdCBwZXJjZW50IG9mIHRoZSBsZW5ndGggdGhlIHNsaWRlciBoYW5kbGUgaGFzIHNsaWRcblx0XHRcdFx0dmFyIHBlcmNlbnRhZ2UgPSBkaXN0YW5jZVRvU2xpZGUgLyB0aGlzLl9zdGF0ZS5zaXplICogMTAwO1xuXHRcdFx0XHRwZXJjZW50YWdlID0gTWF0aC5yb3VuZChwZXJjZW50YWdlIC8gdGhpcy5fc3RhdGUucGVyY2VudGFnZVsyXSkgKiB0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzJdO1xuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnJldmVyc2VkKSB7XG5cdFx0XHRcdFx0cGVyY2VudGFnZSA9IDEwMCAtIHBlcmNlbnRhZ2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhlIHBlcmNlbnQgaXMgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIHNsaWRlci5cblx0XHRcdFx0Ly8gMCUgY29ycmVzcG9uZHMgdG8gdGhlICdtaW4nIHZhbHVlIG9mIHRoZSBzbGlkZVxuXHRcdFx0XHQvLyAxMDAlIGNvcnJlc3BvbmRzIHRvIHRoZSAnbWF4JyB2YWx1ZSBvZiB0aGUgc2xpZGVcblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgcGVyY2VudGFnZSkpO1xuXHRcdFx0fSxcblx0XHRcdF92YWxpZGF0ZUlucHV0VmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZUlucHV0VmFsdWUodmFsKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdmFsaWRhdGVBcnJheSh2YWwpO1xuXHRcdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKEVycm9yTXNncy5mb3JtYXRJbnZhbGlkSW5wdXRFcnJvck1zZyh2YWwpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF92YWxpZGF0ZUFycmF5OiBmdW5jdGlvbiBfdmFsaWRhdGVBcnJheSh2YWwpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgaW5wdXQgPSB2YWxbaV07XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBpbnB1dCAhPT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihFcnJvck1zZ3MuZm9ybWF0SW52YWxpZElucHV0RXJyb3JNc2coaW5wdXQpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfc2V0RGF0YVZhbDogZnVuY3Rpb24gX3NldERhdGFWYWwodmFsKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnLCB2YWwpO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbCk7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC52YWx1ZSA9IHZhbDtcblx0XHRcdH0sXG5cdFx0XHRfdHJpZ2dlcjogZnVuY3Rpb24gX3RyaWdnZXIoZXZ0LCB2YWwpIHtcblx0XHRcdFx0dmFsID0gdmFsIHx8IHZhbCA9PT0gMCA/IHZhbCA6IHVuZGVmaW5lZDtcblxuXHRcdFx0XHR2YXIgY2FsbGJhY2tGbkFycmF5ID0gdGhpcy5ldmVudFRvQ2FsbGJhY2tNYXBbZXZ0XTtcblx0XHRcdFx0aWYgKGNhbGxiYWNrRm5BcnJheSAmJiBjYWxsYmFja0ZuQXJyYXkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja0ZuQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciBjYWxsYmFja0ZuID0gY2FsbGJhY2tGbkFycmF5W2ldO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2tGbih2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIElmIEpRdWVyeSBleGlzdHMsIHRyaWdnZXIgSlF1ZXJ5IGV2ZW50cyAqL1xuXHRcdFx0XHRpZiAoJCkge1xuXHRcdFx0XHRcdHRoaXMuX3RyaWdnZXJKUXVlcnlFdmVudChldnQsIHZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfdHJpZ2dlckpRdWVyeUV2ZW50OiBmdW5jdGlvbiBfdHJpZ2dlckpRdWVyeUV2ZW50KGV2dCwgdmFsKSB7XG5cdFx0XHRcdHZhciBldmVudERhdGEgPSB7XG5cdFx0XHRcdFx0dHlwZTogZXZ0LFxuXHRcdFx0XHRcdHZhbHVlOiB2YWxcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy4kZWxlbWVudC50cmlnZ2VyKGV2ZW50RGF0YSk7XG5cdFx0XHRcdHRoaXMuJHNsaWRlckVsZW0udHJpZ2dlcihldmVudERhdGEpO1xuXHRcdFx0fSxcblx0XHRcdF91bmJpbmRKUXVlcnlFdmVudEhhbmRsZXJzOiBmdW5jdGlvbiBfdW5iaW5kSlF1ZXJ5RXZlbnRIYW5kbGVycygpIHtcblx0XHRcdFx0dGhpcy4kZWxlbWVudC5vZmYoKTtcblx0XHRcdFx0dGhpcy4kc2xpZGVyRWxlbS5vZmYoKTtcblx0XHRcdH0sXG5cdFx0XHRfc2V0VGV4dDogZnVuY3Rpb24gX3NldFRleHQoZWxlbWVudCwgdGV4dCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGVsZW1lbnQuaW5uZXJUZXh0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5pbm5lclRleHQgPSB0ZXh0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnRleHRDb250ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC50ZXh0Q29udGVudCA9IHRleHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIF9yZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc1N0cmluZykge1xuXHRcdFx0XHR2YXIgY2xhc3NlcyA9IGNsYXNzU3RyaW5nLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0dmFyIG5ld0NsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZTtcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2xhc3NUYWcgPSBjbGFzc2VzW2ldO1xuXHRcdFx0XHRcdHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCIoPzpcXFxcc3xeKVwiICsgY2xhc3NUYWcgKyBcIig/OlxcXFxzfCQpXCIpO1xuXHRcdFx0XHRcdG5ld0NsYXNzZXMgPSBuZXdDbGFzc2VzLnJlcGxhY2UocmVnZXgsIFwiIFwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3Q2xhc3Nlcy50cmltKCk7XG5cdFx0XHR9LFxuXHRcdFx0X2FkZENsYXNzOiBmdW5jdGlvbiBfYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NTdHJpbmcpIHtcblx0XHRcdFx0dmFyIGNsYXNzZXMgPSBjbGFzc1N0cmluZy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdHZhciBuZXdDbGFzc2VzID0gZWxlbWVudC5jbGFzc05hbWU7XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNsYXNzVGFnID0gY2xhc3Nlc1tpXTtcblx0XHRcdFx0XHR2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFwiKD86XFxcXHN8XilcIiArIGNsYXNzVGFnICsgXCIoPzpcXFxcc3wkKVwiKTtcblx0XHRcdFx0XHR2YXIgaWZDbGFzc0V4aXN0cyA9IHJlZ2V4LnRlc3QobmV3Q2xhc3Nlcyk7XG5cblx0XHRcdFx0XHRpZiAoIWlmQ2xhc3NFeGlzdHMpIHtcblx0XHRcdFx0XHRcdG5ld0NsYXNzZXMgKz0gXCIgXCIgKyBjbGFzc1RhZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtZW50LmNsYXNzTmFtZSA9IG5ld0NsYXNzZXMudHJpbSgpO1xuXHRcdFx0fSxcblx0XHRcdF9vZmZzZXRMZWZ0OiBmdW5jdGlvbiBfb2Zmc2V0TGVmdChvYmopIHtcblx0XHRcdFx0cmV0dXJuIG9iai5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0fSxcblx0XHRcdF9vZmZzZXRUb3A6IGZ1bmN0aW9uIF9vZmZzZXRUb3Aob2JqKSB7XG5cdFx0XHRcdHZhciBvZmZzZXRUb3AgPSBvYmoub2Zmc2V0VG9wO1xuXHRcdFx0XHR3aGlsZSAoKG9iaiA9IG9iai5vZmZzZXRQYXJlbnQpICYmICFpc05hTihvYmoub2Zmc2V0VG9wKSkge1xuXHRcdFx0XHRcdG9mZnNldFRvcCArPSBvYmoub2Zmc2V0VG9wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvZmZzZXRUb3A7XG5cdFx0XHR9LFxuXHRcdFx0X29mZnNldDogZnVuY3Rpb24gX29mZnNldChvYmopIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRsZWZ0OiB0aGlzLl9vZmZzZXRMZWZ0KG9iaiksXG5cdFx0XHRcdFx0dG9wOiB0aGlzLl9vZmZzZXRUb3Aob2JqKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdF9jc3M6IGZ1bmN0aW9uIF9jc3MoZWxlbWVudFJlZiwgc3R5bGVOYW1lLCB2YWx1ZSkge1xuXHRcdFx0XHRpZiAoJCkge1xuXHRcdFx0XHRcdCQuc3R5bGUoZWxlbWVudFJlZiwgc3R5bGVOYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHN0eWxlID0gc3R5bGVOYW1lLnJlcGxhY2UoL14tbXMtLywgXCJtcy1cIikucmVwbGFjZSgvLShbXFxkYS16XSkvZ2ksIGZ1bmN0aW9uIChhbGwsIGxldHRlcikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGVsZW1lbnRSZWYuc3R5bGVbc3R5bGVdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfdG9WYWx1ZTogZnVuY3Rpb24gX3RvVmFsdWUocGVyY2VudGFnZSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnNjYWxlLnRvVmFsdWUuYXBwbHkodGhpcywgW3BlcmNlbnRhZ2VdKTtcblx0XHRcdH0sXG5cdFx0XHRfdG9QZXJjZW50YWdlOiBmdW5jdGlvbiBfdG9QZXJjZW50YWdlKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc2NhbGUudG9QZXJjZW50YWdlLmFwcGx5KHRoaXMsIFt2YWx1ZV0pO1xuXHRcdFx0fSxcblx0XHRcdF9zZXRUb29sdGlwUG9zaXRpb246IGZ1bmN0aW9uIF9zZXRUb29sdGlwUG9zaXRpb24oKSB7XG5cdFx0XHRcdHZhciB0b29sdGlwcyA9IFt0aGlzLnRvb2x0aXAsIHRoaXMudG9vbHRpcF9taW4sIHRoaXMudG9vbHRpcF9tYXhdO1xuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG5cdFx0XHRcdFx0dmFyIHRvb2x0aXBQb3MgPSB0aGlzLm9wdGlvbnMudG9vbHRpcF9wb3NpdGlvbiB8fCAncmlnaHQnO1xuXHRcdFx0XHRcdHZhciBvcHBvc2l0ZVNpZGUgPSB0b29sdGlwUG9zID09PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuXHRcdFx0XHRcdHRvb2x0aXBzLmZvckVhY2goZnVuY3Rpb24gKHRvb2x0aXApIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FkZENsYXNzKHRvb2x0aXAsIHRvb2x0aXBQb3MpO1xuXHRcdFx0XHRcdFx0dG9vbHRpcC5zdHlsZVtvcHBvc2l0ZVNpZGVdID0gJzEwMCUnO1xuXHRcdFx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnRvb2x0aXBfcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG5cdFx0XHRcdFx0dG9vbHRpcHMuZm9yRWFjaChmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fYWRkQ2xhc3ModG9vbHRpcCwgJ2JvdHRvbScpO1xuXHRcdFx0XHRcdFx0dG9vbHRpcC5zdHlsZS50b3AgPSAyMiArICdweCc7XG5cdFx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0b29sdGlwcy5mb3JFYWNoKGZ1bmN0aW9uICh0b29sdGlwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRDbGFzcyh0b29sdGlwLCAndG9wJyk7XG5cdFx0XHRcdFx0XHR0b29sdGlwLnN0eWxlLnRvcCA9IC10aGlzLnRvb2x0aXAub3V0ZXJIZWlnaHQgLSAxNCArICdweCc7XG5cdFx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIFx0XHRBdHRhY2ggdG8gZ2xvYmFsIG5hbWVzcGFjZVxuICBcdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0XHRpZiAoJCkge1xuXHRcdFx0dmFyIG5hbWVzcGFjZSA9ICQuZm4uc2xpZGVyID8gJ2Jvb3RzdHJhcFNsaWRlcicgOiAnc2xpZGVyJztcblx0XHRcdCQuYnJpZGdldChuYW1lc3BhY2UsIFNsaWRlcik7XG5cdFx0fVxuXHR9KSgkKTtcblxuXHRyZXR1cm4gU2xpZGVyO1xufSk7XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG52YXIgcm9vdFBhcmVudCA9IHt9XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBsZW5ndGggPSArc3ViamVjdFxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbCkgeyAvLyBhc3N1bWUgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgICBpZiAoc3ViamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KHN1YmplY3QuZGF0YSkpXG4gICAgICBzdWJqZWN0ID0gc3ViamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gK3N1YmplY3QubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA+IGtNYXhMZW5ndGgpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcblxuICBpZiAobGVuZ3RoIDwgMClcbiAgICBsZW5ndGggPSAwXG4gIGVsc2VcbiAgICBsZW5ndGggPj4+PSAwIC8vIENvZXJjZSB0byB1aW50MzIuXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICAvKmVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtdGhpcyAqL1xuICAgIHNlbGYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgICAvKmVzbGludC1lbmFibGUgY29uc2lzdGVudC10aGlzICovXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBzZWxmLmxlbmd0aCA9IGxlbmd0aFxuICAgIHNlbGYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBzZWxmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBzZWxmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBzZWxmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzZWxmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIGlmIChsZW5ndGggPiAwICYmIGxlbmd0aCA8PSBCdWZmZXIucG9vbFNpemUpXG4gICAgc2VsZi5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHNlbGZcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2xvd0J1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcbiAgZGVsZXRlIGJ1Zi5wYXJlbnRcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbiAmJiBhW2ldID09PSBiW2ldOyBpKyspIHt9XG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKScpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCA+Pj4gMVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4vLyB0b1N0cmluZyhlbmNvZGluZywgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpXG4gICAgICBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4oYnl0ZSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuXG4gIGlmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApXG4gICAgICBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMClcbiAgICAgIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydClcbiAgICBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICBpZiAobmV3QnVmLmxlbmd0aClcbiAgICBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKVxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKVxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSlcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKVxuICAgIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKVxuICAgIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKVxuICAgIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpID4+PiAwICYgMHhGRlxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgPj4+IDAgJiAweEZGXG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0ludCh0aGlzLFxuICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgICBieXRlTGVuZ3RoLFxuICAgICAgICAgICAgIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSkgLSAxLFxuICAgICAgICAgICAgIC1NYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpKVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSW50KHRoaXMsXG4gICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgIGJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKSAtIDEsXG4gICAgICAgICAgICAgLU1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSkpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSlcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzIC8vIHNvdXJjZVxuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0X3N0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNlbGYubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldF9zdGFydCA8IDApXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNlbGYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5jb25zdHJ1Y3RvciA9IEJ1ZmZlclxuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XFwtXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG4gIHZhciBpID0gMFxuXG4gIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICBjb2RlUG9pbnQgPSBsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwIHwgMHgxMDAwMFxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG5cbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDIwMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNMRSA/IDEgOiAtMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwiXG4vKipcbiAqIGlzQXJyYXlcbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogdG9TdHJpbmdcbiAqL1xuXG52YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYHZhbGBcbiAqIGlzIGFuIGFycmF5LlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgICAgIGlzQXJyYXkoW10pO1xuICogICAgICAgIC8vID4gdHJ1ZVxuICogICAgICAgIGlzQXJyYXkoYXJndW1lbnRzKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKiAgICAgICAgaXNBcnJheSgnJyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7bWl4ZWR9IHZhbFxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXkgfHwgZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gISEgdmFsICYmICdbb2JqZWN0IEFycmF5XScgPT0gc3RyLmNhbGwodmFsKTtcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZTtcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW2ldKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xufVxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICBxdWV1ZS5wdXNoKGZ1bik7XG4gICAgaWYgKCFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBDeXRvc2NhcGUuanMgMi41LjUuXG4gKlxuICogQ3l0b3NjYXBlLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZVxuICogU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnlcbiAqIGxhdGVyIHZlcnNpb24uXG4gKlxuICogQ3l0b3NjYXBlLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTU1xuICogRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZVxuICogZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICogQ3l0b3NjYXBlLmpzLiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4gKi9cblxuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuY3l0b3NjYXBlID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IF9kZXJlcV8oJy4vdXRpbCcpO1xudmFyIGlzID0gX2RlcmVxXygnLi9pcycpO1xudmFyIFByb21pc2UgPSBfZGVyZXFfKCcuL3Byb21pc2UnKTtcblxudmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uKCB0YXJnZXQsIG9wdHMsIG9wdHMyICl7XG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBBbmltYXRpb24pICl7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb24oIHRhcmdldCwgb3B0cywgb3B0czIgKTtcbiAgfVxuXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB1dGlsLmV4dGVuZCgge1xuICAgIGR1cmF0aW9uOiAxMDAwXG4gIH0sIG9wdHMsIG9wdHMyICk7XG5cbiAgX3AudGFyZ2V0ID0gdGFyZ2V0O1xuICBfcC5zdHlsZSA9IF9wLnN0eWxlIHx8IF9wLmNzcztcbiAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gIF9wLmhvb2tlZCA9IGZhbHNlO1xuICBfcC5hcHBseWluZyA9IGZhbHNlO1xuICBfcC5wcm9ncmVzcyA9IDA7XG4gIF9wLmNvbXBsZXRlcyA9IFtdO1xuICBfcC5mcmFtZXMgPSBbXTtcblxuICBpZiggX3AuY29tcGxldGUgJiYgaXMuZm4oX3AuY29tcGxldGUpICl7XG4gICAgX3AuY29tcGxldGVzLnB1c2goIF9wLmNvbXBsZXRlICk7XG4gIH1cblxuICAvLyBmb3IgZnV0dXJlIHRpbWVsaW5lL2FuaW1hdGlvbnMgaW1wbFxuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXNbMF0gPSB0aGlzO1xufTtcblxudmFyIGFuaWZuID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxudXRpbC5leHRlbmQoIGFuaWZuLCB7XG5cbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAnYW5pbWF0aW9uJzsgfSxcblxuICBob29rOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggIV9wLmhvb2tlZCApe1xuICAgICAgLy8gYWRkIHRvIHRhcmdldCdzIGFuaW1hdGlvbiBxdWV1ZVxuICAgICAgdmFyIHE7XG4gICAgICB2YXIgdEFuaSA9IF9wLnRhcmdldC5fcHJpdmF0ZS5hbmltYXRpb247XG4gICAgICBpZiggX3AucXVldWUgKXtcbiAgICAgICAgcSA9IHRBbmkucXVldWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxID0gdEFuaS5jdXJyZW50O1xuICAgICAgfVxuICAgICAgcS5wdXNoKCB0aGlzICk7XG5cbiAgICAgIC8vIGFkZCB0byB0aGUgYW5pbWF0aW9uIGxvb3AgcG9vbFxuICAgICAgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIF9wLnRhcmdldCApICl7XG4gICAgICAgIF9wLnRhcmdldC5jeSgpLmFkZFRvQW5pbWF0aW9uUG9vbCggX3AudGFyZ2V0ICk7XG4gICAgICB9XG5cbiAgICAgIF9wLmhvb2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgLy8gYXV0b3Jld2luZFxuICAgIGlmKCBfcC5wcm9ncmVzcyA9PT0gMSApe1xuICAgICAgX3AucHJvZ3Jlc3MgPSAwO1xuICAgIH1cblxuICAgIF9wLnBsYXlpbmcgPSB0cnVlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgc3RhcnRlZCBieSBhbmltYXRpb24gbG9vcFxuICAgIF9wLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuaG9vaygpO1xuXG4gICAgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgc3RhcnQgdGhlIGFuaW1hdGlvbi4uLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcGxheWluZzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wbGF5aW5nO1xuICB9LFxuXG4gIGFwcGx5OiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBfcC5hcHBseWluZyA9IHRydWU7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG4gICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5ob29rKCk7XG5cbiAgICAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBhcHBseSB0aGUgYW5pbWF0aW9uIGF0IHRoaXMgcHJvZ3Jlc3NcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGFwcGx5aW5nOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmFwcGx5aW5nO1xuICB9LFxuXG4gIHBhdXNlOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBfcC5zdG9wcGVkID0gdHJ1ZTsgLy8gdG8gYmUgcmVtb3ZlZCBmcm9tIGFuaW1hdGlvbiBxdWV1ZXNcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJld2luZDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzcygwKTtcbiAgfSxcblxuICBmYXN0Zm9yd2FyZDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzcygxKTtcbiAgfSxcblxuICB0aW1lOiBmdW5jdGlvbiggdCApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggdCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gX3AucHJvZ3Jlc3MgKiBfcC5kdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3MoIHQgLyBfcC5kdXJhdGlvbiApO1xuICAgIH1cbiAgfSxcblxuICBwcm9ncmVzczogZnVuY3Rpb24oIHAgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB3YXNQbGF5aW5nID0gX3AucGxheWluZztcblxuICAgIGlmKCBwID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiBfcC5wcm9ncmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIHdhc1BsYXlpbmcgKXtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICBfcC5wcm9ncmVzcyA9IHA7XG4gICAgICBfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgIGlmKCB3YXNQbGF5aW5nICl7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNvbXBsZXRlZDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wcm9ncmVzcyA9PT0gMTtcbiAgfSxcblxuICByZXZlcnNlOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHdhc1BsYXlpbmcgPSBfcC5wbGF5aW5nO1xuXG4gICAgaWYoIHdhc1BsYXlpbmcgKXtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG5cbiAgICBfcC5wcm9ncmVzcyA9IDEgLSBfcC5wcm9ncmVzcztcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICB2YXIgc3dhcCA9IGZ1bmN0aW9uKCBhLCBiICl7XG4gICAgICB2YXIgX3BhID0gX3BbYV07XG5cbiAgICAgIF9wW2FdID0gX3BbYl07XG4gICAgICBfcFtiXSA9IF9wYTtcbiAgICB9O1xuXG4gICAgc3dhcCggJ3pvb20nLCAnc3RhcnRab29tJyApO1xuICAgIHN3YXAoICdwYW4nLCAnc3RhcnRQYW4nICk7XG4gICAgc3dhcCggJ3Bvc2l0aW9uJywgJ3N0YXJ0UG9zaXRpb24nICk7XG5cbiAgICAvLyBzd2FwIHN0eWxlc1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgX3Auc3R5bGUubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gX3Auc3R5bGVbaV07XG4gICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgIHZhciBzdGFydFN0eWxlUHJvcCA9IF9wLnN0YXJ0U3R5bGVbIG5hbWUgXTtcblxuICAgICAgX3Auc3RhcnRTdHlsZVsgbmFtZSBdID0gX3Auc3RhcnRTdHlsZVsgdXRpbC5kYXNoMmNhbWVsKCBuYW1lICkgXSA9IHByb3A7XG4gICAgICBfcC5zdHlsZVtpXSA9IHN0YXJ0U3R5bGVQcm9wO1xuICAgIH1cblxuICAgIGlmKCB3YXNQbGF5aW5nICl7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBwcm9taXNlOiBmdW5jdGlvbiggdHlwZSApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICB2YXIgYXJyO1xuXG4gICAgc3dpdGNoKCB0eXBlICl7XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICAgIGFyciA9IF9wLmZyYW1lcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgYXJyID0gX3AuY29tcGxldGVzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiggcmVzb2x2ZSwgcmVqZWN0ICl7XG4gICAgICBhcnIucHVzaChmdW5jdGlvbigpe1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG59ICk7XG5cbmFuaWZuLmNvbXBsZXRlID0gYW5pZm4uY29tcGxldGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbjtcblxufSx7XCIuL2lzXCI6NzcsXCIuL3Byb21pc2VcIjo4MCxcIi4vdXRpbFwiOjk0fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IF9kZXJlcV8oJy4uLy4uL2lzJyk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBhU3RhcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gUmVjb25zdHJ1Y3RzIHRoZSBwYXRoIGZyb20gU3RhcnQgdG8gRW5kLCBhY3VtdWxhdGluZyB0aGUgcmVzdWx0IGluIHBhdGhBY3VtXG4gICAgdmFyIHJlY29uc3RydWN0UGF0aCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGNhbWVGcm9tTWFwLCBwYXRoQWN1bSkge1xuICAgICAgLy8gQmFzZSBjYXNlXG4gICAgICBpZiAoc3RhcnQgPT0gZW5kKSB7XG4gICAgICAgIHBhdGhBY3VtLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKGVuZCkgKTtcbiAgICAgICAgcmV0dXJuIHBhdGhBY3VtO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kIGluIGNhbWVGcm9tTWFwKSB7XG4gICAgICAgIC8vIFdlIGtub3cgd2hpY2ggbm9kZSBpcyBiZWZvcmUgdGhlIGxhc3Qgb25lXG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNhbWVGcm9tTWFwW2VuZF07XG4gICAgICAgIHZhciBwcmV2aW91c0VkZ2UgPSBjYW1lRnJvbUVkZ2VbZW5kXTtcblxuICAgICAgICBwYXRoQWN1bS5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZChlbmQpICk7XG4gICAgICAgIHBhdGhBY3VtLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKHByZXZpb3VzRWRnZSkgKTtcblxuXG4gICAgICAgIHJldHVybiByZWNvbnN0cnVjdFBhdGgoc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyxcbiAgICAgICAgICAgICAgICAgICAgIGNhbWVGcm9tTWFwLFxuICAgICAgICAgICAgICAgICAgICAgcGF0aEFjdW0pO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBzaG91bGQgbm90IHJlYWNoIGhlcmUhXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiBvcGVuU2V0IHdoaWNoIGhhcyBtaW5pbXVtIGZTY29yZVxuICAgIHZhciBmaW5kTWluID0gZnVuY3Rpb24ob3BlblNldCwgZlNjb3JlKSB7XG4gICAgICBpZiAob3BlblNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGJlIHRoZSBjYXNlXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgbWluUG9zID0gMDtcbiAgICAgIHZhciB0ZW1wU2NvcmUgPSBmU2NvcmVbb3BlblNldFswXV07XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG9wZW5TZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHMgPSBmU2NvcmVbb3BlblNldFtpXV07XG4gICAgICAgIGlmIChzIDwgdGVtcFNjb3JlKSB7XG4gICAgICAgICAgdGVtcFNjb3JlID0gcztcbiAgICAgICAgICBtaW5Qb3MgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluUG9zO1xuICAgIH07XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucm9vdCAhPSBudWxsKSB7XG4gICAgICB2YXIgc291cmNlID0gaXMuc3RyaW5nKG9wdGlvbnMucm9vdCkgP1xuICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgdGhpcy5maWx0ZXIob3B0aW9ucy5yb290KVswXSA6XG4gICAgICAgIG9wdGlvbnMucm9vdFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBnb2FsIC0gbWFuZGF0b3J5IVxuICAgIGlmIChvcHRpb25zLmdvYWwgIT0gbnVsbCkge1xuICAgICAgdmFyIHRhcmdldCA9IGlzLnN0cmluZyhvcHRpb25zLmdvYWwpID9cbiAgICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjZ29hbElEXG4gICAgICAgIHRoaXMuZmlsdGVyKG9wdGlvbnMuZ29hbClbMF0gOlxuICAgICAgICBvcHRpb25zLmdvYWxbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gSGV1cmlzdGljIGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy5oZXVyaXN0aWMgIT0gbnVsbCAmJiBpcy5mbihvcHRpb25zLmhldXJpc3RpYykpIHtcbiAgICAgIHZhciBoZXVyaXN0aWMgPSBvcHRpb25zLmhldXJpc3RpYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhldXJpc3RpYyA9IGZ1bmN0aW9uKCl7IHJldHVybiAwOyB9OyAvLyB1c2UgY29uc3RhbnQgaWYgdW5zcGVjaWZpZWRcbiAgICB9XG5cbiAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLndlaWdodCAhPSBudWxsICYmIGlzLmZuKG9wdGlvbnMud2VpZ2h0KSkge1xuICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uKGUpIHtyZXR1cm4gMTt9O1xuICAgIH1cblxuICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsKSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2xvc2VkU2V0ID0gW107XG4gICAgdmFyIG9wZW5TZXQgPSBbc291cmNlLmlkKCldO1xuICAgIHZhciBjYW1lRnJvbSA9IHt9O1xuICAgIHZhciBjYW1lRnJvbUVkZ2UgPSB7fTtcbiAgICB2YXIgZ1Njb3JlID0ge307XG4gICAgdmFyIGZTY29yZSA9IHt9O1xuXG4gICAgZ1Njb3JlW3NvdXJjZS5pZCgpXSA9IDA7XG4gICAgZlNjb3JlW3NvdXJjZS5pZCgpXSA9IGhldXJpc3RpYyhzb3VyY2UpO1xuXG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbihlKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9KTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAvLyBDb3VudGVyXG4gICAgdmFyIHN0ZXBzID0gMDtcblxuICAgIC8vIE1haW4gbG9vcFxuICAgIHdoaWxlIChvcGVuU2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBtaW5Qb3MgPSBmaW5kTWluKG9wZW5TZXQsIGZTY29yZSk7XG4gICAgICB2YXIgY01pbiA9IGN5LmdldEVsZW1lbnRCeUlkKCBvcGVuU2V0W21pblBvc10gKTtcbiAgICAgIHN0ZXBzKys7XG5cbiAgICAgIC8vIElmIHdlJ3ZlIGZvdW5kIG91ciBnb2FsLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgICBpZiAoY01pbi5pZCgpID09IHRhcmdldC5pZCgpKSB7XG4gICAgICAgIHZhciByUGF0aCA9IHJlY29uc3RydWN0UGF0aChzb3VyY2UuaWQoKSwgdGFyZ2V0LmlkKCksIGNhbWVGcm9tLCBbXSk7XG4gICAgICAgIHJQYXRoLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb3VuZCA6IHRydWUsXG4gICAgICAgICAgZGlzdGFuY2UgOiBnU2NvcmVbY01pbi5pZCgpXSxcbiAgICAgICAgICBwYXRoIDogZWxlcy5zcGF3bihyUGF0aCksXG4gICAgICAgICAgc3RlcHMgOiBzdGVwc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgY01pbiB0byBwcm9jZXNzZWQgbm9kZXNcbiAgICAgIGNsb3NlZFNldC5wdXNoKGNNaW4uaWQoKSk7XG4gICAgICAvLyBSZW1vdmUgY01pbiBmcm9tIGJvdW5kYXJ5IG5vZGVzXG4gICAgICBvcGVuU2V0LnNwbGljZShtaW5Qb3MsIDEpO1xuXG4gICAgICAvLyBVcGRhdGUgc2NvcmVzIGZvciBuZWlnaGJvcnMgb2YgY01pblxuICAgICAgLy8gVGFrZSBpbnRvIGFjY291bnQgaWYgZ3JhcGggaXMgZGlyZWN0ZWQgb3Igbm90XG4gICAgICB2YXIgdndFZGdlcyA9IGNNaW4uY29ubmVjdGVkRWRnZXMoKTtcbiAgICAgIGlmKCBkaXJlY3RlZCApeyB2d0VkZ2VzID0gdndFZGdlcy5zdGRGaWx0ZXIoZnVuY3Rpb24oZWxlKXsgcmV0dXJuIGVsZS5kYXRhKCdzb3VyY2UnKSA9PT0gY01pbi5pZCgpOyB9KTsgfVxuICAgICAgdndFZGdlcyA9IHZ3RWRnZXMuaW50ZXJzZWN0KGVkZ2VzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlID0gdndFZGdlc1tpXTtcbiAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKG4peyByZXR1cm4gbi5pZCgpICE9PSBjTWluLmlkKCk7IH0pLmludGVyc2VjdChub2Rlcyk7XG5cbiAgICAgICAgLy8gaWYgbm9kZSBpcyBpbiBjbG9zZWRTZXQsIGlnbm9yZSBpdFxuICAgICAgICBpZiAoY2xvc2VkU2V0LmluZGV4T2Yody5pZCgpKSAhPSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmV3IHRlbnRhdGl2ZSBzY29yZSBmb3Igbm9kZSB3XG4gICAgICAgIHZhciB0ZW1wU2NvcmUgPSBnU2NvcmVbY01pbi5pZCgpXSArIHdlaWdodEZuLmFwcGx5KGUsIFtlXSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGdTY29yZSBmb3Igbm9kZSB3IGlmOlxuICAgICAgICAvLyAgIHcgbm90IHByZXNlbnQgaW4gb3BlblNldFxuICAgICAgICAvLyBPUlxuICAgICAgICAvLyAgIHRlbnRhdGl2ZSBnU2NvcmUgaXMgbGVzcyB0aGFuIHByZXZpb3VzIHZhbHVlXG5cbiAgICAgICAgLy8gdyBub3QgaW4gb3BlblNldFxuICAgICAgICBpZiAob3BlblNldC5pbmRleE9mKHcuaWQoKSkgPT0gLTEpIHtcbiAgICAgICAgICBnU2NvcmVbdy5pZCgpXSA9IHRlbXBTY29yZTtcbiAgICAgICAgICBmU2NvcmVbdy5pZCgpXSA9IHRlbXBTY29yZSArIGhldXJpc3RpYyh3KTtcbiAgICAgICAgICBvcGVuU2V0LnB1c2gody5pZCgpKTsgLy8gQWRkIG5vZGUgdG8gb3BlblNldFxuICAgICAgICAgIGNhbWVGcm9tW3cuaWQoKV0gPSBjTWluLmlkKCk7XG4gICAgICAgICAgY2FtZUZyb21FZGdlW3cuaWQoKV0gPSBlLmlkKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdyBhbHJlYWR5IGluIG9wZW5TZXQsIGJ1dCB3aXRoIGdyZWF0ZXIgZ1Njb3JlXG4gICAgICAgIGlmICh0ZW1wU2NvcmUgPCBnU2NvcmVbdy5pZCgpXSkge1xuICAgICAgICAgIGdTY29yZVt3LmlkKCldID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVt3LmlkKCldID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgIGNhbWVGcm9tW3cuaWQoKV0gPSBjTWluLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgfSAvLyBFbmQgb2YgbmVpZ2hib3JzIHVwZGF0ZVxuXG4gICAgfSAvLyBFbmQgb2YgbWFpbiBsb29wXG5cbiAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIGhlcmUsIHRoZW4gd2UndmUgbm90IHJlYWNoZWQgb3VyIGdvYWxcbiAgICByZXR1cm4ge1xuICAgICAgZm91bmQgOiBmYWxzZSxcbiAgICAgIGRpc3RhbmNlIDogdW5kZWZpbmVkLFxuICAgICAgcGF0aCA6IHVuZGVmaW5lZCxcbiAgICAgIHN0ZXBzIDogc3RlcHNcbiAgICB9O1xuICB9XG5cbn0pOyAvLyBlbGVzZm5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxufSx7XCIuLi8uLi9pc1wiOjc3fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IF9kZXJlcV8oJy4uLy4uL2lzJyk7XG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uLy4uL3V0aWwnKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGJlbGxtYW5Gb3JkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLndlaWdodCAhPSBudWxsICYmIGlzLmZuKG9wdGlvbnMud2VpZ2h0KSkge1xuICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uKGUpIHtyZXR1cm4gMTt9O1xuICAgIH1cblxuICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsKSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyByb290IC0gbWFuZGF0b3J5IVxuICAgIGlmIChvcHRpb25zLnJvb3QgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzLnN0cmluZyhvcHRpb25zLnJvb3QpKSB7XG4gICAgICAgIC8vIHVzZSBpdCBhcyBhIHNlbGVjdG9yLCBlLmcuIFwiI3Jvb3RJRFxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5maWx0ZXIob3B0aW9ucy5yb290KVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBvcHRpb25zLnJvb3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKGUpeyByZXR1cm4gIWUuaXNMb29wKCk7IH0pO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAvLyBtYXBwaW5nOiBub2RlIGlkIC0+IHBvc2l0aW9uIGluIG5vZGVzIGFycmF5XG4gICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6YXRpb25zXG4gICAgdmFyIGNvc3QgPSBbXTtcbiAgICB2YXIgcHJlZGVjZXNzb3IgPSBbXTtcbiAgICB2YXIgcHJlZEVkZ2UgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgaWYgKG5vZGVzW2ldLmlkKCkgPT09IHNvdXJjZS5pZCgpKSB7XG4gICAgICAgIGNvc3RbaV0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29zdFtpXSA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgcHJlZGVjZXNzb3JbaV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gRWRnZXMgcmVsYXhhdGlvblxuICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBmbGFnID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IGVkZ2VzLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2VJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2VdLnNvdXJjZSgpLmlkKCldO1xuICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tlXS50YXJnZXQoKS5pZCgpXTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2VzW2VdLCBbZWRnZXNbZV1dKTtcblxuICAgICAgICB2YXIgdGVtcCA9IGNvc3Rbc291cmNlSW5kZXhdICsgd2VpZ2h0O1xuICAgICAgICBpZiAodGVtcCA8IGNvc3RbdGFyZ2V0SW5kZXhdKSB7XG4gICAgICAgICAgY29zdFt0YXJnZXRJbmRleF0gPSB0ZW1wO1xuICAgICAgICAgIHByZWRlY2Vzc29yW3RhcmdldEluZGV4XSA9IHNvdXJjZUluZGV4O1xuICAgICAgICAgIHByZWRFZGdlW3RhcmdldEluZGV4XSA9IGVkZ2VzW2VdO1xuICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgd2UgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgJ3JldmVyc2UnIGVkZ2VcbiAgICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICAgIHZhciB0ZW1wID0gY29zdFt0YXJnZXRJbmRleF0gKyB3ZWlnaHQ7XG4gICAgICAgICAgaWYgKHRlbXAgPCBjb3N0W3NvdXJjZUluZGV4XSkge1xuICAgICAgICAgICAgY29zdFtzb3VyY2VJbmRleF0gPSB0ZW1wO1xuICAgICAgICAgICAgcHJlZGVjZXNzb3Jbc291cmNlSW5kZXhdID0gdGFyZ2V0SW5kZXg7XG4gICAgICAgICAgICBwcmVkRWRnZVtzb3VyY2VJbmRleF0gPSBlZGdlc1tlXTtcbiAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWZsYWcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZsYWcpIHtcbiAgICAgIC8vIENoZWNrIGZvciBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGVzXG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IGVkZ2VzLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2VJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2VdLnNvdXJjZSgpLmlkKCldO1xuICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tlXS50YXJnZXQoKS5pZCgpXTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2VzW2VdLCBbZWRnZXNbZV1dKTtcblxuICAgICAgICBpZiAoY29zdFtzb3VyY2VJbmRleF0gKyB3ZWlnaHQgPCBjb3N0W3RhcmdldEluZGV4XSkge1xuICAgICAgICAgIHV0aWwuZXJyb3IoXCJHcmFwaCBjb250YWlucyBhIG5lZ2F0aXZlIHdlaWdodCBjeWNsZSBmb3IgQmVsbG1hbi1Gb3JkXCIpO1xuICAgICAgICAgIHJldHVybiB7IHBhdGhUbzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgZGlzdGFuY2VUbzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZTogdHJ1ZX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCByZXN1bHQgb2JqZWN0XG4gICAgdmFyIHBvc2l0aW9uMmlkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBwb3NpdGlvbjJpZC5wdXNoKG5vZGVzW2ldLmlkKCkpO1xuICAgIH1cblxuXG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIGRpc3RhbmNlVG8gOiBmdW5jdGlvbih0bykge1xuICAgICAgICBpZiAoaXMuc3RyaW5nKHRvKSkge1xuICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKHRvKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29zdFtpZDJwb3NpdGlvblt0b0lkXV07XG4gICAgICB9LFxuXG4gICAgICBwYXRoVG8gOiBmdW5jdGlvbih0bykge1xuXG4gICAgICAgIHZhciByZWNvbnN0cnVjdFBhdGhBdXggPSBmdW5jdGlvbihwcmVkZWNlc3NvciwgZnJvbVBvcywgdG9Qb3MsIHBvc2l0aW9uMmlkLCBhY3VtUGF0aCwgcHJlZEVkZ2UpIHtcbiAgICAgICAgICBmb3IoOzspe1xuICAgICAgICAgICAgLy8gQWRkIHRvSWQgdG8gcGF0aFxuICAgICAgICAgICAgYWN1bVBhdGgucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24yaWRbdG9Qb3NdKSApO1xuICAgICAgICAgICAgYWN1bVBhdGgucHVzaCggcHJlZEVkZ2VbdG9Qb3NdICk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tUG9zID09PSB0b1Bvcykge1xuICAgICAgICAgICAgICAvLyByZWFjaGVkIHN0YXJ0aW5nIG5vZGVcbiAgICAgICAgICAgICAgcmV0dXJuIGFjdW1QYXRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBwYXRoIGV4aXN0cywgZGlzY2FydCBhY3VtdWxhdGVkIHBhdGggYW5kIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIHZhciBwcmVkUG9zID0gcHJlZGVjZXNzb3JbdG9Qb3NdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVkUG9zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvUG9zID0gcHJlZFBvcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXMuc3RyaW5nKHRvKSkge1xuICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKHRvKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGggPSBbXTtcblxuICAgICAgICAvLyBUaGlzIHJldHVybnMgYSByZXZlcnNlZCBwYXRoXG4gICAgICAgIHZhciByZXMgPSAgcmVjb25zdHJ1Y3RQYXRoQXV4KHByZWRlY2Vzc29yLFxuICAgICAgICAgICAgICAgICAgICAgIGlkMnBvc2l0aW9uW3NvdXJjZS5pZCgpXSxcbiAgICAgICAgICAgICAgICAgICAgICBpZDJwb3NpdGlvblt0b0lkXSxcbiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjJpZCxcbiAgICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgIHByZWRFZGdlKTtcblxuICAgICAgICAvLyBHZXQgaXQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIgYW5kIHJldHVybiBpdFxuICAgICAgICBpZiAocmVzICE9IG51bGwpIHtcbiAgICAgICAgICByZXMucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZXMuc3Bhd24ocmVzKTtcbiAgICAgIH0sXG5cbiAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IGZhbHNlXG4gICAgfTtcblxuICAgIHJldHVybiByZXM7XG5cbiAgfSAvLyBiZWxsbWFuRm9yZFxuXG59KTsgLy8gZWxlc2ZuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG59LHtcIi4uLy4uL2lzXCI6NzcsXCIuLi8uLi91dGlsXCI6OTR9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gX2RlcmVxXygnLi4vLi4vaXMnKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIHRoZSBwYXBlciBcIk9uIFZhcmlhbnRzIG9mIFNob3J0ZXN0LVBhdGggQmV0d2Vlbm5lc3MgQ2VudHJhbGl0eSBhbmQgdGhlaXIgR2VuZXJpYyBDb21wdXRhdGlvblwiIGJ5IFVscmlrIEJyYW5kZXNcbiAgYmV0d2Vlbm5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gV2VpZ2h0IC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgdmFyIHdlaWdodGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdlaWdodGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRGlyZWN0ZWQgLSBkZWZhdWx0IGZhbHNlXG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCAmJiBpcy5ib29sKG9wdGlvbnMuZGlyZWN0ZWQpKSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHJpb3JpdHlJbnNlcnQgPSBmdW5jdGlvbiAocXVldWUsIGVsZSkge1xuICAgICAgcXVldWUudW5zaGlmdChlbGUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGRbcXVldWVbaV1dIDwgZFtxdWV1ZVtpICsgMV1dICYmIGkgPCBxdWV1ZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIHRtcCA9IHF1ZXVlW2ldO1xuICAgICAgICBxdWV1ZVtpXSA9IHF1ZXVlW2kgKyAxXTtcbiAgICAgICAgcXVldWVbaSArIDFdID0gdG1wO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgLy8gc3RhcnRpbmdcbiAgICB2YXIgViA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgQSA9IHt9O1xuICAgIHZhciBDID0ge307XG5cbiAgICAvLyBBIGNvbnRhaW5zIHRoZSBuZWlnaGJvcmhvb2RzIG9mIGV2ZXJ5IG5vZGVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICBBW1ZbaV0uaWQoKV0gPSBWW2ldLm91dGdvZXJzKFwibm9kZVwiKTsgLy8gZ2V0IG91dGdvZXJzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFbVltpXS5pZCgpXSA9IFZbaV0ub3Blbk5laWdoYm9yaG9vZChcIm5vZGVcIik7IC8vIGdldCBuZWlnaGJvcnMgb2YgZXZlcnkgbm9kZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEMgY29udGFpbnMgdGhlIGJldHdlZW5uZXNzIHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVi5sZW5ndGg7IGkrKykge1xuICAgICAgQ1tWW2ldLmlkKCldID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IFYubGVuZ3RoOyBzKyspIHtcbiAgICAgIHZhciBTID0gW107IC8vIHN0YWNrXG4gICAgICB2YXIgUCA9IHt9O1xuICAgICAgdmFyIGcgPSB7fTtcbiAgICAgIHZhciBkID0ge307XG4gICAgICB2YXIgUSA9IFtdOyAvLyBxdWV1ZVxuXG4gICAgICAvLyBpbml0IGRpY3Rpb25hcmllc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIFBbVltpXS5pZCgpXSA9IFtdO1xuICAgICAgICBnW1ZbaV0uaWQoKV0gPSAwO1xuICAgICAgICBkW1ZbaV0uaWQoKV0gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB9XG5cbiAgICAgIGdbVltzXS5pZCgpXSA9IDE7IC8vIHNpZ21hXG4gICAgICBkW1Zbc10uaWQoKV0gPSAwOyAvLyBkaXN0YW5jZSB0byBzXG5cbiAgICAgIFEudW5zaGlmdChWW3NdLmlkKCkpO1xuXG4gICAgICB3aGlsZSAoUS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB2ID0gUS5wb3AoKTtcbiAgICAgICAgUy5wdXNoKHYpO1xuICAgICAgICBpZiAod2VpZ2h0ZWQpIHtcbiAgICAgICAgICBBW3ZdLmZvckVhY2goZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgIGlmIChjeS4kKCcjJyArIHYpLmVkZ2VzVG8odykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgZWRnZSA9IGN5LiQoJyMnICsgdikuZWRnZXNUbyh3KVswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBlZGdlID0gdy5lZGdlc1RvKCcjJyArIHYpWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWRnZVdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2UsIFtlZGdlXSk7XG5cbiAgICAgICAgICAgIGlmIChkW3cuaWQoKV0gPiBkW3ZdICsgZWRnZVdlaWdodCkge1xuICAgICAgICAgICAgICBkW3cuaWQoKV0gPSBkW3ZdICsgZWRnZVdlaWdodDtcbiAgICAgICAgICAgICAgaWYgKFEuaW5kZXhPZih3LmlkKCkpIDwgMCkgeyAvL2lmIHcgaXMgbm90IGluIFFcbiAgICAgICAgICAgICAgICBwcmlvcml0eUluc2VydChRLCB3LmlkKCkpO1xuICAgICAgICAgICAgICB9IGVsc2UgeyAvLyB1cGRhdGUgcG9zaXRpb24gaWYgdyBpcyBpbiBRXG4gICAgICAgICAgICAgICAgUS5zcGxpY2UoUS5pbmRleE9mKHcuaWQoKSksIDEpO1xuICAgICAgICAgICAgICAgIHByaW9yaXR5SW5zZXJ0KFEsIHcuaWQoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZ1t3LmlkKCldID0gMDtcbiAgICAgICAgICAgICAgUFt3LmlkKCldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFt3LmlkKCldID09IGRbdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgIGdbdy5pZCgpXSA9IGdbdy5pZCgpXSArIGdbdl07XG4gICAgICAgICAgICAgIFBbdy5pZCgpXS5wdXNoKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEFbdl0uZm9yRWFjaChmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgaWYgKGRbdy5pZCgpXSA9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgUS51bnNoaWZ0KHcuaWQoKSk7XG4gICAgICAgICAgICAgIGRbdy5pZCgpXSA9IGRbdl0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRbdy5pZCgpXSA9PSBkW3ZdICsgMSkge1xuICAgICAgICAgICAgICBnW3cuaWQoKV0gPSBnW3cuaWQoKV0gKyBnW3ZdO1xuICAgICAgICAgICAgICBQW3cuaWQoKV0ucHVzaCh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZSA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVbVltpXS5pZCgpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHcgPSBTLnBvcCgpO1xuICAgICAgICBQW3ddLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBlW3ZdID0gZVt2XSArIChnW3ZdIC8gZ1t3XSkgKiAoMSArIGVbd10pO1xuICAgICAgICAgIGlmICh3ICE9IFZbc10uaWQoKSlcbiAgICAgICAgICAgIENbd10gPSBDW3ddICsgZVt3XTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1heCA9IDA7XG4gICAgZm9yICh2YXIga2V5IGluIEMpIHtcbiAgICAgIGlmIChtYXggPCBDW2tleV0pXG4gICAgICAgIG1heCA9IENba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgYmV0d2Vlbm5lc3M6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChpcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ1tub2RlXTtcbiAgICAgIH0sXG5cbiAgICAgIGJldHdlZW5uZXNzTm9ybWFsaXplZDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDW25vZGVdIC8gbWF4O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhbGlhc1xuICAgIHJldC5iZXR3ZWVubmVzc05vcm1hbGlzZWQgPSByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpemVkO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSAvLyBiZXR3ZWVubmVzc0NlbnRyYWxpdHlcblxufSk7IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5lbGVzZm4uYmMgPSBlbGVzZm4uYmV0d2Vlbm5lc3NDZW50cmFsaXR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxufSx7XCIuLi8uLi9pc1wiOjc3fV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IF9kZXJlcV8oJy4uLy4uL2lzJyk7XG52YXIgSGVhcCA9IF9kZXJlcV8oJy4uLy4uL2hlYXAnKTtcblxudmFyIGRlZmluZVNlYXJjaCA9IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgcGFyYW1zID0ge1xuICAgIGJmczogcGFyYW1zLmJmcyB8fCAhcGFyYW1zLmRmcyxcbiAgICBkZnM6IHBhcmFtcy5kZnMgfHwgIXBhcmFtcy5iZnNcbiAgfTtcblxuICAvLyBmcm9tIHBzZXVkb2NvZGUgb24gd2lraXBlZGlhXG4gIHJldHVybiBmdW5jdGlvbiBzZWFyY2hGbiggcm9vdHMsIGZuLCBkaXJlY3RlZCApe1xuICAgIHZhciBvcHRpb25zO1xuICAgIHZhciBzdGQ7XG4gICAgdmFyIHRoaXNBcmc7XG4gICAgaWYoIGlzLnBsYWluT2JqZWN0KHJvb3RzKSAmJiAhaXMuZWxlbWVudE9yQ29sbGVjdGlvbihyb290cykgKXtcbiAgICAgIG9wdGlvbnMgPSByb290cztcbiAgICAgIHJvb3RzID0gb3B0aW9ucy5yb290cyB8fCBvcHRpb25zLnJvb3Q7XG4gICAgICBmbiA9IG9wdGlvbnMudmlzaXQ7XG4gICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICBzdGQgPSBvcHRpb25zLnN0ZDtcbiAgICAgIHRoaXNBcmcgPSBvcHRpb25zLnRoaXNBcmc7XG4gICAgfVxuXG4gICAgZGlyZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICFpcy5mbihmbikgPyBmbiA6IGRpcmVjdGVkO1xuICAgIGZuID0gaXMuZm4oZm4pID8gZm4gOiBmdW5jdGlvbigpe307XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciB2ID0gcm9vdHMgPSBpcy5zdHJpbmcocm9vdHMpID8gdGhpcy5maWx0ZXIocm9vdHMpIDogcm9vdHM7XG4gICAgdmFyIFEgPSBbXTtcbiAgICB2YXIgY29ubmVjdGVkTm9kZXMgPSBbXTtcbiAgICB2YXIgY29ubmVjdGVkQnkgPSB7fTtcbiAgICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgICB2YXIgViA9IHt9O1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIgZm91bmQ7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcblxuICAgIC8vIGVucXVldWUgdlxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKyApe1xuICAgICAgaWYoIHZbaV0uaXNOb2RlKCkgKXtcbiAgICAgICAgUS51bnNoaWZ0KCB2W2ldICk7XG5cbiAgICAgICAgaWYoIHBhcmFtcy5iZnMgKXtcbiAgICAgICAgICBWWyB2W2ldLmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKCB2W2ldICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZDJkZXB0aFsgdltpXS5pZCgpIF0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlKCBRLmxlbmd0aCAhPT0gMCApe1xuICAgICAgdmFyIHYgPSBwYXJhbXMuYmZzID8gUS5zaGlmdCgpIDogUS5wb3AoKTtcblxuICAgICAgaWYoIHBhcmFtcy5kZnMgKXtcbiAgICAgICAgaWYoIFZbIHYuaWQoKSBdICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgVlsgdi5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHYgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIHYuaWQoKSBdO1xuICAgICAgdmFyIHByZXZFZGdlID0gY29ubmVjdGVkQnlbIHYuaWQoKSBdO1xuICAgICAgdmFyIHByZXZOb2RlID0gcHJldkVkZ2UgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHByZXZFZGdlLmNvbm5lY3RlZE5vZGVzKCkubm90KCB2IClbMF07XG4gICAgICB2YXIgcmV0O1xuXG4gICAgICBpZiggc3RkICl7XG4gICAgICAgIHJldCA9IGZuLmNhbGwodGhpc0FyZywgdiwgcHJldkVkZ2UsIHByZXZOb2RlLCBqKyssIGRlcHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGZuLmNhbGwodiwgaisrLCBkZXB0aCwgdiwgcHJldkVkZ2UsIHByZXZOb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYoIHJldCA9PT0gdHJ1ZSApe1xuICAgICAgICBmb3VuZCA9IHY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiggcmV0ID09PSBmYWxzZSApe1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHZ3RWRnZXMgPSB2LmNvbm5lY3RlZEVkZ2VzKGRpcmVjdGVkID8gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YSgnc291cmNlJykgPT09IHYuaWQoKTsgfSA6IHVuZGVmaW5lZCkuaW50ZXJzZWN0KCBlZGdlcyApO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlID0gdndFZGdlc1tpXTtcbiAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmlkKCkgIT09IHYuaWQoKTsgfSkuaW50ZXJzZWN0KCBub2RlcyApO1xuXG4gICAgICAgIGlmKCB3Lmxlbmd0aCAhPT0gMCAmJiAhVlsgdy5pZCgpIF0gKXtcbiAgICAgICAgICB3ID0gd1swXTtcblxuICAgICAgICAgIFEucHVzaCggdyApO1xuXG4gICAgICAgICAgaWYoIHBhcmFtcy5iZnMgKXtcbiAgICAgICAgICAgIFZbIHcuaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCggdyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbm5lY3RlZEJ5WyB3LmlkKCkgXSA9IGU7XG5cbiAgICAgICAgICBpZDJkZXB0aFsgdy5pZCgpIF0gPSBpZDJkZXB0aFsgdi5pZCgpIF0gKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgY29ubmVjdGVkRWxlcyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5vZGUgPSBjb25uZWN0ZWROb2Rlc1tpXTtcbiAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkQnlbIG5vZGUuaWQoKSBdO1xuXG4gICAgICBpZiggZWRnZSApe1xuICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgIH1cblxuICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKCBub2RlICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IGN5LmNvbGxlY3Rpb24oIGNvbm5lY3RlZEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgIGZvdW5kOiBjeS5jb2xsZWN0aW9uKCBmb3VuZCApXG4gICAgfTtcbiAgfTtcbn07XG5cbi8vIHNlYXJjaCwgc3Bhbm5pbmcgdHJlZXMsIGV0Y1xudmFyIGVsZXNmbiA9ICh7XG5cbiAgYnJlYWR0aEZpcnN0U2VhcmNoOiBkZWZpbmVTZWFyY2goeyBiZnM6IHRydWUgfSksXG4gIGRlcHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCh7IGRmczogdHJ1ZSB9KSxcblxuICAvLyBrcnVza2FsJ3MgYWxnb3JpdGhtIChmaW5kcyBtaW4gc3Bhbm5pbmcgdHJlZSwgYXNzdW1pbmcgdW5kaXJlY3RlZCBncmFwaClcbiAgLy8gaW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGtydXNrYWw6IGZ1bmN0aW9uKCB3ZWlnaHRGbiApe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIHdlaWdodEZuID0gaXMuZm4od2VpZ2h0Rm4pID8gd2VpZ2h0Rm4gOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfTsgLy8gaWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuXG4gICAgZnVuY3Rpb24gZmluZFNldChlbGUpe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBmb3Jlc3QubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZXMgPSBmb3Jlc3RbaV07XG5cbiAgICAgICAgaWYoIGVsZXMuYW55U2FtZShlbGUpICl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZXM6IGVsZXMsXG4gICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgQSA9IGN5LmNvbGxlY3Rpb24oY3ksIFtdKTtcbiAgICB2YXIgZm9yZXN0ID0gW107XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgZm9yZXN0LnB1c2goIG5vZGVzW2ldLmNvbGxlY3Rpb24oKSApO1xuICAgIH1cblxuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICB2YXIgUyA9IGVkZ2VzLnRvQXJyYXkoKS5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgdmFyIHdlaWdodEEgPSB3ZWlnaHRGbi5jYWxsKGEsIGEpO1xuICAgICAgdmFyIHdlaWdodEIgPSB3ZWlnaHRGbi5jYWxsKGIsIGIpO1xuXG4gICAgICByZXR1cm4gd2VpZ2h0QSAtIHdlaWdodEI7XG4gICAgfSk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgUy5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgZWRnZSA9IFNbaV07XG4gICAgICB2YXIgdSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICB2YXIgdiA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgICB2YXIgc2V0VSA9IGZpbmRTZXQodSk7XG4gICAgICB2YXIgc2V0ViA9IGZpbmRTZXQodik7XG5cbiAgICAgIGlmKCBzZXRVLmluZGV4ICE9PSBzZXRWLmluZGV4ICl7XG4gICAgICAgIEEgPSBBLmFkZCggZWRnZSApO1xuXG4gICAgICAgIC8vIGNvbWJpbmUgZm9yZXN0cyBmb3IgdSBhbmQgdlxuICAgICAgICBmb3Jlc3RbIHNldFUuaW5kZXggXSA9IHNldFUuZWxlcy5hZGQoIHNldFYuZWxlcyApO1xuICAgICAgICBmb3Jlc3Quc3BsaWNlKCBzZXRWLmluZGV4LCAxICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzLmFkZCggQSApO1xuXG4gIH0sXG5cbiAgZGlqa3N0cmE6IGZ1bmN0aW9uKCByb290LCB3ZWlnaHRGbiwgZGlyZWN0ZWQgKXtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiggaXMucGxhaW5PYmplY3Qocm9vdCkgJiYgIWlzLmVsZW1lbnRPckNvbGxlY3Rpb24ocm9vdCkgKXtcbiAgICAgIG9wdGlvbnMgPSByb290O1xuICAgICAgcm9vdCA9IG9wdGlvbnMucm9vdDtcbiAgICAgIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB3ZWlnaHRGbiA9IGlzLmZuKHdlaWdodEZuKSA/IHdlaWdodEZuIDogZnVuY3Rpb24oKXsgcmV0dXJuIDE7IH07IC8vIGlmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcblxuICAgIHZhciBzb3VyY2UgPSBpcy5zdHJpbmcocm9vdCkgPyB0aGlzLmZpbHRlcihyb290KVswXSA6IHJvb3RbMF07XG4gICAgdmFyIGRpc3QgPSB7fTtcbiAgICB2YXIgcHJldiA9IHt9O1xuICAgIHZhciBrbm93bkRpc3QgPSB7fTtcblxuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5maWx0ZXIoZnVuY3Rpb24oKXsgcmV0dXJuICF0aGlzLmlzTG9vcCgpOyB9KTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgcmV0dXJuIGRpc3RbIG5vZGUuaWQoKSBdO1xuICAgIH07XG5cbiAgICB2YXIgc2V0RGlzdCA9IGZ1bmN0aW9uKG5vZGUsIGQpe1xuICAgICAgZGlzdFsgbm9kZS5pZCgpIF0gPSBkO1xuXG4gICAgICBRLnVwZGF0ZUl0ZW0oIG5vZGUgKTtcbiAgICB9O1xuXG4gICAgdmFyIFEgPSBuZXcgSGVhcChmdW5jdGlvbiggYSwgYiApe1xuICAgICAgcmV0dXJuIGdldERpc3QoYSkgLSBnZXREaXN0KGIpO1xuICAgIH0pO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgZGlzdFsgbm9kZS5pZCgpIF0gPSBub2RlLnNhbWUoIHNvdXJjZSApID8gMCA6IEluZmluaXR5O1xuICAgICAgUS5wdXNoKCBub2RlICk7XG4gICAgfVxuXG4gICAgdmFyIGRpc3RCZXR3ZWVuID0gZnVuY3Rpb24odSwgdil7XG4gICAgICB2YXIgdXZzID0gKCBkaXJlY3RlZCA/IHUuZWRnZXNUbyh2KSA6IHUuZWRnZXNXaXRoKHYpICkuaW50ZXJzZWN0KGVkZ2VzKTtcbiAgICAgIHZhciBzbWFsbGVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICB2YXIgc21hbGxlc3RFZGdlO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHV2cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IHV2c1tpXTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KCBlZGdlLCBbZWRnZV0gKTtcblxuICAgICAgICBpZiggd2VpZ2h0IDwgc21hbGxlc3REaXN0YW5jZSB8fCAhc21hbGxlc3RFZGdlICl7XG4gICAgICAgICAgc21hbGxlc3REaXN0YW5jZSA9IHdlaWdodDtcbiAgICAgICAgICBzbWFsbGVzdEVkZ2UgPSBlZGdlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVkZ2U6IHNtYWxsZXN0RWRnZSxcbiAgICAgICAgZGlzdDogc21hbGxlc3REaXN0YW5jZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgd2hpbGUoIFEuc2l6ZSgpID4gMCApe1xuICAgICAgdmFyIHUgPSBRLnBvcCgpO1xuICAgICAgdmFyIHNtYWxsZXRzRGlzdCA9IGdldERpc3QodSk7XG4gICAgICB2YXIgdWlkID0gdS5pZCgpO1xuXG4gICAgICBrbm93bkRpc3RbdWlkXSA9IHNtYWxsZXRzRGlzdDtcblxuICAgICAgaWYoIHNtYWxsZXRzRGlzdCA9PT0gTWF0aC5JbmZpbml0ZSApe1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIG5laWdoYm9ycyA9IHUubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KG5vZGVzKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB2ID0gbmVpZ2hib3JzW2ldO1xuICAgICAgICB2YXIgdmlkID0gdi5pZCgpO1xuICAgICAgICB2YXIgdkRpc3QgPSBkaXN0QmV0d2Vlbih1LCB2KTtcblxuICAgICAgICB2YXIgYWx0ID0gc21hbGxldHNEaXN0ICsgdkRpc3QuZGlzdDtcblxuICAgICAgICBpZiggYWx0IDwgZ2V0RGlzdCh2KSApe1xuICAgICAgICAgIHNldERpc3QodiwgYWx0KTtcblxuICAgICAgICAgIHByZXZbIHZpZCBdID0ge1xuICAgICAgICAgICAgbm9kZTogdSxcbiAgICAgICAgICAgIGVkZ2U6IHZEaXN0LmVkZ2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvclxuICAgIH0gLy8gd2hpbGVcblxuICAgIHJldHVybiB7XG4gICAgICBkaXN0YW5jZVRvOiBmdW5jdGlvbihub2RlKXtcbiAgICAgICAgdmFyIHRhcmdldCA9IGlzLnN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG5cbiAgICAgICAgcmV0dXJuIGtub3duRGlzdFsgdGFyZ2V0LmlkKCkgXTtcbiAgICAgIH0sXG5cbiAgICAgIHBhdGhUbzogZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIHZhciB0YXJnZXQgPSBpcy5zdHJpbmcobm9kZSkgPyBub2Rlcy5maWx0ZXIobm9kZSlbMF0gOiBub2RlWzBdO1xuICAgICAgICB2YXIgUyA9IFtdO1xuICAgICAgICB2YXIgdSA9IHRhcmdldDtcblxuICAgICAgICBpZiggdGFyZ2V0Lmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICBTLnVuc2hpZnQoIHRhcmdldCApO1xuXG4gICAgICAgICAgd2hpbGUoIHByZXZbIHUuaWQoKSBdICl7XG4gICAgICAgICAgICB2YXIgcCA9IHByZXZbIHUuaWQoKSBdO1xuXG4gICAgICAgICAgICBTLnVuc2hpZnQoIHAuZWRnZSApO1xuICAgICAgICAgICAgUy51bnNoaWZ0KCBwLm5vZGUgKTtcblxuICAgICAgICAgICAgdSA9IHAubm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3kuY29sbGVjdGlvbiggUyApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5lbGVzZm4uYmZzID0gZWxlc2ZuLmJyZWFkdGhGaXJzdFNlYXJjaDtcbmVsZXNmbi5kZnMgPSBlbGVzZm4uZGVwdGhGaXJzdFNlYXJjaDtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbn0se1wiLi4vLi4vaGVhcFwiOjc1LFwiLi4vLi4vaXNcIjo3N31dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi8uLi9pcycpO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICBjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIHZhciBoYXJtb25pYyA9IG9wdGlvbnMuaGFybW9uaWM7XG4gICAgaWYoIGhhcm1vbmljID09PSB1bmRlZmluZWQgKXtcbiAgICAgIGhhcm1vbmljID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2xvc2VuZXNzZXMgPSB7fTtcbiAgICB2YXIgbWF4Q2xvc2VuZXNzID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGZ3ID0gdGhpcy5mbG95ZFdhcnNoYWxsKHsgd2VpZ2h0OiBvcHRpb25zLndlaWdodCwgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQgfSk7XG5cbiAgICAvLyBDb21wdXRlIGNsb3NlbmVzcyBmb3IgZXZlcnkgbm9kZSBhbmQgZmluZCB0aGUgbWF4aW11bSBjbG9zZW5lc3NcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGN1cnJDbG9zZW5lc3MgPSAwO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoaSAhPSBqKSB7XG4gICAgICAgICAgdmFyIGQgPSBmdy5kaXN0YW5jZShub2Rlc1tpXSwgbm9kZXNbal0pO1xuXG4gICAgICAgICAgaWYoIGhhcm1vbmljICl7XG4gICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IDEgLyBkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhaGFybW9uaWMgKXtcbiAgICAgICAgY3VyckNsb3NlbmVzcyA9IDEgLyBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4Q2xvc2VuZXNzIDwgY3VyckNsb3NlbmVzcyl7XG4gICAgICAgIG1heENsb3NlbmVzcyA9IGN1cnJDbG9zZW5lc3M7XG4gICAgICB9XG5cbiAgICAgIGNsb3NlbmVzc2VzW25vZGVzW2ldLmlkKCldID0gY3VyckNsb3NlbmVzcztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2VuZXNzOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb3NlbmVzc2VzW25vZGVdIC8gbWF4Q2xvc2VuZXNzO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGNsb3NlbmVzc0NlbnRyYWxpdHk6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyByb290IC0gbWFuZGF0b3J5IVxuICAgIGlmIChvcHRpb25zLnJvb3QgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzLnN0cmluZyhvcHRpb25zLnJvb3QpKSB7XG4gICAgICAgIC8vIHVzZSBpdCBhcyBhIHNlbGVjdG9yLCBlLmcuIFwiI3Jvb3RJRFxuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuZmlsdGVyKG9wdGlvbnMucm9vdClbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcm9vdCA9IG9wdGlvbnMucm9vdFswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyB3ZWlnaHQgLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLndlaWdodCAhPSBudWxsICYmIGlzLmZuKG9wdGlvbnMud2VpZ2h0KSkge1xuICAgICAgdmFyIHdlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgd2VpZ2h0ID0gZnVuY3Rpb24oKXtyZXR1cm4gMTt9O1xuICAgIH1cblxuICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsICYmIGlzLmJvb2wob3B0aW9ucy5kaXJlY3RlZCkpIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBoYXJtb25pYyA9IG9wdGlvbnMuaGFybW9uaWM7XG4gICAgaWYoIGhhcm1vbmljID09PSB1bmRlZmluZWQgKXtcbiAgICAgIGhhcm1vbmljID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyB3ZSBuZWVkIGRpc3RhbmNlIGZyb20gdGhpcyBub2RlIHRvIGV2ZXJ5IG90aGVyIG5vZGVcbiAgICB2YXIgZGlqa3N0cmEgPSB0aGlzLmRpamtzdHJhKHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgIGRpcmVjdGVkOiBkaXJlY3RlZFxuICAgIH0pO1xuICAgIHZhciB0b3RhbERpc3RhbmNlID0gMDtcblxuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmIChub2Rlc1tpXS5pZCgpICE9IHJvb3QuaWQoKSl7XG4gICAgICAgIHZhciBkID0gZGlqa3N0cmEuZGlzdGFuY2VUbyhub2Rlc1tpXSk7XG5cbiAgICAgICAgaWYoIGhhcm1vbmljICl7XG4gICAgICAgICAgdG90YWxEaXN0YW5jZSArPSAxIC8gZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGFybW9uaWMgPyB0b3RhbERpc3RhbmNlIDogMSAvIHRvdGFsRGlzdGFuY2U7XG4gIH0gLy8gY2xvc2VuZXNzQ2VudHJhbGl0eVxuXG59KTsgLy8gZWxlc2ZuXG5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcbmVsZXNmbi5jYyA9IGVsZXNmbi5jbG9zZW5lc3NDZW50cmFsaXR5O1xuZWxlc2ZuLmNjbiA9IGVsZXNmbi5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXNlZCA9IGVsZXNmbi5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbn0se1wiLi4vLi4vaXNcIjo3N31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi8uLi9pcycpO1xudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi8uLi91dGlsJyk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICB2YXIgZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG1heERlZ3JlZSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAvLyBhZGQgY3VycmVudCBub2RlIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGRlZ3JlZUNlbnRyYWxpdHlcbiAgICAgICAgdmFyIGN1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkodXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtyb290OiBub2RlfSkpO1xuICAgICAgICBpZiAobWF4RGVncmVlIDwgY3VyckRlZ3JlZS5kZWdyZWUpXG4gICAgICAgICAgbWF4RGVncmVlID0gY3VyckRlZ3JlZS5kZWdyZWU7XG5cbiAgICAgICAgZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAoaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGVncmVlc1tub2RlXSAvIG1heERlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG91dGRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBtYXhJbmRlZ3JlZSA9IDA7XG4gICAgICB2YXIgbWF4T3V0ZGVncmVlID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eVxuICAgICAgICB2YXIgY3VyckRlZ3JlZSA9IHRoaXMuZGVncmVlQ2VudHJhbGl0eSh1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge3Jvb3Q6IG5vZGV9KSk7XG5cbiAgICAgICAgaWYgKG1heEluZGVncmVlIDwgY3VyckRlZ3JlZS5pbmRlZ3JlZSlcbiAgICAgICAgICBtYXhJbmRlZ3JlZSA9IGN1cnJEZWdyZWUuaW5kZWdyZWU7XG5cbiAgICAgICAgaWYgKG1heE91dGRlZ3JlZSA8IGN1cnJEZWdyZWUub3V0ZGVncmVlKVxuICAgICAgICAgIG1heE91dGRlZ3JlZSA9IGN1cnJEZWdyZWUub3V0ZGVncmVlO1xuXG4gICAgICAgIGluZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5pbmRlZ3JlZTtcbiAgICAgICAgb3V0ZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGVncmVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmIChpcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbmRlZ3JlZXNbbm9kZV0gLyBtYXhJbmRlZ3JlZTtcbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZGVncmVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmIChpcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBvdXRkZWdyZWVzW25vZGVdIC8gbWF4T3V0ZGVncmVlO1xuICAgICAgICB9XG5cbiAgICAgIH07XG4gICAgfVxuXG4gIH0sIC8vIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkXG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIE9wc2FobCdzIHBhcGVyXG4gIC8vIFwiTm9kZSBjZW50cmFsaXR5IGluIHdlaWdodGVkIG5ldHdvcmtzOiBHZW5lcmFsaXppbmcgZGVncmVlIGFuZCBzaG9ydGVzdCBwYXRoc1wiXG4gIC8vIGNoZWNrIHRoZSBoZWFkaW5nIDIgXCJEZWdyZWVcIlxuICBkZWdyZWVDZW50cmFsaXR5OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGNhbGxpbmdFbGVzID0gdGhpcztcblxuICAgIC8vIHJvb3QgLSBtYW5kYXRvcnkhXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnJvb3QgIT0gbnVsbCkge1xuICAgICAgdmFyIHJvb3QgPSBpcy5zdHJpbmcob3B0aW9ucy5yb290KSA/IHRoaXMuZmlsdGVyKG9wdGlvbnMucm9vdClbMF0gOiBvcHRpb25zLnJvb3RbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gd2VpZ2h0IC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGFscGhhIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy5hbHBoYSAhPSBudWxsICYmIGlzLm51bWJlcihvcHRpb25zLmFscGhhKSkge1xuICAgICAgdmFyIGFscGhhID0gb3B0aW9ucy5hbHBoYTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxwaGEgPSAwO1xuICAgIH1cblxuXG4gICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgdmFyIGNvbm5FZGdlcyA9IHJvb3QuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oIGNhbGxpbmdFbGVzICk7XG4gICAgICB2YXIgayA9IGNvbm5FZGdlcy5sZW5ndGg7XG4gICAgICB2YXIgcyA9IDA7XG5cbiAgICAgIC8vIE5vdywgc3VtIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uRWRnZXNbaV07XG4gICAgICAgIHMgKz0gd2VpZ2h0Rm4uYXBwbHkoZWRnZSwgW2VkZ2VdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVncmVlOiBNYXRoLnBvdyhrLCAxIC0gYWxwaGEpICogTWF0aC5wb3cocywgYWxwaGEpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5jb21pbmcgPSByb290LmNvbm5lY3RlZEVkZ2VzKCdlZGdlW3RhcmdldCA9IFwiJyArIHJvb3QuaWQoKSArICdcIl0nKS5pbnRlcnNlY3Rpb24oIGNhbGxpbmdFbGVzICk7XG4gICAgICB2YXIgb3V0Z29pbmcgPSByb290LmNvbm5lY3RlZEVkZ2VzKCdlZGdlW3NvdXJjZSA9IFwiJyArIHJvb3QuaWQoKSArICdcIl0nKS5pbnRlcnNlY3Rpb24oIGNhbGxpbmdFbGVzICk7XG4gICAgICB2YXIga19pbiA9IGluY29taW5nLmxlbmd0aDtcbiAgICAgIHZhciBrX291dCA9IG91dGdvaW5nLmxlbmd0aDtcbiAgICAgIHZhciBzX2luID0gMDtcbiAgICAgIHZhciBzX291dCA9IDA7XG5cbiAgICAgIC8vIE5vdywgc3VtIGluY29taW5nIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNvbWluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGluY29taW5nW2ldO1xuICAgICAgICBzX2luICs9IHdlaWdodEZuLmFwcGx5KGVkZ2UsIFtlZGdlXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdywgc3VtIG91dGdvaW5nIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRnb2luZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IG91dGdvaW5nW2ldO1xuICAgICAgICBzX291dCArPSB3ZWlnaHRGbi5hcHBseShlZGdlLCBbZWRnZV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRlZ3JlZTogTWF0aC5wb3coa19pbiwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfaW4sIGFscGhhKSxcbiAgICAgICAgb3V0ZGVncmVlOiBNYXRoLnBvdyhrX291dCwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfb3V0LCBhbHBoYSlcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIGRlZ3JlZUNlbnRyYWxpdHlcblxufSk7IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5lbGVzZm4uZGMgPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eTtcbmVsZXNmbi5kY24gPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG59LHtcIi4uLy4uL2lzXCI6NzcsXCIuLi8uLi91dGlsXCI6OTR9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gX2RlcmVxXygnLi4vLi4vaXMnKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGZsb3lkV2Fyc2hhbGw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7XG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oZSkge3JldHVybiAxO307XG4gICAgfVxuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oZSl7IHJldHVybiAhZS5pc0xvb3AoKTsgfSk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcblxuICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuICAgIHZhciBkaXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICB2YXIgbmV3Um93ID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgbmV3Um93W2pdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdSb3dbal0gPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGlzdC5wdXNoKG5ld1Jvdyk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYXRyaXggdXNlZCBmb3IgcGF0aCByZWNvbnN0cnVjdGlvblxuICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG4gICAgdmFyIG5leHQgPSBbXTtcbiAgICB2YXIgZWRnZU5leHQgPSBbXTtcblxuICAgIHZhciBpbml0TWF0cml4ID0gZnVuY3Rpb24obmV4dCl7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld1JvdyA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICAgIG5ld1Jvd1tqXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LnB1c2gobmV3Um93KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaW5pdE1hdHJpeChuZXh0KTtcbiAgICBpbml0TWF0cml4KGVkZ2VOZXh0KTtcblxuICAgIC8vIFByb2Nlc3MgZWRnZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aCA7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbaV0uc291cmNlKCkuaWQoKV07XG4gICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tpXS50YXJnZXQoKS5pZCgpXTtcbiAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbi5hcHBseShlZGdlc1tpXSwgW2VkZ2VzW2ldXSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcbiAgICAgIGlmIChkaXN0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPiB3ZWlnaHQpIHtcbiAgICAgICAgZGlzdFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gd2VpZ2h0O1xuICAgICAgICBuZXh0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgZWRnZU5leHRbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IGVkZ2VzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHByb2Nlc3MgJ3JldmVyc2VkJyBlZGdlc1xuICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2VJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2ldLnRhcmdldCgpLmlkKCldO1xuICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tpXS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2VzW2ldLCBbZWRnZXNbaV1dKTtcblxuICAgICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHByb2Nlc3MgYW5vdGhlciBlZGdlIGJldHdlZW4gc2FtZSAyIG5vZGVzXG4gICAgICAgIGlmIChkaXN0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPiB3ZWlnaHQpIHtcbiAgICAgICAgICBkaXN0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB3ZWlnaHQ7XG4gICAgICAgICAgbmV4dFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gdGFyZ2V0SW5kZXg7XG4gICAgICAgICAgZWRnZU5leHRbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IGVkZ2VzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFpbiBsb29wXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBudW1Ob2RlczsgaysrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgICAgaWYgKGRpc3RbaV1ba10gKyBkaXN0W2tdW2pdIDwgZGlzdFtpXVtqXSkge1xuICAgICAgICAgICAgZGlzdFtpXVtqXSA9IGRpc3RbaV1ba10gKyBkaXN0W2tdW2pdO1xuICAgICAgICAgICAgbmV4dFtpXVtqXSA9IG5leHRbaV1ba107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgcmVzdWx0IG9iamVjdFxuICAgIHZhciBwb3NpdGlvbjJpZCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgcG9zaXRpb24yaWQucHVzaChub2Rlc1tpXS5pZCgpKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0ge1xuICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChpcy5zdHJpbmcoZnJvbSkpIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIGZyb21JZCA9IChjeS5maWx0ZXIoZnJvbSlbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgZnJvbUlkID0gZnJvbS5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzLnN0cmluZyh0bykpIHtcbiAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlcih0bylbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpc3RbaWQycG9zaXRpb25bZnJvbUlkXV1baWQycG9zaXRpb25bdG9JZF1dO1xuICAgICAgfSxcblxuICAgICAgcGF0aDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIHJlY29uc3RydWN0UGF0aEF1eCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBuZXh0LCBwb3NpdGlvbjJpZCwgZWRnZU5leHQpIHtcbiAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgIHJldHVybiBjeS5nZXRFbGVtZW50QnlJZCggcG9zaXRpb24yaWRbZnJvbV0gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHRbZnJvbV1bdG9dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhdGggPSBbIGN5LmdldEVsZW1lbnRCeUlkKHBvc2l0aW9uMmlkW2Zyb21dKSBdO1xuICAgICAgICAgIHZhciBwcmV2ID0gZnJvbTtcbiAgICAgICAgICB3aGlsZSAoZnJvbSAhPT0gdG8pIHtcbiAgICAgICAgICAgIHByZXYgPSBmcm9tO1xuICAgICAgICAgICAgZnJvbSA9IG5leHRbZnJvbV1bdG9dO1xuXG4gICAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VOZXh0W3ByZXZdW2Zyb21dO1xuICAgICAgICAgICAgcGF0aC5wdXNoKCBlZGdlICk7XG5cbiAgICAgICAgICAgIHBhdGgucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24yaWRbZnJvbV0pICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpcy5zdHJpbmcoZnJvbSkpIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIGZyb21JZCA9IChjeS5maWx0ZXIoZnJvbSlbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgZnJvbUlkID0gZnJvbS5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzLnN0cmluZyh0bykpIHtcbiAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlcih0bylbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGhBcnIgPSByZWNvbnN0cnVjdFBhdGhBdXgoaWQycG9zaXRpb25bZnJvbUlkXSxcbiAgICAgICAgICAgICAgICAgICAgICBpZDJwb3NpdGlvblt0b0lkXSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uMmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGVkZ2VOZXh0KTtcblxuICAgICAgICByZXR1cm4gY3kuY29sbGVjdGlvbiggcGF0aEFyciApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzO1xuXG4gIH0gLy8gZmxveWRXYXJzaGFsbFxuXG59KTsgLy8gZWxlc2ZuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG59LHtcIi4uLy4uL2lzXCI6Nzd9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi8uLi91dGlsJyk7XG5cbnZhciBlbGVzZm4gPSB7fTtcblxuW1xuICBfZGVyZXFfKCcuL2Jmcy1kZnMnKSxcbiAgX2RlcmVxXygnLi9hLXN0YXInKSxcbiAgX2RlcmVxXygnLi9mbG95ZC13YXJzaGFsbCcpLFxuICBfZGVyZXFfKCcuL2JlbGxtYW4tZm9yZCcpLFxuICBfZGVyZXFfKCcuL2tlcmdlci1zdGVpbicpLFxuICBfZGVyZXFfKCcuL3BhZ2UtcmFuaycpLFxuICBfZGVyZXFfKCcuL2RlZ3JlZS1jZW50cmFsaXR5JyksXG4gIF9kZXJlcV8oJy4vY2xvc2VuZXNzLWNlbnRyYWxpdHknKSxcbiAgX2RlcmVxXygnLi9iZXR3ZWVubmVzcy1jZW50cmFsaXR5Jylcbl0uZm9yRWFjaChmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIGVsZXNmbiwgcHJvcHMgKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxufSx7XCIuLi8uLi91dGlsXCI6OTQsXCIuL2Etc3RhclwiOjIsXCIuL2JlbGxtYW4tZm9yZFwiOjMsXCIuL2JldHdlZW5uZXNzLWNlbnRyYWxpdHlcIjo0LFwiLi9iZnMtZGZzXCI6NSxcIi4vY2xvc2VuZXNzLWNlbnRyYWxpdHlcIjo2LFwiLi9kZWdyZWUtY2VudHJhbGl0eVwiOjcsXCIuL2Zsb3lkLXdhcnNoYWxsXCI6OCxcIi4va2VyZ2VyLXN0ZWluXCI6MTAsXCIuL3BhZ2UtcmFua1wiOjExfV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uLy4uL3V0aWwnKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gQ29tcHV0ZXMgdGhlIG1pbmltdW0gY3V0IG9mIGFuIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgLy8gUmV0dXJucyB0aGUgY29ycmVjdCBhbnN3ZXIgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG4gIGthcmdlclN0ZWluOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBGdW5jdGlvbiB3aGljaCBjb2xhcHNlcyAyIChtZXRhKSBub2RlcyBpbnRvIG9uZVxuICAgIC8vIFVwZGF0ZXMgdGhlIHJlbWFpbmluZyBlZGdlIGxpc3RzXG4gICAgLy8gUmVjZWl2ZXMgYXMgYSBwYXJhbWF0ZXIgdGhlIGVkZ2Ugd2hpY2ggY2F1c2VzIHRoZSBjb2xsYXBzZVxuICAgIHZhciBjb2xhcHNlID0gZnVuY3Rpb24oZWRnZUluZGV4LCBub2RlTWFwLCByZW1haW5pbmdFZGdlcykge1xuICAgICAgdmFyIGVkZ2VJbmZvID0gcmVtYWluaW5nRWRnZXNbZWRnZUluZGV4XTtcbiAgICAgIHZhciBzb3VyY2VJbiA9IGVkZ2VJbmZvWzFdO1xuICAgICAgdmFyIHRhcmdldEluID0gZWRnZUluZm9bMl07XG4gICAgICB2YXIgcGFydGl0aW9uMSA9IG5vZGVNYXBbc291cmNlSW5dO1xuICAgICAgdmFyIHBhcnRpdGlvbjIgPSBub2RlTWFwW3RhcmdldEluXTtcblxuICAgICAgLy8gRGVsZXRlIGFsbCBlZGdlcyBiZXR3ZWVuIHBhcnRpdGlvbjEgYW5kIHBhcnRpdGlvbjJcbiAgICAgIHZhciBuZXdFZGdlcyA9IHJlbWFpbmluZ0VkZ2VzLmZpbHRlcihmdW5jdGlvbihlZGdlKSB7XG4gICAgICAgIGlmIChub2RlTWFwW2VkZ2VbMV1dID09PSBwYXJ0aXRpb24xICYmIG5vZGVNYXBbZWRnZVsyXV0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVNYXBbZWRnZVsxXV0gPT09IHBhcnRpdGlvbjIgJiYgbm9kZU1hcFtlZGdlWzJdXSA9PT0gcGFydGl0aW9uMSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBbGwgZWRnZXMgcG9pbnRpbmcgdG8gcGFydGl0aW9uMiBzaG91bGQgbm93IHBvaW50IHRvIHBhcnRpdGlvbjFcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBuZXdFZGdlc1tpXTtcbiAgICAgICAgaWYgKGVkZ2VbMV0gPT09IHBhcnRpdGlvbjIpIHsgLy8gQ2hlY2sgc291cmNlXG4gICAgICAgICAgbmV3RWRnZXNbaV0gPSBlZGdlLnNsaWNlKDApO1xuICAgICAgICAgIG5ld0VkZ2VzW2ldWzFdID0gcGFydGl0aW9uMTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGdlWzJdID09PSBwYXJ0aXRpb24yKSB7IC8vIENoZWNrIHRhcmdldFxuICAgICAgICAgIG5ld0VkZ2VzW2ldID0gZWRnZS5zbGljZSgwKTtcbiAgICAgICAgICBuZXdFZGdlc1tpXVsyXSA9IHBhcnRpdGlvbjE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTW92ZSBhbGwgbm9kZXMgZnJvbSBwYXJ0aXRpb24yIHRvIHBhcnRpdGlvbjFcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZU1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobm9kZU1hcFtpXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgICAgIG5vZGVNYXBbaV0gPSBwYXJ0aXRpb24xO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdFZGdlcztcbiAgICB9O1xuXG5cbiAgICAvLyBDb250cmFjdHMgYSBncmFwaCB1bnRpbCB3ZSByZWFjaCBhIGNlcnRhaW4gbnVtYmVyIG9mIG1ldGEgbm9kZXNcbiAgICB2YXIgY29udHJhY3RVbnRpbCA9IGZ1bmN0aW9uKG1ldGFOb2RlTWFwLFxuICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0VkZ2VzLFxuICAgICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgICAgc2l6ZUxpbWl0KSB7XG4gICAgICAvLyBTdG9wIGNvbmRpdGlvblxuICAgICAgaWYgKHNpemUgPD0gc2l6ZUxpbWl0KSB7XG4gICAgICAgIHJldHVybiByZW1haW5pbmdFZGdlcztcbiAgICAgIH1cblxuICAgICAgLy8gQ2hvb3NlIGFuIGVkZ2UgcmFuZG9tbHlcbiAgICAgIHZhciBlZGdlSW5kZXggPSBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogcmVtYWluaW5nRWRnZXMubGVuZ3RoKSk7XG5cbiAgICAgIC8vIENvbGFwc2UgZ3JhcGggYmFzZWQgb24gZWRnZVxuICAgICAgdmFyIG5ld0VkZ2VzID0gY29sYXBzZShlZGdlSW5kZXgsIG1ldGFOb2RlTWFwLCByZW1haW5pbmdFZGdlcyk7XG5cbiAgICAgIHJldHVybiBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLFxuICAgICAgICAgICAgICAgICBuZXdFZGdlcyxcbiAgICAgICAgICAgICAgICAgc2l6ZSAtIDEsXG4gICAgICAgICAgICAgICAgIHNpemVMaW1pdCk7XG4gICAgfTtcblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbihlKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9KTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcbiAgICB2YXIgbnVtSXRlciA9IE1hdGguY2VpbChNYXRoLnBvdyhNYXRoLmxvZyhudW1Ob2RlcykgLyBNYXRoLkxOMiwgMikpO1xuICAgIHZhciBzdG9wU2l6ZSA9IE1hdGguZmxvb3IobnVtTm9kZXMgLyBNYXRoLnNxcnQoMikpO1xuXG4gICAgaWYgKG51bU5vZGVzIDwgMikge1xuICAgICAgdXRpbC5lcnJvcihcIkF0IGxlYXN0IDIgbm9kZXMgYXJlIHJlcXVpcmVkIGZvciBLYXJnZXItU3RlaW4gYWxnb3JpdGhtXCIpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbnVtZXJpY2FsIGlkZW50aWZpZXJzIGZvciBlYWNoIG5vZGVcbiAgICAvLyBtYXBwaW5nOiBub2RlIGlkIC0+IHBvc2l0aW9uIGluIG5vZGVzIGFycmF5XG4gICAgLy8gZm9yIHJldmVyc2UgbWFwcGluZywgc2ltcGx5IHVzZSBub2RlcyBhcnJheVxuICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgIH1cblxuICAgIC8vIE5vdyBzdG9yZSBlZGdlIGRlc3RpbmF0aW9uIGFzIGluZGV4ZXNcbiAgICAvLyBGb3JtYXQgZm9yIGVhY2ggZWRnZSAoZWRnZSBpbmRleCwgc291cmNlIG5vZGUgaW5kZXgsIHRhcmdldCBub2RlIGluZGV4KVxuICAgIHZhciBlZGdlSW5kZXhlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRWRnZXM7IGkrKykge1xuICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICAgIGVkZ2VJbmRleGVzLnB1c2goW2ksIGlkMnBvc2l0aW9uW2Uuc291cmNlKCkuaWQoKV0sIGlkMnBvc2l0aW9uW2UudGFyZ2V0KCkuaWQoKV1dKTtcbiAgICB9XG5cbiAgICAvLyBXZSB3aWxsIHN0b3JlIHRoZSBiZXN0IGN1dCBmb3VuZCBoZXJlXG4gICAgdmFyIG1pbkN1dFNpemUgPSBJbmZpbml0eTtcbiAgICB2YXIgbWluQ3V0O1xuXG4gICAgLy8gSW5pdGlhbCBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgdmFyIG9yaWdpbmFsTWV0YU5vZGUgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIG9yaWdpbmFsTWV0YU5vZGUucHVzaChpKTtcbiAgICB9XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICBmb3IgKHZhciBpdGVyID0gMDsgaXRlciA8PSBudW1JdGVyOyBpdGVyKyspIHtcbiAgICAgIC8vIENyZWF0ZSBuZXcgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgICAgdmFyIG1ldGFOb2RlTWFwID0gb3JpZ2luYWxNZXRhTm9kZS5zbGljZSgwKTtcblxuICAgICAgLy8gQ29udHJhY3QgdW50aWwgc3RvcCBwb2ludCAoc3RvcFNpemUgbm9kZXMpXG4gICAgICB2YXIgZWRnZXNTdGF0ZSA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIGVkZ2VJbmRleGVzLCBudW1Ob2Rlcywgc3RvcFNpemUpO1xuXG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBjb2xhcHNlZCBub2RlcyBzdGF0ZVxuICAgICAgdmFyIG1ldGFOb2RlTWFwMiA9IG1ldGFOb2RlTWFwLnNsaWNlKDApO1xuXG4gICAgICAvLyBSdW4gMiBpdGVyYXRpb25zIHN0YXJ0aW5nIGluIHRoZSBzdG9wIHN0YXRlXG4gICAgICB2YXIgcmVzMSA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIGVkZ2VzU3RhdGUsIHN0b3BTaXplLCAyKTtcbiAgICAgIHZhciByZXMyID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcDIsIGVkZ2VzU3RhdGUsIHN0b3BTaXplLCAyKTtcblxuICAgICAgLy8gSXMgYW55IG9mIHRoZSAyIHJlc3VsdHMgdGhlIGJlc3QgY3V0IHNvIGZhcj9cbiAgICAgIGlmIChyZXMxLmxlbmd0aCA8PSByZXMyLmxlbmd0aCAmJiByZXMxLmxlbmd0aCA8IG1pbkN1dFNpemUpIHtcbiAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczEubGVuZ3RoO1xuICAgICAgICBtaW5DdXQgPSBbcmVzMSwgbWV0YU5vZGVNYXBdO1xuICAgICAgfSBlbHNlIGlmIChyZXMyLmxlbmd0aCA8PSByZXMxLmxlbmd0aCAmJiByZXMyLmxlbmd0aCA8IG1pbkN1dFNpemUpIHtcbiAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczIubGVuZ3RoO1xuICAgICAgICBtaW5DdXQgPSBbcmVzMiwgbWV0YU5vZGVNYXAyXTtcbiAgICAgIH1cbiAgICB9IC8vIGVuZCBvZiBtYWluIGxvb3BcblxuXG4gICAgLy8gQ29uc3RydWN0IHJlc3VsdFxuICAgIHZhciByZXNFZGdlcyA9IChtaW5DdXRbMF0pLm1hcChmdW5jdGlvbihlKXsgcmV0dXJuIGVkZ2VzW2VbMF1dOyB9KTtcbiAgICB2YXIgcGFydGl0aW9uMSA9IFtdO1xuICAgIHZhciBwYXJ0aXRpb24yID0gW107XG5cbiAgICAvLyB0cmF2ZXJzZSBtZXRhTm9kZU1hcCBmb3IgYmVzdCBjdXRcbiAgICB2YXIgd2l0bmVzc05vZGVQYXJ0aXRpb24gPSBtaW5DdXRbMV1bMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DdXRbMV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0aXRpb25JZCA9IG1pbkN1dFsxXVtpXTtcbiAgICAgIGlmIChwYXJ0aXRpb25JZCA9PT0gd2l0bmVzc05vZGVQYXJ0aXRpb24pIHtcbiAgICAgICAgcGFydGl0aW9uMS5wdXNoKG5vZGVzW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRpdGlvbjIucHVzaChub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIGN1dDogZWxlcy5zcGF3bihjeSwgcmVzRWRnZXMpLFxuICAgICAgcGFydGl0aW9uMTogZWxlcy5zcGF3bihwYXJ0aXRpb24xKSxcbiAgICAgIHBhcnRpdGlvbjI6IGVsZXMuc3Bhd24ocGFydGl0aW9uMilcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufSk7IC8vIGVsZXNmblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG59LHtcIi4uLy4uL3V0aWxcIjo5NH1dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gX2RlcmVxXygnLi4vLi4vaXMnKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgcGFnZVJhbms6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBub3JtYWxpemVWZWN0b3IgPSBmdW5jdGlvbih2ZWN0b3IpIHtcbiAgICAgIHZhciBsZW5ndGggPSB2ZWN0b3IubGVuZ3RoO1xuXG4gICAgICAvLyBGaXJzdCwgZ2V0IHN1bSBvZiBhbGwgZWxlbWVudHNcbiAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvdGFsICs9IHZlY3RvcltpXTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93LCBkaXZpZGUgZWFjaCBieSB0aGUgc3VtIG9mIGFsbCBlbGVtZW50c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2ZWN0b3JbaV0gPSB2ZWN0b3JbaV0gLyB0b3RhbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZGFtcGluZ0ZhY3RvciAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucy5kYW1waW5nRmFjdG9yICE9IG51bGwpIHtcbiAgICAgIHZhciBkYW1waW5nRmFjdG9yID0gb3B0aW9ucy5kYW1waW5nRmFjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGFtcGluZ0ZhY3RvciA9IDAuODsgLy8gRGVmYXVsdCBkYW1waW5nIGZhY3RvclxuICAgIH1cblxuICAgIC8vIGRlc2lyZWQgcHJlY2lzaW9uIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmXG4gICAgICBvcHRpb25zLnByZWNpc2lvbiAhPSBudWxsKSB7XG4gICAgICB2YXIgZXBzaWxvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXBzaWxvbiA9IDAuMDAwMDAxOyAvLyBEZWZhdWx0IHByZWNpc2lvblxuICAgIH1cblxuICAgIC8vIE1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucy5pdGVyYXRpb25zICE9IG51bGwpIHtcbiAgICAgIHZhciBudW1JdGVyID0gb3B0aW9ucy5pdGVyYXRpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbnVtSXRlciA9IDIwMDsgLy8gRGVmYXVsdCBudW1iZXIgb2YgaXRlcmF0aW9uc1xuICAgIH1cblxuICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJlxuICAgICAgaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7XG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oZSkge3JldHVybiAxO307XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKGUpeyByZXR1cm4gIWUuaXNMb29wKCk7IH0pO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuXG4gICAgLy8gQ3JlYXRlIG51bWVyaWNhbCBpZGVudGlmaWVycyBmb3IgZWFjaCBub2RlXG4gICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgIC8vIGZvciByZXZlcnNlIG1hcHBpbmcsIHNpbXBseSB1c2Ugbm9kZXMgYXJyYXlcbiAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgdHJhbnNwb3NlZCBhZGphY2VuY3kgbWF0cml4XG4gICAgLy8gRmlyc3QgbGV0cyBoYXZlIGEgemVyb2VkIG1hdHJpeCBvZiB0aGUgcmlnaHQgc2l6ZVxuICAgIC8vIFdlJ2xsIGFsc28ga2VlcCB0cmFjayBvZiB0aGUgc3VtIG9mIGVhY2ggY29sdW1uXG4gICAgdmFyIG1hdHJpeCA9IFtdO1xuICAgIHZhciBjb2x1bW5TdW0gPSBbXTtcbiAgICB2YXIgYWRkaXRpb25hbFByb2IgPSAoMSAtIGRhbXBpbmdGYWN0b3IpIC8gbnVtTm9kZXM7XG5cbiAgICAvLyBDcmVhdGUgbnVsbCBtYXRyaWNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIHZhciBuZXdSb3cgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICBuZXdSb3cucHVzaCgwLjApO1xuICAgICAgfVxuICAgICAgbWF0cml4LnB1c2gobmV3Um93KTtcbiAgICAgIGNvbHVtblN1bS5wdXNoKDAuMCk7XG4gICAgfVxuXG4gICAgLy8gTm93LCBwcm9jZXNzIGVkZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FZGdlczsgaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIHMgPSBpZDJwb3NpdGlvbltlZGdlLnNvdXJjZSgpLmlkKCldO1xuICAgICAgdmFyIHQgPSBpZDJwb3NpdGlvbltlZGdlLnRhcmdldCgpLmlkKCldO1xuICAgICAgdmFyIHcgPSB3ZWlnaHRGbi5hcHBseShlZGdlLCBbZWRnZV0pO1xuXG4gICAgICAvLyBVcGRhdGUgbWF0cml4XG4gICAgICBtYXRyaXhbdF1bc10gKz0gdztcblxuICAgICAgLy8gVXBkYXRlIGNvbHVtbiBzdW1cbiAgICAgIGNvbHVtblN1bVtzXSArPSB3O1xuICAgIH1cblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIHByb2JhYmlsaXR5IGJhc2VkIG9uIGRhbXBpbmcgZmFjdG9yXG4gICAgLy8gQWxzbywgdGFrZSBpbnRvIGFjY291bnQgY29sdW1ucyB0aGF0IGhhdmUgc3VtID0gMFxuICAgIHZhciBwID0gMS4wIC8gbnVtTm9kZXMgKyBhZGRpdGlvbmFsUHJvYjsgLy8gU2hvcnRoYW5kXG4gICAgLy8gVHJhdmVyc2UgbWF0cml4LCBjb2x1bW4gYnkgY29sdW1uXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICBpZiAoY29sdW1uU3VtW2pdID09PSAwKSB7XG4gICAgICAgIC8vIE5vICdsaW5rcycgb3V0IGZyb20gbm9kZSBqdGgsIGFzc3VtZSBlcXVhbCBwcm9iYWJpbGl0eSBmb3IgZWFjaCBwb3NzaWJsZSBub2RlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IHA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vZGUganRoIGhhcyBvdXRnb2luZyBsaW5rLCBjb21wdXRlIG5vcm1hbGl6ZWQgcHJvYmFiaWxpdGllc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtYXRyaXhbaV1bal0gLyBjb2x1bW5TdW1bal0gKyBhZGRpdGlvbmFsUHJvYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXB1dGUgZG9taW5hbnQgZWlnZW52ZWN0b3IgdXNpbmcgcG93ZXIgbWV0aG9kXG4gICAgdmFyIGVpZ2VudmVjdG9yID0gW107XG4gICAgdmFyIG51bGxWZWN0b3IgPSBbXTtcbiAgICB2YXIgcHJldmlvdXM7XG5cbiAgICAvLyBTdGFydCB3aXRoIGEgdmVjdG9yIG9mIGFsbCAxJ3NcbiAgICAvLyBBbHNvLCBpbml0aWFsaXplIGEgbnVsbCB2ZWN0b3Igd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHNob3J0aGFuZFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgZWlnZW52ZWN0b3IucHVzaCgxLjApO1xuICAgICAgbnVsbFZlY3Rvci5wdXNoKDAuMCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPCBudW1JdGVyOyBpdGVyKyspIHtcbiAgICAgIC8vIE5ldyBhcnJheSB3aXRoIGFsbCAwJ3NcbiAgICAgIHZhciB0ZW1wID0gbnVsbFZlY3Rvci5zbGljZSgwKTtcblxuICAgICAgLy8gTXVsdGlwbHkgbWF0cml4IHdpdGggcHJldmlvdXMgcmVzdWx0XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgICAgdGVtcFtpXSArPSBtYXRyaXhbaV1bal0gKiBlaWdlbnZlY3RvcltqXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub3JtYWxpemVWZWN0b3IodGVtcCk7XG4gICAgICBwcmV2aW91cyA9IGVpZ2VudmVjdG9yO1xuICAgICAgZWlnZW52ZWN0b3IgPSB0ZW1wO1xuXG4gICAgICB2YXIgZGlmZiA9IDA7XG4gICAgICAvLyBDb21wdXRlIGRpZmZlcmVuY2UgKHNxdWFyZWQgbW9kdWxlKSBvZiBib3RoIHZlY3RvcnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBkaWZmICs9IE1hdGgucG93KHByZXZpb3VzW2ldIC0gZWlnZW52ZWN0b3JbaV0sIDIpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBkaWZmZXJlbmNlIGlzIGxlc3MgdGhhbiB0aGUgZGVzaXJlZCB0aHJlc2hvbGQsIHN0b3AgaXRlcmF0aW5nXG4gICAgICBpZiAoZGlmZiA8IGVwc2lsb24pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0IHJlc3VsdFxuICAgIHZhciByZXMgPSB7XG4gICAgICByYW5rIDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgLy8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgbm9kZUlkID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpcyBhIG5vZGUgb2JqZWN0XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGUuaWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWlnZW52ZWN0b3JbaWQycG9zaXRpb25bbm9kZUlkXV07XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBwYWdlUmFua1xuXG59KTsgLy8gZWxlc2ZuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG59LHtcIi4uLy4uL2lzXCI6Nzd9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSBfZGVyZXFfKCcuLi9kZWZpbmUnKTtcblxudmFyIGVsZXNmbiA9ICh7XG4gIGFuaW1hdGU6IGRlZmluZS5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lLmFuaW1hdGlvbigpLFxuICBhbmltYXRlZDogZGVmaW5lLmFuaW1hdGVkKCksXG4gIGNsZWFyUXVldWU6IGRlZmluZS5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUuZGVsYXkoKSxcbiAgZGVsYXlBbmltYXRpb246IGRlZmluZS5kZWxheUFuaW1hdGlvbigpLFxuICBzdG9wOiBkZWZpbmUuc3RvcCgpXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbn0se1wiLi4vZGVmaW5lXCI6NDF9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gX2RlcmVxXygnLi4vdXRpbCcpO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgY2xhc3NlczogZnVuY3Rpb24oIGNsYXNzZXMgKXtcbiAgICBjbGFzc2VzID0gY2xhc3Nlcy5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoYW5nZWQgPSBbXTtcbiAgICB2YXIgY2xhc3Nlc01hcCA9IHt9O1xuXG4gICAgLy8gZmlsbCBpbiBjbGFzc2VzIG1hcFxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGNscyA9IGNsYXNzZXNbaV07XG5cbiAgICAgIGNsYXNzZXNNYXBbIGNscyBdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBhbmQgdXBkYXRlIGVhY2ggZWxlXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgZWxlID0gc2VsZltqXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBlbGVDbGFzc2VzID0gX3AuY2xhc3NlcztcbiAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7XG5cbiAgICAgIC8vIGNoZWNrIGlmIGVsZSBoYXMgYWxsIG9mIHRoZSBwYXNzZWQgY2xhc3Nlc1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuICAgICAgICB2YXIgZWxlSGFzQ2xhc3MgPSBlbGVDbGFzc2VzWyBjbHMgXTtcblxuICAgICAgICBpZiggIWVsZUhhc0NsYXNzICl7XG4gICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgZWxlIGhhcyBjbGFzc2VzIG91dHNpZGUgb2YgdGhvc2UgcGFzc2VkXG4gICAgICBpZiggIWNoYW5nZWRFbGUgKXsgZm9yKCB2YXIgZWxlQ2xzIGluIGVsZUNsYXNzZXMgKXtcbiAgICAgICAgdmFyIGVsZUhhc0NsYXNzID0gZWxlQ2xhc3Nlc1sgZWxlQ2xzIF07XG4gICAgICAgIHZhciBzcGVjZENsYXNzID0gY2xhc3Nlc01hcFsgZWxlQ2xzIF07IC8vIGkuZS4gdGhpcyBjbGFzcyBpcyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uXG5cbiAgICAgICAgaWYoIGVsZUhhc0NsYXNzICYmICFzcGVjZENsYXNzICl7XG4gICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gfVxuXG4gICAgICBpZiggY2hhbmdlZEVsZSApe1xuICAgICAgICBfcC5jbGFzc2VzID0gdXRpbC5jb3B5KCBjbGFzc2VzTWFwICk7XG5cbiAgICAgICAgY2hhbmdlZC5wdXNoKCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcbiAgICBpZiggY2hhbmdlZC5sZW5ndGggPiAwICl7XG4gICAgICB0aGlzLnNwYXduKGNoYW5nZWQpXG4gICAgICAgIC51cGRhdGVTdHlsZSgpXG4gICAgICAgIC50cmlnZ2VyKCdjbGFzcycpXG4gICAgICA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgYWRkQ2xhc3M6IGZ1bmN0aW9uKCBjbGFzc2VzICl7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlQ2xhc3MoIGNsYXNzZXMsIHRydWUgKTtcbiAgfSxcblxuICBoYXNDbGFzczogZnVuY3Rpb24oIGNsYXNzTmFtZSApe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiAoIGVsZSAhPSBudWxsICYmIGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2NsYXNzTmFtZV0gKSA/IHRydWUgOiBmYWxzZTtcbiAgfSxcblxuICB0b2dnbGVDbGFzczogZnVuY3Rpb24oIGNsYXNzZXNTdHIsIHRvZ2dsZSApe1xuICAgIHZhciBjbGFzc2VzID0gY2xhc3Nlc1N0ci5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoYW5nZWQgPSBbXTsgLy8gZWxlcyB3aG8gaGFkIGNsYXNzZXMgY2hhbmdlZFxuXG4gICAgZm9yKCB2YXIgaSA9IDAsIGlsID0gc2VsZi5sZW5ndGg7IGkgPCBpbDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gc2VsZltpXTtcbiAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY2xhc3Nlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1tqXTtcbiAgICAgICAgdmFyIGVsZUNsYXNzZXMgPSBlbGUuX3ByaXZhdGUuY2xhc3NlcztcbiAgICAgICAgdmFyIGhhc0NsYXNzID0gZWxlQ2xhc3Nlc1tjbHNdO1xuICAgICAgICB2YXIgc2hvdWxkQWRkID0gdG9nZ2xlIHx8ICh0b2dnbGUgPT09IHVuZGVmaW5lZCAmJiAhaGFzQ2xhc3MpO1xuXG4gICAgICAgIGlmKCBzaG91bGRBZGQgKXtcbiAgICAgICAgICBlbGVDbGFzc2VzW2Nsc10gPSB0cnVlO1xuXG4gICAgICAgICAgaWYoICFoYXNDbGFzcyAmJiAhY2hhbmdlZEVsZSApe1xuICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGVsZSk7XG4gICAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gcmVtb3ZlXG4gICAgICAgICAgZWxlQ2xhc3Nlc1tjbHNdID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiggaGFzQ2xhc3MgJiYgIWNoYW5nZWRFbGUgKXtcbiAgICAgICAgICAgIGNoYW5nZWQucHVzaChlbGUpO1xuICAgICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0gLy8gZm9yIGogY2xhc3Nlc1xuICAgIH0gLy8gZm9yIGkgZWxlc1xuXG4gICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgaWYoIGNoYW5nZWQubGVuZ3RoID4gMCApe1xuICAgICAgdGhpcy5zcGF3bihjaGFuZ2VkKVxuICAgICAgICAudXBkYXRlU3R5bGUoKVxuICAgICAgICAudHJpZ2dlcignY2xhc3MnKVxuICAgICAgO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggY2xhc3NlcyApe1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKCBjbGFzc2VzLCBmYWxzZSApO1xuICB9LFxuXG4gIGZsYXNoQ2xhc3M6IGZ1bmN0aW9uKCBjbGFzc2VzLCBkdXJhdGlvbiApe1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmKCBkdXJhdGlvbiA9PSBudWxsICl7XG4gICAgICBkdXJhdGlvbiA9IDI1MDtcbiAgICB9IGVsc2UgaWYoIGR1cmF0aW9uID09PSAwICl7XG4gICAgICByZXR1cm4gc2VsZjsgLy8gbm90aGluZyB0byBkbyByZWFsbHlcbiAgICB9XG5cbiAgICBzZWxmLmFkZENsYXNzKCBjbGFzc2VzICk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcyggY2xhc3NlcyApO1xuICAgIH0sIGR1cmF0aW9uKTtcblxuICAgIHJldHVybiBzZWxmO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbn0se1wiLi4vdXRpbFwiOjk0fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgYWxsQXJlOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoc2VsZWN0b3IpLmxlbmd0aCA9PT0gdGhpcy5sZW5ndGg7XG4gIH0sXG5cbiAgaXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihzZWxlY3RvcikubGVuZ3RoID4gMDtcbiAgfSxcblxuICBzb21lOiBmdW5jdGlvbiggZm4sIHRoaXNBcmcgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKCB0aGlzW2ldLCBpLCB0aGlzICkgOiBmbi5hcHBseSggdGhpc0FyZywgWyB0aGlzW2ldLCBpLCB0aGlzIF0gKTtcblxuICAgICAgaWYoIHJldCApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgZXZlcnk6IGZ1bmN0aW9uKCBmbiwgdGhpc0FyZyApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4oIHRoaXNbaV0sIGksIHRoaXMgKSA6IGZuLmFwcGx5KCB0aGlzQXJnLCBbIHRoaXNbaV0sIGksIHRoaXMgXSApO1xuXG4gICAgICBpZiggIXJldCApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgc2FtZTogZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oIGNvbGxlY3Rpb24gKTtcblxuICAgIC8vIGNoZWFwIGV4dHJhIGNoZWNrXG4gICAgaWYoIHRoaXMubGVuZ3RoICE9PSBjb2xsZWN0aW9uLmxlbmd0aCApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmludGVyc2VjdCggY29sbGVjdGlvbiApLmxlbmd0aCA9PT0gdGhpcy5sZW5ndGg7XG4gIH0sXG5cbiAgYW55U2FtZTogZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oIGNvbGxlY3Rpb24gKTtcblxuICAgIHJldHVybiB0aGlzLmludGVyc2VjdCggY29sbGVjdGlvbiApLmxlbmd0aCA+IDA7XG4gIH0sXG5cbiAgYWxsQXJlTmVpZ2hib3JzOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbiggY29sbGVjdGlvbiApO1xuXG4gICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KCBjb2xsZWN0aW9uICkubGVuZ3RoID09PSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfVxufSk7XG5cbmVsZXNmbi5hbGxBcmVOZWlnaGJvdXJzID0gZWxlc2ZuLmFsbEFyZU5laWdoYm9ycztcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbn0se31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGVsZXNmbiA9ICh7XG4gIHBhcmVudDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBwYXJlbnQgPSBjeS5nZXRFbGVtZW50QnlJZCggZWxlLl9wcml2YXRlLmRhdGEucGFyZW50ICk7XG5cbiAgICAgIGlmKCBwYXJlbnQuc2l6ZSgpID4gMCApe1xuICAgICAgICBwYXJlbnRzLnB1c2goIHBhcmVudCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBwYXJlbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIHBhcmVudHM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBwYXJlbnRzID0gW107XG5cbiAgICB2YXIgZWxlcyA9IHRoaXMucGFyZW50KCk7XG4gICAgd2hpbGUoIGVsZXMubm9uZW1wdHkoKSApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICBwYXJlbnRzLnB1c2goIGVsZSApO1xuICAgICAgfVxuXG4gICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggcGFyZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBjb21tb25BbmNlc3RvcnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBhbmNlc3RvcnM7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIHBhcmVudHMgPSBlbGUucGFyZW50cygpO1xuXG4gICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMgfHwgcGFyZW50cztcblxuICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmludGVyc2VjdCggcGFyZW50cyApOyAvLyBjdXJyZW50IGxpc3QgbXVzdCBiZSBjb21tb24gd2l0aCBjdXJyZW50IGVsZSBwYXJlbnRzIHNldFxuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvcnMuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIG9ycGhhbnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlcihmdW5jdGlvbiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5wYXJlbnQoKS5lbXB0eSgpO1xuICAgIH0pLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBub25vcnBoYW5zOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUucGFyZW50KCkubm9uZW1wdHkoKTtcbiAgICB9KS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgY2hpbGRyZW46IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uY29uY2F0KCBlbGUuX3ByaXZhdGUuY2hpbGRyZW4gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggY2hpbGRyZW4sIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgc2libGluZ3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCkubm90KCB0aGlzICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIGlzUGFyZW50OiBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbi5sZW5ndGggIT09IDA7XG4gICAgfVxuICB9LFxuXG4gIGlzQ2hpbGQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEucGFyZW50ICE9PSB1bmRlZmluZWQgJiYgZWxlLnBhcmVudCgpLmxlbmd0aCAhPT0gMDtcbiAgICB9XG4gIH0sXG5cbiAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gYWRkKCBlbGVzICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgZWxlbWVudHMucHVzaCggZWxlICk7XG5cbiAgICAgICAgaWYoIGVsZS5jaGlsZHJlbigpLm5vbmVtcHR5KCkgKXtcbiAgICAgICAgICBhZGQoIGVsZS5jaGlsZHJlbigpICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhZGQoIHRoaXMuY2hpbGRyZW4oKSApO1xuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9XG59KTtcblxuLy8gYWxpYXNlc1xuZWxlc2ZuLmFuY2VzdG9ycyA9IGVsZXNmbi5wYXJlbnRzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxufSx7fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gX2RlcmVxXygnLi4vZGVmaW5lJyk7XG52YXIgZm4sIGVsZXNmbjtcblxuZm4gPSBlbGVzZm4gPSAoe1xuXG4gIGRhdGE6IGRlZmluZS5kYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAnaWQnOiB0cnVlLFxuICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgfSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcblxuICByZW1vdmVEYXRhOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBldmVudDogJ2RhdGEnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgJ2lkJzogdHJ1ZSxcbiAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAncGFyZW50JzogdHJ1ZVxuICAgIH0sXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG5cbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuXG4gIHJlbW92ZVNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcblxuICByc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICBhbGxvd0dldHRpbmc6IHRydWVcbiAgfSksXG5cbiAgcmVtb3ZlUnNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlXG4gIH0pLFxuXG4gIGlkOiBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIH1cbiAgfVxuXG59KTtcblxuLy8gYWxpYXNlc1xuZm4uYXR0ciA9IGZuLmRhdGE7XG5mbi5yZW1vdmVBdHRyID0gZm4ucmVtb3ZlRGF0YTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbn0se1wiLi4vZGVmaW5lXCI6NDF9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gX2RlcmVxXygnLi4vdXRpbCcpO1xuXG52YXIgZWxlc2ZuID0ge307XG5cbmZ1bmN0aW9uIGRlZmluZURlZ3JlZUZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCBpbmNsdWRlTG9vcHMgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiggaW5jbHVkZUxvb3BzID09PSB1bmRlZmluZWQgKXtcbiAgICAgIGluY2x1ZGVMb29wcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoIHNlbGYubGVuZ3RoID09PSAwICl7IHJldHVybjsgfVxuXG4gICAgaWYoIHNlbGYuaXNOb2RlKCkgJiYgIXNlbGYucmVtb3ZlZCgpICl7XG4gICAgICB2YXIgZGVncmVlID0gMDtcbiAgICAgIHZhciBub2RlID0gc2VsZlswXTtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tpXTtcblxuICAgICAgICBpZiggIWluY2x1ZGVMb29wcyAmJiBlZGdlLmlzTG9vcCgpICl7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBkZWdyZWUgKz0gY2FsbGJhY2soIG5vZGUsIGVkZ2UgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZ3JlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcbn1cblxudXRpbC5leHRlbmQoZWxlc2ZuLCB7XG4gIGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24obm9kZSwgZWRnZSl7XG4gICAgaWYoIGVkZ2Uuc291cmNlKCkuc2FtZSggZWRnZS50YXJnZXQoKSApICl7XG4gICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KSxcblxuICBpbmRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24obm9kZSwgZWRnZSl7XG4gICAgaWYoIGVkZ2UudGFyZ2V0KCkuc2FtZShub2RlKSApe1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSksXG5cbiAgb3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbihub2RlLCBlZGdlKXtcbiAgICBpZiggZWRnZS5zb3VyY2UoKS5zYW1lKG5vZGUpICl7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KVxufSk7XG5cbmZ1bmN0aW9uIGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKGRlZ3JlZUZuLCBjYWxsYmFjayl7XG4gIHJldHVybiBmdW5jdGlvbiggaW5jbHVkZUxvb3BzICl7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gbm9kZXNbaV07XG4gICAgICB2YXIgZGVncmVlID0gZWxlW2RlZ3JlZUZuXSggaW5jbHVkZUxvb3BzICk7XG4gICAgICBpZiggZGVncmVlICE9PSB1bmRlZmluZWQgJiYgKHJldCA9PT0gdW5kZWZpbmVkIHx8IGNhbGxiYWNrKGRlZ3JlZSwgcmV0KSkgKXtcbiAgICAgICAgcmV0ID0gZGVncmVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG59XG5cbnV0aWwuZXh0ZW5kKGVsZXNmbiwge1xuICBtaW5EZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1pbil7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG5cbiAgbWF4RGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtYXgpe1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pLFxuXG4gIG1pbkluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1pbil7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG5cbiAgbWF4SW5kZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdpbmRlZ3JlZScsIGZ1bmN0aW9uKGRlZ3JlZSwgbWF4KXtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9KSxcblxuICBtaW5PdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdvdXRkZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1pbil7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG5cbiAgbWF4T3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtYXgpe1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pXG59KTtcblxudXRpbC5leHRlbmQoZWxlc2ZuLCB7XG4gIHRvdGFsRGVncmVlOiBmdW5jdGlvbiggaW5jbHVkZUxvb3BzICl7XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB0b3RhbCArPSBub2Rlc1tpXS5kZWdyZWUoIGluY2x1ZGVMb29wcyApO1xuICAgIH1cblxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG59LHtcIi4uL3V0aWxcIjo5NH1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IF9kZXJlcV8oJy4uL2RlZmluZScpO1xudmFyIGlzID0gX2RlcmVxXygnLi4vaXMnKTtcbnZhciB1dGlsID0gX2RlcmVxXygnLi4vdXRpbCcpO1xudmFyIGZuLCBlbGVzZm47XG5cbmZuID0gZWxlc2ZuID0gKHtcblxuICBwb3NpdGlvbjogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAncG9zaXRpb24nLFxuICAgIGJpbmRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAncnRyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB2YWxpZEtleXM6IFsneCcsICd5J10sXG4gICAgb25TZXQ6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICB2YXIgdXBkYXRlZEVsZXMgPSBlbGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICB1cGRhdGVkRWxlcy5ydHJpZ2dlcigncG9zaXRpb24nKTtcbiAgICB9LFxuICAgIGNhblNldDogZnVuY3Rpb24oIGVsZSApe1xuICAgICAgcmV0dXJuICFlbGUubG9ja2VkKCkgJiYgIWVsZS5pc1BhcmVudCgpO1xuICAgIH1cbiAgfSksXG5cbiAgLy8gcG9zaXRpb24gYnV0IG5vIG5vdGlmaWNhdGlvbiB0byByZW5kZXJlclxuICBzaWxlbnRQb3NpdGlvbjogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAncG9zaXRpb24nLFxuICAgIGJpbmRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgdmFsaWRLZXlzOiBbJ3gnLCAneSddLFxuICAgIG9uU2V0OiBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgZWxlcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgIH0sXG4gICAgY2FuU2V0OiBmdW5jdGlvbiggZWxlICl7XG4gICAgICByZXR1cm4gIWVsZS5sb2NrZWQoKSAmJiAhZWxlLmlzUGFyZW50KCk7XG4gICAgfVxuICB9KSxcblxuICBwb3NpdGlvbnM6IGZ1bmN0aW9uKCBwb3MsIHNpbGVudCApe1xuICAgIGlmKCBpcy5wbGFpbk9iamVjdChwb3MpICl7XG4gICAgICB0aGlzLnBvc2l0aW9uKHBvcyk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLmZuKHBvcykgKXtcbiAgICAgIHZhciBmbiA9IHBvcztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgIHZhciBwb3MgPSBmbi5hcHBseShlbGUsIFtpLCBlbGVdKTtcblxuICAgICAgICBpZiggcG9zICYmICFlbGUubG9ja2VkKCkgJiYgIWVsZS5pc1BhcmVudCgpICl7XG4gICAgICAgICAgdmFyIGVsZVBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICBlbGVQb3MueCA9IHBvcy54O1xuICAgICAgICAgIGVsZVBvcy55ID0gcG9zLnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZWRFbGVzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgdmFyIHRvVHJpZ2dlciA9IHVwZGF0ZWRFbGVzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZEVsZXMgKSA6IHRoaXM7XG5cbiAgICAgIGlmKCBzaWxlbnQgKXtcbiAgICAgICAgdG9UcmlnZ2VyLnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b1RyaWdnZXIucnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgc2lsZW50UG9zaXRpb25zOiBmdW5jdGlvbiggcG9zICl7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb25zKCBwb3MsIHRydWUgKTtcbiAgfSxcblxuICAvLyBnZXQvc2V0IHRoZSByZW5kZXJlZCAoaS5lLiBvbiBzY3JlZW4pIHBvc2l0b24gb2YgdGhlIGVsZW1lbnRcbiAgcmVuZGVyZWRQb3NpdGlvbjogZnVuY3Rpb24oIGRpbSwgdmFsICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgcnBvcyA9IGlzLnBsYWluT2JqZWN0KCBkaW0gKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2V0dGluZyA9IHJwb3MgIT09IHVuZGVmaW5lZCB8fCAoIHZhbCAhPT0gdW5kZWZpbmVkICYmIGlzLnN0cmluZyhkaW0pICk7XG5cbiAgICBpZiggZWxlICYmIGVsZS5pc05vZGUoKSApeyAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICBpZiggc2V0dGluZyApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uW2RpbV0gPSAoIHZhbCAtIHBhbltkaW1dICkvem9vbTtcbiAgICAgICAgICB9IGVsc2UgaWYoIHJwb3MgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgeDogKCBycG9zLnggLSBwYW4ueCApIC96b29tLFxuICAgICAgICAgICAgICB5OiAoIHJwb3MueSAtIHBhbi55ICkgL3pvb21cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydHJpZ2dlcigncG9zaXRpb24nKTtcbiAgICAgIH0gZWxzZSB7IC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgcnBvcyA9IHtcbiAgICAgICAgICB4OiBwb3MueCAqIHpvb20gKyBwYW4ueCxcbiAgICAgICAgICB5OiBwb3MueSAqIHpvb20gKyBwYW4ueVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBkaW0gPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICByZXR1cm4gcnBvcztcbiAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICByZXR1cm4gcnBvc1sgZGltIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoICFzZXR0aW5nICl7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgLy8gZ2V0L3NldCB0aGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhcmVudFxuICByZWxhdGl2ZVBvc2l0aW9uOiBmdW5jdGlvbiggZGltLCB2YWwgKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHBwb3MgPSBpcy5wbGFpbk9iamVjdCggZGltICkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIHNldHRpbmcgPSBwcG9zICE9PSB1bmRlZmluZWQgfHwgKCB2YWwgIT09IHVuZGVmaW5lZCAmJiBpcy5zdHJpbmcoZGltKSApO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgaWYoIGVsZSAmJiBlbGUuaXNOb2RlKCkgKXsgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgaWYoIHNldHRpbmcgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgdmFyIHJlbGF0aXZlVG9QYXJlbnQgPSBoYXNQYXJlbnQ7XG5cbiAgICAgICAgICBpZiggaGFzUGFyZW50ICl7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9yaWdpbiA9IHJlbGF0aXZlVG9QYXJlbnQgPyBwYXJlbnQuX3ByaXZhdGUucG9zaXRpb24gOiB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uW2RpbV0gPSB2YWwgKyBvcmlnaW5bZGltXTtcbiAgICAgICAgICB9IGVsc2UgaWYoIHBwb3MgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgeDogcHBvcy54ICsgb3JpZ2luLngsXG4gICAgICAgICAgICAgIHk6IHBwb3MueSArIG9yaWdpbi55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICYmIHBhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICB2YXIgcmVsYXRpdmVUb1BhcmVudCA9IGhhc1BhcmVudDtcblxuICAgICAgICBpZiggaGFzUGFyZW50ICl7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IHJlbGF0aXZlVG9QYXJlbnQgPyBwYXJlbnQuX3ByaXZhdGUucG9zaXRpb24gOiB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICBwcG9zID0ge1xuICAgICAgICAgIHg6IHBvcy54IC0gb3JpZ2luLngsXG4gICAgICAgICAgeTogcG9zLnkgLSBvcmlnaW4ueVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBkaW0gPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICByZXR1cm4gcHBvcztcbiAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICByZXR1cm4gcHBvc1sgZGltIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoICFzZXR0aW5nICl7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcmVuZGVyZWRCb3VuZGluZ0JveDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94KCBvcHRpb25zICk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcblxuICAgIHZhciB4MSA9IGJiLngxICogem9vbSArIHBhbi54O1xuICAgIHZhciB4MiA9IGJiLngyICogem9vbSArIHBhbi54O1xuICAgIHZhciB5MSA9IGJiLnkxICogem9vbSArIHBhbi55O1xuICAgIHZhciB5MiA9IGJiLnkyICogem9vbSArIHBhbi55O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiB4MSxcbiAgICAgIHgyOiB4MixcbiAgICAgIHkxOiB5MSxcbiAgICAgIHkyOiB5MixcbiAgICAgIHc6IHgyIC0geDEsXG4gICAgICBoOiB5MiAtIHkxXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGVDb21wb3VuZEJvdW5kczogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkgKXsgcmV0dXJuIGN5LmNvbGxlY3Rpb24oKTsgfSAvLyBzYXZlIGN5Y2xlcyBmb3Igbm9uIGNvbXBvdW5kIGdyYXBocyBvciB3aGVuIHN0eWxlIGRpc2FibGVkXG5cbiAgICB2YXIgdXBkYXRlZCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlKCBwYXJlbnQgKXtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbigpO1xuICAgICAgdmFyIHN0eWxlID0gcGFyZW50Ll9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIGluY2x1ZGVMYWJlbHMgPSBzdHlsZVsnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnXS52YWx1ZSA9PT0gJ2luY2x1ZGUnO1xuICAgICAgdmFyIGJiID0gY2hpbGRyZW4uYm91bmRpbmdCb3goeyBpbmNsdWRlTGFiZWxzOiBpbmNsdWRlTGFiZWxzLCBpbmNsdWRlRWRnZXM6IHRydWUgfSk7XG4gICAgICB2YXIgcGFkZGluZyA9IHtcbiAgICAgICAgdG9wOiBzdHlsZVsncGFkZGluZy10b3AnXS5wZlZhbHVlLFxuICAgICAgICBib3R0b206IHN0eWxlWydwYWRkaW5nLWJvdHRvbSddLnBmVmFsdWUsXG4gICAgICAgIGxlZnQ6IHN0eWxlWydwYWRkaW5nLWxlZnQnXS5wZlZhbHVlLFxuICAgICAgICByaWdodDogc3R5bGVbJ3BhZGRpbmctcmlnaHQnXS5wZlZhbHVlXG4gICAgICB9O1xuICAgICAgdmFyIHBvcyA9IHBhcmVudC5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgIHZhciBkaWRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgaWYoIHN0eWxlWyd3aWR0aCddLnZhbHVlID09PSAnYXV0bycgKXtcbiAgICAgICAgcGFyZW50Ll9wcml2YXRlLmF1dG9XaWR0aCA9IGJiLnc7XG4gICAgICAgIHBvcy54ID0gKGJiLngxICsgYmIueDIgLSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0KS8yO1xuICAgICAgICBkaWRVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiggc3R5bGVbJ2hlaWdodCddLnZhbHVlID09PSAnYXV0bycgKXtcbiAgICAgICAgcGFyZW50Ll9wcml2YXRlLmF1dG9IZWlnaHQgPSBiYi5oO1xuICAgICAgICBwb3MueSA9IChiYi55MSArIGJiLnkyIC0gcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbSkvMjtcbiAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIGRpZFVwZGF0ZSApe1xuICAgICAgICB1cGRhdGVkLnB1c2goIHBhcmVudCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdvIHVwLCBsZXZlbCBieSBsZXZlbFxuICAgIHZhciBlbGVzID0gdGhpcy5wYXJlbnQoKTtcbiAgICB3aGlsZSggZWxlcy5ub25lbXB0eSgpICl7XG5cbiAgICAgIC8vIHVwZGF0ZSBlYWNoIHBhcmVudCBub2RlIGluIHRoaXMgbGV2ZWxcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICB1cGRhdGUoIGVsZSApO1xuICAgICAgfVxuXG4gICAgICAvLyBuZXh0IGxldmVsXG4gICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gY2hhbmdlZFxuICAgIHJldHVybiB0aGlzLnNwYXduKCB1cGRhdGVkICk7XG4gIH0sXG5cbiAgLy8gZ2V0IHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGVsZW1lbnRzIChpbiByYXcgbW9kZWwgcG9zaXRpb24pXG4gIGJvdW5kaW5nQm94OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgY3kgPSBlbGVzLl9wcml2YXRlLmN5O1xuICAgIHZhciBjeV9wID0gY3kuX3ByaXZhdGU7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5X3Auc3R5bGVFbmFibGVkO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdXRpbC5zdGF0aWNFbXB0eU9iamVjdCgpO1xuXG4gICAgdmFyIGluY2x1ZGVOb2RlcyA9IG9wdGlvbnMuaW5jbHVkZU5vZGVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5pbmNsdWRlTm9kZXM7XG4gICAgdmFyIGluY2x1ZGVFZGdlcyA9IG9wdGlvbnMuaW5jbHVkZUVkZ2VzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5pbmNsdWRlRWRnZXM7XG4gICAgdmFyIGluY2x1ZGVMYWJlbHMgPSBvcHRpb25zLmluY2x1ZGVMYWJlbHMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmluY2x1ZGVMYWJlbHM7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBwcm9qZWN0aW9ucyBldGNcbiAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICBjeV9wLnJlbmRlcmVyLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSggdGhpcyApO1xuICAgIH1cblxuICAgIHZhciB4MSA9IEluZmluaXR5O1xuICAgIHZhciB4MiA9IC1JbmZpbml0eTtcbiAgICB2YXIgeTEgPSBJbmZpbml0eTtcbiAgICB2YXIgeTIgPSAtSW5maW5pdHk7XG5cbiAgICAvLyBmaW5kIGJvdW5kcyBvZiBlbGVtZW50c1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgICAgIHZhciBkaXNwbGF5ID0gc3R5bGVFbmFibGVkID8gX3Auc3R5bGVbJ2Rpc3BsYXknXS52YWx1ZSA6ICdlbGVtZW50JztcbiAgICAgIHZhciBpc05vZGUgPSBfcC5ncm91cCA9PT0gJ25vZGVzJztcbiAgICAgIHZhciBleDEsIGV4MiwgZXkxLCBleTIsIHgsIHk7XG4gICAgICB2YXIgaW5jbHVkZWRFbGUgPSBmYWxzZTtcblxuICAgICAgaWYoIGRpc3BsYXkgPT09ICdub25lJyApeyBjb250aW51ZTsgfSAvLyB0aGVuIGVsZSBkb2Vzbid0IHRha2UgdXAgc3BhY2VcblxuICAgICAgaWYoIGlzTm9kZSAmJiBpbmNsdWRlTm9kZXMgKXtcbiAgICAgICAgaW5jbHVkZWRFbGUgPSB0cnVlO1xuXG4gICAgICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcbiAgICAgICAgeCA9IHBvcy54O1xuICAgICAgICB5ID0gcG9zLnk7XG4gICAgICAgIHZhciB3ID0gZWxlLm91dGVyV2lkdGgoKTtcbiAgICAgICAgdmFyIGhhbGZXID0gdy8yO1xuICAgICAgICB2YXIgaCA9IGVsZS5vdXRlckhlaWdodCgpO1xuICAgICAgICB2YXIgaGFsZkggPSBoLzI7XG5cbiAgICAgICAgLy8gaGFuZGxlIG5vZGUgZGltZW5zaW9uc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgZXgxID0geCAtIGhhbGZXO1xuICAgICAgICBleDIgPSB4ICsgaGFsZlc7XG4gICAgICAgIGV5MSA9IHkgLSBoYWxmSDtcbiAgICAgICAgZXkyID0geSArIGhhbGZIO1xuXG4gICAgICAgIHgxID0gZXgxIDwgeDEgPyBleDEgOiB4MTtcbiAgICAgICAgeDIgPSBleDIgPiB4MiA/IGV4MiA6IHgyO1xuICAgICAgICB5MSA9IGV5MSA8IHkxID8gZXkxIDogeTE7XG4gICAgICAgIHkyID0gZXkyID4geTIgPyBleTIgOiB5MjtcblxuICAgICAgfSBlbHNlIGlmKCBlbGUuaXNFZGdlKCkgJiYgaW5jbHVkZUVkZ2VzICl7XG4gICAgICAgIGluY2x1ZGVkRWxlID0gdHJ1ZTtcblxuICAgICAgICB2YXIgbjEgPSBfcC5zb3VyY2U7XG4gICAgICAgIHZhciBuMV9wID0gbjEuX3ByaXZhdGU7XG4gICAgICAgIHZhciBuMXBvcyA9IG4xX3AucG9zaXRpb247XG5cbiAgICAgICAgdmFyIG4yID0gX3AudGFyZ2V0O1xuICAgICAgICB2YXIgbjJfcCA9IG4yLl9wcml2YXRlO1xuICAgICAgICB2YXIgbjJwb3MgPSBuMl9wLnBvc2l0aW9uO1xuXG5cbiAgICAgICAgLy8gaGFuZGxlIGVkZ2UgZGltZW5zaW9ucyAocm91Z2ggYm94IGVzdGltYXRlKVxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZSB8fCB7fTtcbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICB2YXIgd0hhbGYgPSAwO1xuXG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICB3ID0gc3R5bGVbJ3dpZHRoJ10ucGZWYWx1ZTtcbiAgICAgICAgICB3SGFsZiA9IHcvMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4MSA9IG4xcG9zLng7XG4gICAgICAgIGV4MiA9IG4ycG9zLng7XG4gICAgICAgIGV5MSA9IG4xcG9zLnk7XG4gICAgICAgIGV5MiA9IG4ycG9zLnk7XG5cbiAgICAgICAgaWYoIGV4MSA+IGV4MiApe1xuICAgICAgICAgIHZhciB0ZW1wID0gZXgxO1xuICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICBleDIgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGV5MSA+IGV5MiApe1xuICAgICAgICAgIHZhciB0ZW1wID0gZXkxO1xuICAgICAgICAgIGV5MSA9IGV5MjtcbiAgICAgICAgICBleTIgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGFrZSBpbnRvIGFjY291bnQgZWRnZSB3aWR0aFxuICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICBleTIgKz0gd0hhbGY7XG5cbiAgICAgICAgeDEgPSBleDEgPCB4MSA/IGV4MSA6IHgxO1xuICAgICAgICB4MiA9IGV4MiA+IHgyID8gZXgyIDogeDI7XG4gICAgICAgIHkxID0gZXkxIDwgeTEgPyBleTEgOiB5MTtcbiAgICAgICAgeTIgPSBleTIgPiB5MiA/IGV5MiA6IHkyO1xuXG4gICAgICAgIC8vIGhhbmRsZSBwb2ludHMgYWxvbmcgZWRnZSAoc2FuaXR5IGNoZWNrKVxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICAgICAgdmFyIHB0cyA9IHJzdHlsZS5iZXppZXJQdHMgfHwgcnN0eWxlLmxpbmVQdHMgfHwgW107XG5cbiAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgdmFyIHB0ID0gcHRzW2pdO1xuXG4gICAgICAgICAgICBleDEgPSBwdC54IC0gd0hhbGY7XG4gICAgICAgICAgICBleDIgPSBwdC54ICsgd0hhbGY7XG4gICAgICAgICAgICBleTEgPSBwdC55IC0gd0hhbGY7XG4gICAgICAgICAgICBleTIgPSBwdC55ICsgd0hhbGY7XG5cbiAgICAgICAgICAgIHgxID0gZXgxIDwgeDEgPyBleDEgOiB4MTtcbiAgICAgICAgICAgIHgyID0gZXgyID4geDIgPyBleDIgOiB4MjtcbiAgICAgICAgICAgIHkxID0gZXkxIDwgeTEgPyBleTEgOiB5MTtcbiAgICAgICAgICAgIHkyID0gZXkyID4geTIgPyBleTIgOiB5MjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmVjaXNlIGhheXN0YWNrcyAoc2FuaXR5IGNoZWNrKVxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgJiYgc3R5bGVbJ2N1cnZlLXN0eWxlJ10uc3RyVmFsdWUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgICAgICB2YXIgaHB0cyA9IHJzdHlsZS5oYXlzdGFja1B0cztcblxuICAgICAgICAgIGV4MSA9IGhwdHNbMF0ueDtcbiAgICAgICAgICBleTEgPSBocHRzWzBdLnk7XG4gICAgICAgICAgZXgyID0gaHB0c1sxXS54O1xuICAgICAgICAgIGV5MiA9IGhwdHNbMV0ueTtcblxuICAgICAgICAgIGlmKCBleDEgPiBleDIgKXtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gZXgxO1xuICAgICAgICAgICAgZXgxID0gZXgyO1xuICAgICAgICAgICAgZXgyID0gdGVtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggZXkxID4gZXkyICl7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGV5MTtcbiAgICAgICAgICAgIGV5MSA9IGV5MjtcbiAgICAgICAgICAgIGV5MiA9IHRlbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEgPSBleDEgPCB4MSA/IGV4MSA6IHgxO1xuICAgICAgICAgIHgyID0gZXgyID4geDIgPyBleDIgOiB4MjtcbiAgICAgICAgICB5MSA9IGV5MSA8IHkxID8gZXkxIDogeTE7XG4gICAgICAgICAgeTIgPSBleTIgPiB5MiA/IGV5MiA6IHkyO1xuICAgICAgICB9XG5cbiAgICAgIH0gLy8gZWRnZXNcblxuXG4gICAgICAvLyBoYW5kbGUgbGFiZWwgZGltZW5zaW9uc1xuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuXG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIHN0eWxlID0gX3Auc3R5bGU7XG4gICAgICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgICAgIHZhciBsYWJlbCA9IHN0eWxlWydsYWJlbCddLnN0clZhbHVlO1xuICAgICAgICB2YXIgZm9udFNpemUgPSBzdHlsZVsnZm9udC1zaXplJ107XG4gICAgICAgIHZhciBoYWxpZ24gPSBzdHlsZVsndGV4dC1oYWxpZ24nXTtcbiAgICAgICAgdmFyIHZhbGlnbiA9IHN0eWxlWyd0ZXh0LXZhbGlnbiddO1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJzdHlsZS5sYWJlbFdpZHRoO1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSByc3R5bGUubGFiZWxIZWlnaHQ7XG4gICAgICAgIHZhciBsYWJlbFggPSByc3R5bGUubGFiZWxYO1xuICAgICAgICB2YXIgbGFiZWxZID0gcnN0eWxlLmxhYmVsWTtcbiAgICAgICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICAgICAgdmFyIGF1dG9yb3RhdGUgPSBzdHlsZVsnZWRnZS10ZXh0LXJvdGF0aW9uJ10uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJztcblxuICAgICAgICBpZiggaW5jbHVkZUxhYmVscyAmJiBsYWJlbCAmJiBmb250U2l6ZSAmJiBsYWJlbEhlaWdodCAhPSBudWxsICYmIGxhYmVsV2lkdGggIT0gbnVsbCAmJiBsYWJlbFggIT0gbnVsbCAmJiBsYWJlbFkgIT0gbnVsbCAmJiBoYWxpZ24gJiYgdmFsaWduICl7XG4gICAgICAgICAgdmFyIGxoID0gbGFiZWxIZWlnaHQ7XG4gICAgICAgICAgdmFyIGx3ID0gbGFiZWxXaWR0aDtcbiAgICAgICAgICB2YXIgbHgxLCBseDIsIGx5MSwgbHkyO1xuXG4gICAgICAgICAgaWYoIGlzRWRnZSApe1xuICAgICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHcvMjtcbiAgICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3LzI7XG4gICAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaC8yO1xuICAgICAgICAgICAgbHkyID0gbGFiZWxZICsgbGgvMjtcblxuICAgICAgICAgICAgaWYoIGF1dG9yb3RhdGUgKXtcbiAgICAgICAgICAgICAgdmFyIHRoZXRhID0gX3AucnNjcmF0Y2gubGFiZWxBbmdsZTtcbiAgICAgICAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKCB0aGV0YSApO1xuICAgICAgICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgICAgICAgICAgICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uKCB4LCB5ICl7XG4gICAgICAgICAgICAgICAgeCA9IHggLSBsYWJlbFg7XG4gICAgICAgICAgICAgICAgeSA9IHkgLSBsYWJlbFk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgeDogeCpjb3MgLSB5KnNpbiArIGxhYmVsWCxcbiAgICAgICAgICAgICAgICAgIHk6IHgqc2luICsgeSpjb3MgKyBsYWJlbFlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHZhciBweDF5MSA9IHJvdGF0ZSggbHgxLCBseTEgKTtcbiAgICAgICAgICAgICAgdmFyIHB4MXkyID0gcm90YXRlKCBseDEsIGx5MiApO1xuICAgICAgICAgICAgICB2YXIgcHgyeTEgPSByb3RhdGUoIGx4MiwgbHkxICk7XG4gICAgICAgICAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZSggbHgyLCBseTIgKTtcblxuICAgICAgICAgICAgICBseDEgPSBNYXRoLm1pbiggcHgxeTEueCwgcHgxeTIueCwgcHgyeTEueCwgcHgyeTIueCApO1xuICAgICAgICAgICAgICBseDIgPSBNYXRoLm1heCggcHgxeTEueCwgcHgxeTIueCwgcHgyeTEueCwgcHgyeTIueCApO1xuICAgICAgICAgICAgICBseTEgPSBNYXRoLm1pbiggcHgxeTEueSwgcHgxeTIueSwgcHgyeTEueSwgcHgyeTIueSApO1xuICAgICAgICAgICAgICBseTIgPSBNYXRoLm1heCggcHgxeTEueSwgcHgxeTIueSwgcHgyeTEueSwgcHgyeTIueSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2goIGhhbGlnbi52YWx1ZSApe1xuICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBseDEgPSBsYWJlbFggLSBsdztcbiAgICAgICAgICAgICAgICBseDIgPSBsYWJlbFg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICBseDEgPSBsYWJlbFggLSBsdy8yO1xuICAgICAgICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3LzI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGx4MSA9IGxhYmVsWDtcbiAgICAgICAgICAgICAgICBseDIgPSBsYWJlbFggKyBsdztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoKCB2YWxpZ24udmFsdWUgKXtcbiAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaDtcbiAgICAgICAgICAgICAgICBseTIgPSBsYWJlbFk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaC8yO1xuICAgICAgICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoLzI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBseTEgPSBsYWJlbFk7XG4gICAgICAgICAgICAgICAgbHkyID0gbGFiZWxZICsgbGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEgPSBseDEgPCB4MSA/IGx4MSA6IHgxO1xuICAgICAgICAgIHgyID0gbHgyID4geDIgPyBseDIgOiB4MjtcbiAgICAgICAgICB5MSA9IGx5MSA8IHkxID8gbHkxIDogeTE7XG4gICAgICAgICAgeTIgPSBseTIgPiB5MiA/IGx5MiA6IHkyO1xuICAgICAgICB9XG4gICAgICB9IC8vIHN0eWxlIGVuYWJsZWQgZm9yIGxhYmVsc1xuICAgIH0gLy8gZm9yXG5cbiAgICB2YXIgbm9uaW5mID0gZnVuY3Rpb24oeCl7XG4gICAgICBpZiggeCA9PT0gSW5maW5pdHkgfHwgeCA9PT0gLUluZmluaXR5ICl7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuXG4gICAgeDEgPSBub25pbmYoeDEpO1xuICAgIHgyID0gbm9uaW5mKHgyKTtcbiAgICB5MSA9IG5vbmluZih5MSk7XG4gICAgeTIgPSBub25pbmYoeTIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiB4MSxcbiAgICAgIHgyOiB4MixcbiAgICAgIHkxOiB5MSxcbiAgICAgIHkyOiB5MixcbiAgICAgIHc6IHgyIC0geDEsXG4gICAgICBoOiB5MiAtIHkxXG4gICAgfTtcbiAgfVxufSk7XG5cbnZhciBkZWZpbmVEaW1GbnMgPSBmdW5jdGlvbiggb3B0cyApe1xuICBvcHRzLnVwcGVyY2FzZU5hbWUgPSB1dGlsLmNhcGl0YWxpemUoIG9wdHMubmFtZSApO1xuICBvcHRzLmF1dG9OYW1lID0gJ2F1dG8nICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLmxhYmVsTmFtZSA9ICdsYWJlbCcgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMub3V0ZXJOYW1lID0gJ291dGVyJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy51cHBlcmNhc2VPdXRlck5hbWUgPSB1dGlsLmNhcGl0YWxpemUoIG9wdHMub3V0ZXJOYW1lICk7XG5cbiAgZm5bIG9wdHMubmFtZSBdID0gZnVuY3Rpb24gZGltSW1wbCgpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICB2YXIgZCA9IF9wLnN0eWxlWyBvcHRzLm5hbWUgXTtcblxuICAgICAgICBzd2l0Y2goIGQuc3RyVmFsdWUgKXtcbiAgICAgICAgICBjYXNlICdhdXRvJzpcbiAgICAgICAgICAgIHJldHVybiBfcFsgb3B0cy5hdXRvTmFtZSBdIHx8IDA7XG4gICAgICAgICAgY2FzZSAnbGFiZWwnOlxuICAgICAgICAgICAgcmV0dXJuIF9wLnJzdHlsZVsgb3B0cy5sYWJlbE5hbWUgXSB8fCAwO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZC5wZlZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZm5bICdvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWUgXSA9IGZ1bmN0aW9uIG91dGVyRGltSW1wbCgpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgICAgICAgdmFyIGRpbSA9IGVsZVsgb3B0cy5uYW1lIF0oKTtcbiAgICAgICAgdmFyIGJvcmRlciA9IHN0eWxlWydib3JkZXItd2lkdGgnXS5wZlZhbHVlO1xuICAgICAgICB2YXIgcGFkZGluZyA9IHN0eWxlWyBvcHRzLnBhZGRpbmdzWzBdIF0ucGZWYWx1ZSArIHN0eWxlWyBvcHRzLnBhZGRpbmdzWzFdIF0ucGZWYWx1ZTtcblxuICAgICAgICByZXR1cm4gZGltICsgYm9yZGVyICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmblsgJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlTmFtZSBdID0gZnVuY3Rpb24gcmVuZGVyZWREaW1JbXBsKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICB2YXIgZCA9IGVsZVsgb3B0cy5uYW1lIF0oKTtcbiAgICAgIHJldHVybiBkICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG5cbiAgZm5bICdyZW5kZXJlZCcgKyBvcHRzLnVwcGVyY2FzZU91dGVyTmFtZSBdID0gZnVuY3Rpb24gcmVuZGVyZWRPdXRlckRpbUltcGwoKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBvZCA9IGVsZVsgb3B0cy5vdXRlck5hbWUgXSgpO1xuICAgICAgcmV0dXJuIG9kICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG59O1xuXG5kZWZpbmVEaW1GbnMoe1xuICBuYW1lOiAnd2lkdGgnLFxuICBwYWRkaW5nczogWydwYWRkaW5nLWxlZnQnLCAncGFkZGluZy1yaWdodCddXG59KTtcblxuZGVmaW5lRGltRm5zKHtcbiAgbmFtZTogJ2hlaWdodCcsXG4gIHBhZGRpbmdzOiBbJ3BhZGRpbmctdG9wJywgJ3BhZGRpbmctYm90dG9tJ11cbn0pO1xuXG4vLyBhbGlhc2VzXG5mbi5tb2RlbFBvc2l0aW9uID0gZm4ucG9pbnQgPSBmbi5wb3NpdGlvbjtcbmZuLm1vZGVsUG9zaXRpb25zID0gZm4ucG9pbnRzID0gZm4ucG9zaXRpb25zO1xuZm4ucmVuZGVyZWRQb2ludCA9IGZuLnJlbmRlcmVkUG9zaXRpb247XG5mbi5yZWxhdGl2ZVBvaW50ID0gZm4ucmVsYXRpdmVQb3NpdGlvbjtcbmZuLmJvdW5kaW5nYm94ID0gZm4uYm91bmRpbmdCb3g7XG5mbi5yZW5kZXJlZEJvdW5kaW5nYm94ID0gZm4ucmVuZGVyZWRCb3VuZGluZ0JveDtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbn0se1wiLi4vZGVmaW5lXCI6NDEsXCIuLi9pc1wiOjc3LFwiLi4vdXRpbFwiOjk0fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uL3V0aWwnKTtcbnZhciBpcyA9IF9kZXJlcV8oJy4uL2lzJyk7XG5cbi8vIHJlcHJlc2VudHMgYSBub2RlIG9yIGFuIGVkZ2VcbnZhciBFbGVtZW50ID0gZnVuY3Rpb24oY3ksIHBhcmFtcywgcmVzdG9yZSl7XG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBFbGVtZW50KSApe1xuICAgIHJldHVybiBuZXcgRWxlbWVudChjeSwgcGFyYW1zLCByZXN0b3JlKTtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVzdG9yZSA9IChyZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSA/IHRydWUgOiBmYWxzZSk7XG5cbiAgaWYoIGN5ID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSB1bmRlZmluZWQgfHwgIWlzLmNvcmUoY3kpICl7XG4gICAgdXRpbC5lcnJvcignQW4gZWxlbWVudCBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZSBhbmQgcGFyYW1ldGVycyBzZXQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZ3JvdXAgPSBwYXJhbXMuZ3JvdXA7XG5cbiAgLy8gdHJ5IHRvIGF1dG9tYXRpY2FsbHkgaW5mZXIgdGhlIGdyb3VwIGlmIHVuc3BlY2lmaWVkXG4gIGlmKCBncm91cCA9PSBudWxsICl7XG4gICAgaWYoIHBhcmFtcy5kYXRhLnNvdXJjZSAhPSBudWxsICYmIHBhcmFtcy5kYXRhLnRhcmdldCAhPSBudWxsICl7XG4gICAgICBncm91cCA9ICdlZGdlcyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwID0gJ25vZGVzJztcbiAgICB9XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBncm91cFxuICBpZiggZ3JvdXAgIT09ICdub2RlcycgJiYgZ3JvdXAgIT09ICdlZGdlcycgKXtcbiAgICB1dGlsLmVycm9yKCdBbiBlbGVtZW50IG11c3QgYmUgb2YgdHlwZSBgbm9kZXNgIG9yIGBlZGdlc2A7IHlvdSBzcGVjaWZpZWQgYCcgKyBncm91cCArICdgJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gbWFrZSB0aGUgZWxlbWVudCBhcnJheS1saWtlLCBqdXN0IGxpa2UgYSBjb2xsZWN0aW9uXG4gIHRoaXMubGVuZ3RoID0gMTtcbiAgdGhpc1swXSA9IHRoaXM7XG5cbiAgLy8gTk9URTogd2hlbiBzb21ldGhpbmcgaXMgYWRkZWQgaGVyZSwgYWRkIGFsc28gdG8gZWxlLmpzb24oKVxuICB0aGlzLl9wcml2YXRlID0ge1xuICAgIGN5OiBjeSxcbiAgICBzaW5nbGU6IHRydWUsIC8vIGluZGljYXRlcyB0aGlzIGlzIGFuIGVsZW1lbnRcbiAgICBkYXRhOiBwYXJhbXMuZGF0YSB8fCB7fSwgLy8gZGF0YSBvYmplY3RcbiAgICBwb3NpdGlvbjogcGFyYW1zLnBvc2l0aW9uIHx8IHt9LCAvLyAoeCwgeSkgcG9zaXRpb24gcGFpclxuICAgIGF1dG9XaWR0aDogdW5kZWZpbmVkLCAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIG5vZGVzIGNhbGN1bGF0ZWQgYnkgdGhlIHJlbmRlcmVyIHdoZW4gc2V0IHRvIHNwZWNpYWwgJ2F1dG8nIHZhbHVlXG4gICAgYXV0b0hlaWdodDogdW5kZWZpbmVkLFxuICAgIGxpc3RlbmVyczogW10sIC8vIGFycmF5IG9mIGJvdW5kIGxpc3RlbmVyc1xuICAgIGdyb3VwOiBncm91cCwgLy8gc3RyaW5nOyAnbm9kZXMnIG9yICdlZGdlcydcbiAgICBzdHlsZToge30sIC8vIHByb3BlcnRpZXMgYXMgc2V0IGJ5IHRoZSBzdHlsZVxuICAgIHJzdHlsZToge30sIC8vIHByb3BlcnRpZXMgZm9yIHN0eWxlIHNlbnQgZnJvbSB0aGUgcmVuZGVyZXIgdG8gdGhlIGNvcmVcbiAgICBzdHlsZUN4dHM6IFtdLCAvLyBhcHBsaWVkIHN0eWxlIGNvbnRleHRzIGZyb20gdGhlIHN0eWxlclxuICAgIHJlbW92ZWQ6IHRydWUsIC8vIHdoZXRoZXIgaXQncyBpbnNpZGUgdGhlIHZpczsgdHJ1ZSBpZiByZW1vdmVkIChzZXQgdHJ1ZSBoZXJlIHNpbmNlIHdlIGNhbGwgcmVzdG9yZSlcbiAgICBzZWxlY3RlZDogcGFyYW1zLnNlbGVjdGVkID8gdHJ1ZSA6IGZhbHNlLCAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0ZWRcbiAgICBzZWxlY3RhYmxlOiBwYXJhbXMuc2VsZWN0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICggcGFyYW1zLnNlbGVjdGFibGUgPyB0cnVlIDogZmFsc2UgKSwgLy8gd2hldGhlciBpdCdzIHNlbGVjdGFibGVcbiAgICBsb2NrZWQ6IHBhcmFtcy5sb2NrZWQgPyB0cnVlIDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgbG9ja2VkIChjYW5ub3QgYmUgbW92ZWQpXG4gICAgZ3JhYmJlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZ3JhYmJlZCBieSB0aGUgbW91c2U7IHJlbmRlcmVyIHNldHMgdGhpcyBwcml2YXRlbHlcbiAgICBncmFiYmFibGU6IHBhcmFtcy5ncmFiYmFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAoIHBhcmFtcy5ncmFiYmFibGUgPyB0cnVlIDogZmFsc2UgKSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBjYW4gYmUgZ3JhYmJlZFxuICAgIGFjdGl2ZTogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYWN0aXZlIGZyb20gdXNlciBpbnRlcmFjdGlvblxuICAgIGNsYXNzZXM6IHt9LCAvLyBtYXAgKCBjbGFzc05hbWUgPT4gdHJ1ZSApXG4gICAgYW5pbWF0aW9uOiB7IC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgY3VycmVudDogW10sXG4gICAgICBxdWV1ZTogW11cbiAgICB9LFxuICAgIHJzY3JhdGNoOiB7fSwgLy8gb2JqZWN0IGluIHdoaWNoIHRoZSByZW5kZXJlciBjYW4gc3RvcmUgaW5mb3JtYXRpb25cbiAgICBzY3JhdGNoOiBwYXJhbXMuc2NyYXRjaCB8fCB7fSwgLy8gc2NyYXRjaCBvYmplY3RzXG4gICAgZWRnZXM6IFtdLCAvLyBhcnJheSBvZiBjb25uZWN0ZWQgZWRnZXNcbiAgICBjaGlsZHJlbjogW10gLy8gYXJyYXkgb2YgY2hpbGRyZW5cbiAgfTtcblxuICAvLyByZW5kZXJlZFBvc2l0aW9uIG92ZXJyaWRlcyBpZiBzcGVjaWZpZWRcbiAgaWYoIHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uICl7XG4gICAgdmFyIHJwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICB0aGlzLl9wcml2YXRlLnBvc2l0aW9uID0ge1xuICAgICAgeDogKHJwb3MueCAtIHBhbi54KS96b29tLFxuICAgICAgeTogKHJwb3MueSAtIHBhbi55KS96b29tXG4gICAgfTtcbiAgfVxuXG4gIGlmKCBpcy5zdHJpbmcocGFyYW1zLmNsYXNzZXMpICl7XG4gICAgdmFyIGNsYXNzZXMgPSBwYXJhbXMuY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICAgIGZvciggdmFyIGkgPSAwLCBsID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuICAgICAgaWYoICFjbHMgfHwgY2xzID09PSAnJyApeyBjb250aW51ZTsgfVxuXG4gICAgICBzZWxmLl9wcml2YXRlLmNsYXNzZXNbY2xzXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYoIHBhcmFtcy5zdHlsZSB8fCBwYXJhbXMuY3NzICl7XG4gICAgY3kuc3R5bGUoKS5hcHBseUJ5cGFzcyggdGhpcywgcGFyYW1zLnN0eWxlIHx8IHBhcmFtcy5jc3MgKTtcbiAgfVxuXG4gIGlmKCByZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSApe1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcblxufSx7XCIuLi9pc1wiOjc3LFwiLi4vdXRpbFwiOjk0fV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gX2RlcmVxXygnLi4vZGVmaW5lJyk7XG5cbnZhciBlbGVzZm4gPSAoe1xuICBvbjogZGVmaW5lLm9uKCksIC8vIC5vbiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBkYXRhXSwgaGFuZGxlcilcbiAgb25lOiBkZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICBvbmNlOiBkZWZpbmUub24oeyB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiB0cnVlIH0pLFxuICBvZmY6IGRlZmluZS5vZmYoKSwgLy8gLm9mZiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBoYW5kbGVyXSApXG4gIHRyaWdnZXI6IGRlZmluZS50cmlnZ2VyKCksIC8vIC50cmlnZ2VyKCBldmVudHMgWywgZXh0cmFQYXJhbXNdIClcblxuICBydHJpZ2dlcjogZnVuY3Rpb24oZXZlbnQsIGV4dHJhUGFyYW1zKXsgLy8gZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgaWYoIHRoaXMubGVuZ3RoID09PSAwICl7IHJldHVybjsgfSAvLyBlbXB0eSBjb2xsZWN0aW9ucyBkb24ndCBuZWVkIHRvIG5vdGlmeSBhbnl0aGluZ1xuXG4gICAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gICAgdGhpcy5jeSgpLm5vdGlmeSh7XG4gICAgICB0eXBlOiBldmVudCxcbiAgICAgIGNvbGxlY3Rpb246IHRoaXNcbiAgICB9KTtcblxuICAgIHRoaXMudHJpZ2dlcihldmVudCwgZXh0cmFQYXJhbXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuLy8gYWxpYXNlczpcbmRlZmluZS5ldmVudEFsaWFzZXNPbiggZWxlc2ZuICk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG59LHtcIi4uL2RlZmluZVwiOjQxfV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi9pcycpO1xudmFyIFNlbGVjdG9yID0gX2RlcmVxXygnLi4vc2VsZWN0b3InKTtcblxudmFyIGVsZXNmbiA9ICh7XG4gIG5vZGVzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICByZXR1cm4gZWxlbWVudC5pc05vZGUoKTtcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuXG4gIGVkZ2VzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICByZXR1cm4gZWxlbWVudC5pc0VkZ2UoKTtcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuXG4gIGZpbHRlcjogZnVuY3Rpb24oIGZpbHRlciApe1xuICAgIGlmKCBpcy5mbihmaWx0ZXIpICl7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgIGlmKCBmaWx0ZXIuYXBwbHkoZWxlLCBbaSwgZWxlXSkgKXtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMpO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5zdHJpbmcoZmlsdGVyKSB8fCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKGZpbHRlcikgKXtcbiAgICAgIHJldHVybiBTZWxlY3RvcihmaWx0ZXIpLmZpbHRlcih0aGlzKTtcblxuICAgIH0gZWxzZSBpZiggZmlsdGVyID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCk7IC8vIGlmIG5vdCBoYW5kbGVkIGJ5IGFib3ZlLCBnaXZlICdlbSBhbiBlbXB0eSBjb2xsZWN0aW9uXG4gIH0sXG5cbiAgbm90OiBmdW5jdGlvbiggdG9SZW1vdmUgKXtcbiAgICBpZiggIXRvUmVtb3ZlICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiggaXMuc3RyaW5nKCB0b1JlbW92ZSApICl7XG4gICAgICAgIHRvUmVtb3ZlID0gdGhpcy5maWx0ZXIoIHRvUmVtb3ZlICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzW2ldO1xuXG4gICAgICAgIHZhciByZW1vdmUgPSB0b1JlbW92ZS5fcHJpdmF0ZS5pZHNbIGVsZW1lbnQuaWQoKSBdO1xuICAgICAgICBpZiggIXJlbW92ZSApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZW1lbnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMgKTtcbiAgICB9XG5cbiAgfSxcblxuICBhYnNvbHV0ZUNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIHJldHVybiBjeS5lbGVtZW50cygpLm5vdCggdGhpcyApO1xuICB9LFxuXG4gIGludGVyc2VjdDogZnVuY3Rpb24oIG90aGVyICl7XG4gICAgLy8gaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWQsIHRoZW4gZmlsdGVyIGJ5IGl0IGluc3RlYWRcbiAgICBpZiggaXMuc3RyaW5nKG90aGVyKSApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gb3RoZXI7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG4gICAgdmFyIGNvbDFTbWFsbGVyID0gdGhpcy5sZW5ndGggPCBvdGhlci5sZW5ndGg7XG4gICAgLy8gdmFyIGlkczEgPSBjb2wxU21hbGxlciA/IGNvbDEuX3ByaXZhdGUuaWRzIDogY29sMi5fcHJpdmF0ZS5pZHM7XG4gICAgdmFyIGlkczIgPSBjb2wxU21hbGxlciA/IGNvbDIuX3ByaXZhdGUuaWRzIDogY29sMS5fcHJpdmF0ZS5pZHM7XG4gICAgdmFyIGNvbCA9IGNvbDFTbWFsbGVyID8gY29sMSA6IGNvbDI7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGlkID0gY29sW2ldLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgZWxlID0gaWRzMlsgaWQgXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMgKTtcbiAgfSxcblxuICB4b3I6IGZ1bmN0aW9uKCBvdGhlciApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiggaXMuc3RyaW5nKG90aGVyKSApe1xuICAgICAgb3RoZXIgPSBjeS4kKCBvdGhlciApO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uKCBjb2wsIG90aGVyICl7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBjb2xbaV07XG4gICAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgaW5PdGhlciA9IG90aGVyLl9wcml2YXRlLmlkc1sgaWQgXTtcblxuICAgICAgICBpZiggIWluT3RoZXIgKXtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfTtcblxuICAgIGFkZCggY29sMSwgY29sMiApO1xuICAgIGFkZCggY29sMiwgY29sMSApO1xuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGVsZW1lbnRzICk7XG4gIH0sXG5cbiAgZGlmZjogZnVuY3Rpb24oIG90aGVyICl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmKCBpcy5zdHJpbmcob3RoZXIpICl7XG4gICAgICBvdGhlciA9IGN5LiQoIG90aGVyICk7XG4gICAgfVxuXG4gICAgdmFyIGxlZnQgPSBbXTtcbiAgICB2YXIgcmlnaHQgPSBbXTtcbiAgICB2YXIgYm90aCA9IFtdO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uKCBjb2wsIG90aGVyLCByZXRFbGVzICl7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBjb2xbaV07XG4gICAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgaW5PdGhlciA9IG90aGVyLl9wcml2YXRlLmlkc1sgaWQgXTtcblxuICAgICAgICBpZiggaW5PdGhlciApe1xuICAgICAgICAgIGJvdGgucHVzaCggZWxlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0RWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfTtcblxuICAgIGFkZCggY29sMSwgY29sMiwgbGVmdCApO1xuICAgIGFkZCggY29sMiwgY29sMSwgcmlnaHQgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnNwYXduKCBsZWZ0LCB7IHVuaXF1ZTogdHJ1ZSB9ICksXG4gICAgICByaWdodDogdGhpcy5zcGF3biggcmlnaHQsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgIGJvdGg6IHRoaXMuc3Bhd24oIGJvdGgsIHsgdW5pcXVlOiB0cnVlIH0gKVxuICAgIH07XG4gIH0sXG5cbiAgYWRkOiBmdW5jdGlvbiggdG9BZGQgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYoICF0b0FkZCApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYoIGlzLnN0cmluZyh0b0FkZCkgKXtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgdG9BZGQgPSBjeS5lbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGVsZW1lbnRzLnB1c2goIHRoaXNbaV0gKTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrICl7XG5cbiAgICAgIHZhciBhZGQgPSAhdGhpcy5fcHJpdmF0ZS5pZHNbIHRvQWRkW2ldLmlkKCkgXTtcbiAgICAgIGlmKCBhZGQgKXtcbiAgICAgICAgZWxlbWVudHMucHVzaCggdG9BZGRbaV0gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cyk7XG4gIH0sXG5cbiAgLy8gaW4gcGxhY2UgbWVyZ2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gIG1lcmdlOiBmdW5jdGlvbiggdG9BZGQgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuXG4gICAgaWYoICF0b0FkZCApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYoIGlzLnN0cmluZyh0b0FkZCkgKXtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgdG9BZGQgPSBjeS5lbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHRvQWRkRWxlID0gdG9BZGRbaV07XG4gICAgICB2YXIgaWQgPSB0b0FkZEVsZS5pZCgpO1xuICAgICAgdmFyIGFkZCA9ICFfcC5pZHNbIGlkIF07XG5cbiAgICAgIGlmKCBhZGQgKXtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sZW5ndGgrKztcblxuICAgICAgICB0aGlzWyBpbmRleCBdID0gdG9BZGRFbGU7XG4gICAgICAgIF9wLmlkc1sgaWQgXSA9IHRvQWRkRWxlO1xuICAgICAgICBfcC5pbmRleGVzWyBpZCBdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgLy8gcmVtb3ZlIHNpbmdsZSBlbGUgaW4gcGxhY2UgaW4gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2VPbmU6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICBlbGUgPSBlbGVbMF07XG5cbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgIHZhciBpID0gX3AuaW5kZXhlc1sgaWQgXTtcblxuICAgIGlmKCBpID09IG51bGwgKXtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBubyBuZWVkIHRvIHJlbW92ZVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBlbGVcbiAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICAgIF9wLmlkc1sgaWQgXSA9IHVuZGVmaW5lZDtcbiAgICBfcC5pbmRleGVzWyBpZCBdID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIHVubWVyZ2VkTGFzdEVsZSA9IGkgPT09IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgIC8vIHJlcGxhY2UgZW1wdHkgc3BvdCB3aXRoIGxhc3QgZWxlIGluIGNvbGxlY3Rpb25cbiAgICBpZiggdGhpcy5sZW5ndGggPiAxICYmICF1bm1lcmdlZExhc3RFbGUgKXtcbiAgICAgIHZhciBsYXN0RWxlSSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBsYXN0RWxlID0gdGhpc1sgbGFzdEVsZUkgXTtcblxuICAgICAgdGhpc1sgbGFzdEVsZUkgXSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXNbaV0gPSBsYXN0RWxlO1xuICAgICAgX3AuaW5kZXhlc1sgbGFzdEVsZS5pZCgpIF0gPSBpO1xuICAgIH1cblxuICAgIC8vIHRoZSBjb2xsZWN0aW9uIGlzIG5vdyAxIGVsZSBzbWFsbGVyXG4gICAgdGhpcy5sZW5ndGgtLTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIHJlbW92ZSBlbGVzIGluIHBsYWNlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICB1bm1lcmdlOiBmdW5jdGlvbiggdG9SZW1vdmUgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYoICF0b1JlbW92ZSApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYoIGlzLnN0cmluZyh0b1JlbW92ZSkgKXtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRvUmVtb3ZlO1xuICAgICAgdG9SZW1vdmUgPSBjeS5lbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKyApe1xuICAgICAgdGhpcy51bm1lcmdlT25lKCB0b1JlbW92ZVtpXSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIG1hcDogZnVuY3Rpb24oIG1hcEZuLCB0aGlzQXJnICl7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IG1hcEZuLmFwcGx5KCB0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSApIDogbWFwRm4oIGVsZSwgaSwgZWxlcyApO1xuXG4gICAgICBhcnIucHVzaCggcmV0ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbiAgfSxcblxuICBzdGRGaWx0ZXI6IGZ1bmN0aW9uKCBmbiwgdGhpc0FyZyApe1xuICAgIHZhciBmaWx0ZXJFbGVzID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBpbmNsdWRlID0gdGhpc0FyZyA/IGZuLmFwcGx5KCB0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSApIDogZm4oIGVsZSwgaSwgZWxlcyApO1xuXG4gICAgICBpZiggaW5jbHVkZSApe1xuICAgICAgICBmaWx0ZXJFbGVzLnB1c2goIGVsZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBmaWx0ZXJFbGVzICk7XG4gIH0sXG5cbiAgbWF4OiBmdW5jdGlvbiggdmFsRm4sIHRoaXNBcmcgKXtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhFbGU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkoIHRoaXNBcmcsIFsgZWxlLCBpLCBlbGVzIF0gKSA6IHZhbEZuKCBlbGUsIGksIGVsZXMgKTtcblxuICAgICAgaWYoIHZhbCA+IG1heCApe1xuICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgIG1heEVsZSA9IGVsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG1heCxcbiAgICAgIGVsZTogbWF4RWxlXG4gICAgfTtcbiAgfSxcblxuICBtaW46IGZ1bmN0aW9uKCB2YWxGbiwgdGhpc0FyZyApe1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgbWluRWxlO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgdmFsID0gdGhpc0FyZyA/IHZhbEZuLmFwcGx5KCB0aGlzQXJnLCBbIGVsZSwgaSwgZWxlcyBdICkgOiB2YWxGbiggZWxlLCBpLCBlbGVzICk7XG5cbiAgICAgIGlmKCB2YWwgPCBtaW4gKXtcbiAgICAgICAgbWluID0gdmFsO1xuICAgICAgICBtaW5FbGUgPSBlbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBtaW4sXG4gICAgICBlbGU6IG1pbkVsZVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBhbGlhc2VzXG52YXIgZm4gPSBlbGVzZm47XG5mblsndSddID0gZm5bJ3wnXSA9IGZuWycrJ10gPSBmbi51bmlvbiA9IGZuLm9yID0gZm4uYWRkO1xuZm5bJ1xcXFwnXSA9IGZuWychJ10gPSBmblsnLSddID0gZm4uZGlmZmVyZW5jZSA9IGZuLnJlbGF0aXZlQ29tcGxlbWVudCA9IGZuLnN1YnRyYWN0ID0gZm4ubm90O1xuZm5bJ24nXSA9IGZuWycmJ10gPSBmblsnLiddID0gZm4uYW5kID0gZm4uaW50ZXJzZWN0aW9uID0gZm4uaW50ZXJzZWN0O1xuZm5bJ14nXSA9IGZuWycoKyknXSA9IGZuWycoLSknXSA9IGZuLnN5bW1ldHJpY0RpZmZlcmVuY2UgPSBmbi5zeW1kaWZmID0gZm4ueG9yO1xuZm4uZm5GaWx0ZXIgPSBmbi5maWx0ZXJGbiA9IGZuLnN0ZEZpbHRlcjtcbmZuLmNvbXBsZW1lbnQgPSBmbi5hYnNjb21wID0gZm4uYWJzb2x1dGVDb21wbGVtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxufSx7XCIuLi9pc1wiOjc3LFwiLi4vc2VsZWN0b3JcIjo4MX1dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGVsZXNmbiA9ICh7XG4gIGlzTm9kZTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ncm91cCgpID09PSAnbm9kZXMnO1xuICB9LFxuXG4gIGlzRWRnZTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ncm91cCgpID09PSAnZWRnZXMnO1xuICB9LFxuXG4gIGlzTG9vcDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKSAmJiB0aGlzLnNvdXJjZSgpLmlkKCkgPT09IHRoaXMudGFyZ2V0KCkuaWQoKTtcbiAgfSxcblxuICBpc1NpbXBsZTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKSAmJiB0aGlzLnNvdXJjZSgpLmlkKCkgIT09IHRoaXMudGFyZ2V0KCkuaWQoKTtcbiAgfSxcblxuICBncm91cDogZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JvdXA7XG4gICAgfVxuICB9XG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxufSx7fV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uL3V0aWwnKTtcbnZhciBpcyA9IF9kZXJlcV8oJy4uL2lzJyk7XG5cbnZhciBFbGVtZW50ID0gX2RlcmVxXygnLi9lbGVtZW50Jyk7XG5cbi8vIGZhY3RvcnkgZm9yIGdlbmVyYXRpbmcgZWRnZSBpZHMgd2hlbiBubyBpZCBpcyBzcGVjaWZpZWQgZm9yIGEgbmV3IGVsZW1lbnRcbnZhciBpZEZhY3RvcnkgPSB7XG4gIHByZWZpeDogJ2VsZScsXG4gIGlkOiAwLFxuICBnZW5lcmF0ZTogZnVuY3Rpb24oY3ksIGVsZW1lbnQsIHRyeVRoaXNJZCl7XG4gICAgdmFyIGpzb24gPSBpcy5lbGVtZW50KCBlbGVtZW50ICkgPyBlbGVtZW50Ll9wcml2YXRlIDogZWxlbWVudDtcbiAgICB2YXIgaWQgPSB0cnlUaGlzSWQgIT0gbnVsbCA/IHRyeVRoaXNJZCA6IHRoaXMucHJlZml4ICsgdGhpcy5pZDtcblxuICAgIGlmKCBjeS5nZXRFbGVtZW50QnlJZChpZCkuZW1wdHkoKSApe1xuICAgICAgdGhpcy5pZCsrOyAvLyB3ZSd2ZSB1c2VkIHRoZSBjdXJyZW50IGlkLCBzbyBtb3ZlIGl0IHVwXG4gICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIGtlZXAgdHJ5aW5nIHN1Y2Nlc3NpdmUgdW51c2VkIGlkc1xuICAgICAgd2hpbGUoICFjeS5nZXRFbGVtZW50QnlJZChpZCkuZW1wdHkoKSApe1xuICAgICAgICBpZCA9IHRoaXMucHJlZml4ICsgKCArK3RoaXMuaWQgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaWQ7XG4gIH1cbn07XG5cbi8vIHJlcHJlc2VudHMgYSBzZXQgb2Ygbm9kZXMsIGVkZ2VzLCBvciBib3RoIHRvZ2V0aGVyXG52YXIgQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKGN5LCBlbGVtZW50cywgb3B0aW9ucyl7XG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSApe1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbihjeSwgZWxlbWVudHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYoIGN5ID09PSB1bmRlZmluZWQgfHwgIWlzLmNvcmUoY3kpICl7XG4gICAgdXRpbC5lcnJvcignQSBjb2xsZWN0aW9uIG11c3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29yZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZHMgPSB7fTtcbiAgdmFyIGluZGV4ZXMgPSB7fTtcbiAgdmFyIGNyZWF0ZWRFbGVtZW50cyA9IGZhbHNlO1xuXG4gIGlmKCAhZWxlbWVudHMgKXtcbiAgICBlbGVtZW50cyA9IFtdO1xuICB9IGVsc2UgaWYoIGVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgaXMucGxhaW5PYmplY3QoIGVsZW1lbnRzWzBdICkgJiYgIWlzLmVsZW1lbnQoIGVsZW1lbnRzWzBdICkgKXtcbiAgICBjcmVhdGVkRWxlbWVudHMgPSB0cnVlO1xuXG4gICAgLy8gbWFrZSBlbGVtZW50cyBmcm9tIGpzb24gYW5kIHJlc3RvcmUgYWxsIGF0IG9uY2UgbGF0ZXJcbiAgICB2YXIgZWxlcyA9IFtdO1xuICAgIHZhciBlbGVzSWRzID0ge307XG5cbiAgICBmb3IoIHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgdmFyIGpzb24gPSBlbGVtZW50c1tpXTtcblxuICAgICAgaWYoIGpzb24uZGF0YSA9PSBudWxsICl7XG4gICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IGpzb24uZGF0YTtcblxuICAgICAgLy8gbWFrZSBzdXJlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudHMgaGF2ZSB2YWxpZCBpZHNcbiAgICAgIGlmKCBkYXRhLmlkID09IG51bGwgKXtcbiAgICAgICAgZGF0YS5pZCA9IGlkRmFjdG9yeS5nZW5lcmF0ZSggY3ksIGpzb24gKTtcbiAgICAgIH0gZWxzZSBpZiggY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEuaWQgKS5sZW5ndGggIT09IDAgfHwgZWxlc0lkc1sgZGF0YS5pZCBdICl7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBwcmlvciBpZCBhbHJlYWR5IGV4aXN0c1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gbmV3IEVsZW1lbnQoIGN5LCBqc29uLCBmYWxzZSApO1xuICAgICAgZWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgIGVsZXNJZHNbIGRhdGEuaWQgXSA9IHRydWU7XG4gICAgfVxuXG4gICAgZWxlbWVudHMgPSBlbGVzO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIGZvciggdmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICBpZiggIWVsZW1lbnQgKXsgIGNvbnRpbnVlOyB9XG5cbiAgICB2YXIgaWQgPSBlbGVtZW50Ll9wcml2YXRlLmRhdGEuaWQ7XG5cbiAgICBpZiggIW9wdGlvbnMgfHwgKG9wdGlvbnMudW5pcXVlICYmICFpZHNbIGlkIF0gKSApe1xuICAgICAgaWRzWyBpZCBdID0gZWxlbWVudDtcbiAgICAgIGluZGV4ZXNbIGlkIF0gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgdGhpc1sgdGhpcy5sZW5ndGggXSA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIGlkczogaWRzLFxuICAgIGluZGV4ZXM6IGluZGV4ZXNcbiAgfTtcblxuICAvLyByZXN0b3JlIHRoZSBlbGVtZW50cyBpZiB3ZSBjcmVhdGVkIHRoZW0gZnJvbSBqc29uXG4gIGlmKCBjcmVhdGVkRWxlbWVudHMgKXtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIGtlZXAgdGhlIHByb3RvdHlwZXMgaW4gc3luYyAoYW4gZWxlbWVudCBoYXMgdGhlIHNhbWUgZnVuY3Rpb25zIGFzIGEgY29sbGVjdGlvbilcbi8vIGFuZCB1c2UgZWxlZm4gYW5kIGVsZXNmbiBhcyBzaG9ydGhhbmRzIHRvIHRoZSBwcm90b3R5cGVzXG52YXIgZWxlc2ZuID0gRWxlbWVudC5wcm90b3R5cGUgPSBDb2xsZWN0aW9uLnByb3RvdHlwZTtcblxuZWxlc2ZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICdjb2xsZWN0aW9uJztcbn07XG5cbmVsZXNmbi5zcGF3biA9IGZ1bmN0aW9uKCBjeSwgZWxlcywgb3B0cyApe1xuICBpZiggIWlzLmNvcmUoY3kpICl7IC8vIGN5IGlzIG9wdGlvbmFsXG4gICAgb3B0cyA9IGVsZXM7XG4gICAgZWxlcyA9IGN5O1xuICAgIGN5ID0gdGhpcy5jeSgpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCBjeSwgZWxlcywgb3B0cyApO1xufTtcblxuZWxlc2ZuLmN5ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG59O1xuXG5lbGVzZm4uZWxlbWVudCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzWzBdO1xufTtcblxuZWxlc2ZuLmNvbGxlY3Rpb24gPSBmdW5jdGlvbigpe1xuICBpZiggaXMuY29sbGVjdGlvbih0aGlzKSApe1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2UgeyAvLyBhbiBlbGVtZW50XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCBbdGhpc10gKTtcbiAgfVxufTtcblxuZWxlc2ZuLnVuaXF1ZSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgdGhpcywgeyB1bmlxdWU6IHRydWUgfSApO1xufTtcblxuZWxlc2ZuLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24oIGlkICl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGUgPSB0aGlzLl9wcml2YXRlLmlkc1sgaWQgXTtcblxuICByZXR1cm4gZWxlID8gZWxlIDogbmV3IENvbGxlY3Rpb24oY3kpOyAvLyBnZXQgZWxlIG9yIGVtcHR5IGNvbGxlY3Rpb25cbn07XG5cbmVsZXNmbi5qc29uID0gZnVuY3Rpb24oIG9iaiApe1xuICB2YXIgZWxlID0gdGhpcy5lbGVtZW50KCk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICBpZiggZWxlID09IG51bGwgJiYgb2JqICl7IHJldHVybiB0aGlzOyB9IC8vIGNhbid0IHNldCB0byBubyBlbGVzXG5cbiAgaWYoIGVsZSA9PSBudWxsICl7IHJldHVybiB1bmRlZmluZWQ7IH0gLy8gY2FuJ3QgZ2V0IGZyb20gbm8gZWxlc1xuXG4gIHZhciBwID0gZWxlLl9wcml2YXRlO1xuXG4gIGlmKCBpcy5wbGFpbk9iamVjdChvYmopICl7IC8vIHNldFxuXG4gICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgaWYoIG9iai5kYXRhICl7XG4gICAgICBlbGUuZGF0YSggb2JqLmRhdGEgKTtcbiAgICB9XG5cbiAgICBpZiggb2JqLnBvc2l0aW9uICl7XG4gICAgICBlbGUucG9zaXRpb24oIG9iai5wb3NpdGlvbiApO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBncm91cCAtLSBpbW11dGFibGVcblxuICAgIHZhciBjaGVja1N3aXRjaCA9IGZ1bmN0aW9uKCBrLCB0cnVlRm5OYW1lLCBmYWxzZUZuTmFtZSApe1xuICAgICAgdmFyIG9ial9rID0gb2JqW2tdO1xuXG4gICAgICBpZiggb2JqX2sgIT0gbnVsbCAmJiBvYmpfayAhPT0gcFtrXSApe1xuICAgICAgICBpZiggb2JqX2sgKXtcbiAgICAgICAgICBlbGVbIHRydWVGbk5hbWUgXSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZVsgZmFsc2VGbk5hbWUgXSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNoZWNrU3dpdGNoKCAncmVtb3ZlZCcsICdyZW1vdmUnLCAncmVzdG9yZScgKTtcblxuICAgIGNoZWNrU3dpdGNoKCAnc2VsZWN0ZWQnLCAnc2VsZWN0JywgJ3Vuc2VsZWN0JyApO1xuXG4gICAgY2hlY2tTd2l0Y2goICdzZWxlY3RhYmxlJywgJ3NlbGVjdGlmeScsICd1bnNlbGVjdGlmeScgKTtcblxuICAgIGNoZWNrU3dpdGNoKCAnbG9ja2VkJywgJ2xvY2snLCAndW5sb2NrJyApO1xuXG4gICAgY2hlY2tTd2l0Y2goICdncmFiYmFibGUnLCAnZ3JhYmlmeScsICd1bmdyYWJpZnknICk7XG5cbiAgICBpZiggb2JqLmNsYXNzZXMgIT0gbnVsbCApe1xuICAgICAgZWxlLmNsYXNzZXMoIG9iai5jbGFzc2VzICk7XG4gICAgfVxuXG4gICAgY3kuZW5kQmF0Y2goKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0gZWxzZSBpZiggb2JqID09PSB1bmRlZmluZWQgKXsgLy8gZ2V0XG5cbiAgICB2YXIganNvbiA9IHtcbiAgICAgIGRhdGE6IHV0aWwuY29weSggcC5kYXRhICksXG4gICAgICBwb3NpdGlvbjogdXRpbC5jb3B5KCBwLnBvc2l0aW9uICksXG4gICAgICBncm91cDogcC5ncm91cCxcbiAgICAgIHJlbW92ZWQ6IHAucmVtb3ZlZCxcbiAgICAgIHNlbGVjdGVkOiBwLnNlbGVjdGVkLFxuICAgICAgc2VsZWN0YWJsZTogcC5zZWxlY3RhYmxlLFxuICAgICAgbG9ja2VkOiBwLmxvY2tlZCxcbiAgICAgIGdyYWJiYWJsZTogcC5ncmFiYmFibGUsXG4gICAgICBjbGFzc2VzOiBudWxsXG4gICAgfTtcblxuICAgIHZhciBjbGFzc2VzID0gW107XG4gICAgZm9yKCB2YXIgY2xzIGluIHAuY2xhc3NlcyApe1xuICAgICAgaWYoIHAuY2xhc3Nlc1tjbHNdICl7XG4gICAgICAgIGNsYXNzZXMucHVzaChjbHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBqc29uLmNsYXNzZXMgPSBjbGFzc2VzLmpvaW4oJyAnKTtcblxuICAgIHJldHVybiBqc29uO1xuICB9XG59O1xuXG5lbGVzZm4uanNvbnMgPSBmdW5jdGlvbigpe1xuICB2YXIganNvbnMgPSBbXTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG5cbiAgICBqc29ucy5wdXNoKCBqc29uICk7XG4gIH1cblxuICByZXR1cm4ganNvbnM7XG59O1xuXG5lbGVzZm4uY2xvbmUgPSBmdW5jdGlvbigpe1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBlbGVzQXJyID0gW107XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgIHZhciBjbG9uZSA9IG5ldyBFbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7IC8vIE5CIG5vIHJlc3RvcmVcblxuICAgIGVsZXNBcnIucHVzaCggY2xvbmUgKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbiggY3ksIGVsZXNBcnIgKTtcbn07XG5lbGVzZm4uY29weSA9IGVsZXNmbi5jbG9uZTtcblxuZWxlc2ZuLnJlc3RvcmUgPSBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcmVzdG9yZWQgPSBbXTtcbiAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuXG4gIGlmKCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkICl7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSB0cnVlO1xuICB9XG5cbiAgLy8gY3JlYXRlIGFycmF5cyBvZiBub2RlcyBhbmQgZWRnZXMsIHNpbmNlIHdlIG5lZWQgdG9cbiAgLy8gcmVzdG9yZSB0aGUgbm9kZXMgZmlyc3RcbiAgdmFyIGVsZW1lbnRzID0gW107XG4gIHZhciBub2RlcyA9IFtdLCBlZGdlcyA9IFtdO1xuICB2YXIgbnVtTm9kZXMgPSAwO1xuICB2YXIgbnVtRWRnZXMgPSAwO1xuICBmb3IoIHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IHNlbGZbaV07XG5cbiAgICAvLyBrZWVwIG5vZGVzIGZpcnN0IGluIHRoZSBhcnJheSBhbmQgZWRnZXMgYWZ0ZXJcbiAgICBpZiggZWxlLmlzTm9kZSgpICl7IC8vIHB1dCB0byBmcm9udCBvZiBhcnJheSBpZiBub2RlXG4gICAgICBub2Rlcy5wdXNoKCBlbGUgKTtcbiAgICAgIG51bU5vZGVzKys7XG4gICAgfSBlbHNlIHsgLy8gcHV0IHRvIGVuZCBvZiBhcnJheSBpZiBlZGdlXG4gICAgICBlZGdlcy5wdXNoKCBlbGUgKTtcbiAgICAgIG51bUVkZ2VzKys7XG4gICAgfVxuICB9XG5cbiAgZWxlbWVudHMgPSBub2Rlcy5jb25jYXQoIGVkZ2VzICk7XG5cbiAgLy8gbm93LCByZXN0b3JlIGVhY2ggZWxlbWVudFxuICBmb3IoIHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVtZW50c1tpXTtcblxuICAgIGlmKCAhZWxlLnJlbW92ZWQoKSApe1xuICAgICAgLy8gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIF9wcml2YXRlID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBkYXRhID0gX3ByaXZhdGUuZGF0YTtcblxuICAgIC8vIHNldCBpZCBhbmQgdmFsaWRhdGVcbiAgICBpZiggZGF0YS5pZCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBkYXRhLmlkID0gaWRGYWN0b3J5LmdlbmVyYXRlKCBjeSwgZWxlICk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLm51bWJlcihkYXRhLmlkKSApe1xuICAgICAgZGF0YS5pZCA9ICcnICsgZGF0YS5pZDsgLy8gbm93IGl0J3MgYSBzdHJpbmdcblxuICAgIH0gZWxzZSBpZiggaXMuZW1wdHlTdHJpbmcoZGF0YS5pZCkgfHwgIWlzLnN0cmluZyhkYXRhLmlkKSApe1xuICAgICAgdXRpbC5lcnJvcignQ2FuIG5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIGludmFsaWQgc3RyaW5nIElEIGAnICsgZGF0YS5pZCArICdgJyk7XG5cbiAgICAgIC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIGl0IGhhcyBlbXB0eSBzdHJpbmcgYXMgaWQgb3Igbm9uLXN0cmluZyBpZFxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmKCBjeS5nZXRFbGVtZW50QnlJZCggZGF0YS5pZCApLmxlbmd0aCAhPT0gMCApe1xuICAgICAgdXRpbC5lcnJvcignQ2FuIG5vdCBjcmVhdGUgc2Vjb25kIGVsZW1lbnQgd2l0aCBJRCBgJyArIGRhdGEuaWQgKyAnYCcpO1xuXG4gICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBvbmUgYWxyZWFkeSBoYXMgdGhhdCBpZFxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlkID0gZGF0YS5pZDsgLy8gaWQgaXMgZmluYWxpc2VkLCBub3cgbGV0J3Mga2VlcCBhIHJlZlxuXG4gICAgaWYoIGVsZS5pc05vZGUoKSApeyAvLyBleHRyYSBjaGVja3MgZm9yIG5vZGVzXG4gICAgICB2YXIgbm9kZSA9IGVsZTtcbiAgICAgIHZhciBwb3MgPSBfcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBub2RlcyBoYXZlIGEgZGVmaW5lZCBwb3NpdGlvblxuXG4gICAgICBpZiggcG9zLnggPT0gbnVsbCApe1xuICAgICAgICBwb3MueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmKCBwb3MueSA9PSBudWxsICl7XG4gICAgICAgIHBvcy55ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggZWxlLmlzRWRnZSgpICl7IC8vIGV4dHJhIGNoZWNrcyBmb3IgZWRnZXNcblxuICAgICAgdmFyIGVkZ2UgPSBlbGU7XG4gICAgICB2YXIgZmllbGRzID0gWydzb3VyY2UnLCAndGFyZ2V0J107XG4gICAgICB2YXIgZmllbGRzTGVuZ3RoID0gZmllbGRzLmxlbmd0aDtcbiAgICAgIHZhciBiYWRTb3VyY2VPclRhcmdldCA9IGZhbHNlO1xuICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGZpZWxkc0xlbmd0aDsgaisrKXtcblxuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbal07XG4gICAgICAgIHZhciB2YWwgPSBkYXRhW2ZpZWxkXTtcblxuICAgICAgICBpZiggaXMubnVtYmVyKHZhbCkgKXtcbiAgICAgICAgICB2YWwgPSBkYXRhW2ZpZWxkXSA9ICcnICsgZGF0YVtmaWVsZF07IC8vIG5vdyBzdHJpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCB2YWwgPT0gbnVsbCB8fCB2YWwgPT09ICcnICl7XG4gICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGlmIHNvdXJjZSBvciB0YXJnZXQgaXMgbm90IGRlZmluZWQgcHJvcGVybHlcbiAgICAgICAgICB1dGlsLmVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIHVuc3BlY2lmaWVkICcgKyBmaWVsZCk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYoIGN5LmdldEVsZW1lbnRCeUlkKHZhbCkuZW1wdHkoKSApe1xuICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBlZGdlIGlmIG9uZSBvZiBpdHMgbm9kZXMgZG9lc24ndCBleGlzdFxuICAgICAgICAgIHV0aWwuZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggbm9uZXhpc3RhbnQgJyArIGZpZWxkICsgJyBgJyArIHZhbCArICdgJyk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBiYWRTb3VyY2VPclRhcmdldCApeyBjb250aW51ZTsgfSAvLyBjYW4ndCBjcmVhdGUgdGhpc1xuXG4gICAgICB2YXIgc3JjID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEuc291cmNlICk7XG4gICAgICB2YXIgdGd0ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEudGFyZ2V0ICk7XG5cbiAgICAgIHNyYy5fcHJpdmF0ZS5lZGdlcy5wdXNoKCBlZGdlICk7XG4gICAgICB0Z3QuX3ByaXZhdGUuZWRnZXMucHVzaCggZWRnZSApO1xuXG4gICAgICBlZGdlLl9wcml2YXRlLnNvdXJjZSA9IHNyYztcbiAgICAgIGVkZ2UuX3ByaXZhdGUudGFyZ2V0ID0gdGd0O1xuXG4gICAgfSAvLyBpZiBpcyBlZGdlXG5cbiAgICAvLyBjcmVhdGUgbW9jayBpZHMgbWFwIGZvciBlbGVtZW50IHNvIGl0IGNhbiBiZSB1c2VkIGxpa2UgY29sbGVjdGlvbnNcbiAgICBfcHJpdmF0ZS5pZHMgPSB7fTtcbiAgICBfcHJpdmF0ZS5pZHNbIGlkIF0gPSBlbGU7XG5cbiAgICBfcHJpdmF0ZS5yZW1vdmVkID0gZmFsc2U7XG4gICAgY3kuYWRkVG9Qb29sKCBlbGUgKTtcblxuICAgIHJlc3RvcmVkLnB1c2goIGVsZSApO1xuICB9IC8vIGZvciBlYWNoIGVsZW1lbnRcblxuICAvLyBkbyBjb21wb3VuZCBub2RlIHNhbml0eSBjaGVja3NcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7IC8vIGVhY2ggbm9kZVxuICAgIHZhciBub2RlID0gZWxlbWVudHNbaV07XG4gICAgdmFyIGRhdGEgPSBub2RlLl9wcml2YXRlLmRhdGE7XG5cbiAgICBpZiggaXMubnVtYmVyKGRhdGEucGFyZW50KSApeyAvLyB0aGVuIGF1dG9tYWtlIHN0cmluZ1xuICAgICAgZGF0YS5wYXJlbnQgPSAnJyArIGRhdGEucGFyZW50O1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRJZCA9IGRhdGEucGFyZW50O1xuXG4gICAgdmFyIHNwZWNpZmllZFBhcmVudCA9IHBhcmVudElkICE9IG51bGw7XG5cbiAgICBpZiggc3BlY2lmaWVkUGFyZW50ICl7XG4gICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIHBhcmVudElkICk7XG5cbiAgICAgIGlmKCBwYXJlbnQuZW1wdHkoKSApe1xuICAgICAgICAvLyBub24tZXhpc3RhbnQgcGFyZW50OyBqdXN0IHJlbW92ZSBpdFxuICAgICAgICBkYXRhLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWxmQXNQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgICB3aGlsZSggIWFuY2VzdG9yLmVtcHR5KCkgKXtcbiAgICAgICAgICBpZiggbm9kZS5zYW1lKGFuY2VzdG9yKSApe1xuICAgICAgICAgICAgLy8gbWFyayBzZWxmIGFzIHBhcmVudCBhbmQgcmVtb3ZlIGZyb20gZGF0YVxuICAgICAgICAgICAgc2VsZkFzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRhdGEucGFyZW50ID0gdW5kZWZpbmVkOyAvLyByZW1vdmUgcGFyZW50IHJlZmVyZW5jZVxuXG4gICAgICAgICAgICAvLyBleGl0IG9yIHdlIGxvb3AgZm9yZXZlclxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhc2VsZkFzUGFyZW50ICl7XG4gICAgICAgICAgLy8gY29ubmVjdCB3aXRoIGNoaWxkcmVuXG4gICAgICAgICAgcGFyZW50WzBdLl9wcml2YXRlLmNoaWxkcmVuLnB1c2goIG5vZGUgKTtcbiAgICAgICAgICBub2RlLl9wcml2YXRlLnBhcmVudCA9IHBhcmVudFswXTtcblxuICAgICAgICAgIC8vIGxldCB0aGUgY29yZSBrbm93IHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaFxuICAgICAgICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGVsc2VcbiAgICB9IC8vIGlmIHNwZWNpZmllZCBwYXJlbnRcbiAgfSAvLyBmb3IgZWFjaCBub2RlXG5cbiAgcmVzdG9yZWQgPSBuZXcgQ29sbGVjdGlvbiggY3ksIHJlc3RvcmVkICk7XG4gIGlmKCByZXN0b3JlZC5sZW5ndGggPiAwICl7XG5cbiAgICB2YXIgdG9VcGRhdGVTdHlsZSA9IHJlc3RvcmVkLmFkZCggcmVzdG9yZWQuY29ubmVjdGVkTm9kZXMoKSApLmFkZCggcmVzdG9yZWQucGFyZW50KCkgKTtcbiAgICB0b1VwZGF0ZVN0eWxlLnVwZGF0ZVN0eWxlKCBub3RpZnlSZW5kZXJlciApO1xuXG4gICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICByZXN0b3JlZC5ydHJpZ2dlcignYWRkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVkLnRyaWdnZXIoJ2FkZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmOyAvLyBjaGFpbmFiaWxpdHlcbn07XG5cbmVsZXNmbi5yZW1vdmVkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUgJiYgZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG59O1xuXG5lbGVzZm4uaW5zaWRlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUgJiYgIWVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xufTtcblxuZWxlc2ZuLnJlbW92ZSA9IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZW1vdmVkID0gW107XG4gIHZhciBlbGVzVG9SZW1vdmUgPSBbXTtcbiAgdmFyIGVsZXNUb1JlbW92ZUlkcyA9IHt9O1xuICB2YXIgY3kgPSBzZWxmLl9wcml2YXRlLmN5O1xuXG4gIGlmKCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkICl7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSB0cnVlO1xuICB9XG5cbiAgLy8gYWRkIGNvbm5lY3RlZCBlZGdlc1xuICBmdW5jdGlvbiBhZGRDb25uZWN0ZWRFZGdlcyhub2RlKXtcbiAgICB2YXIgZWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGFkZCggZWRnZXNbaV0gKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGFkZCBkZXNjZW5kYW50IG5vZGVzXG4gIGZ1bmN0aW9uIGFkZENoaWxkcmVuKG5vZGUpe1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrICl7XG4gICAgICBhZGQoIGNoaWxkcmVuW2ldICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkKCBlbGUgKXtcbiAgICB2YXIgYWxyZWFkeUFkZGVkID0gIGVsZXNUb1JlbW92ZUlkc1sgZWxlLmlkKCkgXTtcbiAgICBpZiggYWxyZWFkeUFkZGVkICl7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXNUb1JlbW92ZUlkc1sgZWxlLmlkKCkgXSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoIGVsZS5pc05vZGUoKSApe1xuICAgICAgZWxlc1RvUmVtb3ZlLnB1c2goIGVsZSApOyAvLyBub2RlcyBhcmUgcmVtb3ZlZCBsYXN0XG5cbiAgICAgIGFkZENvbm5lY3RlZEVkZ2VzKCBlbGUgKTtcbiAgICAgIGFkZENoaWxkcmVuKCBlbGUgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlc1RvUmVtb3ZlLnVuc2hpZnQoIGVsZSApOyAvLyBlZGdlcyBhcmUgcmVtb3ZlZCBmaXJzdFxuICAgIH1cbiAgfVxuXG4gIC8vIG1ha2UgdGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gcmVtb3ZlXG4gIC8vIChtYXkgYmUgcmVtb3ZpbmcgbW9yZSB0aGFuIHNwZWNpZmllZCBkdWUgdG8gY29ubmVjdGVkIGVkZ2VzIGV0YylcblxuICBmb3IoIHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IHNlbGZbaV07XG5cbiAgICBhZGQoIGVsZSApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRWRnZVJlZihub2RlLCBlZGdlKXtcbiAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgIGZvciggdmFyIGogPSAwOyBqIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG5cbiAgICAgIGlmKCBlZGdlID09PSBjb25uZWN0ZWRFZGdlICl7XG4gICAgICAgIGNvbm5lY3RlZEVkZ2VzLnNwbGljZSggaiwgMSApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZFJlZihwYXJlbnQsIGVsZSl7XG4gICAgZWxlID0gZWxlWzBdO1xuICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrICl7XG4gICAgICBpZiggY2hpbGRyZW5bal1bMF0gPT09IGVsZVswXSApe1xuICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1RvUmVtb3ZlLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNUb1JlbW92ZVtpXTtcblxuICAgIC8vIG1hcmsgYXMgcmVtb3ZlZFxuICAgIGVsZS5fcHJpdmF0ZS5yZW1vdmVkID0gdHJ1ZTtcblxuICAgIC8vIHJlbW92ZSBmcm9tIGNvcmUgcG9vbFxuICAgIGN5LnJlbW92ZUZyb21Qb29sKCBlbGUgKTtcblxuICAgIC8vIGFkZCB0byBsaXN0IG9mIHJlbW92ZWQgZWxlbWVudHNcbiAgICByZW1vdmVkLnB1c2goIGVsZSApO1xuXG4gICAgaWYoIGVsZS5pc0VkZ2UoKSApeyAvLyByZW1vdmUgcmVmZXJlbmNlcyB0byB0aGlzIGVkZ2UgaW4gaXRzIGNvbm5lY3RlZCBub2Rlc1xuICAgICAgdmFyIHNyYyA9IGVsZS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciB0Z3QgPSBlbGUudGFyZ2V0KClbMF07XG5cbiAgICAgIHJlbW92ZUVkZ2VSZWYoIHNyYywgZWxlICk7XG4gICAgICByZW1vdmVFZGdlUmVmKCB0Z3QsIGVsZSApO1xuXG4gICAgfSBlbHNlIHsgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBwYXJlbnRcbiAgICAgIHZhciBwYXJlbnQgPSBlbGUucGFyZW50KCk7XG5cbiAgICAgIGlmKCBwYXJlbnQubGVuZ3RoICE9PSAwICl7XG4gICAgICAgIHJlbW92ZUNoaWxkUmVmKHBhcmVudCwgZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoIG9yIG5vdFxuICB2YXIgZWxlc1N0aWxsSW5zaWRlID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSBmYWxzZTtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzU3RpbGxJbnNpZGUubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1N0aWxsSW5zaWRlW2ldO1xuXG4gICAgaWYoIGVsZS5pc1BhcmVudCgpICl7XG4gICAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZW1vdmVkRWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbiggdGhpcy5jeSgpLCByZW1vdmVkICk7XG4gIGlmKCByZW1vdmVkRWxlbWVudHMuc2l6ZSgpID4gMCApe1xuICAgIC8vIG11c3QgbWFudWFsbHkgbm90aWZ5IHNpbmNlIHRyaWdnZXIgd29uJ3QgZG8gdGhpcyBhdXRvbWF0aWNhbGx5IG9uY2UgcmVtb3ZlZFxuXG4gICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICB0aGlzLmN5KCkubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICAgIGNvbGxlY3Rpb246IHJlbW92ZWRFbGVtZW50c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlZEVsZW1lbnRzLnRyaWdnZXIoJ3JlbW92ZScpO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGVtcHR5IHJlbWFpbmluZyBwYXJlbnQgbm9kZXNcbiAgdmFyIGNoZWNrZWRQYXJlbnRJZCA9IHt9O1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzVG9SZW1vdmVbaV07XG4gICAgdmFyIGlzTm9kZSA9IGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJztcbiAgICB2YXIgcGFyZW50SWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5wYXJlbnQ7XG5cbiAgICBpZiggaXNOb2RlICYmIHBhcmVudElkICE9PSB1bmRlZmluZWQgJiYgIWNoZWNrZWRQYXJlbnRJZFsgcGFyZW50SWQgXSApe1xuICAgICAgY2hlY2tlZFBhcmVudElkWyBwYXJlbnRJZCBdID0gdHJ1ZTtcbiAgICAgIHZhciBwYXJlbnQgPSBjeS5nZXRFbGVtZW50QnlJZCggcGFyZW50SWQgKTtcblxuICAgICAgaWYoIHBhcmVudCAmJiBwYXJlbnQubGVuZ3RoICE9PSAwICYmICFwYXJlbnQuX3ByaXZhdGUucmVtb3ZlZCAmJiBwYXJlbnQuY2hpbGRyZW4oKS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgcGFyZW50LnVwZGF0ZVN0eWxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCBjeSwgcmVtb3ZlZCApO1xufTtcblxuZWxlc2ZuLm1vdmUgPSBmdW5jdGlvbiggc3RydWN0ICl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgaWYoIHN0cnVjdC5zb3VyY2UgIT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudGFyZ2V0ICE9PSB1bmRlZmluZWQgKXtcbiAgICB2YXIgc3JjSWQgPSBzdHJ1Y3Quc291cmNlO1xuICAgIHZhciB0Z3RJZCA9IHN0cnVjdC50YXJnZXQ7XG4gICAgdmFyIHNyY0V4aXN0cyA9IGN5LmdldEVsZW1lbnRCeUlkKCBzcmNJZCApLmxlbmd0aCA+IDA7XG4gICAgdmFyIHRndEV4aXN0cyA9IGN5LmdldEVsZW1lbnRCeUlkKCB0Z3RJZCApLmxlbmd0aCA+IDA7XG5cbiAgICBpZiggc3JjRXhpc3RzIHx8IHRndEV4aXN0cyApe1xuICAgICAgdmFyIGpzb25zID0gdGhpcy5qc29ucygpO1xuXG4gICAgICB0aGlzLnJlbW92ZSgpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG5cbiAgICAgICAgaWYoIGpzb24uZ3JvdXAgPT09ICdlZGdlcycgKXtcbiAgICAgICAgICBpZiggc3JjRXhpc3RzICl7IGpzb24uZGF0YS5zb3VyY2UgPSBzcmNJZDsgfVxuICAgICAgICAgIGlmKCB0Z3RFeGlzdHMgKXsganNvbi5kYXRhLnRhcmdldCA9IHRndElkOyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN5LmFkZCgganNvbnMgKTtcbiAgICB9XG5cbiAgfSBlbHNlIGlmKCBzdHJ1Y3QucGFyZW50ICE9PSB1bmRlZmluZWQgKXsgLy8gbW92ZSBub2RlIHRvIG5ldyBwYXJlbnRcbiAgICB2YXIgcGFyZW50SWQgPSBzdHJ1Y3QucGFyZW50O1xuICAgIHZhciBwYXJlbnRFeGlzdHMgPSBwYXJlbnRJZCA9PT0gbnVsbCB8fCBjeS5nZXRFbGVtZW50QnlJZCggcGFyZW50SWQgKS5sZW5ndGggPiAwO1xuXG4gICAgaWYoIHBhcmVudEV4aXN0cyApe1xuICAgICAgdmFyIGpzb25zID0gdGhpcy5qc29ucygpO1xuICAgICAgdmFyIGRlc2NzID0gdGhpcy5kZXNjZW5kYW50cygpO1xuICAgICAgdmFyIGRlc2NzRXRjID0gZGVzY3MubWVyZ2UoIGRlc2NzLmFkZCh0aGlzKS5jb25uZWN0ZWRFZGdlcygpICk7XG5cbiAgICAgIHRoaXMucmVtb3ZlKCk7IC8vIE5COiBhbHNvIHJlbW92ZXMgZGVzY2VuZGFudHMgYW5kIHRoZWlyIGNvbm5lY3RlZCBlZGdlc1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGpzb24gPSBqc29uc1tpXTtcblxuICAgICAgICBpZigganNvbi5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICAgIGpzb24uZGF0YS5wYXJlbnQgPSBwYXJlbnRJZCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBhcmVudElkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGN5LmFkZCgganNvbnMgKS5tZXJnZSggZGVzY3NFdGMucmVzdG9yZSgpICk7XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gaWYgbm90aGluZyBkb25lXG59O1xuXG5bXG4gIF9kZXJlcV8oJy4vYWxnb3JpdGhtcycpLFxuICBfZGVyZXFfKCcuL2FuaW1hdGlvbicpLFxuICBfZGVyZXFfKCcuL2NsYXNzJyksXG4gIF9kZXJlcV8oJy4vY29tcGFyYXRvcnMnKSxcbiAgX2RlcmVxXygnLi9jb21wb3VuZHMnKSxcbiAgX2RlcmVxXygnLi9kYXRhJyksXG4gIF9kZXJlcV8oJy4vZGVncmVlJyksXG4gIF9kZXJlcV8oJy4vZGltZW5zaW9ucycpLFxuICBfZGVyZXFfKCcuL2V2ZW50cycpLFxuICBfZGVyZXFfKCcuL2ZpbHRlcicpLFxuICBfZGVyZXFfKCcuL2dyb3VwJyksXG4gIF9kZXJlcV8oJy4vaW5kZXgnKSxcbiAgX2RlcmVxXygnLi9pdGVyYXRpb24nKSxcbiAgX2RlcmVxXygnLi9sYXlvdXQnKSxcbiAgX2RlcmVxXygnLi9zdHlsZScpLFxuICBfZGVyZXFfKCcuL3N3aXRjaC1mdW5jdGlvbnMnKSxcbiAgX2RlcmVxXygnLi90cmF2ZXJzaW5nJylcbl0uZm9yRWFjaChmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIGVsZXNmbiwgcHJvcHMgKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3Rpb247XG5cbn0se1wiLi4vaXNcIjo3NyxcIi4uL3V0aWxcIjo5NCxcIi4vYWxnb3JpdGhtc1wiOjksXCIuL2FuaW1hdGlvblwiOjEyLFwiLi9jbGFzc1wiOjEzLFwiLi9jb21wYXJhdG9yc1wiOjE0LFwiLi9jb21wb3VuZHNcIjoxNSxcIi4vZGF0YVwiOjE2LFwiLi9kZWdyZWVcIjoxNyxcIi4vZGltZW5zaW9uc1wiOjE4LFwiLi9lbGVtZW50XCI6MTksXCIuL2V2ZW50c1wiOjIwLFwiLi9maWx0ZXJcIjoyMSxcIi4vZ3JvdXBcIjoyMixcIi4vaW5kZXhcIjoyMyxcIi4vaXRlcmF0aW9uXCI6MjQsXCIuL2xheW91dFwiOjI1LFwiLi9zdHlsZVwiOjI2LFwiLi9zd2l0Y2gtZnVuY3Rpb25zXCI6MjcsXCIuL3RyYXZlcnNpbmdcIjoyOH1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gX2RlcmVxXygnLi4vaXMnKTtcbnZhciB6SW5kZXhTb3J0ID0gX2RlcmVxXygnLi96c29ydCcpO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgZWFjaDogZnVuY3Rpb24oZm4pe1xuICAgIGlmKCBpcy5mbihmbikgKXtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciByZXQgPSBmbi5hcHBseSggZWxlLCBbIGksIGVsZSBdICk7XG5cbiAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXsgYnJlYWs7IH0gLy8gZXhpdCBlYWNoIGVhcmx5IG9uIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBmb3JFYWNoOiBmdW5jdGlvbihmbiwgdGhpc0FyZyl7XG4gICAgaWYoIGlzLmZuKGZuKSApe1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IGZuLmFwcGx5KCB0aGlzQXJnLCBbIGVsZSwgaSwgdGhpcyBdICkgOiBmbiggZWxlLCBpLCB0aGlzICk7XG5cbiAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXsgYnJlYWs7IH0gLy8gZXhpdCBlYWNoIGVhcmx5IG9uIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHRvQXJyYXk6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICBhcnJheS5wdXNoKCB0aGlzW2ldICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuXG4gIHNsaWNlOiBmdW5jdGlvbihzdGFydCwgZW5kKXtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgdGhpc1NpemUgPSB0aGlzLmxlbmd0aDtcblxuICAgIGlmKCBlbmQgPT0gbnVsbCApe1xuICAgICAgZW5kID0gdGhpc1NpemU7XG4gICAgfVxuXG4gICAgaWYoIHN0YXJ0ID09IG51bGwgKXtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG5cbiAgICBpZiggc3RhcnQgPCAwICl7XG4gICAgICBzdGFydCA9IHRoaXNTaXplICsgc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYoIGVuZCA8IDAgKXtcbiAgICAgIGVuZCA9IHRoaXNTaXplICsgZW5kO1xuICAgIH1cblxuICAgIGZvcih2YXIgaSA9IHN0YXJ0OyBpID49IDAgJiYgaSA8IGVuZCAmJiBpIDwgdGhpc1NpemU7IGkrKyl7XG4gICAgICBhcnJheS5wdXNoKCB0aGlzW2ldICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oYXJyYXkpO1xuICB9LFxuXG4gIHNpemU6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICB9LFxuXG4gIGVxOiBmdW5jdGlvbihpKXtcbiAgICByZXR1cm4gdGhpc1tpXSB8fCB0aGlzLnNwYXduKCk7XG4gIH0sXG5cbiAgZmlyc3Q6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXNbMF0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuXG4gIGxhc3Q6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXNbIHRoaXMubGVuZ3RoIC0gMSBdIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcblxuICBlbXB0eTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gIH0sXG5cbiAgbm9uZW1wdHk6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICF0aGlzLmVtcHR5KCk7XG4gIH0sXG5cbiAgc29ydDogZnVuY3Rpb24oIHNvcnRGbiApe1xuICAgIGlmKCAhaXMuZm4oIHNvcnRGbiApICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc29ydGVkID0gdGhpcy50b0FycmF5KCkuc29ydCggc29ydEZuICk7XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihzb3J0ZWQpO1xuICB9LFxuXG4gIHNvcnRCeVpJbmRleDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5zb3J0KCB6SW5kZXhTb3J0ICk7XG4gIH0sXG5cbiAgekRlcHRoOiBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmKCAhZWxlICl7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICAgIC8vIHZhciBjeSA9IGVsZS5jeSgpO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgZ3JvdXAgPSBfcC5ncm91cDtcblxuICAgIGlmKCBncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgdmFyIGRlcHRoID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpLnNpemUoKSA6IDA7XG5cbiAgICAgIGlmKCAhZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7IC8vIGNoaWxkbGVzcyBub2RlcyBhbHdheXMgb24gdG9wXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICB2YXIgc3JjRGVwdGggPSBzcmMuekRlcHRoKCk7XG4gICAgICB2YXIgdGd0RGVwdGggPSB0Z3QuekRlcHRoKCk7XG5cbiAgICAgIHJldHVybiBNYXRoLm1heCggc3JjRGVwdGgsIHRndERlcHRoLCAwICk7IC8vIGRlcHRoIG9mIGRlZXBlc3QgcGFyZW50XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbn0se1wiLi4vaXNcIjo3NyxcIi4venNvcnRcIjoyOX1dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gX2RlcmVxXygnLi4vaXMnKTtcbnZhciB1dGlsID0gX2RlcmVxXygnLi4vdXRpbCcpO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICAvLyB1c2luZyBzdGFuZGFyZCBsYXlvdXQgb3B0aW9ucywgYXBwbHkgcG9zaXRpb24gZnVuY3Rpb24gKHcvIG9yIHcvbyBhbmltYXRpb24pXG4gIGxheW91dFBvc2l0aW9uczogZnVuY3Rpb24oIGxheW91dCwgb3B0aW9ucywgZm4gKXtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAgIGxheW91dC5hbmltYXRpb25zID0gW107XG5cbiAgICBpZiggb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBsYXN0Tm9kZSA9IGkgPT09IG5vZGVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgdmFyIG5ld1BvcyA9IGZuLmNhbGwoIG5vZGUsIGksIG5vZGUgKTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgICAgICBpZiggIWlzLm51bWJlcihwb3MueCkgfHwgIWlzLm51bWJlcihwb3MueSkgKXtcbiAgICAgICAgICBub2RlLnNpbGVudFBvc2l0aW9uKHsgeDogMCwgeTogMCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmkgPSBub2RlLmFuaW1hdGlvbih7XG4gICAgICAgICAgcG9zaXRpb246IG5ld1BvcyxcbiAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICAgIHN0ZXA6ICFsYXN0Tm9kZSA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICAgICAgY3kuZml0KCBvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcGxldGU6ICFsYXN0Tm9kZSA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiggb3B0aW9ucy56b29tICE9IG51bGwgKXtcbiAgICAgICAgICAgICAgY3kuem9vbSggb3B0aW9ucy56b29tICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBvcHRpb25zLnBhbiApe1xuICAgICAgICAgICAgICBjeS5wYW4oIG9wdGlvbnMucGFuICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgICAgICBjeS5maXQoIG9wdGlvbnMuZWxlcywgb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGF5b3V0LmFuaW1hdGlvbnMucHVzaCggYW5pICk7XG5cbiAgICAgICAgYW5pLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzLnBvc2l0aW9ucyggZm4gKTtcblxuICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgIGN5LmZpdCggb3B0aW9ucy5lbGVzLCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9wdGlvbnMuem9vbSAhPSBudWxsICl7XG4gICAgICAgIGN5Lnpvb20oIG9wdGlvbnMuem9vbSApO1xuICAgICAgfVxuXG4gICAgICBpZiggb3B0aW9ucy5wYW4gKXtcbiAgICAgICAgY3kucGFuKCBvcHRpb25zLnBhbiApO1xuICAgICAgfVxuXG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgbGF5b3V0OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGN5LmxheW91dCggdXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGVsZXM6IHRoaXNcbiAgICB9KSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgbWFrZUxheW91dDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICByZXR1cm4gY3kubWFrZUxheW91dCggdXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGVsZXM6IHRoaXNcbiAgICB9KSApO1xuICB9XG5cbn0pO1xuXG4vLyBhbGlhc2VzOlxuZWxlc2ZuLmNyZWF0ZUxheW91dCA9IGVsZXNmbi5tYWtlTGF5b3V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxufSx7XCIuLi9pc1wiOjc3LFwiLi4vdXRpbFwiOjk0fV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi9pcycpO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICAvLyBmdWxseSB1cGRhdGVzIChyZWNhbGN1bGF0ZXMpIHRoZSBzdHlsZSBmb3IgdGhlIGVsZW1lbnRzXG4gIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgaWYoIGN5Ll9wcml2YXRlLmJhdGNoaW5nU3R5bGUgKXtcbiAgICAgIHZhciBiRWxlcyA9IGN5Ll9wcml2YXRlLmJhdGNoU3R5bGVFbGVzO1xuXG4gICAgICBiRWxlcy5tZXJnZSggdGhpcyApO1xuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmcgYW5kIGV4aXQgZWFybHkgd2hlbiBiYXRjaGluZ1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSBub3RpZnlSZW5kZXJlciB8fCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgc3R5bGUuYXBwbHkoIHRoaXMgKTtcblxuICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgIHZhciB0b05vdGlmeSA9IHVwZGF0ZWRDb21wb3VuZHMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkQ29tcG91bmRzICkgOiB0aGlzO1xuXG4gICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgIH0gZWxzZSB7XG4gICAgICB0b05vdGlmeS50cmlnZ2VyKCdzdHlsZScpOyAvLyBqdXN0IGZpcmUgdGhlIGV2ZW50XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIC8vIGp1c3QgdXBkYXRlIHRoZSBtYXBwZXJzIGluIHRoZSBlbGVtZW50cycgc3R5bGVzOyBjaGVhcGVyIHRoYW4gZWxlcy51cGRhdGVTdHlsZSgpXG4gIHVwZGF0ZU1hcHBlcnM6IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICBub3RpZnlSZW5kZXJlciA9IG5vdGlmeVJlbmRlcmVyIHx8IG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICBzdHlsZS51cGRhdGVNYXBwZXJzKCB0aGlzICk7XG5cbiAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcblxuICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCByZW5kZXJlciBrbm93IHdlIGNoYW5nZWQgc3R5bGVcbiAgICB9IGVsc2Uge1xuICAgICAgdG9Ob3RpZnkudHJpZ2dlcignc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyBnZXQgdGhlIHNwZWNpZmllZCBjc3MgcHJvcGVydHkgYXMgYSByZW5kZXJlZCB2YWx1ZSAoaS5lLiBvbi1zY3JlZW4gdmFsdWUpXG4gIC8vIG9yIGdldCB0aGUgd2hvbGUgcmVuZGVyZWQgc3R5bGUgaWYgbm8gcHJvcGVydHkgc3BlY2lmaWVkIChOQiBkb2Vzbid0IGFsbG93IHNldHRpbmcpXG4gIHJlbmRlcmVkQ3NzOiBmdW5jdGlvbiggcHJvcGVydHkgKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICB2YXIgcmVuc3R5bGUgPSBlbGUuY3koKS5zdHlsZSgpLmdldFJlbmRlcmVkU3R5bGUoIGVsZSApO1xuXG4gICAgICBpZiggcHJvcGVydHkgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gcmVuc3R5bGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVuc3R5bGVbIHByb3BlcnR5IF07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIHJlYWQgdGhlIGNhbGN1bGF0ZWQgY3NzIHN0eWxlIG9mIHRoZSBlbGVtZW50IG9yIG92ZXJyaWRlIHRoZSBzdHlsZSAodmlhIGEgYnlwYXNzKVxuICBjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG5cbiAgICBpZiggaXMucGxhaW5PYmplY3QobmFtZSkgKXsgLy8gdGhlbiBleHRlbmQgdGhlIGJ5cGFzc1xuICAgICAgdmFyIHByb3BzID0gbmFtZTtcbiAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKCB0aGlzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMgKTtcblxuICAgICAgdmFyIHVwZGF0ZWRDb21wb3VuZHMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcbiAgICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuXG4gICAgfSBlbHNlIGlmKCBpcy5zdHJpbmcobmFtZSkgKXtcblxuICAgICAgaWYoIHZhbHVlID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKCBlbGUsIG5hbWUgKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7IC8vIHRoZW4gc2V0IHRoZSBieXBhc3Mgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgc3R5bGUuYXBwbHlCeXBhc3MoIHRoaXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuXG4gICAgICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcbiAgICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYoIG5hbWUgPT09IHVuZGVmaW5lZCApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIHN0eWxlLmdldFJhd1N0eWxlKCBlbGUgKTtcbiAgICAgIH0gZWxzZSB7IC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcmVtb3ZlQ3NzOiBmdW5jdGlvbiggbmFtZXMgKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGlmKCBuYW1lcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgc3R5bGUucmVtb3ZlQWxsQnlwYXNzZXMoIGVsZSwgdXBkYXRlVHJhbnNpdGlvbnMgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZXMgPSBuYW1lcy5zcGxpdCgvXFxzKy8pO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgc3R5bGUucmVtb3ZlQnlwYXNzZXMoIGVsZSwgbmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZWRDb21wb3VuZHMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG4gICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbigpe1xuICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ2VsZW1lbnQnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBoaWRlOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB2aXNpYmxlOiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0cnVlOyB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgaWYoXG4gICAgICAgIHN0eWxlWyd2aXNpYmlsaXR5J10udmFsdWUgIT09ICd2aXNpYmxlJ1xuICAgICAgICB8fCBzdHlsZVsnZGlzcGxheSddLnZhbHVlICE9PSAnZWxlbWVudCdcbiAgICAgICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgICB2YXIgcGFyZW50cyA9IGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkgOiBudWxsO1xuXG4gICAgICAgIGlmKCBwYXJlbnRzICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBwU3R5bGUgPSBwYXJlbnQuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgICAgICB2YXIgcFZpcyA9IHBTdHlsZVsndmlzaWJpbGl0eSddLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHBEaXMgPSBwU3R5bGVbJ2Rpc3BsYXknXS52YWx1ZTtcblxuICAgICAgICAgICAgaWYoIHBWaXMgIT09ICd2aXNpYmxlJyB8fCBwRGlzICE9PSAnZWxlbWVudCcgKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBlbGUuX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgICAgIHJldHVybiBzcmMudmlzaWJsZSgpICYmIHRndC52aXNpYmxlKCk7XG4gICAgICB9XG5cbiAgICB9XG4gIH0sXG5cbiAgaGlkZGVuOiBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICAgIH1cbiAgfSxcblxuICBlZmZlY3RpdmVPcGFjaXR5OiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiAxOyB9XG5cbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gX3Auc3R5bGUub3BhY2l0eS52YWx1ZTtcblxuICAgICAgaWYoICFoYXNDb21wb3VuZE5vZGVzICl7IHJldHVybiBwYXJlbnRPcGFjaXR5OyB9XG5cbiAgICAgIHZhciBwYXJlbnRzID0gIV9wLmRhdGEucGFyZW50ID8gbnVsbCA6IGVsZS5wYXJlbnRzKCk7XG5cbiAgICAgIGlmKCBwYXJlbnRzICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgIHZhciBvcGFjaXR5ID0gcGFyZW50Ll9wcml2YXRlLnN0eWxlLm9wYWNpdHkudmFsdWU7XG5cbiAgICAgICAgICBwYXJlbnRPcGFjaXR5ID0gb3BhY2l0eSAqIHBhcmVudE9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgfVxuICB9LFxuXG4gIHRyYW5zcGFyZW50OiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBlbGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZS5vcGFjaXR5LnZhbHVlID09PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgPT09IDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGlzRnVsbEF1dG9QYXJlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBhdXRvVyA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS52YWx1ZSA9PT0gJ2F1dG8nO1xuICAgICAgdmFyIGF1dG9IID0gZWxlLl9wcml2YXRlLnN0eWxlWydoZWlnaHQnXS52YWx1ZSA9PT0gJ2F1dG8nO1xuXG4gICAgICByZXR1cm4gZWxlLmlzUGFyZW50KCkgJiYgYXV0b1cgJiYgYXV0b0g7XG4gICAgfVxuICB9LFxuXG4gIGJhY2tncm91bmRpbmc6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYmFja2dyb3VuZGluZyA/IHRydWUgOiBmYWxzZTtcbiAgfVxuXG59KTtcblxuXG5lbGVzZm4uYnlwYXNzID0gZWxlc2ZuLnN0eWxlID0gZWxlc2ZuLmNzcztcbmVsZXNmbi5yZW5kZXJlZFN0eWxlID0gZWxlc2ZuLnJlbmRlcmVkQ3NzO1xuZWxlc2ZuLnJlbW92ZUJ5cGFzcyA9IGVsZXNmbi5yZW1vdmVTdHlsZSA9IGVsZXNmbi5yZW1vdmVDc3M7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG59LHtcIi4uL2lzXCI6Nzd9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbGVzZm4gPSB7fTtcblxuZnVuY3Rpb24gZGVmaW5lU3dpdGNoRnVuY3Rpb24ocGFyYW1zKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGNoYW5nZWRFbGVzID0gW107XG5cbiAgICAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBkYXRhLCBoYW5kbGVyIClcbiAgICBpZiggYXJncy5sZW5ndGggPT09IDIgKXtcbiAgICAgIHZhciBkYXRhID0gYXJnc1swXTtcbiAgICAgIHZhciBoYW5kbGVyID0gYXJnc1sxXTtcbiAgICAgIHRoaXMuYmluZCggcGFyYW1zLmV2ZW50LCBkYXRhLCBoYW5kbGVyICk7XG4gICAgfVxuXG4gICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggaGFuZGxlciApXG4gICAgZWxzZSBpZiggYXJncy5sZW5ndGggPT09IDEgKXtcbiAgICAgIHZhciBoYW5kbGVyID0gYXJnc1swXTtcbiAgICAgIHRoaXMuYmluZCggcGFyYW1zLmV2ZW50LCBoYW5kbGVyICk7XG4gICAgfVxuXG4gICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCgpXG4gICAgZWxzZSBpZiggYXJncy5sZW5ndGggPT09IDAgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIGFibGUgPSAhcGFyYW1zLmFibGVGaWVsZCB8fCBlbGUuX3ByaXZhdGVbcGFyYW1zLmFibGVGaWVsZF07XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gIT0gcGFyYW1zLnZhbHVlO1xuXG4gICAgICAgIGlmKCBwYXJhbXMub3ZlcnJpZGVBYmxlICl7XG4gICAgICAgICAgdmFyIG92ZXJyaWRlQWJsZSA9IHBhcmFtcy5vdmVycmlkZUFibGUoZWxlKTtcblxuICAgICAgICAgIGlmKCBvdmVycmlkZUFibGUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgYWJsZSA9IG92ZXJyaWRlQWJsZTtcblxuICAgICAgICAgICAgaWYoICFvdmVycmlkZUFibGUgKXsgcmV0dXJuIHRoaXM7IH0gLy8gdG8gc2F2ZSBjeWNsZXMgYXNzdW1lIG5vdCBhYmxlIGZvciBhbGwgb24gb3ZlcnJpZGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggYWJsZSApe1xuICAgICAgICAgIGVsZS5fcHJpdmF0ZVtwYXJhbXMuZmllbGRdID0gcGFyYW1zLnZhbHVlO1xuXG4gICAgICAgICAgaWYoIGNoYW5nZWQgKXtcbiAgICAgICAgICAgIGNoYW5nZWRFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlZENvbGwgPSB0aGlzLnNwYXduKCBjaGFuZ2VkRWxlcyApO1xuICAgICAgY2hhbmdlZENvbGwudXBkYXRlU3R5bGUoKTsgLy8gY2hhbmdlIG9mIHN0YXRlID0+IHBvc3NpYmxlIGNoYW5nZSBvZiBzdHlsZVxuICAgICAgY2hhbmdlZENvbGwudHJpZ2dlciggcGFyYW1zLmV2ZW50ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZmluZVN3aXRjaFNldCggcGFyYW1zICl7XG4gIGVsZXNmblsgcGFyYW1zLmZpZWxkIF0gPSBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgaWYoIHBhcmFtcy5vdmVycmlkZUZpZWxkICl7XG4gICAgICAgIHZhciB2YWwgPSBwYXJhbXMub3ZlcnJpZGVGaWVsZChlbGUpO1xuXG4gICAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZVsgcGFyYW1zLmZpZWxkIF07XG4gICAgfVxuICB9O1xuXG4gIGVsZXNmblsgcGFyYW1zLm9uIF0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgZXZlbnQ6IHBhcmFtcy5vbixcbiAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgZWxlc2ZuWyBwYXJhbXMub2ZmIF0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgZXZlbnQ6IHBhcmFtcy5vZmYsXG4gICAgZmllbGQ6IHBhcmFtcy5maWVsZCxcbiAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgb3ZlcnJpZGVBYmxlOiBwYXJhbXMub3ZlcnJpZGVBYmxlLFxuICAgIHZhbHVlOiBmYWxzZVxuICB9KTtcbn1cblxuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdsb2NrZWQnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbihlbGUpe1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvbG9jaygpID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdsb2NrJyxcbiAgb2ZmOiAndW5sb2NrJ1xufSk7XG5cbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnZ3JhYmJhYmxlJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24oZWxlKXtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3VuZ3JhYmlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnZ3JhYmlmeScsXG4gIG9mZjogJ3VuZ3JhYmlmeSdcbn0pO1xuXG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3NlbGVjdGVkJyxcbiAgYWJsZUZpZWxkOiAnc2VsZWN0YWJsZScsXG4gIG92ZXJyaWRlQWJsZTogZnVuY3Rpb24oZWxlKXtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3Vuc2VsZWN0aWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdzZWxlY3QnLFxuICBvZmY6ICd1bnNlbGVjdCdcbn0pO1xuXG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3NlbGVjdGFibGUnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbihlbGUpe1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ3NlbGVjdGlmeScsXG4gIG9mZjogJ3Vuc2VsZWN0aWZ5J1xufSk7XG5cbmVsZXNmbi5kZXNlbGVjdCA9IGVsZXNmbi51bnNlbGVjdDtcblxuZWxlc2ZuLmdyYWJiZWQgPSBmdW5jdGlvbigpe1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgaWYoIGVsZSApe1xuICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JhYmJlZDtcbiAgfVxufTtcblxuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdhY3RpdmUnLFxuICBvbjogJ2FjdGl2YXRlJyxcbiAgb2ZmOiAndW5hY3RpdmF0ZSdcbn0pO1xuXG5lbGVzZm4uaW5hY3RpdmUgPSBmdW5jdGlvbigpe1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgaWYoIGVsZSApe1xuICAgIHJldHVybiAhZWxlLl9wcml2YXRlLmFjdGl2ZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbn0se31dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi91dGlsJyk7XG52YXIgaXMgPSBfZGVyZXFfKCcuLi9pcycpO1xuXG52YXIgZWxlc2ZuID0ge307XG5cbnV0aWwuZXh0ZW5kKGVsZXNmbiwge1xuICAvLyBnZXQgdGhlIHJvb3Qgbm9kZXMgaW4gdGhlIERBR1xuICByb290czogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciByb290cyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzRWRnZXNQb2ludGluZ0luID0gZWxlLmNvbm5lY3RlZEVkZ2VzKGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ3RhcmdldCcpID09PSBlbGUuaWQoKSAmJiB0aGlzLmRhdGEoJ3NvdXJjZScpICE9PSBlbGUuaWQoKTtcbiAgICAgIH0pLmxlbmd0aCA+IDA7XG5cbiAgICAgIGlmKCAhaGFzRWRnZXNQb2ludGluZ0luICl7XG4gICAgICAgIHJvb3RzLnB1c2goIGVsZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCByb290cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICAvLyBnZXQgdGhlIGxlYWYgbm9kZXMgaW4gdGhlIERBR1xuICBsZWF2ZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgbGVhdmVzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNFZGdlc1BvaW50aW5nT3V0ID0gZWxlLmNvbm5lY3RlZEVkZ2VzKGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ3NvdXJjZScpID09PSBlbGUuaWQoKSAmJiB0aGlzLmRhdGEoJ3RhcmdldCcpICE9PSBlbGUuaWQoKTtcbiAgICAgIH0pLmxlbmd0aCA+IDA7XG5cbiAgICAgIGlmKCAhaGFzRWRnZXNQb2ludGluZ091dCApe1xuICAgICAgICBsZWF2ZXMucHVzaCggZWxlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGxlYXZlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICAvLyBub3JtYWxseSBjYWxsZWQgY2hpbGRyZW4gaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzID1lZGdlcz0+IG91dGdvaW5nIG5vZGVzXG4gIG91dGdvZXJzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIG9FbGVzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIGVsZUlkID0gZWxlLmlkKCk7XG5cbiAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIHZhciBlZGdlcyA9IGVsZS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyY0lkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndElkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnRhcmdldDtcblxuICAgICAgICBpZiggc3JjSWQgPT09IGVsZUlkICYmIHRndElkICE9PSBlbGVJZCApe1xuICAgICAgICAgIG9FbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlLnRhcmdldCgpWzBdICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggb0VsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgLy8gYWthIERBRyBkZXNjZW5kYW50c1xuICBzdWNjZXNzb3JzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHNFbGVzID0gW107XG4gICAgdmFyIHNFbGVzSWRzID0ge307XG5cbiAgICBmb3IoOzspe1xuICAgICAgdmFyIG91dGdvZXJzID0gZWxlcy5vdXRnb2VycygpO1xuXG4gICAgICBpZiggb3V0Z29lcnMubGVuZ3RoID09PSAwICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgbm8gb3V0Z29lcnMgbGVmdFxuXG4gICAgICB2YXIgbmV3T3V0Z29lcnMgPSBmYWxzZTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3V0Z29lcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG91dGdvZXIgPSBvdXRnb2Vyc1tpXTtcbiAgICAgICAgdmFyIG91dGdvZXJJZCA9IG91dGdvZXIuaWQoKTtcblxuICAgICAgICBpZiggIXNFbGVzSWRzWyBvdXRnb2VySWQgXSApe1xuICAgICAgICAgIHNFbGVzSWRzWyBvdXRnb2VySWQgXSA9IHRydWU7XG4gICAgICAgICAgc0VsZXMucHVzaCggb3V0Z29lciApO1xuICAgICAgICAgIG5ld091dGdvZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggIW5ld091dGdvZXJzICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgdG91Y2hlZCBhbGwgb3V0Z29lcnMgYWxyZWFkeVxuXG4gICAgICBlbGVzID0gb3V0Z29lcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHNFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIC8vIG5vcm1hbGx5IGNhbGxlZCBwYXJlbnRzIGluIGdyYXBoIHRoZW9yeVxuICAvLyB0aGVzZSBub2RlcyA8PWVkZ2VzPSBpbmNvbWluZyBub2Rlc1xuICBpbmNvbWVyczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBvRWxlcyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBlbGVJZCA9IGVsZS5pZCgpO1xuXG4gICAgICBpZiggIWVsZS5pc05vZGUoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICB2YXIgZWRnZXMgPSBlbGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgIHZhciBzcmNJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3RJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS50YXJnZXQ7XG5cbiAgICAgICAgaWYoIHRndElkID09PSBlbGVJZCAmJiBzcmNJZCAhPT0gZWxlSWQgKXtcbiAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgICAgb0VsZXMucHVzaCggZWRnZS5zb3VyY2UoKVswXSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIG9FbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIC8vIGFrYSBEQUcgYW5jZXN0b3JzXG4gIHByZWRlY2Vzc29yczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBwRWxlcyA9IFtdO1xuICAgIHZhciBwRWxlc0lkcyA9IHt9O1xuXG4gICAgZm9yKDs7KXtcbiAgICAgIHZhciBpbmNvbWVycyA9IGVsZXMuaW5jb21lcnMoKTtcblxuICAgICAgaWYoIGluY29tZXJzLmxlbmd0aCA9PT0gMCApeyBicmVhazsgfSAvLyBkb25lIGlmIG5vIGluY29tZXJzIGxlZnRcblxuICAgICAgdmFyIG5ld0luY29tZXJzID0gZmFsc2U7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGluY29tZXJzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBpbmNvbWVyID0gaW5jb21lcnNbaV07XG4gICAgICAgIHZhciBpbmNvbWVySWQgPSBpbmNvbWVyLmlkKCk7XG5cbiAgICAgICAgaWYoICFwRWxlc0lkc1sgaW5jb21lcklkIF0gKXtcbiAgICAgICAgICBwRWxlc0lkc1sgaW5jb21lcklkIF0gPSB0cnVlO1xuICAgICAgICAgIHBFbGVzLnB1c2goIGluY29tZXIgKTtcbiAgICAgICAgICBuZXdJbmNvbWVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoICFuZXdJbmNvbWVycyApeyBicmVhazsgfSAvLyBkb25lIGlmIHRvdWNoZWQgYWxsIGluY29tZXJzIGFscmVhZHlcblxuICAgICAgZWxlcyA9IGluY29tZXJzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBwRWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfVxufSk7XG5cblxuLy8gTmVpZ2hib3VyaG9vZCBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnV0aWwuZXh0ZW5kKGVsZXNmbiwge1xuICBuZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7IC8vIGZvciBhbGwgbm9kZXNcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIC8vIGZvciBlYWNoIGNvbm5lY3RlZCBlZGdlLCBhZGQgdGhlIGVkZ2UgYW5kIHRoZSBvdGhlciBub2RlXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLl9wcml2YXRlLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UuX3ByaXZhdGUudGFyZ2V0O1xuICAgICAgICB2YXIgb3RoZXJOb2RlID0gbm9kZSA9PT0gc3JjID8gdGd0IDogc3JjO1xuXG4gICAgICAgIC8vIG5lZWQgY2hlY2sgaW4gY2FzZSBvZiBsb29wXG4gICAgICAgIGlmKCBvdGhlck5vZGUubGVuZ3RoID4gMCApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIG90aGVyTm9kZVswXSApOyAvLyBhZGQgbm9kZSAxIGhvcCBhd2F5XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgY29ubmVjdGVkIGVkZ2VcbiAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZVswXSApO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuICggdGhpcy5zcGF3biggZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBjbG9zZWROZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoKS5hZGQoIHRoaXMgKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgb3Blbk5laWdoYm9yaG9vZDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCggc2VsZWN0b3IgKTtcbiAgfVxufSk7XG5cbi8vIGFsaWFzZXNcbmVsZXNmbi5uZWlnaGJvdXJob29kID0gZWxlc2ZuLm5laWdoYm9yaG9vZDtcbmVsZXNmbi5jbG9zZWROZWlnaGJvdXJob29kID0gZWxlc2ZuLmNsb3NlZE5laWdoYm9yaG9vZDtcbmVsZXNmbi5vcGVuTmVpZ2hib3VyaG9vZCA9IGVsZXNmbi5vcGVuTmVpZ2hib3Job29kO1xuXG4vLyBFZGdlIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy9cblxudXRpbC5leHRlbmQoZWxlc2ZuLCB7XG4gIHNvdXJjZTogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIHNyYztcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHNyYyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNyYyAmJiBzZWxlY3RvciA/IHNyYy5maWx0ZXIoIHNlbGVjdG9yICkgOiBzcmM7XG4gIH0sXG5cbiAgdGFyZ2V0OiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgdGd0O1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgdGd0ID0gZWxlLl9wcml2YXRlLnRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGd0ICYmIHNlbGVjdG9yID8gdGd0LmZpbHRlciggc2VsZWN0b3IgKSA6IHRndDtcbiAgfSxcblxuICBzb3VyY2VzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgYXR0cjogJ3NvdXJjZSdcbiAgfSksXG5cbiAgdGFyZ2V0czogZGVmaW5lU291cmNlRnVuY3Rpb24oe1xuICAgIGF0dHI6ICd0YXJnZXQnXG4gIH0pXG59KTtcblxuZnVuY3Rpb24gZGVmaW5lU291cmNlRnVuY3Rpb24oIHBhcmFtcyApe1xuICByZXR1cm4gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgc3JjID0gZWxlLl9wcml2YXRlWyBwYXJhbXMuYXR0ciBdO1xuXG4gICAgICBpZiggc3JjICl7XG4gICAgICAgIHNvdXJjZXMucHVzaCggc3JjICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHNvdXJjZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH07XG59XG5cbnV0aWwuZXh0ZW5kKGVsZXNmbiwge1xuICBlZGdlc1dpdGg6IGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKCksXG5cbiAgZWRnZXNUbzogZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oe1xuICAgIHRoaXNJczogJ3NvdXJjZSdcbiAgfSlcbn0pO1xuXG5mdW5jdGlvbiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbiggcGFyYW1zICl7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGVkZ2VzV2l0aEltcGwoIG90aGVyTm9kZXMgKXtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBwID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgLy8gZ2V0IGVsZW1lbnRzIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkXG4gICAgaWYoIGlzLnN0cmluZyhvdGhlck5vZGVzKSApe1xuICAgICAgb3RoZXJOb2RlcyA9IGN5LiQoIG90aGVyTm9kZXMgKTtcbiAgICB9XG5cbiAgICB2YXIgdGhpc0lkcyA9IHRoaXMuX3ByaXZhdGUuaWRzO1xuICAgIHZhciBvdGhlcklkcyA9IG90aGVyTm9kZXMuX3ByaXZhdGUuaWRzO1xuXG4gICAgZm9yKCB2YXIgaCA9IDA7IGggPCBvdGhlck5vZGVzLmxlbmd0aDsgaCsrICl7XG4gICAgICB2YXIgZWRnZXMgPSBvdGhlck5vZGVzW2hdLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBlZGdlRGF0YSA9IGVkZ2UuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgdmFyIHRoaXNUb090aGVyID0gdGhpc0lkc1sgZWRnZURhdGEuc291cmNlIF0gJiYgb3RoZXJJZHNbIGVkZ2VEYXRhLnRhcmdldCBdO1xuICAgICAgICB2YXIgb3RoZXJUb1RoaXMgPSBvdGhlcklkc1sgZWRnZURhdGEuc291cmNlIF0gJiYgdGhpc0lkc1sgZWRnZURhdGEudGFyZ2V0IF07XG4gICAgICAgIHZhciBlZGdlQ29ubmVjdHNUaGlzQW5kT3RoZXIgPSB0aGlzVG9PdGhlciB8fCBvdGhlclRvVGhpcztcblxuICAgICAgICBpZiggIWVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIGlmKCBwLnRoaXNJcyApe1xuICAgICAgICAgIGlmKCBwLnRoaXNJcyA9PT0gJ3NvdXJjZScgJiYgIXRoaXNUb090aGVyICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICBpZiggcC50aGlzSXMgPT09ICd0YXJnZXQnICYmICFvdGhlclRvVGhpcyApeyBjb250aW51ZTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApO1xuICB9O1xufVxuXG51dGlsLmV4dGVuZChlbGVzZm4sIHtcbiAgY29ubmVjdGVkRWRnZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciByZXRFbGVzID0gW107XG5cbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbm9kZSA9IGVsZXNbaV07XG4gICAgICBpZiggIW5vZGUuaXNOb2RlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgdmFyIGVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICByZXRFbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggcmV0RWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBjb25uZWN0ZWROb2RlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIHJldEVsZXMgPSBbXTtcblxuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlZGdlID0gZWxlc1tpXTtcbiAgICAgIGlmKCAhZWRnZS5pc0VkZ2UoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICByZXRFbGVzLnB1c2goIGVkZ2Uuc291cmNlKClbMF0gKTtcbiAgICAgIHJldEVsZXMucHVzaCggZWRnZS50YXJnZXQoKVswXSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCByZXRFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIHBhcmFsbGVsRWRnZXM6IGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbigpLFxuXG4gIGNvZGlyZWN0ZWRFZGdlczogZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHtcbiAgICBjb2RpcmVjdGVkOiB0cnVlXG4gIH0pXG59KTtcblxuZnVuY3Rpb24gZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHBhcmFtcyl7XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBjb2RpcmVjdGVkOiBmYWxzZVxuICB9O1xuICBwYXJhbXMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICB2YXIgcCA9IHBhcmFtcztcblxuICAgIC8vIGxvb2sgYXQgYWxsIHRoZSBlZGdlcyBpbiB0aGUgY29sbGVjdGlvblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlZGdlMSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIHNyYzEgPSBlZGdlMS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciBzcmNpZDEgPSBzcmMxLmlkKCk7XG4gICAgICB2YXIgdGd0MSA9IGVkZ2UxLnRhcmdldCgpWzBdO1xuICAgICAgdmFyIHRndGlkMSA9IHRndDEuaWQoKTtcbiAgICAgIHZhciBzcmNFZGdlczEgPSBzcmMxLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICAvLyBsb29rIGF0IGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc3JjIG5vZGUgb2YgdGhpcyBlZGdlXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHNyY0VkZ2VzMS5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgZWRnZTIgPSBzcmNFZGdlczFbal07XG4gICAgICAgIHZhciBlZGdlMmRhdGEgPSBlZGdlMi5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICB2YXIgdGd0aWQyID0gZWRnZTJkYXRhLnRhcmdldDtcbiAgICAgICAgdmFyIHNyY2lkMiA9IGVkZ2UyZGF0YS5zb3VyY2U7XG5cbiAgICAgICAgdmFyIGNvZGlyZWN0ZWQgPSB0Z3RpZDIgPT09IHRndGlkMSAmJiBzcmNpZDIgPT09IHNyY2lkMTtcbiAgICAgICAgdmFyIG9wcGRpcmVjdGVkID0gc3JjaWQxID09PSB0Z3RpZDIgJiYgdGd0aWQxID09PSBzcmNpZDI7XG5cbiAgICAgICAgaWYoIChwLmNvZGlyZWN0ZWQgJiYgY29kaXJlY3RlZCkgfHwgKCFwLmNvZGlyZWN0ZWQgJiYgKGNvZGlyZWN0ZWQgfHwgb3BwZGlyZWN0ZWQpKSApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVkZ2UyICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH07XG5cbn1cblxuLy8gTWlzYyBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vXG5cbnV0aWwuZXh0ZW5kKGVsZXNmbiwge1xuICBjb21wb25lbnRzOiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgdmlzaXRlZCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB2YXIgdW52aXNpdGVkID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG5cbiAgICB2YXIgdmlzaXRJbkNvbXBvbmVudCA9IGZ1bmN0aW9uKCBub2RlLCBjb21wb25lbnQgKXtcbiAgICAgIHZpc2l0ZWQubWVyZ2UoIG5vZGUgKTtcbiAgICAgIHVudmlzaXRlZC51bm1lcmdlKCBub2RlICk7XG4gICAgICBjb21wb25lbnQubWVyZ2UoIG5vZGUgKTtcbiAgICB9O1xuXG4gICAgZG8ge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaCggY29tcG9uZW50ICk7XG5cbiAgICAgIHZhciByb290ID0gdW52aXNpdGVkWzBdO1xuICAgICAgdmlzaXRJbkNvbXBvbmVudCggcm9vdCwgY29tcG9uZW50ICk7XG5cbiAgICAgIHRoaXMuYmZzKHtcbiAgICAgICAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAgICAgICByb290czogcm9vdCxcbiAgICAgICAgdmlzaXQ6IGZ1bmN0aW9uKCBpLCBkZXB0aCwgdiwgZSwgdSApe1xuICAgICAgICAgIHZpc2l0SW5Db21wb25lbnQoIHYsIGNvbXBvbmVudCApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH0gd2hpbGUoIHVudmlzaXRlZC5sZW5ndGggPiAwICk7XG5cbiAgICByZXR1cm4gY29tcG9uZW50cy5tYXAoZnVuY3Rpb24oIGNvbXBvbmVudCApe1xuICAgICAgcmV0dXJuIGNvbXBvbmVudC5jbG9zZWROZWlnaGJvcmhvb2QoKTsgLy8gYWRkIHRoZSBlZGdlc1xuICAgIH0pO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbn0se1wiLi4vaXNcIjo3NyxcIi4uL3V0aWxcIjo5NH1dLDI5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHpJbmRleFNvcnQgPSBmdW5jdGlvbiggYSwgYiApe1xuICB2YXIgY3kgPSBhLmN5KCk7XG4gIHZhciBhX3AgPSBhLl9wcml2YXRlO1xuICB2YXIgYl9wID0gYi5fcHJpdmF0ZTtcbiAgdmFyIHpEaWZmID0gYV9wLnN0eWxlWyd6LWluZGV4J10udmFsdWUgLSBiX3Auc3R5bGVbJ3otaW5kZXgnXS52YWx1ZTtcbiAgdmFyIGRlcHRoQSA9IDA7XG4gIHZhciBkZXB0aEIgPSAwO1xuICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGFJc05vZGUgPSBhX3AuZ3JvdXAgPT09ICdub2Rlcyc7XG4gIHZhciBhSXNFZGdlID0gYV9wLmdyb3VwID09PSAnZWRnZXMnO1xuICB2YXIgYklzTm9kZSA9IGJfcC5ncm91cCA9PT0gJ25vZGVzJztcbiAgdmFyIGJJc0VkZ2UgPSBiX3AuZ3JvdXAgPT09ICdlZGdlcyc7XG5cbiAgLy8gbm8gbmVlZCB0byBjYWxjdWxhdGUgZWxlbWVudCBkZXB0aCBpZiB0aGVyZSBpcyBubyBjb21wb3VuZCBub2RlXG4gIGlmKCBoYXNDb21wb3VuZE5vZGVzICl7XG4gICAgZGVwdGhBID0gYS56RGVwdGgoKTtcbiAgICBkZXB0aEIgPSBiLnpEZXB0aCgpO1xuICB9XG5cbiAgdmFyIGRlcHRoRGlmZiA9IGRlcHRoQSAtIGRlcHRoQjtcbiAgdmFyIHNhbWVEZXB0aCA9IGRlcHRoRGlmZiA9PT0gMDtcblxuICBpZiggc2FtZURlcHRoICl7XG5cbiAgICBpZiggYUlzTm9kZSAmJiBiSXNFZGdlICl7XG4gICAgICByZXR1cm4gMTsgLy8gJ2EnIGlzIGEgbm9kZSwgaXQgc2hvdWxkIGJlIGRyYXduIGxhdGVyXG5cbiAgICB9IGVsc2UgaWYoIGFJc0VkZ2UgJiYgYklzTm9kZSApe1xuICAgICAgcmV0dXJuIC0xOyAvLyAnYScgaXMgYW4gZWRnZSwgaXQgc2hvdWxkIGJlIGRyYXduIGZpcnN0XG5cbiAgICB9IGVsc2UgeyAvLyBib3RoIG5vZGVzIG9yIGJvdGggZWRnZXNcbiAgICAgIGlmKCB6RGlmZiA9PT0gMCApeyAvLyBzYW1lIHotaW5kZXggPT4gY29tcGFyZSBpbmRpY2VzIGluIHRoZSBjb3JlIChvcmRlciBhZGRlZCB0byBncmFwaCB3LyBsYXN0IG9uIHRvcClcbiAgICAgICAgcmV0dXJuIGFfcC5pbmRleCAtIGJfcC5pbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB6RGlmZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgLy8gZWxlbWVudHMgb24gZGlmZmVyZW50IGxldmVsXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRlcHRoRGlmZjsgLy8gZGVlcGVyIGVsZW1lbnQgc2hvdWxkIGJlIGRyYXduIGxhdGVyXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB6SW5kZXhTb3J0O1xuXG59LHt9XSwzMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IF9kZXJlcV8oJy4uL2lzJyk7XG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uL3V0aWwnKTtcbnZhciBDb2xsZWN0aW9uID0gX2RlcmVxXygnLi4vY29sbGVjdGlvbicpO1xudmFyIEVsZW1lbnQgPSBfZGVyZXFfKCcuLi9jb2xsZWN0aW9uL2VsZW1lbnQnKTtcbnZhciB3aW5kb3cgPSBfZGVyZXFfKCcuLi93aW5kb3cnKTtcbnZhciBkb2N1bWVudCA9IHdpbmRvdyA/IHdpbmRvdy5kb2N1bWVudCA6IG51bGw7XG52YXIgTnVsbFJlbmRlcmVyID0gX2RlcmVxXygnLi4vZXh0ZW5zaW9ucy9yZW5kZXJlci9udWxsJyk7XG5cbnZhciBjb3JlZm4gPSB7XG4gIGFkZDogZnVuY3Rpb24ob3B0cyl7XG5cbiAgICB2YXIgZWxlbWVudHM7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIC8vIGFkZCB0aGUgZWxlbWVudHNcbiAgICBpZiggaXMuZWxlbWVudE9yQ29sbGVjdGlvbihvcHRzKSApe1xuICAgICAgdmFyIGVsZXMgPSBvcHRzO1xuXG4gICAgICBpZiggZWxlcy5fcHJpdmF0ZS5jeSA9PT0gY3kgKXsgLy8gc2FtZSBpbnN0YW5jZSA9PiBqdXN0IHJlc3RvcmVcbiAgICAgICAgZWxlbWVudHMgPSBlbGVzLnJlc3RvcmUoKTtcblxuICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlLCBjb3B5IGZyb20ganNvblxuICAgICAgICB2YXIganNvbnMgPSBbXTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICBqc29ucy5wdXNoKCBlbGUuanNvbigpICk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKCBjeSwganNvbnMgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzcGVjaWZ5IGFuIGFycmF5IG9mIG9wdGlvbnNcbiAgICBlbHNlIGlmKCBpcy5hcnJheShvcHRzKSApe1xuICAgICAgdmFyIGpzb25zID0gb3B0cztcblxuICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgIH1cblxuICAgIC8vIHNwZWNpZnkgdmlhIG9wdHMubm9kZXMgYW5kIG9wdHMuZWRnZXNcbiAgICBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdChvcHRzKSAmJiAoaXMuYXJyYXkob3B0cy5ub2RlcykgfHwgaXMuYXJyYXkob3B0cy5lZGdlcykpICl7XG4gICAgICB2YXIgZWxlc0J5R3JvdXAgPSBvcHRzO1xuICAgICAgdmFyIGpzb25zID0gW107XG5cbiAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG4gICAgICBmb3IoIHZhciBpID0gMCwgaWwgPSBncnMubGVuZ3RoOyBpIDwgaWw7IGkrKyApe1xuICAgICAgICB2YXIgZ3JvdXAgPSBncnNbaV07XG4gICAgICAgIHZhciBlbGVzQXJyYXkgPSBlbGVzQnlHcm91cFtncm91cF07XG5cbiAgICAgICAgaWYoIGlzLmFycmF5KGVsZXNBcnJheSkgKXtcblxuICAgICAgICAgIGZvciggdmFyIGogPSAwLCBqbCA9IGVsZXNBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrICl7XG4gICAgICAgICAgICB2YXIganNvbiA9IHV0aWwuZXh0ZW5kKCB7IGdyb3VwOiBncm91cCB9LCBlbGVzQXJyYXlbal0gKTtcblxuICAgICAgICAgICAganNvbnMucHVzaCgganNvbiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKGN5LCBqc29ucyk7XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmeSBvcHRpb25zIGZvciBvbmUgZWxlbWVudFxuICAgIGVsc2Uge1xuICAgICAgdmFyIGpzb24gPSBvcHRzO1xuICAgICAgZWxlbWVudHMgPSAobmV3IEVsZW1lbnQoIGN5LCBqc29uICkpLmNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbihjb2xsZWN0aW9uKXtcbiAgICBpZiggaXMuZWxlbWVudE9yQ29sbGVjdGlvbihjb2xsZWN0aW9uKSApe1xuICAgICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgfSBlbHNlIGlmKCBpcy5zdHJpbmcoY29sbGVjdGlvbikgKXtcbiAgICAgIHZhciBzZWxlY3RvciA9IGNvbGxlY3Rpb247XG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy4kKCBzZWxlY3RvciApO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xsZWN0aW9uLnJlbW92ZSgpO1xuICB9LFxuXG4gIGxvYWQ6IGZ1bmN0aW9uKGVsZW1lbnRzLCBvbmxvYWQsIG9uZG9uZSl7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIGN5Lm5vdGlmaWNhdGlvbnMoZmFsc2UpO1xuXG4gICAgLy8gcmVtb3ZlIG9sZCBlbGVtZW50c1xuICAgIHZhciBvbGRFbGVzID0gY3kuZWxlbWVudHMoKTtcbiAgICBpZiggb2xkRWxlcy5sZW5ndGggPiAwICl7XG4gICAgICBvbGRFbGVzLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGlmKCBlbGVtZW50cyAhPSBudWxsICl7XG4gICAgICBpZiggaXMucGxhaW5PYmplY3QoZWxlbWVudHMpIHx8IGlzLmFycmF5KGVsZW1lbnRzKSApe1xuICAgICAgICBjeS5hZGQoIGVsZW1lbnRzICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3kub25lKCdsYXlvdXRyZWFkeScsIGZ1bmN0aW9uKGUpe1xuICAgICAgY3kubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgICAgIGN5LnRyaWdnZXIoZSk7IC8vIHdlIG1pc3NlZCB0aGlzIGV2ZW50IGJ5IHR1cm5pbmcgbm90aWZpY2F0aW9ucyBvZmYsIHNvIHBhc3MgaXQgb25cblxuICAgICAgY3kubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICBjb2xsZWN0aW9uOiBjeS5lbGVtZW50cygpXG4gICAgICB9KTtcblxuICAgICAgY3kub25lKCdsb2FkJywgb25sb2FkKTtcbiAgICAgIGN5LnRyaWdnZXIoJ2xvYWQnKTtcbiAgICB9KS5vbmUoJ2xheW91dHN0b3AnLCBmdW5jdGlvbigpe1xuICAgICAgY3kub25lKCdkb25lJywgb25kb25lKTtcbiAgICAgIGN5LnRyaWdnZXIoJ2RvbmUnKTtcbiAgICB9KTtcblxuICAgIHZhciBsYXlvdXRPcHRzID0gdXRpbC5leHRlbmQoe30sIGN5Ll9wcml2YXRlLm9wdGlvbnMubGF5b3V0KTtcbiAgICBsYXlvdXRPcHRzLmVsZXMgPSBjeS4kKCk7XG5cbiAgICBjeS5sYXlvdXQoIGxheW91dE9wdHMgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcblxufSx7XCIuLi9jb2xsZWN0aW9uXCI6MjMsXCIuLi9jb2xsZWN0aW9uL2VsZW1lbnRcIjoxOSxcIi4uL2V4dGVuc2lvbnMvcmVuZGVyZXIvbnVsbFwiOjczLFwiLi4vaXNcIjo3NyxcIi4uL3V0aWxcIjo5NCxcIi4uL3dpbmRvd1wiOjEwMH1dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IF9kZXJlcV8oJy4uL2RlZmluZScpO1xudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi91dGlsJyk7XG52YXIgaXMgPSBfZGVyZXFfKCcuLi9pcycpO1xuXG52YXIgY29yZWZuID0gKHtcblxuICAvLyBwdWxsIGluIGFuaW1hdGlvbiBmdW5jdGlvbnNcbiAgYW5pbWF0ZTogZGVmaW5lLmFuaW1hdGUoKSxcbiAgYW5pbWF0aW9uOiBkZWZpbmUuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUuYW5pbWF0ZWQoKSxcbiAgY2xlYXJRdWV1ZTogZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgZGVsYXk6IGRlZmluZS5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lLmRlbGF5QW5pbWF0aW9uKCksXG4gIHN0b3A6IGRlZmluZS5zdG9wKCksXG5cbiAgYWRkVG9BbmltYXRpb25Qb29sOiBmdW5jdGlvbiggZWxlcyApe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcblxuICAgIGN5Ll9wcml2YXRlLmFuaUVsZXMubWVyZ2UoIGVsZXMgKTtcbiAgfSxcblxuICBzdG9wQW5pbWF0aW9uTG9vcDogZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nID0gZmFsc2U7XG4gIH0sXG5cbiAgc3RhcnRBbmltYXRpb25Mb29wOiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBjeS5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZyA9IHRydWU7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcblxuICAgIC8vIE5CIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIGV4ZWMgaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzIGlmIHN0eWxlIGVuYWJsZWRcbiAgICAvLyBhbmQgZXhwbGljaXQgY3kuZGVzdHJveSgpIGlzIG5lY2Vzc2FyeSB0byBzdG9wIHRoZSBsb29wXG5cbiAgICBmdW5jdGlvbiBnbG9iYWxBbmltYXRpb25TdGVwKCl7XG4gICAgICBpZiggIWN5Ll9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nICl7IHJldHVybjsgfVxuXG4gICAgICB1dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbihub3cpe1xuICAgICAgICBoYW5kbGVFbGVtZW50cyhub3cpO1xuICAgICAgICBnbG9iYWxBbmltYXRpb25TdGVwKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBnbG9iYWxBbmltYXRpb25TdGVwKCk7IC8vIGZpcnN0IGNhbGxcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVsZW1lbnRzKCBub3cgKXtcbiAgICAgIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuYW5pRWxlcztcbiAgICAgIHZhciBkb25lRWxlcyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVFbGVtZW50KCBlbGUsIGlzQ29yZSApe1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBjdXJyZW50ID0gX3AuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgICAgIHZhciBxdWV1ZSA9IF9wLmFuaW1hdGlvbi5xdWV1ZTtcbiAgICAgICAgdmFyIHJhbkFuaXMgPSBmYWxzZTtcblxuICAgICAgICAvLyBpZiBub3RoaW5nIGN1cnJlbnRseSBhbmltYXRpbmcsIGdldCBzb21ldGhpbmcgZnJvbSB0aGUgcXVldWVcbiAgICAgICAgaWYoIGN1cnJlbnQubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgdmFyIG5leHQgPSBxdWV1ZS5zaGlmdCgpO1xuXG4gICAgICAgICAgaWYoIG5leHQgKXtcbiAgICAgICAgICAgIGN1cnJlbnQucHVzaCggbmV4dCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxsYmFja3MgPSBmdW5jdGlvbiggY2FsbGJhY2tzICl7XG4gICAgICAgICAgZm9yKCB2YXIgaiA9IGNhbGxiYWNrcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSApe1xuICAgICAgICAgICAgdmFyIGNiID0gY2FsbGJhY2tzW2pdO1xuXG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoIDAsIGNhbGxiYWNrcy5sZW5ndGggKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzdGVwIGFuZCByZW1vdmUgaWYgZG9uZVxuICAgICAgICBmb3IoIHZhciBpID0gY3VycmVudC5sZW5ndGggLSAxOyBpID49IDA7IGktLSApe1xuICAgICAgICAgIHZhciBhbmkgPSBjdXJyZW50W2ldO1xuICAgICAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcblxuICAgICAgICAgIGlmKCBhbmlfcC5zdG9wcGVkICl7XG4gICAgICAgICAgICBjdXJyZW50LnNwbGljZSggaSwgMSApO1xuXG4gICAgICAgICAgICBhbmlfcC5ob29rZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGFuaV9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGFuaV9wLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgY2FsbGJhY2tzKCBhbmlfcC5mcmFtZXMgKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICFhbmlfcC5wbGF5aW5nICYmICFhbmlfcC5hcHBseWluZyApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgLy8gYW4gYXBwbHkoKSB3aGlsZSBwbGF5aW5nIHNob3VsZG4ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgIGlmKCBhbmlfcC5wbGF5aW5nICYmIGFuaV9wLmFwcGx5aW5nICl7XG4gICAgICAgICAgICBhbmlfcC5hcHBseWluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhYW5pX3Auc3RhcnRlZCApe1xuICAgICAgICAgICAgc3RhcnRBbmltYXRpb24oIGVsZSwgYW5pLCBub3cgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGVwKCBlbGUsIGFuaSwgbm93LCBpc0NvcmUgKTtcblxuICAgICAgICAgIGlmKCBhbmlfcC5hcHBseWluZyApe1xuICAgICAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWxsYmFja3MoIGFuaV9wLmZyYW1lcyApO1xuXG4gICAgICAgICAgaWYoIGFuaS5jb21wbGV0ZWQoKSApe1xuICAgICAgICAgICAgY3VycmVudC5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICAgIGFuaV9wLmhvb2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYW5pX3AucGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYW5pX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjYWxsYmFja3MoIGFuaV9wLmNvbXBsZXRlcyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJhbkFuaXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFpc0NvcmUgJiYgY3VycmVudC5sZW5ndGggPT09IDAgJiYgcXVldWUubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgZG9uZUVsZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmFuQW5pcztcbiAgICAgIH0gLy8gaGFuZGxlRWxlbWVudFxuXG4gICAgICAvLyBoYW5kbGUgYWxsIGVsZXNcbiAgICAgIHZhciByYW5FbGVBbmkgPSBmYWxzZTtcbiAgICAgIGZvciggdmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tlXTtcbiAgICAgICAgdmFyIGhhbmRsZWRUaGlzRWxlID0gaGFuZGxlRWxlbWVudCggZWxlICk7XG5cbiAgICAgICAgcmFuRWxlQW5pID0gcmFuRWxlQW5pIHx8IGhhbmRsZWRUaGlzRWxlO1xuICAgICAgfSAvLyBlYWNoIGVsZW1lbnRcblxuICAgICAgdmFyIHJhbkNvcmVBbmkgPSBoYW5kbGVFbGVtZW50KCBjeSwgdHJ1ZSApO1xuXG4gICAgICAvLyBub3RpZnkgcmVuZGVyZXJcbiAgICAgIGlmKCByYW5FbGVBbmkgfHwgcmFuQ29yZUFuaSApe1xuICAgICAgICB2YXIgdG9Ob3RpZnk7XG5cbiAgICAgICAgaWYoIGVsZXMubGVuZ3RoID4gMCApe1xuICAgICAgICAgIHZhciB1cGRhdGVkRWxlcyA9IGVsZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICB0b05vdGlmeSA9IHVwZGF0ZWRFbGVzLmxlbmd0aCA+IDAgPyBlbGVzLmFkZCggdXBkYXRlZEVsZXMgKSA6IGVsZXM7XG4gICAgICAgIH1cblxuICAgICAgICBjeS5ub3RpZnkoe1xuICAgICAgICAgIHR5cGU6ICdkcmF3JyxcbiAgICAgICAgICBjb2xsZWN0aW9uOiB0b05vdGlmeVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gbGlzdCBvZiBjdXJyZW50bHkgYW5pbWF0aW5nIGlmIGl0cyBxdWV1ZXMgYXJlIGVtcHR5XG4gICAgICBlbGVzLnVubWVyZ2UoIGRvbmVFbGVzICk7XG5cbiAgICB9IC8vIGhhbmRsZUVsZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBzdGFydEFuaW1hdGlvbiggc2VsZiwgYW5pLCBub3cgKXtcbiAgICAgIHZhciBpc0NvcmUgPSBpcy5jb3JlKCBzZWxmICk7XG4gICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgICAgIHZhciBlbGUgPSBzZWxmO1xuICAgICAgdmFyIHN0eWxlID0gY3kuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG5cbiAgICAgIGlmKCBpc0VsZXMgKXtcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICBhbmlfcC5zdGFydFBvc2l0aW9uID0gYW5pX3Auc3RhcnRQb3NpdGlvbiB8fCB7XG4gICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgeTogcG9zLnlcbiAgICAgICAgfTtcblxuICAgICAgICBhbmlfcC5zdGFydFN0eWxlID0gYW5pX3Auc3RhcnRTdHlsZSB8fCBzdHlsZS5nZXRWYWx1ZVN0eWxlKCBlbGUgKTtcbiAgICAgIH1cblxuICAgICAgaWYoIGlzQ29yZSApe1xuICAgICAgICB2YXIgcGFuID0gY3kuX3ByaXZhdGUucGFuO1xuXG4gICAgICAgIGFuaV9wLnN0YXJ0UGFuID0gYW5pX3Auc3RhcnRQYW4gfHwge1xuICAgICAgICAgIHg6IHBhbi54LFxuICAgICAgICAgIHk6IHBhbi55XG4gICAgICAgIH07XG5cbiAgICAgICAgYW5pX3Auc3RhcnRab29tID0gYW5pX3Auc3RhcnRab29tICE9IG51bGwgPyBhbmlfcC5zdGFydFpvb20gOiBjeS5fcHJpdmF0ZS56b29tO1xuICAgICAgfVxuXG4gICAgICBhbmlfcC5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIGFuaV9wLnN0YXJ0VGltZSA9IG5vdyAtIGFuaV9wLnByb2dyZXNzICogYW5pX3AuZHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcCggc2VsZiwgYW5pLCBub3csIGlzQ29yZSApe1xuICAgICAgdmFyIHN0eWxlID0gY3kuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgICAgIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG4gICAgICB2YXIgcEVhc2luZyA9IGFuaV9wLmVhc2luZztcbiAgICAgIHZhciBzdGFydFRpbWUgPSBhbmlfcC5zdGFydFRpbWU7XG5cbiAgICAgIGlmKCAhYW5pX3AuZWFzaW5nSW1wbCApe1xuXG4gICAgICAgIGlmKCBwRWFzaW5nID09IG51bGwgKXsgLy8gdXNlIGRlZmF1bHRcbiAgICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1snbGluZWFyJ107XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiBkZWZpbmUgdy8gbmFtZVxuICAgICAgICAgIHZhciBlYXNpbmdWYWxzO1xuXG4gICAgICAgICAgaWYoIGlzLnN0cmluZyggcEVhc2luZyApICl7XG4gICAgICAgICAgICB2YXIgZWFzaW5nUHJvcCA9IHN0eWxlLnBhcnNlKCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsIHBFYXNpbmcpO1xuXG4gICAgICAgICAgICBlYXNpbmdWYWxzID0gZWFzaW5nUHJvcC52YWx1ZTtcblxuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gYXNzdW1lIHByZXBhcnNlZCBhcnJheVxuICAgICAgICAgICAgZWFzaW5nVmFscyA9IHBFYXNpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5hbWUsIGFyZ3M7XG5cbiAgICAgICAgICBpZiggaXMuc3RyaW5nKCBlYXNpbmdWYWxzICkgKXtcbiAgICAgICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzO1xuICAgICAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gZWFzaW5nVmFsc1sxXTtcbiAgICAgICAgICAgIGFyZ3MgPSBlYXNpbmdWYWxzLnNsaWNlKDIpLm1hcChmdW5jdGlvbihuKXsgcmV0dXJuICtuOyB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggYXJncy5sZW5ndGggPiAwICl7IC8vIGNyZWF0ZSB3aXRoIGFyZ3NcbiAgICAgICAgICAgIGlmKCBuYW1lID09PSAnc3ByaW5nJyApe1xuICAgICAgICAgICAgICBhcmdzLnB1c2goIGFuaV9wLmR1cmF0aW9uICk7IC8vIG5lZWQgZHVyYXRpb24gdG8gZ2VuZXJhdGUgc3ByaW5nXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzWyBuYW1lIF0uYXBwbHkoIG51bGwsIGFyZ3MgKTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBzdGF0aWMgaW1wbCBieSBuYW1lXG4gICAgICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1sgbmFtZSBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhciBlYXNpbmcgPSBhbmlfcC5lYXNpbmdJbXBsO1xuICAgICAgdmFyIHBlcmNlbnQ7XG5cbiAgICAgIGlmKCBhbmlfcC5kdXJhdGlvbiA9PT0gMCApe1xuICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlcmNlbnQgPSAobm93IC0gc3RhcnRUaW1lKSAvIGFuaV9wLmR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiggYW5pX3AuYXBwbHlpbmcgKXtcbiAgICAgICAgcGVyY2VudCA9IGFuaV9wLnByb2dyZXNzO1xuICAgICAgfVxuXG4gICAgICBpZiggcGVyY2VudCA8IDAgKXtcbiAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICB9IGVsc2UgaWYoIHBlcmNlbnQgPiAxICl7XG4gICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiggYW5pX3AuZGVsYXkgPT0gbnVsbCApeyAvLyB0aGVuIHVwZGF0ZVxuXG4gICAgICAgIHZhciBzdGFydFBvcyA9IGFuaV9wLnN0YXJ0UG9zaXRpb247XG4gICAgICAgIHZhciBlbmRQb3MgPSBhbmlfcC5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uO1xuICAgICAgICBpZiggZW5kUG9zICYmIGlzRWxlcyApe1xuICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRQb3MueCwgZW5kUG9zLnggKSApe1xuICAgICAgICAgICAgcG9zLnggPSBlYXNlKCBzdGFydFBvcy54LCBlbmRQb3MueCwgcGVyY2VudCwgZWFzaW5nICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBvcy55LCBlbmRQb3MueSApICl7XG4gICAgICAgICAgICBwb3MueSA9IGVhc2UoIHN0YXJ0UG9zLnksIGVuZFBvcy55LCBwZXJjZW50LCBlYXNpbmcgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRQYW4gPSBhbmlfcC5zdGFydFBhbjtcbiAgICAgICAgdmFyIGVuZFBhbiA9IGFuaV9wLnBhbjtcbiAgICAgICAgdmFyIHBhbiA9IF9wLnBhbjtcbiAgICAgICAgdmFyIGFuaW1hdGluZ1BhbiA9IGVuZFBhbiAhPSBudWxsICYmIGlzQ29yZTtcbiAgICAgICAgaWYoIGFuaW1hdGluZ1BhbiApe1xuICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRQYW4ueCwgZW5kUGFuLnggKSApe1xuICAgICAgICAgICAgcGFuLnggPSBlYXNlKCBzdGFydFBhbi54LCBlbmRQYW4ueCwgcGVyY2VudCwgZWFzaW5nICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBhbi55LCBlbmRQYW4ueSApICl7XG4gICAgICAgICAgICBwYW4ueSA9IGVhc2UoIHN0YXJ0UGFuLnksIGVuZFBhbi55LCBwZXJjZW50LCBlYXNpbmcgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3BhbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0Wm9vbSA9IGFuaV9wLnN0YXJ0Wm9vbTtcbiAgICAgICAgdmFyIGVuZFpvb20gPSBhbmlfcC56b29tO1xuICAgICAgICB2YXIgYW5pbWF0aW5nWm9vbSA9IGVuZFpvb20gIT0gbnVsbCAmJiBpc0NvcmU7XG4gICAgICAgIGlmKCBhbmltYXRpbmdab29tICl7XG4gICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFpvb20sIGVuZFpvb20gKSApe1xuICAgICAgICAgICAgX3Auem9vbSA9IGVhc2UoIHN0YXJ0Wm9vbSwgZW5kWm9vbSwgcGVyY2VudCwgZWFzaW5nICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCd6b29tJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggYW5pbWF0aW5nUGFuIHx8IGFuaW1hdGluZ1pvb20gKXtcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXdwb3J0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcHMgPSBhbmlfcC5zdHlsZTtcbiAgICAgICAgaWYoIHByb3BzICYmIGlzRWxlcyApe1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHByb3A7XG5cbiAgICAgICAgICAgIHZhciBzdGFydCA9IGFuaV9wLnN0YXJ0U3R5bGVbIG5hbWUgXTtcbiAgICAgICAgICAgIHZhciBlYXNlZFZhbCA9IGVhc2UoIHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGVhc2luZyApO1xuXG4gICAgICAgICAgICBzdHlsZS5vdmVycmlkZUJ5cGFzcyggc2VsZiwgbmFtZSwgZWFzZWRWYWwgKTtcbiAgICAgICAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgICAgIH0gLy8gaWZcblxuICAgICAgfVxuXG4gICAgICBpZiggaXMuZm4oYW5pX3Auc3RlcCkgKXtcbiAgICAgICAgYW5pX3Auc3RlcC5hcHBseSggc2VsZiwgWyBub3cgXSApO1xuICAgICAgfVxuXG4gICAgICBhbmlfcC5wcm9ncmVzcyA9IHBlcmNlbnQ7XG5cbiAgICAgIHJldHVybiBwZXJjZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkKHN0YXJ0LCBlbmQpe1xuICAgICAgaWYoIHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiggaXMubnVtYmVyKHN0YXJ0KSAmJiBpcy5udW1iZXIoZW5kKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiggKHN0YXJ0KSAmJiAoZW5kKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGFzc3VtZXMgcDAgPSAwLCBwMyA9IDFcbiAgICBmdW5jdGlvbiBldmFsQ3ViaWNCZXppZXIoIHAxLCBwMiwgdCApe1xuICAgICAgdmFyIG9uZV90ID0gMSAtIHQ7XG4gICAgICB2YXIgdHNxID0gdCp0O1xuXG4gICAgICByZXR1cm4gKCAzICogb25lX3QgKiBvbmVfdCAqIHQgKiBwMSApICsgKCAzICogb25lX3QgKiB0c3EgKiBwMiApICsgdHNxICogdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdWJpY0JlemllciggcDEsIHAyICl7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oIHN0YXJ0LCBlbmQsIHBlcmNlbnQgKXtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIGV2YWxDdWJpY0JlemllciggcDEsIHAyLCBwZXJjZW50ICk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qISBSdW5nZS1LdXR0YSBzcHJpbmcgcGh5c2ljcyBmdW5jdGlvbiBnZW5lcmF0b3IuIEFkYXB0ZWQgZnJvbSBGcmFtZXIuanMsIGNvcHlyaWdodCBLb2VuIEJvay4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cbiAgICAvKiBHaXZlbiBhIHRlbnNpb24sIGZyaWN0aW9uLCBhbmQgZHVyYXRpb24sIGEgc2ltdWxhdGlvbiBhdCA2MEZQUyB3aWxsIGZpcnN0IHJ1biB3aXRob3V0IGEgZGVmaW5lZCBkdXJhdGlvbiBpbiBvcmRlciB0byBjYWxjdWxhdGUgdGhlIGZ1bGwgcGF0aC4gQSBzZWNvbmQgcGFzc1xuICAgICAgIHRoZW4gYWRqdXN0cyB0aGUgdGltZSBkZWx0YSAtLSB1c2luZyB0aGUgcmVsYXRpb24gYmV0d2VlbiBhY3R1YWwgdGltZSBhbmQgZHVyYXRpb24gLS0gdG8gY2FsY3VsYXRlIHRoZSBwYXRoIGZvciB0aGUgZHVyYXRpb24tY29uc3RyYWluZWQgYW5pbWF0aW9uLiAqL1xuICAgIHZhciBnZW5lcmF0ZVNwcmluZ1JLNCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgtc3RhdGUudGVuc2lvbiAqIHN0YXRlLngpIC0gKHN0YXRlLmZyaWN0aW9uICogc3RhdGUudik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUgKGluaXRpYWxTdGF0ZSwgZHQsIGRlcml2YXRpdmUpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICB4OiBpbml0aWFsU3RhdGUueCArIGRlcml2YXRpdmUuZHggKiBkdCxcbiAgICAgICAgICAgICAgICB2OiBpbml0aWFsU3RhdGUudiArIGRlcml2YXRpdmUuZHYgKiBkdCxcbiAgICAgICAgICAgICAgICB0ZW5zaW9uOiBpbml0aWFsU3RhdGUudGVuc2lvbixcbiAgICAgICAgICAgICAgICBmcmljdGlvbjogaW5pdGlhbFN0YXRlLmZyaWN0aW9uXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4geyBkeDogc3RhdGUudiwgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3ByaW5nSW50ZWdyYXRlU3RhdGUgKHN0YXRlLCBkdCkge1xuICAgICAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgICAgICAgICAgICAgICBkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYSksXG4gICAgICAgICAgICAgICAgYyA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQgKiAwLjUsIGIpLFxuICAgICAgICAgICAgICAgIGQgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0LCBjKSxcbiAgICAgICAgICAgICAgICBkeGR0ID0gMS4wIC8gNi4wICogKGEuZHggKyAyLjAgKiAoYi5keCArIGMuZHgpICsgZC5keCksXG4gICAgICAgICAgICAgICAgZHZkdCA9IDEuMCAvIDYuMCAqIChhLmR2ICsgMi4wICogKGIuZHYgKyBjLmR2KSArIGQuZHYpO1xuXG4gICAgICAgICAgICBzdGF0ZS54ID0gc3RhdGUueCArIGR4ZHQgKiBkdDtcbiAgICAgICAgICAgIHN0YXRlLnYgPSBzdGF0ZS52ICsgZHZkdCAqIGR0O1xuXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3ByaW5nUks0RmFjdG9yeSAodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKSB7XG5cbiAgICAgICAgICAgIHZhciBpbml0U3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IC0xLFxuICAgICAgICAgICAgICAgICAgICB2OiAwLFxuICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmcmljdGlvbjogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGF0aCA9IFswXSxcbiAgICAgICAgICAgICAgICB0aW1lX2xhcHNlZCA9IDAsXG4gICAgICAgICAgICAgICAgdG9sZXJhbmNlID0gMSAvIDEwMDAwLFxuICAgICAgICAgICAgICAgIERUID0gMTYgLyAxMDAwLFxuICAgICAgICAgICAgICAgIGhhdmVfZHVyYXRpb24sIGR0LCBsYXN0X3N0YXRlO1xuXG4gICAgICAgICAgICB0ZW5zaW9uID0gcGFyc2VGbG9hdCh0ZW5zaW9uKSB8fCA1MDA7XG4gICAgICAgICAgICBmcmljdGlvbiA9IHBhcnNlRmxvYXQoZnJpY3Rpb24pIHx8IDIwO1xuICAgICAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCBudWxsO1xuXG4gICAgICAgICAgICBpbml0U3RhdGUudGVuc2lvbiA9IHRlbnNpb247XG4gICAgICAgICAgICBpbml0U3RhdGUuZnJpY3Rpb24gPSBmcmljdGlvbjtcblxuICAgICAgICAgICAgaGF2ZV9kdXJhdGlvbiA9IGR1cmF0aW9uICE9PSBudWxsO1xuXG4gICAgICAgICAgICAvKiBDYWxjdWxhdGUgdGhlIGFjdHVhbCB0aW1lIGl0IHRha2VzIGZvciB0aGlzIGFuaW1hdGlvbiB0byBjb21wbGV0ZSB3aXRoIHRoZSBwcm92aWRlZCBjb25kaXRpb25zLiAqL1xuICAgICAgICAgICAgaWYgKGhhdmVfZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAvKiBSdW4gdGhlIHNpbXVsYXRpb24gd2l0aG91dCBhIGR1cmF0aW9uLiAqL1xuICAgICAgICAgICAgICAgIHRpbWVfbGFwc2VkID0gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbik7XG4gICAgICAgICAgICAgICAgLyogQ29tcHV0ZSB0aGUgYWRqdXN0ZWQgdGltZSBkZWx0YS4gKi9cbiAgICAgICAgICAgICAgICBkdCA9IHRpbWVfbGFwc2VkIC8gZHVyYXRpb24gKiBEVDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHQgPSBEVDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvKiBOZXh0L3N0ZXAgZnVuY3Rpb24gLiovXG4gICAgICAgICAgICAgICAgbGFzdF9zdGF0ZSA9IHNwcmluZ0ludGVncmF0ZVN0YXRlKGxhc3Rfc3RhdGUgfHwgaW5pdFN0YXRlLCBkdCk7XG4gICAgICAgICAgICAgICAgLyogU3RvcmUgdGhlIHBvc2l0aW9uLiAqL1xuICAgICAgICAgICAgICAgIHBhdGgucHVzaCgxICsgbGFzdF9zdGF0ZS54KTtcbiAgICAgICAgICAgICAgICB0aW1lX2xhcHNlZCArPSAxNjtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgY2hhbmdlIHRocmVzaG9sZCBpcyByZWFjaGVkLCBicmVhay4gKi9cbiAgICAgICAgICAgICAgICBpZiAoIShNYXRoLmFicyhsYXN0X3N0YXRlLngpID4gdG9sZXJhbmNlICYmIE1hdGguYWJzKGxhc3Rfc3RhdGUudikgPiB0b2xlcmFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogSWYgZHVyYXRpb24gaXMgbm90IGRlZmluZWQsIHJldHVybiB0aGUgYWN0dWFsIHRpbWUgcmVxdWlyZWQgZm9yIGNvbXBsZXRpbmcgdGhpcyBhbmltYXRpb24uIE90aGVyd2lzZSwgcmV0dXJuIGEgY2xvc3VyZSB0aGF0IGhvbGRzIHRoZVxuICAgICAgICAgICAgICAgY29tcHV0ZWQgcGF0aCBhbmQgcmV0dXJucyBhIHNuYXBzaG90IG9mIHRoZSBwb3NpdGlvbiBhY2NvcmRpbmcgdG8gYSBnaXZlbiBwZXJjZW50Q29tcGxldGUuICovXG4gICAgICAgICAgICByZXR1cm4gIWhhdmVfZHVyYXRpb24gPyB0aW1lX2xhcHNlZCA6IGZ1bmN0aW9uKHBlcmNlbnRDb21wbGV0ZSkgeyByZXR1cm4gcGF0aFsgKHBlcmNlbnRDb21wbGV0ZSAqIChwYXRoLmxlbmd0aCAtIDEpKSB8IDAgXTsgfTtcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgdmFyIGVhc2luZ3MgPSB7XG4gICAgICAnbGluZWFyJzogZnVuY3Rpb24oIHN0YXJ0LCBlbmQsIHBlcmNlbnQgKXtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHBlcmNlbnQ7XG4gICAgICB9LFxuXG4gICAgICAvLyBkZWZhdWx0IGVhc2luZ3NcbiAgICAgICdlYXNlJzogY3ViaWNCZXppZXIoIDAuMjUsIDAuMSwgMC4yNSwgMSApLFxuICAgICAgJ2Vhc2UtaW4nOiBjdWJpY0JlemllciggMC40MiwgMCwgMSwgMSApLFxuICAgICAgJ2Vhc2Utb3V0JzogY3ViaWNCZXppZXIoIDAsIDAsIDAuNTgsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dCc6IGN1YmljQmV6aWVyKCAwLjQyLCAwLCAwLjU4LCAxICksXG5cbiAgICAgIC8vIHNpbmVcbiAgICAgICdlYXNlLWluLXNpbmUnOiBjdWJpY0JlemllciggMC40NywgMCwgMC43NDUsIDAuNzE1ICksXG4gICAgICAnZWFzZS1vdXQtc2luZSc6IGN1YmljQmV6aWVyKCAwLjM5LCAwLjU3NSwgMC41NjUsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dC1zaW5lJzogY3ViaWNCZXppZXIoIDAuNDQ1LCAwLjA1LCAwLjU1LCAwLjk1ICksXG5cbiAgICAgIC8vIHF1YWRcbiAgICAgICdlYXNlLWluLXF1YWQnOiBjdWJpY0JlemllciggMC41NSwgMC4wODUsIDAuNjgsIDAuNTMgKSxcbiAgICAgICdlYXNlLW91dC1xdWFkJzogY3ViaWNCZXppZXIoIDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQgKSxcbiAgICAgICdlYXNlLWluLW91dC1xdWFkJzogY3ViaWNCZXppZXIoIDAuNDU1LCAwLjAzLCAwLjUxNSwgMC45NTUgKSxcblxuICAgICAgLy8gY3ViaWNcbiAgICAgICdlYXNlLWluLWN1YmljJzogY3ViaWNCZXppZXIoIDAuNTUsIDAuMDU1LCAwLjY3NSwgMC4xOSApLFxuICAgICAgJ2Vhc2Utb3V0LWN1YmljJzogY3ViaWNCZXppZXIoIDAuMjE1LCAwLjYxLCAwLjM1NSwgMSApLFxuICAgICAgJ2Vhc2UtaW4tb3V0LWN1YmljJzogY3ViaWNCZXppZXIoIDAuNjQ1LCAwLjA0NSwgMC4zNTUsIDEgKSxcblxuICAgICAgLy8gcXVhcnRcbiAgICAgICdlYXNlLWluLXF1YXJ0JzogY3ViaWNCZXppZXIoIDAuODk1LCAwLjAzLCAwLjY4NSwgMC4yMiApLFxuICAgICAgJ2Vhc2Utb3V0LXF1YXJ0JzogY3ViaWNCZXppZXIoIDAuMTY1LCAwLjg0LCAwLjQ0LCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtcXVhcnQnOiBjdWJpY0JlemllciggMC43NywgMCwgMC4xNzUsIDEgKSxcblxuICAgICAgLy8gcXVpbnRcbiAgICAgICdlYXNlLWluLXF1aW50JzogY3ViaWNCZXppZXIoIDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNiApLFxuICAgICAgJ2Vhc2Utb3V0LXF1aW50JzogY3ViaWNCZXppZXIoIDAuMjMsIDEsIDAuMzIsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dC1xdWludCc6IGN1YmljQmV6aWVyKCAwLjg2LCAwLCAwLjA3LCAxICksXG5cbiAgICAgIC8vIGV4cG9cbiAgICAgICdlYXNlLWluLWV4cG8nOiBjdWJpY0JlemllciggMC45NSwgMC4wNSwgMC43OTUsIDAuMDM1ICksXG4gICAgICAnZWFzZS1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKCAwLjE5LCAxLCAwLjIyLCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKCAxLCAwLCAwLCAxICksXG5cbiAgICAgIC8vIGNpcmNcbiAgICAgICdlYXNlLWluLWNpcmMnOiBjdWJpY0JlemllciggMC42LCAwLjA0LCAwLjk4LCAwLjMzNSApLFxuICAgICAgJ2Vhc2Utb3V0LWNpcmMnOiBjdWJpY0JlemllciggMC4wNzUsIDAuODIsIDAuMTY1LCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKCAwLjc4NSwgMC4xMzUsIDAuMTUsIDAuODYgKSxcblxuXG4gICAgICAvLyB1c2VyIHBhcmFtIGVhc2luZ3MuLi5cblxuICAgICAgJ3NwcmluZyc6IGZ1bmN0aW9uKCB0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24gKXtcbiAgICAgICAgdmFyIHNwcmluZyA9IGdlbmVyYXRlU3ByaW5nUks0KCB0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24gKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHN0YXJ0LCBlbmQsIHBlcmNlbnQgKXtcbiAgICAgICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogc3ByaW5nKCBwZXJjZW50ICk7XG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAnY3ViaWMtYmV6aWVyJzogZnVuY3Rpb24oIHgxLCB5MSwgeDIsIHkyICl7XG4gICAgICAgIHJldHVybiBjdWJpY0JlemllciggeDEsIHkxLCB4MiwgeTIgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZWFzZSggc3RhcnRQcm9wLCBlbmRQcm9wLCBwZXJjZW50LCBlYXNpbmdGbiApe1xuICAgICAgaWYoIHBlcmNlbnQgPCAwICl7XG4gICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgfSBlbHNlIGlmKCBwZXJjZW50ID4gMSApe1xuICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgICAgIGlmKCBzdGFydFByb3AucGZWYWx1ZSAhPSBudWxsIHx8IHN0YXJ0UHJvcC52YWx1ZSAhPSBudWxsICl7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRQcm9wLnBmVmFsdWUgIT0gbnVsbCA/IHN0YXJ0UHJvcC5wZlZhbHVlIDogc3RhcnRQcm9wLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydFByb3A7XG4gICAgICB9XG5cbiAgICAgIGlmKCBlbmRQcm9wLnBmVmFsdWUgIT0gbnVsbCB8fCBlbmRQcm9wLnZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgZW5kID0gZW5kUHJvcC5wZlZhbHVlICE9IG51bGwgPyBlbmRQcm9wLnBmVmFsdWUgOiBlbmRQcm9wLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gZW5kUHJvcDtcbiAgICAgIH1cblxuICAgICAgaWYoIGlzLm51bWJlcihzdGFydCkgJiYgaXMubnVtYmVyKGVuZCkgKXtcbiAgICAgICAgcmV0dXJuIGVhc2luZ0ZuKCBzdGFydCwgZW5kLCBwZXJjZW50ICk7XG5cbiAgICAgIH0gZWxzZSBpZiggaXMuYXJyYXkoc3RhcnQpICYmIGlzLmFycmF5KGVuZCkgKXtcbiAgICAgICAgdmFyIGVhc2VkQXJyID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbmQubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgc2kgPSBzdGFydFtpXTtcbiAgICAgICAgICB2YXIgZWkgPSBlbmRbaV07XG5cbiAgICAgICAgICBpZiggc2kgIT0gbnVsbCAmJiBlaSAhPSBudWxsICl7XG4gICAgICAgICAgICB2YXIgdmFsID0gZWFzaW5nRm4oc2ksIGVpLCBwZXJjZW50KTtcblxuICAgICAgICAgICAgaWYoIHN0YXJ0UHJvcC5yb3VuZFZhbHVlICl7IHZhbCA9IE1hdGgucm91bmQoIHZhbCApOyB9XG5cbiAgICAgICAgICAgIGVhc2VkQXJyLnB1c2goIHZhbCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlYXNlZEFyci5wdXNoKCBlaSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlYXNlZEFycjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG5cbn0se1wiLi4vZGVmaW5lXCI6NDEsXCIuLi9pc1wiOjc3LFwiLi4vdXRpbFwiOjk0fV0sMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gX2RlcmVxXygnLi4vZGVmaW5lJyk7XG5cbnZhciBjb3JlZm4gPSAoe1xuICBvbjogZGVmaW5lLm9uKCksIC8vIC5vbiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBkYXRhXSwgaGFuZGxlcilcbiAgb25lOiBkZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICBvbmNlOiBkZWZpbmUub24oeyB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiB0cnVlIH0pLFxuICBvZmY6IGRlZmluZS5vZmYoKSwgLy8gLm9mZiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBoYW5kbGVyXSApXG4gIHRyaWdnZXI6IGRlZmluZS50cmlnZ2VyKCkgLy8gLnRyaWdnZXIoIGV2ZW50cyBbLCBleHRyYVBhcmFtc10gKVxufSk7XG5cbmRlZmluZS5ldmVudEFsaWFzZXNPbiggY29yZWZuICk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuXG59LHtcIi4uL2RlZmluZVwiOjQxfV0sMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yZWZuID0gKHtcblxuICBwbmc6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHJldHVybiByZW5kZXJlci5wbmcoIG9wdGlvbnMgKTtcbiAgfSxcblxuICBqcGc6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIG9wdGlvbnMuYmcgPSBvcHRpb25zLmJnIHx8ICcjZmZmJztcblxuICAgIHJldHVybiByZW5kZXJlci5qcGcoIG9wdGlvbnMgKTtcbiAgfVxuXG59KTtcblxuY29yZWZuLmpwZWcgPSBjb3JlZm4uanBnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcblxufSx7fV0sMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2luZG93ID0gX2RlcmVxXygnLi4vd2luZG93Jyk7XG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uL3V0aWwnKTtcbnZhciBDb2xsZWN0aW9uID0gX2RlcmVxXygnLi4vY29sbGVjdGlvbicpO1xudmFyIGlzID0gX2RlcmVxXygnLi4vaXMnKTtcbnZhciBQcm9taXNlID0gX2RlcmVxXygnLi4vcHJvbWlzZScpO1xudmFyIGRlZmluZSA9IF9kZXJlcV8oJy4uL2RlZmluZScpO1xuXG52YXIgQ29yZSA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBDb3JlKSApe1xuICAgIHJldHVybiBuZXcgQ29yZShvcHRzKTtcbiAgfVxuICB2YXIgY3kgPSB0aGlzO1xuXG4gIG9wdHMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0cyk7XG5cbiAgdmFyIGNvbnRhaW5lciA9IG9wdHMuY29udGFpbmVyO1xuXG4gIC8vIGFsbG93IGZvciBwYXNzaW5nIGEgd3JhcHBlZCBqcXVlcnkgb2JqZWN0XG4gIC8vIGUuZy4gY3l0b3NjYXBlKHsgY29udGFpbmVyOiAkKCcjY3knKSB9KVxuICBpZiggY29udGFpbmVyICYmICFpcy5odG1sRWxlbWVudCggY29udGFpbmVyICkgJiYgaXMuaHRtbEVsZW1lbnQoIGNvbnRhaW5lclswXSApICl7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyWzBdO1xuICB9XG5cbiAgdmFyIHJlZyA9IGNvbnRhaW5lciA/IGNvbnRhaW5lci5fY3lyZWcgOiBudWxsOyAvLyBlLmcuIGFscmVhZHkgcmVnaXN0ZXJlZCBzb21lIGluZm8gKGUuZy4gcmVhZGllcykgdmlhIGpxdWVyeVxuICByZWcgPSByZWcgfHwge307XG5cbiAgaWYoIHJlZyAmJiByZWcuY3kgKXtcbiAgICByZWcuY3kuZGVzdHJveSgpO1xuXG4gICAgcmVnID0ge307IC8vIG9sZCBpbnN0YW5jZSA9PiByZXBsYWNlIHJlZyBjb21wbGV0ZWx5XG4gIH1cblxuICB2YXIgcmVhZGllcyA9IHJlZy5yZWFkaWVzID0gcmVnLnJlYWRpZXMgfHwgW107XG5cbiAgaWYoIGNvbnRhaW5lciApeyBjb250YWluZXIuX2N5cmVnID0gcmVnOyB9IC8vIG1ha2Ugc3VyZSBjb250YWluZXIgYXNzb2MnZCByZWcgcG9pbnRzIHRvIHRoaXMgY3lcbiAgcmVnLmN5ID0gY3k7XG5cbiAgdmFyIGhlYWQgPSB3aW5kb3cgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZXIgIT09IHVuZGVmaW5lZCAmJiAhb3B0cy5oZWFkbGVzcztcbiAgdmFyIG9wdGlvbnMgPSBvcHRzO1xuICBvcHRpb25zLmxheW91dCA9IHV0aWwuZXh0ZW5kKCB7IG5hbWU6IGhlYWQgPyAnZ3JpZCcgOiAnbnVsbCcgfSwgb3B0aW9ucy5sYXlvdXQgKTtcbiAgb3B0aW9ucy5yZW5kZXJlciA9IHV0aWwuZXh0ZW5kKCB7IG5hbWU6IGhlYWQgPyAnY2FudmFzJyA6ICdudWxsJyB9LCBvcHRpb25zLnJlbmRlcmVyICk7XG5cbiAgdmFyIGRlZlZhbCA9IGZ1bmN0aW9uKCBkZWYsIHZhbCwgYWx0VmFsICl7XG4gICAgaWYoIHZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gZWxzZSBpZiggYWx0VmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiBhbHRWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZWY7XG4gICAgfVxuICB9O1xuXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsIC8vIGh0bWwgZG9tIGVsZSBjb250YWluZXJcbiAgICByZWFkeTogZmFsc2UsIC8vIHdoZXRoZXIgcmVhZHkgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgaW5pdHJlbmRlcjogZmFsc2UsIC8vIGhhcyBpbml0cmVuZGVyIGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsIC8vIGNhY2hlZCBvcHRpb25zXG4gICAgZWxlbWVudHM6IFtdLCAvLyBhcnJheSBvZiBlbGVtZW50c1xuICAgIGlkMmluZGV4OiB7fSwgLy8gZWxlbWVudCBpZCA9PiBpbmRleCBpbiBlbGVtZW50cyBhcnJheVxuICAgIGxpc3RlbmVyczogW10sIC8vIGxpc3Qgb2YgbGlzdGVuZXJzXG4gICAgb25SZW5kZXJzOiBbXSwgLy8gcmVuZGVyaW5nIGxpc3RlbmVyc1xuICAgIGFuaUVsZXM6IENvbGxlY3Rpb24odGhpcyksIC8vIGVsZW1lbnRzIGJlaW5nIGFuaW1hdGVkXG4gICAgc2NyYXRjaDoge30sIC8vIHNjcmF0Y2ggb2JqZWN0IGZvciBjb3JlXG4gICAgbGF5b3V0OiBudWxsLFxuICAgIHJlbmRlcmVyOiBudWxsLFxuICAgIG5vdGlmaWNhdGlvbnNFbmFibGVkOiB0cnVlLCAvLyB3aGV0aGVyIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgdG8gdGhlIHJlbmRlcmVyXG4gICAgbWluWm9vbTogMWUtNTAsXG4gICAgbWF4Wm9vbTogMWU1MCxcbiAgICB6b29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuem9vbWluZ0VuYWJsZWQpLFxuICAgIHVzZXJab29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclpvb21pbmdFbmFibGVkKSxcbiAgICBwYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMucGFubmluZ0VuYWJsZWQpLFxuICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclBhbm5pbmdFbmFibGVkKSxcbiAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy5ib3hTZWxlY3Rpb25FbmFibGVkKSxcbiAgICBhdXRvbG9jazogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG9sb2NrLCBvcHRpb25zLmF1dG9sb2NrTm9kZXMpLFxuICAgIGF1dG91bmdyYWJpZnk6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5LCBvcHRpb25zLmF1dG91bmdyYWJpZnlOb2RlcyksXG4gICAgYXV0b3Vuc2VsZWN0aWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3Vuc2VsZWN0aWZ5KSxcbiAgICBzdHlsZUVuYWJsZWQ6IG9wdGlvbnMuc3R5bGVFbmFibGVkID09PSB1bmRlZmluZWQgPyBoZWFkIDogb3B0aW9ucy5zdHlsZUVuYWJsZWQsXG4gICAgem9vbTogaXMubnVtYmVyKG9wdGlvbnMuem9vbSkgPyBvcHRpb25zLnpvb20gOiAxLFxuICAgIHBhbjoge1xuICAgICAgeDogaXMucGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIGlzLm51bWJlcihvcHRpb25zLnBhbi54KSA/IG9wdGlvbnMucGFuLnggOiAwLFxuICAgICAgeTogaXMucGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIGlzLm51bWJlcihvcHRpb25zLnBhbi55KSA/IG9wdGlvbnMucGFuLnkgOiAwXG4gICAgfSxcbiAgICBhbmltYXRpb246IHsgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICBjdXJyZW50OiBbXSxcbiAgICAgIHF1ZXVlOiBbXVxuICAgIH0sXG4gICAgaGFzQ29tcG91bmROb2RlczogZmFsc2UsXG4gICAgZGVmZXJyZWRFeGVjUXVldWU6IFtdXG4gIH07XG5cbiAgLy8gc2V0IHNlbGVjdGlvbiB0eXBlXG4gIHZhciBzZWxUeXBlID0gb3B0aW9ucy5zZWxlY3Rpb25UeXBlO1xuICBpZiggc2VsVHlwZSA9PT0gdW5kZWZpbmVkIHx8IChzZWxUeXBlICE9PSAnYWRkaXRpdmUnICYmIHNlbFR5cGUgIT09ICdzaW5nbGUnKSApe1xuICAgIC8vIHRoZW4gc2V0IGRlZmF1bHRcblxuICAgIF9wLnNlbGVjdGlvblR5cGUgPSAnc2luZ2xlJztcbiAgfSBlbHNlIHtcbiAgICBfcC5zZWxlY3Rpb25UeXBlID0gc2VsVHlwZTtcbiAgfVxuXG4gIC8vIGluaXQgem9vbSBib3VuZHNcbiAgaWYoIGlzLm51bWJlcihvcHRpb25zLm1pblpvb20pICYmIGlzLm51bWJlcihvcHRpb25zLm1heFpvb20pICYmIG9wdGlvbnMubWluWm9vbSA8IG9wdGlvbnMubWF4Wm9vbSApe1xuICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gICAgX3AubWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbTtcbiAgfSBlbHNlIGlmKCBpcy5udW1iZXIob3B0aW9ucy5taW5ab29tKSAmJiBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gIH0gZWxzZSBpZiggaXMubnVtYmVyKG9wdGlvbnMubWF4Wm9vbSkgJiYgb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgKXtcbiAgICBfcC5tYXhab29tID0gb3B0aW9ucy5tYXhab29tO1xuICB9XG5cbiAgdmFyIGxvYWRFeHREYXRhID0gZnVuY3Rpb24oIG5leHQgKXtcbiAgICB2YXIgYW55SXNQcm9taXNlID0gZmFsc2U7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV4dERhdGEubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBkYXR1bSA9IGV4dERhdGFbaV07XG5cbiAgICAgIGlmKCBpcy5wcm9taXNlKGRhdHVtKSApe1xuICAgICAgICBhbnlJc1Byb21pc2UgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggYW55SXNQcm9taXNlICl7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoIGV4dERhdGEgKS50aGVuKCBuZXh0ICk7IC8vIGxvYWQgYWxsIGRhdGEgYXN5bmNocm9ub3VzbHksIHRoZW4gZXhlYyByZXN0IG9mIGluaXRcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dCggZXh0RGF0YSApOyAvLyBleGVjIHN5bmNocm9ub3VzbHkgZm9yIGNvbnZlbmllbmNlXG4gICAgfVxuICB9O1xuXG4gIC8vIGNyZWF0ZSB0aGUgcmVuZGVyZXJcbiAgY3kuaW5pdFJlbmRlcmVyKCB1dGlsLmV4dGVuZCh7XG4gICAgaGlkZUVkZ2VzT25WaWV3cG9ydDogb3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0LFxuICAgIGhpZGVMYWJlbHNPblZpZXdwb3J0OiBvcHRpb25zLmhpZGVMYWJlbHNPblZpZXdwb3J0LFxuICAgIHRleHR1cmVPblZpZXdwb3J0OiBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0LFxuICAgIHdoZWVsU2Vuc2l0aXZpdHk6IGlzLm51bWJlcihvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkpICYmIG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eSA+IDAgPyBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgOiAxLFxuICAgIG1vdGlvbkJsdXI6IG9wdGlvbnMubW90aW9uQmx1ciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMubW90aW9uQmx1ciwgLy8gb24gYnkgZGVmYXVsdFxuICAgIG1vdGlvbkJsdXJPcGFjaXR5OiBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5ID09PSB1bmRlZmluZWQgPyAwLjA1IDogb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eSxcbiAgICBwaXhlbFJhdGlvOiBpcy5udW1iZXIob3B0aW9ucy5waXhlbFJhdGlvKSAmJiBvcHRpb25zLnBpeGVsUmF0aW8gPiAwID8gb3B0aW9ucy5waXhlbFJhdGlvIDogdW5kZWZpbmVkLFxuICAgIGRlc2t0b3BUYXBUaHJlc2hvbGQ6IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCA9PT0gdW5kZWZpbmVkID8gNCA6IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCxcbiAgICB0b3VjaFRhcFRocmVzaG9sZDogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZCA9PT0gdW5kZWZpbmVkID8gOCA6IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGRcbiAgfSwgb3B0aW9ucy5yZW5kZXJlcikgKTtcblxuICB2YXIgZXh0RGF0YSA9IFsgb3B0aW9ucy5zdHlsZSwgb3B0aW9ucy5lbGVtZW50cyBdO1xuICBsb2FkRXh0RGF0YShmdW5jdGlvbiggdGhlbnMgKXtcbiAgICB2YXIgaW5pdFN0eWxlID0gdGhlbnNbMF07XG4gICAgdmFyIGluaXRFbGVzID0gdGhlbnNbMV07XG5cbiAgICAvLyBpbml0IHN0eWxlXG4gICAgaWYoIF9wLnN0eWxlRW5hYmxlZCApe1xuICAgICAgY3kuc2V0U3R5bGUoIGluaXRTdHlsZSApO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgdGhlIHBhc3NlZCBmdW5jdGlvbiBmb3IgdGhlIGBpbml0cmVuZGVyYCBldmVudFxuICAgIGlmKCBvcHRpb25zLmluaXRyZW5kZXIgKXtcbiAgICAgIGN5Lm9uKCdpbml0cmVuZGVyJywgb3B0aW9ucy5pbml0cmVuZGVyKTtcbiAgICAgIGN5Lm9uKCdpbml0cmVuZGVyJywgZnVuY3Rpb24oKXtcbiAgICAgICAgX3AuaW5pdHJlbmRlciA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsIGxvYWRcbiAgICBjeS5sb2FkKGluaXRFbGVzLCBmdW5jdGlvbigpeyAvLyBvbnJlYWR5XG4gICAgICBjeS5zdGFydEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgIF9wLnJlYWR5ID0gdHJ1ZTtcblxuICAgICAgLy8gaWYgYSByZWFkeSBjYWxsYmFjayBpcyBzcGVjaWZpZWQgYXMgYW4gb3B0aW9uLCB0aGUgYmluZCBpdFxuICAgICAgaWYoIGlzLmZuKCBvcHRpb25zLnJlYWR5ICkgKXtcbiAgICAgICAgY3kub24oJ3JlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGJpbmQgYWxsIHRoZSByZWFkeSBoYW5kbGVycyByZWdpc3RlcmVkIGJlZm9yZSBjcmVhdGluZyB0aGlzIGluc3RhbmNlXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHJlYWRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGZuID0gcmVhZGllc1tpXTtcbiAgICAgICAgY3kub24oJ3JlYWR5JywgZm4pO1xuICAgICAgfVxuICAgICAgaWYoIHJlZyApeyByZWcucmVhZGllcyA9IFtdOyB9IC8vIGNsZWFyIGIvYyB3ZSd2ZSBib3VuZCB0aGVtIGFsbCBhbmQgZG9uJ3Qgd2FudCB0byBrZWVwIGl0IGFyb3VuZCBpbiBjYXNlIGEgbmV3IGNvcmUgdXNlcyB0aGUgc2FtZSBkaXYgZXRjXG5cbiAgICAgIGN5LnRyaWdnZXIoJ3JlYWR5Jyk7XG4gICAgfSwgb3B0aW9ucy5kb25lKTtcblxuICB9KTtcbn07XG5cbnZhciBjb3JlZm4gPSBDb3JlLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxudXRpbC5leHRlbmQoY29yZWZuLCB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiAnY29yZSc7XG4gIH0sXG5cbiAgaXNSZWFkeTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZWFkeTtcbiAgfSxcblxuICByZWFkeTogZnVuY3Rpb24oIGZuICl7XG4gICAgaWYoIHRoaXMuaXNSZWFkeSgpICl7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3JlYWR5JywgW10sIGZuKTsgLy8ganVzdCBjYWxscyBmbiBhcyB0aG91Z2ggdHJpZ2dlcmVkIHZpYSByZWFkeSBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCdyZWFkeScsIGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBpbml0cmVuZGVyOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmluaXRyZW5kZXI7XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcblxuICAgIGN5Lm5vdGlmeSh7IHR5cGU6ICdkZXN0cm95JyB9KTsgLy8gZGVzdHJveSB0aGUgcmVuZGVyZXJcblxuICAgIHZhciBkb21FbGUgPSBjeS5jb250YWluZXIoKTtcbiAgICBpZiggZG9tRWxlICl7XG4gICAgICBkb21FbGUuX2N5cmVnID0gbnVsbDtcblxuICAgICAgd2hpbGUoIGRvbUVsZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgZG9tRWxlLnJlbW92ZUNoaWxkKCBkb21FbGUuY2hpbGROb2Rlc1swXSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjeTtcbiAgfSxcblxuICBnZXRFbGVtZW50QnlJZDogZnVuY3Rpb24oIGlkICl7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fcHJpdmF0ZS5pZDJpbmRleFsgaWQgXTtcbiAgICBpZiggaW5kZXggIT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHNbIGluZGV4IF07XG4gICAgfVxuXG4gICAgLy8gd29yc3QgY2FzZSwgcmV0dXJuIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgICByZXR1cm4gQ29sbGVjdGlvbiggdGhpcyApO1xuICB9LFxuXG4gIHNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc2VsZWN0aW9uVHlwZTtcbiAgfSxcblxuICBoYXNDb21wb3VuZE5vZGVzOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXM7XG4gIH0sXG5cbiAgc3R5bGVFbmFibGVkOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgfSxcblxuICBhZGRUb1Bvb2w6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICB2YXIgaWQyaW5kZXggPSB0aGlzLl9wcml2YXRlLmlkMmluZGV4O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgaW5kZXggPSBpZDJpbmRleFsgaWQgXTtcbiAgICAgIHZhciBhbHJlYWR5SW5Qb29sID0gaW5kZXggIT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYoICFhbHJlYWR5SW5Qb29sICl7XG4gICAgICAgIGluZGV4ID0gZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgaWQyaW5kZXhbIGlkIF0gPSBpbmRleDtcbiAgICAgICAgZWxlLl9wcml2YXRlLmluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcmVtb3ZlRnJvbVBvb2w6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICB2YXIgaWQyaW5kZXggPSB0aGlzLl9wcml2YXRlLmlkMmluZGV4O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgaW5kZXggPSBpZDJpbmRleFsgaWQgXTtcbiAgICAgIHZhciBpblBvb2wgPSBpbmRleCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiggaW5Qb29sICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuaWQyaW5kZXhbIGlkIF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGVsZW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgLy8gYWRqdXN0IHRoZSBpbmRleCBvZiBhbGwgZWxlbWVudHMgcGFzdCB0aGlzIGluZGV4XG4gICAgICAgIGZvciggdmFyIGogPSBpbmRleDsgaiA8IGVsZW1lbnRzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGppZCA9IGVsZW1lbnRzW2pdLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgICAgaWQyaW5kZXhbIGppZCBdLS07XG4gICAgICAgICAgZWxlbWVudHNbal0uX3ByaXZhdGUuaW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb250YWluZXI6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29udGFpbmVyO1xuICB9LFxuXG4gIG9wdGlvbnM6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHV0aWwuY29weSggdGhpcy5fcHJpdmF0ZS5vcHRpb25zICk7XG4gIH0sXG5cbiAganNvbjogZnVuY3Rpb24oIG9iaiApe1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG5cbiAgICBpZiggaXMucGxhaW5PYmplY3Qob2JqKSApeyAvLyBzZXRcblxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICBpZiggb2JqLmVsZW1lbnRzICl7XG4gICAgICAgIHZhciBpZEluSnNvbiA9IHt9O1xuXG4gICAgICAgIHZhciB1cGRhdGVFbGVzID0gZnVuY3Rpb24oIGpzb25zLCBnciApe1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwganNvbnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG4gICAgICAgICAgICB2YXIgaWQgPSBqc29uLmRhdGEuaWQ7XG4gICAgICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cbiAgICAgICAgICAgIGlkSW5Kc29uWyBpZCBdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYoIGVsZS5sZW5ndGggIT09IDAgKXsgLy8gZXhpc3RpbmcgZWxlbWVudCBzaG91bGQgYmUgdXBkYXRlZFxuICAgICAgICAgICAgICBlbGUuanNvbigganNvbiApO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAgICAgICBpZiggZ3IgKXtcbiAgICAgICAgICAgICAgICBjeS5hZGQoIHV0aWwuZXh0ZW5kKHsgZ3JvdXA6IGdyIH0sIGpzb24pICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3kuYWRkKCBqc29uICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGlzLmFycmF5KG9iai5lbGVtZW50cykgKXsgLy8gZWxlbWVudHM6IFtdXG4gICAgICAgICAgdXBkYXRlRWxlcyggb2JqLmVsZW1lbnRzICk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gZWxlbWVudHM6IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfVxuICAgICAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBncnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBnciA9IGdyc1tpXTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IG9iai5lbGVtZW50c1sgZ3IgXTtcblxuICAgICAgICAgICAgaWYoIGlzLmFycmF5KGVsZW1lbnRzKSApe1xuICAgICAgICAgICAgICB1cGRhdGVFbGVzKCBlbGVtZW50cywgZ3IgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbGVtZW50cyBub3Qgc3BlY2lmaWVkIGluIGpzb24gc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgICAgY3kuZWxlbWVudHMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICAgIHJldHVybiAhaWRJbkpzb25bIGVsZS5pZCgpIF07XG4gICAgICAgIH0pLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiggb2JqLnN0eWxlICl7XG4gICAgICAgIGN5LnN0eWxlKCBvYmouc3R5bGUgKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9iai56b29tICE9IG51bGwgJiYgb2JqLnpvb20gIT09IF9wLnpvb20gKXtcbiAgICAgICAgY3kuem9vbSggb2JqLnpvb20gKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9iai5wYW4gKXtcbiAgICAgICAgaWYoIG9iai5wYW4ueCAhPT0gX3AucGFuLnggfHwgb2JqLnBhbi55ICE9PSBfcC5wYW4ueSApe1xuICAgICAgICAgIGN5LnBhbiggb2JqLnBhbiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWVsZHMgPSBbXG4gICAgICAgICdtaW5ab29tJywgJ21heFpvb20nLCAnem9vbWluZ0VuYWJsZWQnLCAndXNlclpvb21pbmdFbmFibGVkJyxcbiAgICAgICAgJ3Bhbm5pbmdFbmFibGVkJywgJ3VzZXJQYW5uaW5nRW5hYmxlZCcsXG4gICAgICAgICdib3hTZWxlY3Rpb25FbmFibGVkJyxcbiAgICAgICAgJ2F1dG9sb2NrJywgJ2F1dG91bmdyYWJpZnknLCAnYXV0b3Vuc2VsZWN0aWZ5J1xuICAgICAgXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGYgPSBmaWVsZHNbaV07XG5cbiAgICAgICAgaWYoIG9ialtmXSAhPSBudWxsICl7XG4gICAgICAgICAgY3lbZl0oIG9ialtmXSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0gZWxzZSBpZiggb2JqID09PSB1bmRlZmluZWQgKXsgLy8gZ2V0XG4gICAgICB2YXIganNvbiA9IHt9O1xuXG4gICAgICBqc29uLmVsZW1lbnRzID0ge307XG4gICAgICBjeS5lbGVtZW50cygpLmVhY2goZnVuY3Rpb24oaSwgZWxlKXtcbiAgICAgICAgdmFyIGdyb3VwID0gZWxlLmdyb3VwKCk7XG5cbiAgICAgICAgaWYoICFqc29uLmVsZW1lbnRzW2dyb3VwXSApe1xuICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBqc29uLmVsZW1lbnRzW2dyb3VwXS5wdXNoKCBlbGUuanNvbigpICk7XG4gICAgICB9KTtcblxuICAgICAgaWYoIHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkICl7XG4gICAgICAgIGpzb24uc3R5bGUgPSBjeS5zdHlsZSgpLmpzb24oKTtcbiAgICAgIH1cblxuICAgICAganNvbi56b29taW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnpvb21pbmdFbmFibGVkO1xuICAgICAganNvbi51c2VyWm9vbWluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnpvb20gPSBjeS5fcHJpdmF0ZS56b29tO1xuICAgICAganNvbi5taW5ab29tID0gY3kuX3ByaXZhdGUubWluWm9vbTtcbiAgICAgIGpzb24ubWF4Wm9vbSA9IGN5Ll9wcml2YXRlLm1heFpvb207XG4gICAgICBqc29uLnBhbm5pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnVzZXJQYW5uaW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICAgIGpzb24ucGFuID0gdXRpbC5jb3B5KCBjeS5fcHJpdmF0ZS5wYW4gKTtcbiAgICAgIGpzb24uYm94U2VsZWN0aW9uRW5hYmxlZCA9IGN5Ll9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICBqc29uLnJlbmRlcmVyID0gdXRpbC5jb3B5KCBjeS5fcHJpdmF0ZS5vcHRpb25zLnJlbmRlcmVyICk7XG4gICAgICBqc29uLmhpZGVFZGdlc09uVmlld3BvcnQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gICAgICBqc29uLmhpZGVMYWJlbHNPblZpZXdwb3J0ID0gY3kuX3ByaXZhdGUub3B0aW9ucy5oaWRlTGFiZWxzT25WaWV3cG9ydDtcbiAgICAgIGpzb24udGV4dHVyZU9uVmlld3BvcnQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICAgICAganNvbi53aGVlbFNlbnNpdGl2aXR5ID0gY3kuX3ByaXZhdGUub3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgICAganNvbi5tb3Rpb25CbHVyID0gY3kuX3ByaXZhdGUub3B0aW9ucy5tb3Rpb25CbHVyO1xuXG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gIH0sXG5cbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gIH0pLFxuXG4gIHJlbW92ZVNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZVxuICB9KVxuXG59KTtcblxuW1xuICBfZGVyZXFfKCcuL2FkZC1yZW1vdmUnKSxcbiAgX2RlcmVxXygnLi9hbmltYXRpb24nKSxcbiAgX2RlcmVxXygnLi9ldmVudHMnKSxcbiAgX2RlcmVxXygnLi9leHBvcnQnKSxcbiAgX2RlcmVxXygnLi9sYXlvdXQnKSxcbiAgX2RlcmVxXygnLi9ub3RpZmljYXRpb24nKSxcbiAgX2RlcmVxXygnLi9yZW5kZXJlcicpLFxuICBfZGVyZXFfKCcuL3NlYXJjaCcpLFxuICBfZGVyZXFfKCcuL3N0eWxlJyksXG4gIF9kZXJlcV8oJy4vdmlld3BvcnQnKVxuXS5mb3JFYWNoKGZ1bmN0aW9uKCBwcm9wcyApe1xuICB1dGlsLmV4dGVuZCggY29yZWZuLCBwcm9wcyApO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcblxufSx7XCIuLi9jb2xsZWN0aW9uXCI6MjMsXCIuLi9kZWZpbmVcIjo0MSxcIi4uL2lzXCI6NzcsXCIuLi9wcm9taXNlXCI6ODAsXCIuLi91dGlsXCI6OTQsXCIuLi93aW5kb3dcIjoxMDAsXCIuL2FkZC1yZW1vdmVcIjozMCxcIi4vYW5pbWF0aW9uXCI6MzEsXCIuL2V2ZW50c1wiOjMyLFwiLi9leHBvcnRcIjozMyxcIi4vbGF5b3V0XCI6MzUsXCIuL25vdGlmaWNhdGlvblwiOjM2LFwiLi9yZW5kZXJlclwiOjM3LFwiLi9zZWFyY2hcIjozOCxcIi4vc3R5bGVcIjozOSxcIi4vdmlld3BvcnRcIjo0MH1dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi91dGlsJyk7XG52YXIgaXMgPSBfZGVyZXFfKCcuLi9pcycpO1xuXG52YXIgY29yZWZuID0gKHtcblxuICBsYXlvdXQ6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5fcHJpdmF0ZS5wcmV2TGF5b3V0ID0gKCBwYXJhbXMgPT0gbnVsbCA/IHRoaXMuX3ByaXZhdGUucHJldkxheW91dCA6IHRoaXMubWFrZUxheW91dCggcGFyYW1zICkgKTtcblxuICAgIGxheW91dC5ydW4oKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIG1ha2VMYXlvdXQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIGlmKCBvcHRpb25zID09IG51bGwgKXtcbiAgICAgIHV0aWwuZXJyb3IoJ0xheW91dCBvcHRpb25zIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiggb3B0aW9ucy5uYW1lID09IG51bGwgKXtcbiAgICAgIHV0aWwuZXJyb3IoJ0EgYG5hbWVgIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB2YXIgTGF5b3V0ID0gY3kuZXh0ZW5zaW9uKCdsYXlvdXQnLCBuYW1lKTtcblxuICAgIGlmKCBMYXlvdXQgPT0gbnVsbCApe1xuICAgICAgdXRpbC5lcnJvcignQ2FuIG5vdCBhcHBseSBsYXlvdXQ6IE5vIHN1Y2ggbGF5b3V0IGAnICsgbmFtZSArICdgIGZvdW5kOyBkaWQgeW91IGluY2x1ZGUgaXRzIEpTIGZpbGU/Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZXM7XG4gICAgaWYoIGlzLnN0cmluZyggb3B0aW9ucy5lbGVzICkgKXtcbiAgICAgIGVsZXMgPSBjeS4kKCBvcHRpb25zLmVsZXMgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcyA9IG9wdGlvbnMuZWxlcyAhPSBudWxsID8gb3B0aW9ucy5lbGVzIDogY3kuJCgpO1xuICAgIH1cblxuICAgIHZhciBsYXlvdXQgPSBuZXcgTGF5b3V0KCB1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgY3k6IGN5LFxuICAgICAgZWxlczogZWxlc1xuICAgIH0pICk7XG5cbiAgICByZXR1cm4gbGF5b3V0O1xuICB9XG5cbn0pO1xuXG5jb3JlZm4uY3JlYXRlTGF5b3V0ID0gY29yZWZuLm1ha2VMYXlvdXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuXG59LHtcIi4uL2lzXCI6NzcsXCIuLi91dGlsXCI6OTR9XSwzNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb3JlZm4gPSAoe1xuICBub3RpZnk6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoIF9wLmJhdGNoaW5nTm90aWZ5ICl7XG4gICAgICB2YXIgYkVsZXMgPSBfcC5iYXRjaE5vdGlmeUVsZXM7XG4gICAgICB2YXIgYlR5cGVzID0gX3AuYmF0Y2hOb3RpZnlUeXBlcztcblxuICAgICAgaWYoIHBhcmFtcy5jb2xsZWN0aW9uICl7XG4gICAgICAgIGJFbGVzLm1lcmdlKCBwYXJhbXMuY29sbGVjdGlvbiApO1xuICAgICAgfVxuXG4gICAgICBpZiggIWJUeXBlcy5pZHNbIHBhcmFtcy50eXBlIF0gKXtcbiAgICAgICAgYlR5cGVzLnB1c2goIHBhcmFtcy50eXBlICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjsgLy8gbm90aWZpY2F0aW9ucyBhcmUgZGlzYWJsZWQgZHVyaW5nIGJhdGNoaW5nXG4gICAgfVxuXG4gICAgaWYoICFfcC5ub3RpZmljYXRpb25zRW5hYmxlZCApeyByZXR1cm47IH0gLy8gZXhpdCBvbiBkaXNhYmxlZFxuXG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpO1xuXG4gICAgcmVuZGVyZXIubm90aWZ5KHBhcmFtcyk7XG4gIH0sXG5cbiAgbm90aWZpY2F0aW9uczogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICB2YXIgcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggYm9vbCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gcC5ub3RpZmljYXRpb25zRW5hYmxlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5ub3RpZmljYXRpb25zRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIG5vTm90aWZpY2F0aW9uczogZnVuY3Rpb24oIGNhbGxiYWNrICl7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKGZhbHNlKTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHRoaXMubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgfSxcblxuICBzdGFydEJhdGNoOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggX3AuYmF0Y2hDb3VudCA9PSBudWxsICl7XG4gICAgICBfcC5iYXRjaENvdW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiggX3AuYmF0Y2hDb3VudCA9PT0gMCApe1xuICAgICAgX3AuYmF0Y2hpbmdTdHlsZSA9IF9wLmJhdGNoaW5nTm90aWZ5ID0gdHJ1ZTtcbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzID0gdGhpcy5jb2xsZWN0aW9uKCk7XG4gICAgICBfcC5iYXRjaE5vdGlmeUVsZXMgPSB0aGlzLmNvbGxlY3Rpb24oKTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5VHlwZXMgPSBbXTtcblxuICAgICAgX3AuYmF0Y2hOb3RpZnlUeXBlcy5pZHMgPSB7fTtcbiAgICB9XG5cbiAgICBfcC5iYXRjaENvdW50Kys7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBlbmRCYXRjaDogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgX3AuYmF0Y2hDb3VudC0tO1xuXG4gICAgaWYoIF9wLmJhdGNoQ291bnQgPT09IDAgKXtcbiAgICAgIC8vIHVwZGF0ZSBzdHlsZSBmb3IgZGlydHkgZWxlc1xuICAgICAgX3AuYmF0Y2hpbmdTdHlsZSA9IGZhbHNlO1xuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMudXBkYXRlU3R5bGUoKTtcblxuICAgICAgLy8gbm90aWZ5IHRoZSByZW5kZXJlciBvZiBxdWV1ZWQgZWxlcyBhbmQgZXZlbnQgdHlwZXNcbiAgICAgIF9wLmJhdGNoaW5nTm90aWZ5ID0gZmFsc2U7XG4gICAgICB0aGlzLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6IF9wLmJhdGNoTm90aWZ5VHlwZXMsXG4gICAgICAgIGNvbGxlY3Rpb246IF9wLmJhdGNoTm90aWZ5RWxlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYmF0Y2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApe1xuICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5lbmRCYXRjaCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIGJhdGNoRGF0YTogZnVuY3Rpb24oIG1hcCApe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5iYXRjaChmdW5jdGlvbigpe1xuICAgICAgZm9yKCB2YXIgaWQgaW4gbWFwICl7XG4gICAgICAgIHZhciBkYXRhID0gbWFwW2lkXTtcbiAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG4gICAgICAgIGVsZS5kYXRhKCBkYXRhICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcblxufSx7fV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uL3V0aWwnKTtcblxudmFyIGNvcmVmbiA9ICh7XG5cbiAgcmVuZGVyVG86IGZ1bmN0aW9uKCBjb250ZXh0LCB6b29tLCBwYW4sIHB4UmF0aW8gKXtcbiAgICB2YXIgciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG5cbiAgICByLnJlbmRlclRvKCBjb250ZXh0LCB6b29tLCBwYW4sIHB4UmF0aW8gKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW5kZXJlcjogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgfSxcblxuICBmb3JjZVJlbmRlcjogZnVuY3Rpb24oKXtcbiAgICB0aGlzLm5vdGlmeSh7XG4gICAgICB0eXBlOiAnZHJhdydcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlc2l6ZTogZnVuY3Rpb24oKXtcbiAgICB0aGlzLm5vdGlmeSh7XG4gICAgICB0eXBlOiAncmVzaXplJ1xuICAgIH0pO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdyZXNpemUnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGluaXRSZW5kZXJlcjogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgdmFyIFJlbmRlcmVyUHJvdG8gPSBjeS5leHRlbnNpb24oJ3JlbmRlcmVyJywgb3B0aW9ucy5uYW1lKTtcbiAgICBpZiggUmVuZGVyZXJQcm90byA9PSBudWxsICl7XG4gICAgICB1dGlsLmVycm9yKCdDYW4gbm90IGluaXRpYWxpc2U6IE5vIHN1Y2ggcmVuZGVyZXIgYCVzYCBmb3VuZDsgZGlkIHlvdSBpbmNsdWRlIGl0cyBKUyBmaWxlPycsIG9wdGlvbnMubmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJPcHRzID0gdXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGN5OiBjeVxuICAgIH0pO1xuICAgIHZhciByZW5kZXJlciA9IGN5Ll9wcml2YXRlLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyUHJvdG8oIHJPcHRzICk7XG5cbiAgICByZW5kZXJlci5pbml0KCByT3B0cyApO1xuXG4gIH0sXG5cbiAgdHJpZ2dlck9uUmVuZGVyOiBmdW5jdGlvbigpe1xuICAgIHZhciBjYnMgPSB0aGlzLl9wcml2YXRlLm9uUmVuZGVycztcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY2IgPSBjYnNbaV07XG5cbiAgICAgIGNiKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb25SZW5kZXI6IGZ1bmN0aW9uKCBjYiApe1xuICAgIHRoaXMuX3ByaXZhdGUub25SZW5kZXJzLnB1c2goIGNiICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvZmZSZW5kZXI6IGZ1bmN0aW9uKCBmbiApe1xuICAgIHZhciBjYnMgPSB0aGlzLl9wcml2YXRlLm9uUmVuZGVycztcblxuICAgIGlmKCBmbiA9PSBudWxsICl7IC8vIHVuYmluZCBhbGxcbiAgICAgIHRoaXMuX3ByaXZhdGUub25SZW5kZXJzID0gW107XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNicy5sZW5ndGg7IGkrKyApeyAvLyB1bmJpbmQgc3BlY2lmaWVkXG4gICAgICB2YXIgY2IgPSBjYnNbaV07XG5cbiAgICAgIGlmKCBmbiA9PT0gY2IgKXtcbiAgICAgICAgY2JzLnNwbGljZSggaSwgMSApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59KTtcblxuY29yZWZuLmludmFsaWRhdGVEaW1lbnNpb25zID0gY29yZWZuLnJlc2l6ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG5cbn0se1wiLi4vdXRpbFwiOjk0fV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi9pcycpO1xudmFyIENvbGxlY3Rpb24gPSBfZGVyZXFfKCcuLi9jb2xsZWN0aW9uJyk7XG5cbnZhciBjb3JlZm4gPSAoe1xuXG4gIC8vIGdldCBhIGNvbGxlY3Rpb25cbiAgLy8gLSBlbXB0eSBjb2xsZWN0aW9uIG9uIG5vIGFyZ3NcbiAgLy8gLSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIGluIHRoZSBncmFwaCBvbiBzZWxlY3RvciBhcmdcbiAgLy8gLSBndWFyYW50ZWUgYSByZXR1cm5lZCBjb2xsZWN0aW9uIHdoZW4gZWxlbWVudHMgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWRcbiAgY29sbGVjdGlvbjogZnVuY3Rpb24oIGVsZXMsIG9wdHMgKXtcblxuICAgIGlmKCBpcy5zdHJpbmcoIGVsZXMgKSApe1xuICAgICAgcmV0dXJuIHRoaXMuJCggZWxlcyApO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKCBlbGVzICkgKXtcbiAgICAgIHJldHVybiBlbGVzLmNvbGxlY3Rpb24oKTtcblxuICAgIH0gZWxzZSBpZiggaXMuYXJyYXkoIGVsZXMgKSApe1xuICAgICAgcmV0dXJuIENvbGxlY3Rpb24oIHRoaXMsIGVsZXMsIG9wdHMgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ29sbGVjdGlvbiggdGhpcyApO1xuICB9LFxuXG4gIG5vZGVzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLiQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmlzTm9kZSgpO1xuICAgIH0pO1xuXG4gICAgaWYoIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gbm9kZXMuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlcztcbiAgfSxcblxuICBlZGdlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy4kKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKTtcbiAgICB9KTtcblxuICAgIGlmKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIGVkZ2VzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWRnZXM7XG4gIH0sXG5cbiAgLy8gc2VhcmNoIHRoZSBncmFwaCBsaWtlIGpRdWVyeVxuICAkOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlcyA9IG5ldyBDb2xsZWN0aW9uKCB0aGlzLCB0aGlzLl9wcml2YXRlLmVsZW1lbnRzICk7XG5cbiAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiBlbGVzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlcztcbiAgfVxuXG59KTtcblxuLy8gYWxpYXNlc1xuY29yZWZuLmVsZW1lbnRzID0gY29yZWZuLmZpbHRlciA9IGNvcmVmbi4kO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcblxufSx7XCIuLi9jb2xsZWN0aW9uXCI6MjMsXCIuLi9pc1wiOjc3fV0sMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi9pcycpO1xudmFyIFN0eWxlID0gX2RlcmVxXygnLi4vc3R5bGUnKTtcblxudmFyIGNvcmVmbiA9ICh7XG5cbiAgc3R5bGU6IGZ1bmN0aW9uKCBuZXdTdHlsZSApe1xuICAgIGlmKCBuZXdTdHlsZSApe1xuICAgICAgdmFyIHMgPSB0aGlzLnNldFN0eWxlKCBuZXdTdHlsZSApO1xuXG4gICAgICBzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlO1xuICB9LFxuXG4gIHNldFN0eWxlOiBmdW5jdGlvbiggc3R5bGUgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoIGlzLnN0eWxlc2hlZXQoc3R5bGUpICl7XG4gICAgICBfcC5zdHlsZSA9IHN0eWxlLmdlbmVyYXRlU3R5bGUodGhpcyk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLmFycmF5KHN0eWxlKSApIHtcbiAgICAgIF9wLnN0eWxlID0gU3R5bGUuZnJvbUpzb24odGhpcywgc3R5bGUpO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5zdHJpbmcoc3R5bGUpICl7XG4gICAgICBfcC5zdHlsZSA9IFN0eWxlLmZyb21TdHJpbmcodGhpcywgc3R5bGUpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIF9wLnN0eWxlID0gU3R5bGUoIHRoaXMgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Auc3R5bGU7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcblxufSx7XCIuLi9pc1wiOjc3LFwiLi4vc3R5bGVcIjo4Nn1dLDQwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gX2RlcmVxXygnLi4vaXMnKTtcblxudmFyIGNvcmVmbiA9ICh7XG5cbiAgYXV0b2xvY2s6IGZ1bmN0aW9uKGJvb2wpe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2sgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvbG9jaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBhdXRvdW5ncmFiaWZ5OiBmdW5jdGlvbihib29sKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnkgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGF1dG91bnNlbGVjdGlmeTogZnVuY3Rpb24oYm9vbCl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnkgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHVzZXJQYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB6b29taW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgdXNlclpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBwYW46IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgIHN3aXRjaCggYXJncy5sZW5ndGggKXtcbiAgICBjYXNlIDA6IC8vIC5wYW4oKVxuICAgICAgcmV0dXJuIHBhbjtcblxuICAgIGNhc2UgMTpcblxuICAgICAgaWYoIGlzLnN0cmluZyggYXJnc1swXSApICl7IC8vIC5wYW4oJ3gnKVxuICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICByZXR1cm4gcGFuWyBkaW0gXTtcblxuICAgICAgfSBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdCggYXJnc1swXSApICkgeyAvLyAucGFuKHsgeDogMCwgeTogMTAwIH0pXG4gICAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZGltcyA9IGFyZ3NbMF07XG4gICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgaWYoIGlzLm51bWJlcih4KSApe1xuICAgICAgICAgIHBhbi54ID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBpcy5udW1iZXIoeSkgKXtcbiAgICAgICAgICBwYW4ueSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6IC8vIC5wYW4oJ3gnLCAxMDApXG4gICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICB2YWwgPSBhcmdzWzFdO1xuXG4gICAgICBpZiggKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiBpcy5udW1iZXIodmFsKSApe1xuICAgICAgICBwYW5bZGltXSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmlnZ2VyKCdwYW4gdmlld3BvcnQnKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrOyAvLyBpbnZhbGlkXG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHBhbkJ5OiBmdW5jdGlvbihwYXJhbXMpe1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG5cbiAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN3aXRjaCggYXJncy5sZW5ndGggKXtcbiAgICBjYXNlIDE6XG5cbiAgICAgIGlmKCBpcy5wbGFpbk9iamVjdCggYXJnc1swXSApICkgeyAvLyAucGFuQnkoeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgZGltcyA9IGFyZ3NbMF07XG4gICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgaWYoIGlzLm51bWJlcih4KSApe1xuICAgICAgICAgIHBhbi54ICs9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaXMubnVtYmVyKHkpICl7XG4gICAgICAgICAgcGFuLnkgKz0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcigncGFuIHZpZXdwb3J0Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjogLy8gLnBhbkJ5KCd4JywgMTAwKVxuICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgIHZhbCA9IGFyZ3NbMV07XG5cbiAgICAgIGlmKCAoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmIGlzLm51bWJlcih2YWwpICl7XG4gICAgICAgIHBhbltkaW1dICs9IHZhbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmlnZ2VyKCdwYW4gdmlld3BvcnQnKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrOyAvLyBpbnZhbGlkXG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGZpdDogZnVuY3Rpb24oIGVsZW1lbnRzLCBwYWRkaW5nICl7XG4gICAgdmFyIHZpZXdwb3J0U3RhdGUgPSB0aGlzLmdldEZpdFZpZXdwb3J0KCBlbGVtZW50cywgcGFkZGluZyApO1xuXG4gICAgaWYoIHZpZXdwb3J0U3RhdGUgKXtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBfcC56b29tID0gdmlld3BvcnRTdGF0ZS56b29tO1xuICAgICAgX3AucGFuID0gdmlld3BvcnRTdGF0ZS5wYW47XG5cbiAgICAgIHRoaXMudHJpZ2dlcigncGFuIHpvb20gdmlld3BvcnQnKTtcblxuICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgZ2V0Rml0Vmlld3BvcnQ6IGZ1bmN0aW9uKCBlbGVtZW50cywgcGFkZGluZyApe1xuICAgIGlmKCBpcy5udW1iZXIoZWxlbWVudHMpICYmIHBhZGRpbmcgPT09IHVuZGVmaW5lZCApeyAvLyBlbGVtZW50cyBpcyBvcHRpb25hbFxuICAgICAgcGFkZGluZyA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJiO1xuXG4gICAgaWYoIGlzLnN0cmluZyhlbGVtZW50cykgKXtcbiAgICAgIHZhciBzZWwgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdGhpcy4kKCBzZWwgKTtcblxuICAgIH0gZWxzZSBpZiggaXMuYm91bmRpbmdCb3goZWxlbWVudHMpICl7IC8vIGFzc3VtZSBiYlxuICAgICAgdmFyIGJiZSA9IGVsZW1lbnRzO1xuICAgICAgYmIgPSB7XG4gICAgICAgIHgxOiBiYmUueDEsXG4gICAgICAgIHkxOiBiYmUueTEsXG4gICAgICAgIHgyOiBiYmUueDIsXG4gICAgICAgIHkyOiBiYmUueTJcbiAgICAgIH07XG5cbiAgICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG5cbiAgICB9IGVsc2UgaWYoICFpcy5lbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSApe1xuICAgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgYmIgPSBiYiB8fCBlbGVtZW50cy5ib3VuZGluZ0JveCgpO1xuXG4gICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgIHZhciB6b29tO1xuICAgIHBhZGRpbmcgPSBpcy5udW1iZXIocGFkZGluZykgPyBwYWRkaW5nIDogMDtcblxuICAgIGlmKCAhaXNOYU4odykgJiYgIWlzTmFOKGgpICYmIHcgPiAwICYmIGggPiAwICYmICFpc05hTihiYi53KSAmJiAhaXNOYU4oYmIuaCkgJiYgIGJiLncgPiAwICYmIGJiLmggPiAwICl7XG4gICAgICB6b29tID0gTWF0aC5taW4oICh3IC0gMipwYWRkaW5nKS9iYi53LCAoaCAtIDIqcGFkZGluZykvYmIuaCApO1xuXG4gICAgICAvLyBjcm9wIHpvb21cbiAgICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcblxuICAgICAgdmFyIHBhbiA9IHsgLy8gbm93IHBhbiB0byBtaWRkbGVcbiAgICAgICAgeDogKHcgLSB6b29tKiggYmIueDEgKyBiYi54MiApKS8yLFxuICAgICAgICB5OiAoaCAtIHpvb20qKCBiYi55MSArIGJiLnkyICkpLzJcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIHBhbjogcGFuXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSxcblxuICBtaW5ab29tOiBmdW5jdGlvbiggem9vbSApe1xuICAgIGlmKCB6b29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1pblpvb207XG4gICAgfSBlbHNlIGlmKCBpcy5udW1iZXIoem9vbSkgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUubWluWm9vbSA9IHpvb207XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgbWF4Wm9vbTogZnVuY3Rpb24oIHpvb20gKXtcbiAgICBpZiggem9vbSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXhab29tO1xuICAgIH0gZWxzZSBpZiggaXMubnVtYmVyKHpvb20pICl7XG4gICAgICB0aGlzLl9wcml2YXRlLm1heFpvb20gPSB6b29tO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHpvb206IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgcG9zOyAvLyBpbiByZW5kZXJlZCBweFxuICAgIHZhciB6b29tO1xuXG4gICAgaWYoIHBhcmFtcyA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gZ2V0IHRoZSB6b29tXG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29tO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5udW1iZXIocGFyYW1zKSApeyAvLyB0aGVuIHNldCB0aGUgem9vbVxuICAgICAgem9vbSA9IHBhcmFtcztcblxuICAgIH0gZWxzZSBpZiggaXMucGxhaW5PYmplY3QocGFyYW1zKSApeyAvLyB0aGVuIHpvb20gYWJvdXQgYSBwb2ludFxuICAgICAgem9vbSA9IHBhcmFtcy5sZXZlbDtcblxuICAgICAgaWYoIHBhcmFtcy5wb3NpdGlvbiApe1xuICAgICAgICB2YXIgcCA9IHBhcmFtcy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgICB2YXIgeiA9IHRoaXMuX3ByaXZhdGUuem9vbTtcblxuICAgICAgICBwb3MgPSB7IC8vIGNvbnZlcnQgdG8gcmVuZGVyZWQgcHhcbiAgICAgICAgICB4OiBwLnggKiB6ICsgcGFuLngsXG4gICAgICAgICAgeTogcC55ICogeiArIHBhbi55XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYoIHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uICl7XG4gICAgICAgIHBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiggcG9zICYmICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBwYW5uaW5nIGRpc2FibGVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkICl7XG4gICAgICByZXR1cm4gdGhpczsgLy8gem9vbWluZyBkaXNhYmxlZFxuICAgIH1cblxuICAgIGlmKCAhaXMubnVtYmVyKHpvb20pIHx8ICggcG9zICYmICghaXMubnVtYmVyKHBvcy54KSB8fCAhaXMubnVtYmVyKHBvcy55KSkgKSApe1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNhbid0IHpvb20gd2l0aCBpbnZhbGlkIHBhcmFtc1xuICAgIH1cblxuICAgIC8vIGNyb3Agem9vbVxuICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICB6b29tID0gem9vbSA8IHRoaXMuX3ByaXZhdGUubWluWm9vbSA/IHRoaXMuX3ByaXZhdGUubWluWm9vbSA6IHpvb207XG5cbiAgICBpZiggcG9zICl7IC8vIHNldCB6b29tIGFib3V0IHBvc2l0aW9uXG4gICAgICB2YXIgcGFuMSA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgdmFyIHpvb20xID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgICAgdmFyIHpvb20yID0gem9vbTtcblxuICAgICAgdmFyIHBhbjIgPSB7XG4gICAgICAgIHg6IC16b29tMi96b29tMSAqIChwb3MueCAtIHBhbjEueCkgKyBwb3MueCxcbiAgICAgICAgeTogLXpvb20yL3pvb20xICogKHBvcy55IC0gcGFuMS55KSArIHBvcy55XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9wcml2YXRlLnpvb20gPSB6b29tO1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW4gPSBwYW4yO1xuXG4gICAgICB2YXIgcG9zQ2hhbmdlZCA9IHBhbjEueCAhPT0gcGFuMi54IHx8IHBhbjEueSAhPT0gcGFuMi55O1xuICAgICAgdGhpcy50cmlnZ2VyKCcgem9vbSAnICsgKHBvc0NoYW5nZWQgPyAnIHBhbiAnIDogJycpICsgJyB2aWV3cG9ydCAnICk7XG5cbiAgICB9IGVsc2UgeyAvLyBqdXN0IHNldCB0aGUgem9vbVxuICAgICAgdGhpcy5fcHJpdmF0ZS56b29tID0gem9vbTtcbiAgICAgIHRoaXMudHJpZ2dlcignem9vbSB2aWV3cG9ydCcpO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5KHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB2aWV3cG9ydDogZnVuY3Rpb24oIG9wdHMgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB6b29tRGVmZCA9IHRydWU7XG4gICAgdmFyIHBhbkRlZmQgPSB0cnVlO1xuICAgIHZhciBldmVudHMgPSBbXTsgLy8gdG8gdHJpZ2dlclxuICAgIHZhciB6b29tRmFpbGVkID0gZmFsc2U7XG4gICAgdmFyIHBhbkZhaWxlZCA9IGZhbHNlO1xuXG4gICAgaWYoICFvcHRzICl7IHJldHVybiB0aGlzOyB9XG4gICAgaWYoICFpcy5udW1iZXIob3B0cy56b29tKSApeyB6b29tRGVmZCA9IGZhbHNlOyB9XG4gICAgaWYoICFpcy5wbGFpbk9iamVjdChvcHRzLnBhbikgKXsgcGFuRGVmZCA9IGZhbHNlOyB9XG4gICAgaWYoICF6b29tRGVmZCAmJiAhcGFuRGVmZCApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgaWYoIHpvb21EZWZkICl7XG4gICAgICB2YXIgeiA9IG9wdHMuem9vbTtcblxuICAgICAgaWYoIHogPCBfcC5taW5ab29tIHx8IHogPiBfcC5tYXhab29tIHx8ICFfcC56b29taW5nRW5hYmxlZCApe1xuICAgICAgICB6b29tRmFpbGVkID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Auem9vbSA9IHo7XG5cbiAgICAgICAgZXZlbnRzLnB1c2goJ3pvb20nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggcGFuRGVmZCAmJiAoIXpvb21GYWlsZWQgfHwgIW9wdHMuY2FuY2VsT25GYWlsZWRab29tKSAmJiBfcC5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgdmFyIHAgPSBvcHRzLnBhbjtcblxuICAgICAgaWYoIGlzLm51bWJlcihwLngpICl7XG4gICAgICAgIF9wLnBhbi54ID0gcC54O1xuICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoIGlzLm51bWJlcihwLnkpICl7XG4gICAgICAgIF9wLnBhbi55ID0gcC55O1xuICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoICFwYW5GYWlsZWQgKXtcbiAgICAgICAgZXZlbnRzLnB1c2goJ3BhbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBldmVudHMubGVuZ3RoID4gMCApe1xuICAgICAgZXZlbnRzLnB1c2goJ3ZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLnRyaWdnZXIoIGV2ZW50cy5qb2luKCcgJykgKTtcblxuICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBjZW50ZXI6IGZ1bmN0aW9uKCBlbGVtZW50cyApe1xuICAgIHZhciBwYW4gPSB0aGlzLmdldENlbnRlclBhbiggZWxlbWVudHMgKTtcblxuICAgIGlmKCBwYW4gKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUucGFuID0gcGFuO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuXG4gICAgICB0aGlzLm5vdGlmeSh7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBnZXRDZW50ZXJQYW46IGZ1bmN0aW9uKCBlbGVtZW50cywgem9vbSApe1xuICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKCBpcy5zdHJpbmcoZWxlbWVudHMpICl7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cyggc2VsZWN0b3IgKTtcbiAgICB9IGVsc2UgaWYoICFpcy5lbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSApe1xuICAgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgdmFyIGJiID0gZWxlbWVudHMuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3ByaXZhdGUuem9vbSA6IHpvb207XG5cbiAgICB2YXIgcGFuID0geyAvLyBtaWRkbGVcbiAgICAgIHg6ICh3IC0gem9vbSooIGJiLngxICsgYmIueDIgKSkvMixcbiAgICAgIHk6IChoIC0gem9vbSooIGJiLnkxICsgYmIueTIgKSkvMlxuICAgIH07XG5cbiAgICByZXR1cm4gcGFuO1xuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpe1xuICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy52aWV3cG9ydCh7XG4gICAgICBwYW46IHsgeDogMCwgeTogMCB9LFxuICAgICAgem9vbTogMVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgd2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX3ByaXZhdGUuY29udGFpbmVyO1xuXG4gICAgaWYoIGNvbnRhaW5lciApe1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gMTsgLy8gZmFsbGJhY2sgaWYgbm8gY29udGFpbmVyIChub3QgMCBiL2MgY2FuIGJlIHVzZWQgZm9yIGRpdmlkaW5nIGV0YylcbiAgfSxcblxuICBoZWlnaHQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX3ByaXZhdGUuY29udGFpbmVyO1xuXG4gICAgaWYoIGNvbnRhaW5lciApe1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7IC8vIGZhbGxiYWNrIGlmIG5vIGNvbnRhaW5lciAobm90IDAgYi9jIGNhbiBiZSB1c2VkIGZvciBkaXZpZGluZyBldGMpXG4gIH0sXG5cbiAgZXh0ZW50OiBmdW5jdGlvbigpe1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgem9vbSA9IHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICB2YXIgcmIgPSB0aGlzLnJlbmRlcmVkRXh0ZW50KCk7XG5cbiAgICB2YXIgYiA9IHtcbiAgICAgIHgxOiAoIHJiLngxIC0gcGFuLnggKS96b29tLFxuICAgICAgeDI6ICggcmIueDIgLSBwYW4ueCApL3pvb20sXG4gICAgICB5MTogKCByYi55MSAtIHBhbi55ICkvem9vbSxcbiAgICAgIHkyOiAoIHJiLnkyIC0gcGFuLnkgKS96b29tXG4gICAgfTtcblxuICAgIGIudyA9IGIueDIgLSBiLngxO1xuICAgIGIuaCA9IGIueTIgLSBiLnkxO1xuXG4gICAgcmV0dXJuIGI7XG4gIH0sXG5cbiAgcmVuZGVyZWRFeHRlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiAwLFxuICAgICAgeTE6IDAsXG4gICAgICB4Mjogd2lkdGgsXG4gICAgICB5MjogaGVpZ2h0LFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHRcbiAgICB9O1xuICB9XG59KTtcblxuLy8gYWxpYXNlc1xuY29yZWZuLmNlbnRyZSA9IGNvcmVmbi5jZW50ZXI7XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5jb3JlZm4uYXV0b2xvY2tOb2RlcyA9IGNvcmVmbi5hdXRvbG9jaztcbmNvcmVmbi5hdXRvdW5ncmFiaWZ5Tm9kZXMgPSBjb3JlZm4uYXV0b3VuZ3JhYmlmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG5cbn0se1wiLi4vaXNcIjo3N31dLDQxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gdXNlIHRoaXMgbW9kdWxlIHRvIGNoZXJyeSBwaWNrIGZ1bmN0aW9ucyBpbnRvIHlvdXIgcHJvdG90eXBlXG4vLyAodXNlZnVsIGZvciBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gdGhlIGNvcmUgYW5kIGNvbGxlY3Rpb25zLCBmb3IgZXhhbXBsZSlcblxuLy8gZS5nLlxuLy8gdmFyIGZvbyA9IGRlZmluZS5mb28oeyAvKiBwYXJhbXMuLi4gKi8gfSlcblxudmFyIHV0aWwgPSBfZGVyZXFfKCcuL3V0aWwnKTtcbnZhciBpcyA9IF9kZXJlcV8oJy4vaXMnKTtcbnZhciBTZWxlY3RvciA9IF9kZXJlcV8oJy4vc2VsZWN0b3InKTtcbnZhciBQcm9taXNlID0gX2RlcmVxXygnLi9wcm9taXNlJyk7XG52YXIgRXZlbnQgPSBfZGVyZXFfKCcuL2V2ZW50Jyk7XG52YXIgQW5pbWF0aW9uID0gX2RlcmVxXygnLi9hbmltYXRpb24nKTtcblxudmFyIGRlZmluZSA9IHtcblxuICAvLyBhY2Nlc3MgZGF0YSBmaWVsZFxuICBkYXRhOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogZmFsc2UsXG4gICAgICBhbGxvd0dldHRpbmc6IGZhbHNlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBpbW11dGFibGVLZXlzOiB7fSwgLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICB1cGRhdGVTdHlsZTogZmFsc2UsXG4gICAgICBvblNldDogZnVuY3Rpb24oIHNlbGYgKXt9LFxuICAgICAgY2FuU2V0OiBmdW5jdGlvbiggc2VsZiApeyByZXR1cm4gdHJ1ZTsgfVxuICAgIH07XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGFJbXBsKCBuYW1lLCB2YWx1ZSApe1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBzaW5nbGUgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmWzBdIDogc2VsZjtcblxuICAgICAgLy8gLmRhdGEoJ2ZvbycsIC4uLilcbiAgICAgIGlmKCBpcy5zdHJpbmcobmFtZSkgKXsgLy8gc2V0IG9yIGdldCBwcm9wZXJ0eVxuXG4gICAgICAgIC8vIC5kYXRhKCdmb28nKVxuICAgICAgICBpZiggcC5hbGxvd0dldHRpbmcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApeyAvLyBnZXRcblxuICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgaWYoIHNpbmdsZSApe1xuICAgICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlWyBwLmZpZWxkIF1bIG5hbWUgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICAvLyAuZGF0YSgnZm9vJywgJ2JhcicpXG4gICAgICAgIH0gZWxzZSBpZiggcC5hbGxvd1NldHRpbmcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHsgLy8gc2V0XG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1tuYW1lXTtcbiAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwLCBsID0gYWxsLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICAgICAgICBpZiggcC5jYW5TZXQoIGFsbFtpXSApICl7XG4gICAgICAgICAgICAgICAgYWxsW2ldLl9wcml2YXRlWyBwLmZpZWxkIF1bIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG4gICAgICAgICAgICBpZiggcC51cGRhdGVTdHlsZSApeyBzZWxmLnVwZGF0ZVN0eWxlKCk7IH1cblxuICAgICAgICAgICAgLy8gY2FsbCBvblNldCBjYWxsYmFja1xuICAgICAgICAgICAgcC5vblNldCggc2VsZiApO1xuXG4gICAgICAgICAgICBpZiggcC5zZXR0aW5nVHJpZ2dlcnNFdmVudCApe1xuICAgICAgICAgICAgICBzZWxmWyBwLnRyaWdnZXJGbk5hbWUgXSggcC5zZXR0aW5nRXZlbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy8gLmRhdGEoeyAnZm9vJzogJ2JhcicgfSlcbiAgICAgIH0gZWxzZSBpZiggcC5hbGxvd1NldHRpbmcgJiYgaXMucGxhaW5PYmplY3QobmFtZSkgKXsgLy8gZXh0ZW5kXG4gICAgICAgIHZhciBvYmogPSBuYW1lO1xuICAgICAgICB2YXIgaywgdjtcblxuICAgICAgICBmb3IoIGsgaW4gb2JqICl7XG4gICAgICAgICAgdiA9IG9ialsgayBdO1xuXG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trXTtcbiAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwLCBsID0gYWxsLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICAgICAgICBpZiggcC5jYW5TZXQoIGFsbFtpXSApICl7XG4gICAgICAgICAgICAgICAgYWxsW2ldLl9wcml2YXRlWyBwLmZpZWxkIF1bIGsgXSA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuICAgICAgICBpZiggcC51cGRhdGVTdHlsZSApeyBzZWxmLnVwZGF0ZVN0eWxlKCk7IH1cblxuICAgICAgICAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG4gICAgICAgIHAub25TZXQoIHNlbGYgKTtcblxuICAgICAgICBpZiggcC5zZXR0aW5nVHJpZ2dlcnNFdmVudCApe1xuICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLnNldHRpbmdFdmVudCApO1xuICAgICAgICB9XG5cbiAgICAgIC8vIC5kYXRhKGZ1bmN0aW9uKCl7IC4uLiB9KVxuICAgICAgfSBlbHNlIGlmKCBwLmFsbG93QmluZGluZyAmJiBpcy5mbihuYW1lKSApeyAvLyBiaW5kIHRvIGV2ZW50XG4gICAgICAgIHZhciBmbiA9IG5hbWU7XG4gICAgICAgIHNlbGYuYmluZCggcC5iaW5kaW5nRXZlbnQsIGZuICk7XG5cbiAgICAgIC8vIC5kYXRhKClcbiAgICAgIH0gZWxzZSBpZiggcC5hbGxvd0dldHRpbmcgJiYgbmFtZSA9PT0gdW5kZWZpbmVkICl7IC8vIGdldCB3aG9sZSBvYmplY3RcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgaWYoIHNpbmdsZSApe1xuICAgICAgICAgIHJldCA9IHNpbmdsZS5fcHJpdmF0ZVsgcC5maWVsZCBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmFiaWxpdHlcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LCAvLyBkYXRhXG5cbiAgLy8gcmVtb3ZlIGRhdGEgZmllbGRcbiAgcmVtb3ZlRGF0YTogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZSxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9IC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuICAgIH07XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZURhdGFJbXBsKCBuYW1lcyApe1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgLy8gLnJlbW92ZURhdGEoJ2ZvbyBiYXInKVxuICAgICAgaWYoIGlzLnN0cmluZyhuYW1lcykgKXsgLy8gdGhlbiBnZXQgdGhlIGxpc3Qgb2Yga2V5cywgYW5kIGRlbGV0ZSB0aGVtXG4gICAgICAgIHZhciBrZXlzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGw7IGkrKyApeyAvLyBkZWxldGUgZWFjaCBub24tZW1wdHkga2V5XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYoIGlzLmVtcHR5U3RyaW5nKGtleSkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNbIGtleSBdOyAvLyBub3QgdmFsaWQgaWYgaW1tdXRhYmxlXG4gICAgICAgICAgaWYoIHZhbGlkICl7XG4gICAgICAgICAgICBmb3IoIHZhciBpX2EgPSAwLCBsX2EgPSBhbGwubGVuZ3RoOyBpX2EgPCBsX2E7IGlfYSsrICl7XG4gICAgICAgICAgICAgIGFsbFsgaV9hIF0uX3ByaXZhdGVbIHAuZmllbGQgXVsga2V5IF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHAudHJpZ2dlckV2ZW50ICl7XG4gICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuZXZlbnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyAucmVtb3ZlRGF0YSgpXG4gICAgICB9IGVsc2UgaWYoIG5hbWVzID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBkZWxldGUgYWxsIGtleXNcblxuICAgICAgICBmb3IoIHZhciBpX2EgPSAwLCBsX2EgPSBhbGwubGVuZ3RoOyBpX2EgPCBsX2E7IGlfYSsrICl7XG4gICAgICAgICAgdmFyIF9wcml2YXRlRmllbGRzID0gYWxsWyBpX2EgXS5fcHJpdmF0ZVsgcC5maWVsZCBdO1xuXG4gICAgICAgICAgZm9yKCB2YXIga2V5IGluIF9wcml2YXRlRmllbGRzICl7XG4gICAgICAgICAgICB2YXIgdmFsaWRLZXlUb0RlbGV0ZSA9ICFwLmltbXV0YWJsZUtleXNbIGtleSBdO1xuXG4gICAgICAgICAgICBpZiggdmFsaWRLZXlUb0RlbGV0ZSApe1xuICAgICAgICAgICAgICBfcHJpdmF0ZUZpZWxkc1sga2V5IF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHAudHJpZ2dlckV2ZW50ICl7XG4gICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuZXZlbnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LCAvLyByZW1vdmVEYXRhXG5cbiAgLy8gZXZlbnQgZnVuY3Rpb24gcmV1c2FibGUgc3R1ZmZcbiAgZXZlbnQ6IHtcbiAgICByZWdleDogLyhcXHcrKShcXC5cXHcrKT8vLCAvLyByZWdleCBmb3IgbWF0Y2hpbmcgZXZlbnQgc3RyaW5ncyAoZS5nLiBcImNsaWNrLm5hbWVzcGFjZVwiKVxuICAgIG9wdGlvbmFsVHlwZVJlZ2V4OiAvKFxcdyspPyhcXC5cXHcrKT8vLFxuICAgIGZhbHNlQ2FsbGJhY2s6IGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZTsgfVxuICB9LFxuXG4gIC8vIGV2ZW50IGJpbmRpbmdcbiAgb246IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICB1bmJpbmRTZWxmT25UcmlnZ2VyOiBmYWxzZSxcbiAgICAgIHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IGZhbHNlXG4gICAgfTtcbiAgICBwYXJhbXMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gb25JbXBsKGV2ZW50cywgc2VsZWN0b3IsIGRhdGEsIGNhbGxiYWNrKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gaXMuc3RyaW5nKGV2ZW50cyk7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcblxuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KHNlbGVjdG9yKSApeyAvLyBzZWxlY3RvciBpcyBhY3R1YWxseSBkYXRhXG4gICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgZGF0YSA9IHNlbGVjdG9yO1xuICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiggaXMuZm4oc2VsZWN0b3IpIHx8IHNlbGVjdG9yID09PSBmYWxzZSApeyAvLyBzZWxlY3RvciBpcyBhY3R1YWxseSBjYWxsYmFja1xuICAgICAgICBjYWxsYmFjayA9IHNlbGVjdG9yO1xuICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYoIGlzLmZuKGRhdGEpIHx8IGRhdGEgPT09IGZhbHNlICl7IC8vIGRhdGEgaXMgYWN0dWFsbHkgY2FsbGJhY2tcbiAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGVyZSBpc24ndCBhIGNhbGxiYWNrLCB3ZSBjYW4ndCByZWFsbHkgZG8gYW55dGhpbmdcbiAgICAgIC8vIChjYW4ndCBzcGVhayBmb3IgbWFwcGVkIGV2ZW50cyBhcmcgdmVyc2lvbilcbiAgICAgIGlmKCAhKGlzLmZuKGNhbGxiYWNrKSB8fCBjYWxsYmFjayA9PT0gZmFsc2UpICYmIGV2ZW50c0lzU3RyaW5nICl7XG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfVxuXG4gICAgICBpZiggZXZlbnRzSXNTdHJpbmcgKXsgLy8gdGhlbiBjb252ZXJ0IHRvIG1hcFxuICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgIG1hcFsgZXZlbnRzIF0gPSBjYWxsYmFjaztcbiAgICAgICAgZXZlbnRzID0gbWFwO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBldnRzIGluIGV2ZW50cyApe1xuICAgICAgICBjYWxsYmFjayA9IGV2ZW50c1tldnRzXTtcbiAgICAgICAgaWYoIGNhbGxiYWNrID09PSBmYWxzZSApe1xuICAgICAgICAgIGNhbGxiYWNrID0gZGVmaW5lLmV2ZW50LmZhbHNlQ2FsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWlzLmZuKGNhbGxiYWNrKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIGV2dHMgPSBldnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZXZ0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBldnQgPSBldnRzW2ldO1xuICAgICAgICAgIGlmKCBpcy5lbXB0eVN0cmluZyhldnQpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goIGRlZmluZS5ldmVudC5yZWdleCApOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0ge1xuICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssIC8vIGNhbGxiYWNrIHRvIHJ1blxuICAgICAgICAgICAgICBkYXRhOiBkYXRhLCAvLyBleHRyYSBkYXRhIGluIGV2ZW50T2JqLmRhdGFcbiAgICAgICAgICAgICAgZGVsZWdhdGVkOiBzZWxlY3RvciA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZXZ0IGlzIGRlbGVnYXRlZFxuICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsIC8vIHRoZSBzZWxlY3RvciB0byBtYXRjaCBmb3IgZGVsZWdhdGVkIGV2ZW50c1xuICAgICAgICAgICAgICBzZWxPYmo6IG5ldyBTZWxlY3RvcihzZWxlY3RvciksIC8vIGNhY2hlZCBzZWxlY3RvciBvYmplY3QgdG8gc2F2ZSByZWJ1aWxkaW5nXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsIC8vIHRoZSBldmVudCB0eXBlIChlLmcuICdjbGljaycpXG4gICAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLCAvLyB0aGUgZXZlbnQgbmFtZXNwYWNlIChlLmcuIFwiLmZvb1wiKVxuICAgICAgICAgICAgICB1bmJpbmRTZWxmT25UcmlnZ2VyOiBwLnVuYmluZFNlbGZPblRyaWdnZXIsXG4gICAgICAgICAgICAgIHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHAudW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcixcbiAgICAgICAgICAgICAgYmluZGVyczogYWxsIC8vIHdobyBib3VuZCB0b2dldGhlclxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgICAgdmFyIF9wID0gYWxsW2pdLl9wcml2YXRlO1xuXG4gICAgICAgICAgICAgIF9wLmxpc3RlbmVycyA9IF9wLmxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgICAgICAgX3AubGlzdGVuZXJzLnB1c2goIGxpc3RlbmVyICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGZvciBldmVudHMgYXJyYXlcbiAgICAgIH0gLy8gZm9yIGV2ZW50cyBtYXBcblxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSwgLy8gb25cblxuICBldmVudEFsaWFzZXNPbjogZnVuY3Rpb24oIHByb3RvICl7XG4gICAgdmFyIHAgPSBwcm90bztcblxuICAgIHAuYWRkTGlzdGVuZXIgPSBwLmxpc3RlbiA9IHAuYmluZCA9IHAub247XG4gICAgcC5yZW1vdmVMaXN0ZW5lciA9IHAudW5saXN0ZW4gPSBwLnVuYmluZCA9IHAub2ZmO1xuICAgIHAuZW1pdCA9IHAudHJpZ2dlcjtcblxuICAgIC8vIHRoaXMgaXMganVzdCBhIHdyYXBwZXIgYWxpYXMgb2YgLm9uKClcbiAgICBwLnBvbiA9IHAucHJvbWlzZU9uID0gZnVuY3Rpb24oIGV2ZW50cywgc2VsZWN0b3IgKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oIHJlc29sdmUsIHJlamVjdCApe1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiggZSApe1xuICAgICAgICAgIHNlbGYub2ZmLmFwcGx5KCBzZWxmLCBvZmZBcmdzICk7XG5cbiAgICAgICAgICByZXNvbHZlKCBlICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9uQXJncyA9IGFyZ3MuY29uY2F0KFsgY2FsbGJhY2sgXSk7XG4gICAgICAgIHZhciBvZmZBcmdzID0gb25BcmdzLmNvbmNhdChbXSk7XG5cbiAgICAgICAgc2VsZi5vbi5hcHBseSggc2VsZiwgb25BcmdzICk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuXG4gIG9mZjogZnVuY3Rpb24gb2ZmSW1wbCggcGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgIH07XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gaXMuc3RyaW5nKGV2ZW50cyk7XG5cbiAgICAgIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICl7IC8vIHRoZW4gdW5iaW5kIGFsbFxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgYWxsW2ldLl9wcml2YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICB9XG5cbiAgICAgIGlmKCBpcy5mbihzZWxlY3RvcikgfHwgc2VsZWN0b3IgPT09IGZhbHNlICl7IC8vIHNlbGVjdG9yIGlzIGFjdHVhbGx5IGNhbGxiYWNrXG4gICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiggZXZlbnRzSXNTdHJpbmcgKXsgLy8gdGhlbiBjb252ZXJ0IHRvIG1hcFxuICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgIG1hcFsgZXZlbnRzIF0gPSBjYWxsYmFjaztcbiAgICAgICAgZXZlbnRzID0gbWFwO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBldnRzIGluIGV2ZW50cyApe1xuICAgICAgICBjYWxsYmFjayA9IGV2ZW50c1tldnRzXTtcblxuICAgICAgICBpZiggY2FsbGJhY2sgPT09IGZhbHNlICl7XG4gICAgICAgICAgY2FsbGJhY2sgPSBkZWZpbmUuZXZlbnQuZmFsc2VDYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGV2dHMgPSBldnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGZvciggdmFyIGggPSAwOyBoIDwgZXZ0cy5sZW5ndGg7IGgrKyApe1xuICAgICAgICAgIHZhciBldnQgPSBldnRzW2hdO1xuICAgICAgICAgIGlmKCBpcy5lbXB0eVN0cmluZyhldnQpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goIGRlZmluZS5ldmVudC5vcHRpb25hbFR5cGVSZWdleCApOyAvLyBbdHlwZV1bLm5hbWVzcGFjZV1cbiAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV0gPyBtYXRjaFsxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApeyAvL1xuICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gYWxsW2ldLl9wcml2YXRlLmxpc3RlbmVycyA9IGFsbFtpXS5fcHJpdmF0ZS5saXN0ZW5lcnMgfHwgW107XG5cbiAgICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBsaXN0ZW5lcnMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbal07XG4gICAgICAgICAgICAgICAgdmFyIG5zTWF0Y2hlcyA9ICFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSBsaXN0ZW5lci5uYW1lc3BhY2U7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVNYXRjaGVzID0gIXR5cGUgfHwgbGlzdGVuZXIudHlwZSA9PT0gdHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgY2JNYXRjaGVzID0gIWNhbGxiYWNrIHx8IGNhbGxiYWNrID09PSBsaXN0ZW5lci5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJNYXRjaGVzID0gbnNNYXRjaGVzICYmIHR5cGVNYXRjaGVzICYmIGNiTWF0Y2hlcztcblxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBsaXN0ZW5lciBpZiBpdCBtYXRjaGVzXG4gICAgICAgICAgICAgICAgaWYoIGxpc3RlbmVyTWF0Y2hlcyApe1xuICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gZm9yIGxpc3RlbmVyc1xuICAgICAgICAgICAgfSAvLyBmb3IgYWxsXG4gICAgICAgICAgfSAvLyBpZiBtYXRjaFxuICAgICAgICB9IC8vIGZvciBldmVudHMgYXJyYXlcblxuICAgICAgfSAvLyBmb3IgZXZlbnRzIG1hcFxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LCAvLyBvZmZcblxuICB0cmlnZ2VyOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRyaWdnZXJJbXBsKGV2ZW50cywgZXh0cmFQYXJhbXMsIGZuVG9UcmlnZ2VyKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gaXMuc3RyaW5nKGV2ZW50cyk7XG4gICAgICB2YXIgZXZlbnRzSXNPYmplY3QgPSBpcy5wbGFpbk9iamVjdChldmVudHMpO1xuICAgICAgdmFyIGV2ZW50c0lzRXZlbnQgPSBpcy5ldmVudChldmVudHMpO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCAoIGlzLmNvcmUodGhpcykgPyB0aGlzIDogbnVsbCApO1xuICAgICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5ID8gY3kuaGFzQ29tcG91bmROb2RlcygpIDogZmFsc2U7XG5cbiAgICAgIGlmKCBldmVudHNJc1N0cmluZyApeyAvLyB0aGVuIG1ha2UgYSBwbGFpbiBldmVudCBvYmplY3QgZm9yIGVhY2ggZXZlbnQgbmFtZVxuICAgICAgICB2YXIgZXZ0cyA9IGV2ZW50cy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBldmVudHMgPSBbXTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZXZ0ID0gZXZ0c1tpXTtcbiAgICAgICAgICBpZiggaXMuZW1wdHlTdHJpbmcoZXZ0KSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKCBkZWZpbmUuZXZlbnQucmVnZXggKTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBldmVudHMucHVzaCgge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlXG4gICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoIGV2ZW50c0lzT2JqZWN0ICl7IC8vIHB1dCBpbiBsZW5ndGggMSBhcnJheVxuICAgICAgICB2YXIgZXZlbnRBcmdPYmogPSBldmVudHM7XG5cbiAgICAgICAgZXZlbnRzID0gWyBldmVudEFyZ09iaiBdO1xuICAgICAgfVxuXG4gICAgICBpZiggZXh0cmFQYXJhbXMgKXtcbiAgICAgICAgaWYoICFpcy5hcnJheShleHRyYVBhcmFtcykgKXsgLy8gbWFrZSBzdXJlIGV4dHJhIHBhcmFtcyBhcmUgaW4gYW4gYXJyYXkgaWYgc3BlY2lmaWVkXG4gICAgICAgICAgZXh0cmFQYXJhbXMgPSBbIGV4dHJhUGFyYW1zIF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSwgd2UndmUgZ290IG5vdGhpbmdcbiAgICAgICAgZXh0cmFQYXJhbXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKysgKXsgLy8gdHJpZ2dlciBlYWNoIGV2ZW50IGluIG9yZGVyXG4gICAgICAgIHZhciBldnRPYmogPSBldmVudHNbaV07XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKysgKXsgLy8gZm9yIGVhY2hcbiAgICAgICAgICB2YXIgdHJpZ2dlcmVyID0gYWxsW2pdO1xuICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0cmlnZ2VyZXIuX3ByaXZhdGUubGlzdGVuZXJzID0gdHJpZ2dlcmVyLl9wcml2YXRlLmxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgICB2YXIgdHJpZ2dlcmVySXNFbGVtZW50ID0gaXMuZWxlbWVudCh0cmlnZ2VyZXIpO1xuICAgICAgICAgIHZhciBidWJibGVVcCA9IHRyaWdnZXJlcklzRWxlbWVudCB8fCBwYXJhbXMubGF5b3V0O1xuXG4gICAgICAgICAgLy8gY3JlYXRlIHRoZSBldmVudCBmb3IgdGhpcyBlbGVtZW50IGZyb20gdGhlIGV2ZW50IG9iamVjdFxuICAgICAgICAgIHZhciBldnQ7XG5cbiAgICAgICAgICBpZiggZXZlbnRzSXNFdmVudCApeyAvLyB0aGVuIGp1c3QgZ2V0IHRoZSBvYmplY3RcbiAgICAgICAgICAgIGV2dCA9IGV2dE9iajtcblxuICAgICAgICAgICAgZXZ0LmN5VGFyZ2V0ID0gZXZ0LmN5VGFyZ2V0IHx8IHRyaWdnZXJlcjtcbiAgICAgICAgICAgIGV2dC5jeSA9IGV2dC5jeSB8fCBjeTtcblxuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gd2UgaGF2ZSB0byBtYWtlIG9uZVxuICAgICAgICAgICAgZXZ0ID0gbmV3IEV2ZW50KCBldnRPYmosIHtcbiAgICAgICAgICAgICAgY3lUYXJnZXQ6IHRyaWdnZXJlcixcbiAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICBuYW1lc3BhY2U6IGV2dE9iai5uYW1lc3BhY2VcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiBhIGxheW91dCB3YXMgc3BlY2lmaWVkLCB0aGVuIHB1dCBpdCBpbiB0aGUgdHlwZWQgZXZlbnRcbiAgICAgICAgICBpZiggZXZ0T2JqLmxheW91dCApe1xuICAgICAgICAgICAgZXZ0LmxheW91dCA9IGV2dE9iai5sYXlvdXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdHJpZ2dlcmVkIGJ5IGxheW91dCwgcHV0IGluIGV2ZW50XG4gICAgICAgICAgaWYoIHBhcmFtcy5sYXlvdXQgKXtcbiAgICAgICAgICAgIGV2dC5sYXlvdXQgPSB0cmlnZ2VyZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY3JlYXRlIGEgcmVuZGVyZWQgcG9zaXRpb24gYmFzZWQgb24gdGhlIHBhc3NlZCBwb3NpdGlvblxuICAgICAgICAgIGlmKCBldnQuY3lQb3NpdGlvbiApe1xuICAgICAgICAgICAgdmFyIHBvcyA9IGV2dC5jeVBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG5cbiAgICAgICAgICAgIGV2dC5jeVJlbmRlcmVkUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgIHg6IHBvcy54ICogem9vbSArIHBhbi54LFxuICAgICAgICAgICAgICB5OiBwb3MueSAqIHpvb20gKyBwYW4ueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggZm5Ub1RyaWdnZXIgKXsgLy8gdGhlbiBvdmVycmlkZSB0aGUgbGlzdGVuZXJzIGxpc3Qgd2l0aCBqdXN0IHRoZSBvbmUgd2Ugc3BlY2lmaWVkXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBbe1xuICAgICAgICAgICAgICBuYW1lc3BhY2U6IGV2dC5uYW1lc3BhY2UsXG4gICAgICAgICAgICAgIHR5cGU6IGV2dC50eXBlLFxuICAgICAgICAgICAgICBjYWxsYmFjazogZm5Ub1RyaWdnZXJcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgbGlzdGVuZXJzLmxlbmd0aDsgaysrICl7IC8vIGNoZWNrIGVhY2ggbGlzdGVuZXJcbiAgICAgICAgICAgIHZhciBsaXMgPSBsaXN0ZW5lcnNba107XG4gICAgICAgICAgICB2YXIgbnNNYXRjaGVzID0gIWxpcy5uYW1lc3BhY2UgfHwgbGlzLm5hbWVzcGFjZSA9PT0gZXZ0Lm5hbWVzcGFjZTtcbiAgICAgICAgICAgIHZhciB0eXBlTWF0Y2hlcyA9IGxpcy50eXBlID09PSBldnQudHlwZTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNYXRjaGVzID0gbGlzLmRlbGVnYXRlZCA/ICggdHJpZ2dlcmVyICE9PSBldnQuY3lUYXJnZXQgJiYgaXMuZWxlbWVudChldnQuY3lUYXJnZXQpICYmIGxpcy5zZWxPYmoubWF0Y2hlcyhldnQuY3lUYXJnZXQpICkgOiAodHJ1ZSk7IC8vIHdlJ3JlIG5vdCBnb2luZyB0byB2YWxpZGF0ZSB0aGUgaGllcmFyY2h5OyB0aGF0J3MgdG9vIGV4cGVuc2l2ZVxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyTWF0Y2hlcyA9IG5zTWF0Y2hlcyAmJiB0eXBlTWF0Y2hlcyAmJiB0YXJnZXRNYXRjaGVzO1xuXG4gICAgICAgICAgICBpZiggbGlzdGVuZXJNYXRjaGVzICl7IC8vIHRoZW4gdHJpZ2dlciBpdFxuICAgICAgICAgICAgICB2YXIgYXJncyA9IFsgZXZ0IF07XG4gICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdCggZXh0cmFQYXJhbXMgKTsgLy8gYWRkIGV4dHJhIHBhcmFtcyB0byBhcmdzIGxpc3RcblxuICAgICAgICAgICAgICBpZiggbGlzLmRhdGEgKXsgLy8gYWRkIG9uIGRhdGEgcGx1Z2dlZCBpbnRvIGJpbmRpbmdcbiAgICAgICAgICAgICAgICBldnQuZGF0YSA9IGxpcy5kYXRhO1xuICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBvciBjbGVhciBpdCBpbiBjYXNlIHRoZSBldmVudCBvYmogaXMgcmV1c2VkXG4gICAgICAgICAgICAgICAgZXZ0LmRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiggbGlzLnVuYmluZFNlbGZPblRyaWdnZXIgfHwgbGlzLnVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXIgKXsgLy8gdGhlbiByZW1vdmUgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGssIDEpO1xuICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmKCBsaXMudW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlciApeyAvLyB0aGVuIGRlbGV0ZSB0aGUgbGlzdGVuZXIgZm9yIGFsbCBiaW5kZXJzXG4gICAgICAgICAgICAgICAgdmFyIGJpbmRlcnMgPSBsaXMuYmluZGVycztcbiAgICAgICAgICAgICAgICBmb3IoIHZhciBsID0gMDsgbCA8IGJpbmRlcnMubGVuZ3RoOyBsKysgKXtcbiAgICAgICAgICAgICAgICAgIHZhciBiaW5kZXIgPSBiaW5kZXJzW2xdO1xuICAgICAgICAgICAgICAgICAgaWYoICFiaW5kZXIgfHwgYmluZGVyID09PSB0cmlnZ2VyZXIgKXsgY29udGludWU7IH0gLy8gYWxyZWFkeSBoYW5kbGVkIHRyaWdnZXJlciBvciB3ZSBjYW4ndCBoYW5kbGUgaXRcblxuICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlckxpc3RlbmVycyA9IGJpbmRlci5fcHJpdmF0ZS5saXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgICBmb3IoIHZhciBtID0gMDsgbSA8IGJpbmRlckxpc3RlbmVycy5sZW5ndGg7IG0rKyApe1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGVyTGlzdGVuZXIgPSBiaW5kZXJMaXN0ZW5lcnNbbV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIGJpbmRlckxpc3RlbmVyID09PSBsaXMgKXsgLy8gZGVsZXRlIGxpc3RlbmVyIGZyb20gbGlzdFxuICAgICAgICAgICAgICAgICAgICAgIGJpbmRlckxpc3RlbmVycy5zcGxpY2UobSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgbS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gcnVuIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGxpcy5kZWxlZ2F0ZWQgPyBldnQuY3lUYXJnZXQgOiB0cmlnZ2VyZXI7XG4gICAgICAgICAgICAgIHZhciByZXQgPSBsaXMuY2FsbGJhY2suYXBwbHkoIGNvbnRleHQsIGFyZ3MgKTtcblxuICAgICAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSB8fCBldnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApe1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYnViYmxlXG4gICAgICAgICAgICAgICAgYnViYmxlVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7XG4gICAgICAgICAgICAgICAgICAvLyByZXR1cm5pbmcgZmFsc2UgaXMgYSBzaG9ydGhhbmQgZm9yIHN0b3BwaW5nIHByb3BhZ2F0aW9uIGFuZCBwcmV2ZW50aW5nIHRoZSBkZWYuIGFjdGlvblxuICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGlmIGxpc3RlbmVyIG1hdGNoZXNcbiAgICAgICAgICB9IC8vIGZvciBlYWNoIGxpc3RlbmVyXG5cbiAgICAgICAgICAvLyBidWJibGUgdXAgZXZlbnQgZm9yIGVsZW1lbnRzXG4gICAgICAgICAgaWYoIGJ1YmJsZVVwICl7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmRzID8gdHJpZ2dlcmVyLl9wcml2YXRlLnBhcmVudCA6IG51bGw7XG4gICAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICE9IG51bGwgJiYgcGFyZW50Lmxlbmd0aCAhPT0gMDtcblxuICAgICAgICAgICAgaWYoIGhhc1BhcmVudCApeyAvLyB0aGVuIGJ1YmJsZSB1cCB0byBwYXJlbnRcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgICAgICBwYXJlbnQudHJpZ2dlcihldnQpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlLCBidWJibGUgdXAgdG8gdGhlIGNvcmVcbiAgICAgICAgICAgICAgY3kudHJpZ2dlcihldnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IC8vIGZvciBlYWNoIG9mIGFsbFxuICAgICAgfSAvLyBmb3IgZWFjaCBldmVudFxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LCAvLyB0cmlnZ2VyXG5cbiAgYW5pbWF0ZWQ6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgIGZuUGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZWRJbXBsKCl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgdmFyIGVsZSA9IGFsbFswXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50Lmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgLy8gYW5pbWF0ZWRcblxuICBjbGVhclF1ZXVlOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyUXVldWVJbXBsKCl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0sIC8vIGNsZWFyUXVldWVcblxuICBkZWxheTogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgZm5QYXJhbXMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGZuUGFyYW1zKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUltcGwoIHRpbWUsIGNvbXBsZXRlICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICB9KTtcbiAgICB9O1xuICB9LCAvLyBkZWxheVxuXG4gIGRlbGF5QW5pbWF0aW9uOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5QW5pbWF0aW9uSW1wbCggdGltZSwgY29tcGxldGUgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24oe1xuICAgICAgICBkZWxheTogdGltZSxcbiAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgLy8gZGVsYXlcblxuICBhbmltYXRpb246IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgIGZuUGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0aW9uSW1wbCggcHJvcGVydGllcywgcGFyYW1zICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIHZhciBpc0NvcmUgPSAhc2VsZklzQXJyYXlMaWtlO1xuICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcblxuICAgICAgcHJvcGVydGllcyA9IHV0aWwuZXh0ZW5kKCB7fSwgcHJvcGVydGllcywgcGFyYW1zICk7XG5cbiAgICAgIGlmKCBwcm9wZXJ0aWVzLmR1cmF0aW9uID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDQwMDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoKCBwcm9wZXJ0aWVzLmR1cmF0aW9uICl7XG4gICAgICBjYXNlICdzbG93JzpcbiAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDYwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmYXN0JzpcbiAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDIwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzRW1wdHkgPSB0cnVlO1xuICAgICAgaWYoIHByb3BlcnRpZXMgKXsgZm9yKCB2YXIgaSBpbiBwcm9wZXJ0aWVzICl7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICBwcm9wZXJ0aWVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IH1cblxuICAgICAgaWYoIHByb3BlcnRpZXNFbXB0eSApe1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbiggYWxsWzBdLCBwcm9wZXJ0aWVzICk7IC8vIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgfVxuXG4gICAgICBpZiggaXNFbGVzICl7XG4gICAgICAgIHByb3BlcnRpZXMuc3R5bGUgPSBzdHlsZS5nZXRQcm9wc0xpc3QoIHByb3BlcnRpZXMuc3R5bGUgfHwgcHJvcGVydGllcy5jc3MgKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLmNzcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYoIHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbiAmJiBpc0VsZXMgKXtcbiAgICAgICAgdmFyIHJwb3MgPSBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICAgICAgcHJvcGVydGllcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiAoIHJwb3MueCAtIHBhbi54ICkgL3pvb20sXG4gICAgICAgICAgeTogKCBycG9zLnkgLSBwYW4ueSApIC96b29tXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHBhbiB3LyBwYW5CeSBpZiBzZXRcbiAgICAgIGlmKCBwcm9wZXJ0aWVzLnBhbkJ5ICYmIGlzQ29yZSApe1xuICAgICAgICB2YXIgcGFuQnkgPSBwcm9wZXJ0aWVzLnBhbkJ5O1xuICAgICAgICB2YXIgY3lQYW4gPSBjeS5wYW4oKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IHtcbiAgICAgICAgICB4OiBjeVBhbi54ICsgcGFuQnkueCxcbiAgICAgICAgICB5OiBjeVBhbi55ICsgcGFuQnkueVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSBwYW4gdy8gY2VudGVyIGlmIHNldFxuICAgICAgdmFyIGNlbnRlciA9IHByb3BlcnRpZXMuY2VudGVyIHx8IHByb3BlcnRpZXMuY2VudHJlO1xuICAgICAgaWYoIGNlbnRlciAmJiBpc0NvcmUgKXtcbiAgICAgICAgdmFyIGNlbnRlclBhbiA9IGN5LmdldENlbnRlclBhbiggY2VudGVyLmVsZXMsIHByb3BlcnRpZXMuem9vbSApO1xuXG4gICAgICAgIGlmKCBjZW50ZXJQYW4gKXtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGNlbnRlclBhbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSBwYW4gJiB6b29tIHcvIGZpdCBpZiBzZXRcbiAgICAgIGlmKCBwcm9wZXJ0aWVzLmZpdCAmJiBpc0NvcmUgKXtcbiAgICAgICAgdmFyIGZpdCA9IHByb3BlcnRpZXMuZml0O1xuICAgICAgICB2YXIgZml0VnAgPSBjeS5nZXRGaXRWaWV3cG9ydCggZml0LmVsZXMgfHwgZml0LmJvdW5kaW5nQm94LCBmaXQucGFkZGluZyApO1xuXG4gICAgICAgIGlmKCBmaXRWcCApe1xuICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gZml0VnAucGFuO1xuICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IGZpdFZwLnpvb207XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oIGFsbFswXSwgcHJvcGVydGllcyApO1xuICAgIH07XG4gIH0sIC8vIGFuaW1hdGVcblxuICBhbmltYXRlOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVJbXBsKCBwcm9wZXJ0aWVzLCBwYXJhbXMgKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIGlmKCBwYXJhbXMgKXtcbiAgICAgICAgcHJvcGVydGllcyA9IHV0aWwuZXh0ZW5kKCB7fSwgcHJvcGVydGllcywgcGFyYW1zICk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1hbnVhbGx5IGhvb2sgYW5kIHJ1biB0aGUgYW5pbWF0aW9uXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICB2YXIgcXVldWUgPSBlbGUuYW5pbWF0ZWQoKSAmJiAocHJvcGVydGllcy5xdWV1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BlcnRpZXMucXVldWUpO1xuXG4gICAgICAgIHZhciBhbmkgPSBlbGUuYW5pbWF0aW9uKCBwcm9wZXJ0aWVzLCAocXVldWUgPyB7IHF1ZXVlOiB0cnVlIH0gOiB1bmRlZmluZWQpICk7XG5cbiAgICAgICAgYW5pLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfTtcbiAgfSwgLy8gYW5pbWF0ZVxuXG4gIHN0b3A6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgIGZuUGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc3RvcEltcGwoIGNsZWFyUXVldWUsIGp1bXBUb0VuZCApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgYW5pcyA9IF9wLmFuaW1hdGlvbi5jdXJyZW50O1xuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYW5pcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBhbmkgPSBhbmlzW2pdO1xuICAgICAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcblxuICAgICAgICAgIGlmKCBqdW1wVG9FbmQgKXtcbiAgICAgICAgICAgIC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBhbmltYXRpb24gbG9vcCwgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgLy8gd2lsbCBnbyBzdHJhaWdodCB0byB0aGUgZW5kIGFuZCBiZSByZW1vdmVkXG4gICAgICAgICAgICBhbmlfcC5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIHF1ZXVlIG9mIGZ1dHVyZSBhbmltYXRpb25zXG4gICAgICAgIGlmKCBjbGVhclF1ZXVlICl7XG4gICAgICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWp1bXBUb0VuZCApe1xuICAgICAgICAgIF9wLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gd2UgaGF2ZSB0byBub3RpZnkgKHRoZSBhbmltYXRpb24gbG9vcCBkb2Vzbid0IGRvIGl0IGZvciB1cyBvbiBgc3RvcGApXG4gICAgICBjeS5ub3RpZnkoe1xuICAgICAgICBjb2xsZWN0aW9uOiB0aGlzLFxuICAgICAgICB0eXBlOiAnZHJhdydcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9IC8vIHN0b3BcblxufTsgLy8gZGVmaW5lXG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lO1xuXG59LHtcIi4vYW5pbWF0aW9uXCI6MSxcIi4vZXZlbnRcIjo0MixcIi4vaXNcIjo3NyxcIi4vcHJvbWlzZVwiOjgwLFwiLi9zZWxlY3RvclwiOjgxLFwiLi91dGlsXCI6OTR9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qIVxuRXZlbnQgb2JqZWN0IGJhc2VkIG9uIGpRdWVyeSBldmVudHMsIE1JVCBsaWNlbnNlXG5cbmh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlL1xuaHR0cHM6Ly90bGRybGVnYWwuY29tL2xpY2Vuc2UvbWl0LWxpY2Vuc2Vcbmh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuKi9cblxudmFyIEV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG4gIC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuICBpZiAoICEodGhpcyBpbnN0YW5jZW9mIEV2ZW50KSApIHtcbiAgICByZXR1cm4gbmV3IEV2ZW50KCBzcmMsIHByb3BzICk7XG4gIH1cblxuICAvLyBFdmVudCBvYmplY3RcbiAgaWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuICAgIHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG4gICAgLy8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcbiAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9ICggc3JjLmRlZmF1bHRQcmV2ZW50ZWQgKSA/IHJldHVyblRydWUgOiByZXR1cm5GYWxzZTtcblxuICAvLyBFdmVudCB0eXBlXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50eXBlID0gc3JjO1xuICB9XG5cbiAgLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcbiAgaWYgKCBwcm9wcyApIHtcbiAgICAvLyB1dGlsLmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblxuICAgIC8vIG1vcmUgZWZmaWNpZW50IHRvIG1hbnVhbGx5IGNvcHkgZmllbGRzIHdlIHVzZVxuICAgIHRoaXMudHlwZSA9IHByb3BzLnR5cGUgIT09IHVuZGVmaW5lZCA/IHByb3BzLnR5cGUgOiB0aGlzLnR5cGU7XG4gICAgdGhpcy5jeSA9IHByb3BzLmN5O1xuICAgIHRoaXMuY3lUYXJnZXQgPSBwcm9wcy5jeVRhcmdldDtcbiAgICB0aGlzLmN5UG9zaXRpb24gPSBwcm9wcy5jeVBvc2l0aW9uO1xuICAgIHRoaXMuY3lSZW5kZXJlZFBvc2l0aW9uID0gcHJvcHMuY3lSZW5kZXJlZFBvc2l0aW9uO1xuICAgIHRoaXMubmFtZXNwYWNlID0gcHJvcHMubmFtZXNwYWNlO1xuICAgIHRoaXMubGF5b3V0ID0gcHJvcHMubGF5b3V0O1xuICAgIHRoaXMuZGF0YSA9IHByb3BzLmRhdGE7XG4gICAgdGhpcy5tZXNzYWdlID0gcHJvcHMubWVzc2FnZTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG4gIHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbn07XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICdldmVudCc7XG4gIH0sXG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgIGlmICggIWUgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgcHJldmVudERlZmF1bHQgZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICBpZiAoIGUucHJldmVudERlZmF1bHQgKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cbiAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICBpZiAoICFlICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgIGlmICggZS5zdG9wUHJvcGFnYXRpb24gKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfSxcblxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sXG5cbiAgaXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcbiAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG5cbn0se31dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBfZGVyZXFfKCcuL3V0aWwnKTtcbnZhciBkZWZpbmUgPSBfZGVyZXFfKCcuL2RlZmluZScpO1xudmFyIENvbGxlY3Rpb24gPSBfZGVyZXFfKCcuL2NvbGxlY3Rpb24nKTtcbnZhciBDb3JlID0gX2RlcmVxXygnLi9jb3JlJyk7XG52YXIgaW5jRXh0cyA9IF9kZXJlcV8oJy4vZXh0ZW5zaW9ucycpO1xudmFyIGlzID0gX2RlcmVxXygnLi9pcycpO1xuXG4vLyByZWdpc3RlcmVkIGV4dGVuc2lvbnMgdG8gY3l0b3NjYXBlLCBpbmRleGVkIGJ5IG5hbWVcbnZhciBleHRlbnNpb25zID0ge307XG5cbi8vIHJlZ2lzdGVyZWQgbW9kdWxlcyBmb3IgZXh0ZW5zaW9ucywgaW5kZXhlZCBieSBuYW1lXG52YXIgbW9kdWxlcyA9IHt9O1xuXG5mdW5jdGlvbiBzZXRFeHRlbnNpb24oIHR5cGUsIG5hbWUsIHJlZ2lzdHJhbnQgKXtcblxuICB2YXIgZXh0ID0gcmVnaXN0cmFudDtcblxuICBpZiggdHlwZSA9PT0gJ2NvcmUnICl7XG4gICAgQ29yZS5wcm90b3R5cGVbIG5hbWUgXSA9IHJlZ2lzdHJhbnQ7XG5cbiAgfSBlbHNlIGlmKCB0eXBlID09PSAnY29sbGVjdGlvbicgKXtcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVsgbmFtZSBdID0gcmVnaXN0cmFudDtcblxuICB9IGVsc2UgaWYoIHR5cGUgPT09ICdsYXlvdXQnICl7XG4gICAgLy8gZmlsbCBpbiBtaXNzaW5nIGxheW91dCBmdW5jdGlvbnMgaW4gdGhlIHByb3RvdHlwZVxuXG4gICAgdmFyIExheW91dCA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICByZWdpc3RyYW50LmNhbGwoIHRoaXMsIG9wdGlvbnMgKTtcblxuICAgICAgLy8gbWFrZSBzdXJlIGxheW91dCBoYXMgX3ByaXZhdGUgZm9yIHVzZSB3LyBzdGQgYXBpcyBsaWtlIC5vbigpXG4gICAgICBpZiggIWlzLnBsYWluT2JqZWN0KHRoaXMuX3ByaXZhdGUpICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJpdmF0ZS5jeSA9IG9wdGlvbnMuY3k7XG4gICAgICB0aGlzLl9wcml2YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgIH07XG5cbiAgICB2YXIgbGF5b3V0UHJvdG8gPSBMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggcmVnaXN0cmFudC5wcm90b3R5cGUgKTtcblxuICAgIHZhciBvcHRMYXlvdXRGbnMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3B0TGF5b3V0Rm5zLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZm5OYW1lID0gb3B0TGF5b3V0Rm5zW2ldO1xuXG4gICAgICBsYXlvdXRQcm90b1tmbk5hbWVdID0gbGF5b3V0UHJvdG9bZm5OYW1lXSB8fCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcbiAgICB9XG5cbiAgICAvLyBlaXRoZXIgLnN0YXJ0KCkgb3IgLnJ1bigpIGlzIGRlZmluZWQsIHNvIGF1dG9nZW4gdGhlIG90aGVyXG4gICAgaWYoIGxheW91dFByb3RvLnN0YXJ0ICYmICFsYXlvdXRQcm90by5ydW4gKXtcbiAgICAgIGxheW91dFByb3RvLnJ1biA9IGZ1bmN0aW9uKCl7IHRoaXMuc3RhcnQoKTsgcmV0dXJuIHRoaXM7IH07XG4gICAgfSBlbHNlIGlmKCAhbGF5b3V0UHJvdG8uc3RhcnQgJiYgbGF5b3V0UHJvdG8ucnVuICl7XG4gICAgICBsYXlvdXRQcm90by5zdGFydCA9IGZ1bmN0aW9uKCl7IHRoaXMucnVuKCk7IHJldHVybiB0aGlzOyB9O1xuICAgIH1cblxuICAgIGlmKCAhbGF5b3V0UHJvdG8uc3RvcCApe1xuICAgICAgbGF5b3V0UHJvdG8uc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIGlmKCBvcHRzICYmIG9wdHMuYW5pbWF0ZSApe1xuICAgICAgICAgIHZhciBhbmlzID0gdGhpcy5hbmltYXRpb25zO1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYW5pcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgYW5pc1tpXS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdsYXlvdXRzdG9wJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmKCAhbGF5b3V0UHJvdG8uZGVzdHJveSApe1xuICAgICAgbGF5b3V0UHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBsYXlvdXRQcm90by5vbiA9IGRlZmluZS5vbih7IGxheW91dDogdHJ1ZSB9KTtcbiAgICBsYXlvdXRQcm90by5vbmUgPSBkZWZpbmUub24oeyBsYXlvdXQ6IHRydWUsIHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSk7XG4gICAgbGF5b3V0UHJvdG8ub25jZSA9IGRlZmluZS5vbih7IGxheW91dDogdHJ1ZSwgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogdHJ1ZSB9KTtcbiAgICBsYXlvdXRQcm90by5vZmYgPSBkZWZpbmUub2ZmKHsgbGF5b3V0OiB0cnVlIH0pO1xuICAgIGxheW91dFByb3RvLnRyaWdnZXIgPSBkZWZpbmUudHJpZ2dlcih7IGxheW91dDogdHJ1ZSB9KTtcblxuICAgIGRlZmluZS5ldmVudEFsaWFzZXNPbiggbGF5b3V0UHJvdG8gKTtcblxuICAgIGV4dCA9IExheW91dDsgLy8gcmVwbGFjZSB3aXRoIG91ciB3cmFwcGVkIGxheW91dFxuXG4gIH0gZWxzZSBpZiggdHlwZSA9PT0gJ3JlbmRlcmVyJyAmJiBuYW1lICE9PSAnbnVsbCcgJiYgbmFtZSAhPT0gJ2Jhc2UnICl7XG4gICAgLy8gdXNlciByZWdpc3RlcmVkIHJlbmRlcmVycyBpbmhlcml0IGZyb20gYmFzZVxuXG4gICAgdmFyIGJQcm90byA9IGdldEV4dGVuc2lvbiggJ3JlbmRlcmVyJywgJ2Jhc2UnICkucHJvdG90eXBlO1xuICAgIHZhciByUHJvdG8gPSByZWdpc3RyYW50LnByb3RvdHlwZTtcblxuICAgIGZvciggdmFyIHBOYW1lIGluIGJQcm90byApe1xuICAgICAgdmFyIHBWYWwgPSBiUHJvdG9bIHBOYW1lIF07XG4gICAgICB2YXIgZXhpc3RzSW5SID0gclByb3RvWyBwTmFtZSBdICE9IG51bGw7XG5cbiAgICAgIGlmKCBleGlzdHNJblIgKXtcbiAgICAgICAgdXRpbC5lcnJvcignQ2FuIG5vdCByZWdpc3RlciByZW5kZXJlciBgJyArIG5hbWUgKyAnYCBzaW5jZSBpdCBvdmVycmlkZXMgYCcgKyBwTmFtZSArICdgIGluIGl0cyBwcm90b3R5cGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByUHJvdG9bIHBOYW1lIF0gPSBwVmFsOyAvLyB0YWtlIGltcGwgZnJvbSBiYXNlXG4gICAgfVxuXG4gICAgYlByb3RvLmNsaWVudEZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKCBuYW1lICl7XG4gICAgICByUHJvdG9bIG5hbWUgXSA9IHJQcm90b1sgbmFtZSBdIHx8IGZ1bmN0aW9uKCl7XG4gICAgICAgIHV0aWwuZXJyb3IoJ1JlbmRlcmVyIGRvZXMgbm90IGltcGxlbWVudCBgcmVuZGVyZXIuJyArIG5hbWUgKyAnKClgIG9uIGl0cyBwcm90b3R5cGUnKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgfVxuXG4gIHJldHVybiB1dGlsLnNldE1hcCh7XG4gICAgbWFwOiBleHRlbnNpb25zLFxuICAgIGtleXM6IFsgdHlwZSwgbmFtZSBdLFxuICAgIHZhbHVlOiBleHRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbih0eXBlLCBuYW1lKXtcbiAgcmV0dXJuIHV0aWwuZ2V0TWFwKHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogWyB0eXBlLCBuYW1lIF1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lLCByZWdpc3RyYW50KXtcbiAgcmV0dXJuIHV0aWwuc2V0TWFwKHtcbiAgICBtYXA6IG1vZHVsZXMsXG4gICAga2V5czogWyB0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lIF0sXG4gICAgdmFsdWU6IHJlZ2lzdHJhbnRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lKXtcbiAgcmV0dXJuIHV0aWwuZ2V0TWFwKHtcbiAgICBtYXA6IG1vZHVsZXMsXG4gICAga2V5czogWyB0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lIF1cbiAgfSk7XG59XG5cbnZhciBleHRlbnNpb24gPSBmdW5jdGlvbigpe1xuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJylcbiAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgKXtcbiAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgeyAuLi4gfSlcbiAgZWxzZSBpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gMyApe1xuICAgIHJldHVybiBzZXRFeHRlbnNpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZVNoYXBlJywgJ2VsbGlwc2UnKVxuICBlbHNlIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSA0ICl7XG4gICAgcmV0dXJuIGdldE1vZHVsZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScsIHsgLi4uIH0pXG4gIGVsc2UgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDUgKXtcbiAgICByZXR1cm4gc2V0TW9kdWxlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBlbHNlIHtcbiAgICB1dGlsLmVycm9yKCdJbnZhbGlkIGV4dGVuc2lvbiBhY2Nlc3Mgc3ludGF4Jyk7XG4gIH1cblxufTtcblxuLy8gYWxsb3dzIGEgY29yZSBpbnN0YW5jZSB0byBhY2Nlc3MgZXh0ZW5zaW9ucyBpbnRlcm5hbGx5XG5Db3JlLnByb3RvdHlwZS5leHRlbnNpb24gPSBleHRlbnNpb247XG5cbi8vIGluY2x1ZGVkIGV4dGVuc2lvbnNcbmluY0V4dHMuZm9yRWFjaChmdW5jdGlvbiggZ3JvdXAgKXtcbiAgZ3JvdXAuZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKCBleHQgKXtcbiAgICBzZXRFeHRlbnNpb24oIGdyb3VwLnR5cGUsIGV4dC5uYW1lLCBleHQuaW1wbCApO1xuICB9KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuc2lvbjtcblxufSx7XCIuL2NvbGxlY3Rpb25cIjoyMyxcIi4vY29yZVwiOjM0LFwiLi9kZWZpbmVcIjo0MSxcIi4vZXh0ZW5zaW9uc1wiOjQ0LFwiLi9pc1wiOjc3LFwiLi91dGlsXCI6OTR9XSw0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICB7XG4gICAgdHlwZTogJ2xheW91dCcsXG4gICAgZXh0ZW5zaW9uczogX2RlcmVxXygnLi9sYXlvdXQnKVxuICB9LFxuXG4gIHtcbiAgICB0eXBlOiAncmVuZGVyZXInLFxuICAgIGV4dGVuc2lvbnM6IF9kZXJlcV8oJy4vcmVuZGVyZXInKVxuICB9XG5dO1xuXG59LHtcIi4vbGF5b3V0XCI6NTAsXCIuL3JlbmRlcmVyXCI6NzJ9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gX2RlcmVxXygnLi4vLi4vdXRpbCcpO1xudmFyIG1hdGggPSBfZGVyZXFfKCcuLi8uLi9tYXRoJyk7XG52YXIgaXMgPSBfZGVyZXFfKCcuLi8uLi9pcycpO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBkaXJlY3RlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgZGlyZWN0ZWQgZG93bndhcmRzIChvciBlZGdlcyBjYW4gcG9pbnQgaW4gYW55IGRpcmVjdGlvbiBpZiBmYWxzZSlcbiAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgb24gZml0XG4gIGNpcmNsZTogZmFsc2UsIC8vIHB1dCBkZXB0aHMgaW4gY29uY2VudHJpYyBjaXJjbGVzIGlmIHRydWUsIHB1dCBkZXB0aHMgdG9wIGRvd24gaWYgZmFsc2VcbiAgc3BhY2luZ0ZhY3RvcjogMS43NSwgLy8gcG9zaXRpdmUgc3BhY2luZyBmYWN0b3IsIGxhcmdlciA9PiBtb3JlIHNwYWNlIGJldHdlZW4gbm9kZXMgKE4uQi4gbi9hIGlmIGNhdXNlcyBvdmVybGFwKVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIHJvb3RzOiB1bmRlZmluZWQsIC8vIHRoZSByb290cyBvZiB0aGUgdHJlZXNcbiAgbWF4aW1hbEFkanVzdG1lbnRzOiAwLCAvLyBob3cgbWFueSB0aW1lcyB0byB0cnkgdG8gcG9zaXRpb24gdGhlIG5vZGVzIGluIGEgbWF4aW1hbCB3YXkgKGkuZS4gbm8gYmFja3RyYWNraW5nKVxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG59O1xuXG5mdW5jdGlvbiBCcmVhZHRoRmlyc3RMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblxuQnJlYWR0aEZpcnN0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcblxuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gIHZhciBncmFwaCA9IGVsZXM7XG5cbiAgdmFyIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSApO1xuXG4gIHZhciByb290cztcbiAgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24ob3B0aW9ucy5yb290cykgKXtcbiAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gIH0gZWxzZSBpZiggaXMuYXJyYXkob3B0aW9ucy5yb290cykgKXtcbiAgICB2YXIgcm9vdHNBcnJheSA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnJvb3RzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgaWQgPSBvcHRpb25zLnJvb3RzW2ldO1xuICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuICAgICAgcm9vdHNBcnJheS5wdXNoKCBlbGUgKTtcbiAgICB9XG5cbiAgICByb290cyA9IGN5LmNvbGxlY3Rpb24oIHJvb3RzQXJyYXkgKTtcbiAgfSBlbHNlIGlmKCBpcy5zdHJpbmcob3B0aW9ucy5yb290cykgKXtcbiAgICByb290cyA9IGN5LiQoIG9wdGlvbnMucm9vdHMgKTtcblxuICB9IGVsc2Uge1xuICAgIGlmKCBvcHRpb25zLmRpcmVjdGVkICl7XG4gICAgICByb290cyA9IG5vZGVzLnJvb3RzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgICB2YXIgdW5oYW5kbGVkTm9kZXMgPSBub2RlcztcblxuICAgICAgd2hpbGUoIHVuaGFuZGxlZE5vZGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgdmFyIGN1cnJDb21wID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgICAgIGVsZXMuYmZzKHtcbiAgICAgICAgICByb290czogdW5oYW5kbGVkTm9kZXNbMF0sXG4gICAgICAgICAgdmlzaXQ6IGZ1bmN0aW9uKGksIGRlcHRoLCBub2RlLCBlZGdlLCBwTm9kZSl7XG4gICAgICAgICAgICBjdXJyQ29tcCA9IGN1cnJDb21wLmFkZCggbm9kZSApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlyZWN0ZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHVuaGFuZGxlZE5vZGVzID0gdW5oYW5kbGVkTm9kZXMubm90KCBjdXJyQ29tcCApO1xuICAgICAgICBjb21wb25lbnRzLnB1c2goIGN1cnJDb21wICk7XG4gICAgICB9XG5cbiAgICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjb21wID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgdmFyIG1heERlZ3JlZSA9IGNvbXAubWF4RGVncmVlKCBmYWxzZSApO1xuICAgICAgICB2YXIgY29tcFJvb3RzID0gY29tcC5maWx0ZXIoZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWdyZWUoZmFsc2UpID09PSBtYXhEZWdyZWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJvb3RzID0gcm9vdHMuYWRkKCBjb21wUm9vdHMgKTtcbiAgICAgIH1cblxuICAgIH1cbiAgfVxuXG5cbiAgdmFyIGRlcHRocyA9IFtdO1xuICB2YXIgZm91bmRCeUJmcyA9IHt9O1xuICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgdmFyIHByZXZOb2RlID0ge307XG4gIHZhciBwcmV2RWRnZSA9IHt9O1xuICB2YXIgc3VjY2Vzc29ycyA9IHt9O1xuXG4gIC8vIGZpbmQgdGhlIGRlcHRocyBvZiB0aGUgbm9kZXNcbiAgZ3JhcGguYmZzKHtcbiAgICByb290czogcm9vdHMsXG4gICAgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQsXG4gICAgdmlzaXQ6IGZ1bmN0aW9uKGksIGRlcHRoLCBub2RlLCBlZGdlLCBwTm9kZSl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgICBpZiggIWRlcHRoc1tkZXB0aF0gKXtcbiAgICAgICAgZGVwdGhzW2RlcHRoXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBkZXB0aHNbZGVwdGhdLnB1c2goIGVsZSApO1xuICAgICAgZm91bmRCeUJmc1sgaWQgXSA9IHRydWU7XG4gICAgICBpZDJkZXB0aFsgaWQgXSA9IGRlcHRoO1xuICAgICAgcHJldk5vZGVbIGlkIF0gPSBwTm9kZTtcbiAgICAgIHByZXZFZGdlWyBpZCBdID0gZWRnZTtcblxuICAgICAgaWYoIHBOb2RlICl7XG4gICAgICAgIHZhciBwcmV2SWQgPSBwTm9kZS5pZCgpO1xuICAgICAgICB2YXIgc3VjYyA9IHN1Y2Nlc3NvcnNbIHByZXZJZCBdID0gc3VjY2Vzc29yc1sgcHJldklkIF0gfHwgW107XG5cbiAgICAgICAgc3VjYy5wdXNoKCBub2RlICk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBjaGVjayBmb3Igbm9kZXMgbm90IGZvdW5kIGJ5IGJmc1xuICB2YXIgb3JwaGFuTm9kZXMgPSBbXTtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBub2Rlc1tpXTtcblxuICAgIGlmKCBmb3VuZEJ5QmZzWyBlbGUuaWQoKSBdICl7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JwaGFuTm9kZXMucHVzaCggZWxlICk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXNzaWduIG9ycGhhbiBub2RlcyBhIGRlcHRoIGZyb20gdGhlaXIgbmVpZ2hib3Job29kXG4gIHZhciBtYXhDaGVja3MgPSBvcnBoYW5Ob2Rlcy5sZW5ndGggKiAzO1xuICB2YXIgY2hlY2tzID0gMDtcbiAgd2hpbGUoIG9ycGhhbk5vZGVzLmxlbmd0aCAhPT0gMCAmJiBjaGVja3MgPCBtYXhDaGVja3MgKXtcbiAgICB2YXIgbm9kZSA9IG9ycGhhbk5vZGVzLnNoaWZ0KCk7XG4gICAgdmFyIG5laWdoYm9ycyA9IG5vZGUubmVpZ2hib3Job29kKCkubm9kZXMoKTtcbiAgICB2YXIgYXNzaWduZWREZXB0aCA9IGZhbHNlO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBkZXB0aCA9IGlkMmRlcHRoWyBuZWlnaGJvcnNbaV0uaWQoKSBdO1xuXG4gICAgICBpZiggZGVwdGggIT09IHVuZGVmaW5lZCApe1xuICAgICAgICBkZXB0aHNbZGVwdGhdLnB1c2goIG5vZGUgKTtcbiAgICAgICAgYXNzaWduZWREZXB0aCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCAhYXNzaWduZWREZXB0aCApe1xuICAgICAgb3JwaGFuTm9kZXMucHVzaCggbm9kZSApO1xuICAgIH1cblxuICAgIGNoZWNrcysrO1xuICB9XG5cbiAgLy8gYXNzaWduIG9ycGhhbiBub2RlcyB0aGF0IGFyZSBzdGlsbCBsZWZ0IHRvIHRoZSBkZXB0aCBvZiB0aGVpciBzdWJncmFwaFxuICB3aGlsZSggb3JwaGFuTm9kZXMubGVuZ3RoICE9PSAwICl7XG4gICAgdmFyIG5vZGUgPSBvcnBoYW5Ob2Rlcy5zaGlmdCgpO1xuICAgIC8vdmFyIHN1YmdyYXBoID0gZ3JhcGguYmZzKCBub2RlICkucGF0aDtcbiAgICB2YXIgYXNzaWduZWREZXB0aCA9IGZhbHNlO1xuXG4gICAgLy8gZm9yKCB2YXIgaSA9IDA7IGkgPCBzdWJncmFwaC5sZW5ndGg7IGkrKyApe1xuICAgIC8vICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIHN1YmdyYXBoW2ldLmlkKCkgXTtcblxuICAgIC8vICAgaWYoIGRlcHRoICE9PSB1bmRlZmluZWQgKXtcbiAgICAvLyAgICAgZGVwdGhzW2RlcHRoXS5wdXNoKCBub2RlICk7XG4gICAgLy8gICAgIGFzc2lnbmVkRGVwdGggPSB0cnVlO1xuICAgIC8vICAgICBicmVhaztcbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgICBpZiggIWFzc2lnbmVkRGVwdGggKXsgLy8gd29yc3QgY2FzZSBpZiB0aGUgZ3JhcGggcmVhbGx5IGlzbid0IHRyZWUgZnJpZW5kbHksIHRoZW4ganVzdCBkdW1wIGl0IGluIDBcbiAgICAgIGlmKCBkZXB0aHMubGVuZ3RoID09PSAwICl7XG4gICAgICAgIGRlcHRocy5wdXNoKFtdKTtcbiAgICAgIH1cblxuICAgICAgZGVwdGhzWzBdLnB1c2goIG5vZGUgKTtcbiAgICB9XG4gIH1cblxuICAvLyBhc3NpZ24gdGhlIG5vZGVzIGEgZGVwdGggYW5kIGluZGV4XG4gIHZhciBhc3NpZ25EZXB0aHNUb0VsZXMgPSBmdW5jdGlvbigpe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZGVwdGhzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlcyA9IGRlcHRoc1tpXTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2pdO1xuXG4gICAgICAgIGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdCA9IHtcbiAgICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgICBpbmRleDogalxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgYXNzaWduRGVwdGhzVG9FbGVzKCk7XG5cblxuICB2YXIgaW50ZXJzZWN0c0RlcHRoID0gZnVuY3Rpb24oIG5vZGUgKXsgLy8gcmV0dXJucyB0cnVlIGlmIGhhcyBlZGdlcyBwb2ludGluZyBpbiBmcm9tIGEgaGlnaGVyIGRlcHRoXG4gICAgdmFyIGVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcyhmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YSgndGFyZ2V0JykgPT09IG5vZGUuaWQoKTtcbiAgICB9KTtcbiAgICB2YXIgdGhpc0luZm8gPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgIHZhciBoaWdoZXN0RGVwdGhPZk90aGVyID0gMDtcbiAgICB2YXIgaGlnaGVzdE90aGVyO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciBvdGhlckluZm8gPSBvdGhlck5vZGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG5cbiAgICAgIGlmKCB0aGlzSW5mby5kZXB0aCA8PSBvdGhlckluZm8uZGVwdGggJiYgaGlnaGVzdERlcHRoT2ZPdGhlciA8IG90aGVySW5mby5kZXB0aCApe1xuICAgICAgICBoaWdoZXN0RGVwdGhPZk90aGVyID0gb3RoZXJJbmZvLmRlcHRoO1xuICAgICAgICBoaWdoZXN0T3RoZXIgPSBvdGhlck5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhpZ2hlc3RPdGhlcjtcbiAgfTtcblxuICAgLy8gbWFrZSBtYXhpbWFsIGlmIHNvIHNldCBieSBhZGp1c3RpbmcgZGVwdGhzXG4gIGZvciggdmFyIGFkaiA9IDA7IGFkaiA8IG9wdGlvbnMubWF4aW1hbEFkanVzdG1lbnRzOyBhZGorKyApe1xuXG4gICAgdmFyIG5EZXB0aHMgPSBkZXB0aHMubGVuZ3RoO1xuICAgIHZhciBlbGVzVG9Nb3ZlID0gW107XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuRGVwdGhzOyBpKysgKXtcbiAgICAgIHZhciBkZXB0aCA9IGRlcHRoc1tpXTtcblxuICAgICAgdmFyIG5EZXB0aCA9IGRlcHRoLmxlbmd0aDtcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbkRlcHRoOyBqKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGRlcHRoW2pdO1xuICAgICAgICB2YXIgaW5mbyA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgICAgdmFyIGludEVsZSA9IGludGVyc2VjdHNEZXB0aChlbGUpO1xuXG4gICAgICAgIGlmKCBpbnRFbGUgKXtcbiAgICAgICAgICBpbmZvLmludEVsZSA9IGludEVsZTtcbiAgICAgICAgICBlbGVzVG9Nb3ZlLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzVG9Nb3ZlLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1RvTW92ZVtpXTtcbiAgICAgIHZhciBpbmZvID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgdmFyIGludEVsZSA9IGluZm8uaW50RWxlO1xuICAgICAgdmFyIGludEluZm8gPSBpbnRFbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG5cbiAgICAgIGRlcHRoc1sgaW5mby5kZXB0aCBdLnNwbGljZSggaW5mby5pbmRleCwgMSApOyAvLyByZW1vdmUgZnJvbSBvbGQgZGVwdGggJiBpbmRleFxuXG4gICAgICAvLyBhZGQgdG8gZW5kIG9mIG5ldyBkZXB0aFxuICAgICAgdmFyIG5ld0RlcHRoID0gaW50SW5mby5kZXB0aCArIDE7XG4gICAgICB3aGlsZSggbmV3RGVwdGggPiBkZXB0aHMubGVuZ3RoIC0gMSApe1xuICAgICAgICBkZXB0aHMucHVzaChbXSk7XG4gICAgICB9XG4gICAgICBkZXB0aHNbIG5ld0RlcHRoIF0ucHVzaCggZWxlICk7XG5cbiAgICAgIGluZm8uZGVwdGggPSBuZXdEZXB0aDtcbiAgICAgIGluZm8uaW5kZXggPSBkZXB0aHNbbmV3RGVwdGhdLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgYXNzaWduRGVwdGhzVG9FbGVzKCk7XG4gIH1cblxuICAvLyBmaW5kIG1pbiBkaXN0YW5jZSB3ZSBuZWVkIHRvIGxlYXZlIGJldHdlZW4gbm9kZXNcbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcbiAgaWYoIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICAgIHZhciBuYmIgPSBuLmJvdW5kaW5nQm94KCk7XG4gICAgICB2YXIgdyA9IG5iYi53O1xuICAgICAgdmFyIGggPSBuYmIuaDtcblxuICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gICAgfVxuICAgIG1pbkRpc3RhbmNlICo9IG9wdGlvbnMuc3BhY2luZ0ZhY3RvcjsgLy8ganVzdCB0byBoYXZlIHNvbWUgbmljZSBzcGFjaW5nXG4gIH1cblxuICAvLyBnZXQgdGhlIHdlaWdodGVkIHBlcmNlbnQgZm9yIGFuIGVsZW1lbnQgYmFzZWQgb24gaXRzIGNvbm5lY3Rpdml0eSB0byBvdGhlciBsZXZlbHNcbiAgdmFyIGNhY2hlZFdlaWdodGVkUGVyY2VudCA9IHt9O1xuICB2YXIgZ2V0V2VpZ2h0ZWRQZXJjZW50ID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIGlmKCBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbIGVsZS5pZCgpIF0gKXtcbiAgICAgIHJldHVybiBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbIGVsZS5pZCgpIF07XG4gICAgfVxuXG4gICAgdmFyIGVsZURlcHRoID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0LmRlcHRoO1xuICAgIHZhciBuZWlnaGJvcnMgPSBlbGUubmVpZ2hib3Job29kKCkubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICB2YXIgcGVyY2VudCA9IDA7XG4gICAgdmFyIHNhbXBsZXMgPSAwO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcbiAgICAgIHZhciBiZiA9IG5laWdoYm9yLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgdmFyIGluZGV4ID0gYmYuaW5kZXg7XG4gICAgICB2YXIgZGVwdGggPSBiZi5kZXB0aDtcbiAgICAgIHZhciBuRGVwdGggPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcblxuICAgICAgaWYoIGVsZURlcHRoID4gZGVwdGggfHwgZWxlRGVwdGggPT09IDAgKXsgLy8gb25seSBnZXQgaW5mbHVlbmNlZCBieSBlbGVtZW50cyBhYm92ZVxuICAgICAgICBwZXJjZW50ICs9IGluZGV4IC8gbkRlcHRoO1xuICAgICAgICBzYW1wbGVzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2FtcGxlcyA9IE1hdGgubWF4KDEsIHNhbXBsZXMpO1xuICAgIHBlcmNlbnQgPSBwZXJjZW50IC8gc2FtcGxlcztcblxuICAgIGlmKCBzYW1wbGVzID09PSAwICl7IC8vIHNvIGxvbmUgbm9kZXMgaGF2ZSBhIFwiZG9uJ3QgY2FyZVwiIHN0YXRlIGluIHNvcnRpbmdcbiAgICAgIHBlcmNlbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50WyBlbGUuaWQoKSBdID0gcGVyY2VudDtcbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfTtcblxuXG4gIC8vIHJlYXJyYW5nZSB0aGUgaW5kaWNlcyBpbiBlYWNoIGRlcHRoIGxldmVsIGJhc2VkIG9uIGNvbm5lY3Rpdml0eVxuXG4gIHZhciBzb3J0Rm4gPSBmdW5jdGlvbihhLCBiKXtcbiAgICB2YXIgYXBjdCA9IGdldFdlaWdodGVkUGVyY2VudCggYSApO1xuICAgIHZhciBicGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KCBiICk7XG5cbiAgICByZXR1cm4gYXBjdCAtIGJwY3Q7XG4gIH07XG5cbiAgZm9yKCB2YXIgdGltZXMgPSAwOyB0aW1lcyA8IDM7IHRpbWVzKysgKXsgLy8gZG8gaXQgYSBmZXcgdGltZXMgYi9jIHRoZSBkZXB0aHMgYXJlIGR5bmFtaWMgYW5kIHdlIHdhbnQgYSBtb3JlIHN0YWJsZSByZXN1bHRcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZGVwdGhzLmxlbmd0aDsgaSsrICl7XG4gICAgICBkZXB0aHNbaV0gPSBkZXB0aHNbaV0uc29ydCggc29ydEZuICk7XG4gICAgfVxuICAgIGFzc2lnbkRlcHRoc1RvRWxlcygpOyAvLyBhbmQgdXBkYXRlXG5cbiAgfVxuXG4gIHZhciBiaWdnZXN0RGVwdGhTaXplID0gMDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXB0aHMubGVuZ3RoOyBpKysgKXtcbiAgICBiaWdnZXN0RGVwdGhTaXplID0gTWF0aC5tYXgoIGRlcHRoc1tpXS5sZW5ndGgsIGJpZ2dlc3REZXB0aFNpemUgKTtcbiAgfVxuXG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53LzIsXG4gICAgeTogYmIueDEgKyBiYi5oLzJcbiAgfTtcblxuICB2YXIgZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiggZWxlLCBpc0JvdHRvbURlcHRoICl7XG4gICAgdmFyIGluZm8gPSBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgdmFyIGRlcHRoID0gaW5mby5kZXB0aDtcbiAgICB2YXIgaW5kZXggPSBpbmZvLmluZGV4O1xuICAgIHZhciBkZXB0aFNpemUgPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcblxuICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLm1heCggYmIudyAvIChkZXB0aFNpemUgKyAxKSwgbWluRGlzdGFuY2UgKTtcbiAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5tYXgoIGJiLmggLyAoZGVwdGhzLmxlbmd0aCArIDEpLCBtaW5EaXN0YW5jZSApO1xuICAgIHZhciByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWluKCBiYi53IC8gMiAvIGRlcHRocy5sZW5ndGgsIGJiLmggLyAyIC8gZGVwdGhzLmxlbmd0aCApO1xuICAgIHJhZGl1c1N0ZXBTaXplID0gTWF0aC5tYXgoIHJhZGl1c1N0ZXBTaXplLCBtaW5EaXN0YW5jZSApO1xuXG4gICAgaWYoICFvcHRpb25zLmNpcmNsZSApe1xuXG4gICAgICB2YXIgZXBvcyA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyAoaW5kZXggKyAxIC0gKGRlcHRoU2l6ZSArIDEpLzIpICogZGlzdGFuY2VYLFxuICAgICAgICB5OiAoZGVwdGggKyAxKSAqIGRpc3RhbmNlWVxuICAgICAgfTtcblxuICAgICAgaWYoIGlzQm90dG9tRGVwdGggKXtcbiAgICAgICAgcmV0dXJuIGVwb3M7XG4gICAgICB9XG5cbiAgICAgIC8vIHZhciBzdWNjcyA9IHN1Y2Nlc3NvcnNbIGVsZS5pZCgpIF07XG4gICAgICAvLyBpZiggc3VjY3MgKXtcbiAgICAgIC8vICAgZXBvcy54ID0gMDtcbiAgICAgIC8vXG4gICAgICAvLyAgIGZvciggdmFyIGkgPSAwIDsgaSA8IHN1Y2NzLmxlbmd0aDsgaSsrICl7XG4gICAgICAvLyAgICAgdmFyIHNwb3MgPSBwb3NbIHN1Y2NzW2ldLmlkKCkgXTtcbiAgICAgIC8vXG4gICAgICAvLyAgICAgZXBvcy54ICs9IHNwb3MueDtcbiAgICAgIC8vICAgfVxuICAgICAgLy9cbiAgICAgIC8vICAgZXBvcy54IC89IHN1Y2NzLmxlbmd0aDtcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIC8vZGVidWdnZXI7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiBlcG9zO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCBvcHRpb25zLmNpcmNsZSApe1xuICAgICAgICB2YXIgcmFkaXVzID0gcmFkaXVzU3RlcFNpemUgKiBkZXB0aCArIHJhZGl1c1N0ZXBTaXplIC0gKGRlcHRocy5sZW5ndGggPiAwICYmIGRlcHRoc1swXS5sZW5ndGggPD0gMyA/IHJhZGl1c1N0ZXBTaXplLzIgOiAwKTtcbiAgICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBkZXB0aHNbZGVwdGhdLmxlbmd0aCAqIGluZGV4O1xuXG4gICAgICAgIGlmKCBkZXB0aCA9PT0gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoID09PSAxICl7XG4gICAgICAgICAgcmFkaXVzID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogY2VudGVyLnggKyByYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgeTogY2VudGVyLnkgKyByYWRpdXMgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgICAgfTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBjZW50ZXIueCArIChpbmRleCArIDEgLSAoZGVwdGhTaXplICsgMSkvMikgKiBkaXN0YW5jZVgsXG4gICAgICAgICAgeTogKGRlcHRoICsgMSkgKiBkaXN0YW5jZVlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICAvLyBnZXQgcG9zaXRpb25zIGluIHJldmVyc2UgZGVwdGggb3JkZXJcbiAgdmFyIHBvcyA9IHt9O1xuICBmb3IoIHZhciBpID0gZGVwdGhzLmxlbmd0aCAtIDE7IGkgPj0wOyBpLS0gKXtcbiAgICB2YXIgZGVwdGggPSBkZXB0aHNbaV07XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IGRlcHRoLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgbm9kZSA9IGRlcHRoW2pdO1xuXG4gICAgICBwb3NbIG5vZGUuaWQoKSBdID0gZ2V0UG9zaXRpb24oIG5vZGUsIGkgPT09IGRlcHRocy5sZW5ndGggLSAxICk7XG4gICAgfVxuICB9XG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHBvc1sgdGhpcy5pZCgpIF07XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcmVhZHRoRmlyc3RMYXlvdXQ7XG5cbn0se1wiLi4vLi4vaXNcIjo3NyxcIi4uLy4uL21hdGhcIjo3OSxcIi4uLy4uL3V0aWxcIjo5NH1dLDQ2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi8uLi91dGlsJyk7XG52YXIgbWF0aCA9IF9kZXJlcV8oJy4uLy4uL21hdGgnKTtcbnZhciBpcyA9IF9kZXJlcV8oJy4uLy4uL2lzJyk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIHBhZGRpbmc6IDMwLCAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggYW5kIHJhZGl1cyBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIHJhZGl1czogdW5kZWZpbmVkLCAvLyB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgc3RhcnRBbmdsZTogMy8yICogTWF0aC5QSSwgLy8gd2hlcmUgbm9kZXMgc3RhcnQgaW4gcmFkaWFuc1xuICBzd2VlcDogdW5kZWZpbmVkLCAvLyBob3cgbWFueSByYWRpYW5zIHNob3VsZCBiZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub2RlIChkZWZhdWx0cyB0byBmdWxsIGNpcmNsZSlcbiAgY2xvY2t3aXNlOiB0cnVlLCAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNsb2Nrd2lzZSAodHJ1ZSkgb3IgY291bnRlcmNsb2Nrd2lzZS9hbnRpY2xvY2t3aXNlIChmYWxzZSlcbiAgc29ydDogdW5kZWZpbmVkLCAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG59O1xuXG5mdW5jdGlvbiBDaXJjbGVMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblxuQ2lyY2xlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcblxuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuXG4gIHZhciBjbG9ja3dpc2UgPSBvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgIT09IHVuZGVmaW5lZCA/ICFvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgOiBvcHRpb25zLmNsb2Nrd2lzZTtcblxuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG5cbiAgaWYoIG9wdGlvbnMuc29ydCApe1xuICAgIG5vZGVzID0gbm9kZXMuc29ydCggb3B0aW9ucy5zb3J0ICk7XG4gIH1cblxuICB2YXIgYmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICB9ICk7XG5cbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncvMixcbiAgICB5OiBiYi55MSArIGJiLmgvMlxuICB9O1xuXG4gIHZhciBzd2VlcCA9IG9wdGlvbnMuc3dlZXAgPT09IHVuZGVmaW5lZCA/IDIqTWF0aC5QSSAtIDIqTWF0aC5QSS9ub2Rlcy5sZW5ndGggOiBvcHRpb25zLnN3ZWVwO1xuXG4gIHZhciBkVGhldGEgPSBzd2VlcCAvICggTWF0aC5tYXgoMSwgbm9kZXMubGVuZ3RoIC0gMSkgKTtcbiAgdmFyIHI7XG5cbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgdmFyIG5iYiA9IG4uYm91bmRpbmdCb3goKTtcbiAgICB2YXIgdyA9IG5iYi53O1xuICAgIHZhciBoID0gbmJiLmg7XG5cbiAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgfVxuXG4gIGlmKCBpcy5udW1iZXIob3B0aW9ucy5yYWRpdXMpICl7XG4gICAgciA9IG9wdGlvbnMucmFkaXVzO1xuICB9IGVsc2UgaWYoIG5vZGVzLmxlbmd0aCA8PSAxICl7XG4gICAgciA9IDA7XG4gIH0gZWxzZSB7XG4gICAgciA9IE1hdGgubWluKCBiYi5oLCBiYi53ICkvMiAtIG1pbkRpc3RhbmNlO1xuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcbiAgaWYoIG5vZGVzLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgIG1pbkRpc3RhbmNlICo9IDEuNzU7IC8vIGp1c3QgdG8gaGF2ZSBzb21lIG5pY2Ugc3BhY2luZ1xuXG4gICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQoIG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2UgLyAoIGRjb3MqZGNvcyArIGRzaW4qZHNpbiApICk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcbiAgICByID0gTWF0aC5tYXgoIHJNaW4sIHIgKTtcbiAgfVxuXG4gIHZhciBnZXRQb3MgPSBmdW5jdGlvbiggaSwgZWxlICl7XG4gICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlICsgaSAqIGRUaGV0YSAqICggY2xvY2t3aXNlID8gMSA6IC0xICk7XG5cbiAgICB2YXIgcnggPSByICogTWF0aC5jb3MoIHRoZXRhICk7XG4gICAgdmFyIHJ5ID0gciAqIE1hdGguc2luKCB0aGV0YSApO1xuICAgIHZhciBwb3MgPSB7XG4gICAgICB4OiBjZW50ZXIueCArIHJ4LFxuICAgICAgeTogY2VudGVyLnkgKyByeVxuICAgIH07XG5cbiAgICByZXR1cm4gcG9zO1xuICB9O1xuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyggdGhpcywgb3B0aW9ucywgZ2V0UG9zICk7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZUxheW91dDtcblxufSx7XCIuLi8uLi9pc1wiOjc3LFwiLi4vLi4vbWF0aFwiOjc5LFwiLi4vLi4vdXRpbFwiOjk0fV0sNDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uLy4uL3V0aWwnKTtcbnZhciBtYXRoID0gX2RlcmVxXygnLi4vLi4vbWF0aCcpO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCwgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gIHN0YXJ0QW5nbGU6IDMvMiAqIE1hdGguUEksIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgc3dlZXA6IHVuZGVmaW5lZCwgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gIGNsb2Nrd2lzZTogdHJ1ZSwgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gIGVxdWlkaXN0YW50OiBmYWxzZSwgLy8gd2hldGhlciBsZXZlbHMgaGF2ZSBhbiBlcXVhbCByYWRpYWwgZGlzdGFuY2UgYmV0d2VuIHRoZW0sIG1heSBjYXVzZSBib3VuZGluZyBib3ggb3ZlcmZsb3dcbiAgbWluTm9kZVNwYWNpbmc6IDEwLCAvLyBtaW4gc3BhY2luZyBiZXR3ZWVuIG91dHNpZGUgb2Ygbm9kZXMgKHVzZWQgZm9yIHJhZGl1cyBhZGp1c3RtZW50KVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIGhlaWdodDogdW5kZWZpbmVkLCAvLyBoZWlnaHQgb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgaGVpZ2h0KVxuICB3aWR0aDogdW5kZWZpbmVkLCAvLyB3aWR0aCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciB3aWR0aClcbiAgY29uY2VudHJpYzogZnVuY3Rpb24obm9kZSl7IC8vIHJldHVybnMgbnVtZXJpYyB2YWx1ZSBmb3IgZWFjaCBub2RlLCBwbGFjaW5nIGhpZ2hlciBub2RlcyBpbiBsZXZlbHMgdG93YXJkcyB0aGUgY2VudHJlXG4gICAgcmV0dXJuIG5vZGUuZGVncmVlKCk7XG4gIH0sXG4gIGxldmVsV2lkdGg6IGZ1bmN0aW9uKG5vZGVzKXsgLy8gdGhlIHZhcmlhdGlvbiBvZiBjb25jZW50cmljIHZhbHVlcyBpbiBlYWNoIGxldmVsXG4gICAgcmV0dXJuIG5vZGVzLm1heERlZ3JlZSgpIC8gNDtcbiAgfSxcbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxufTtcblxuZnVuY3Rpb24gQ29uY2VudHJpY0xheW91dCggb3B0aW9ucyApe1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xufVxuXG5Db25jZW50cmljTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcblxuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG5cbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuXG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG5cbiAgdmFyIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSApO1xuXG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53LzIsXG4gICAgeTogYmIueTEgKyBiYi5oLzJcbiAgfTtcblxuICB2YXIgbm9kZVZhbHVlcyA9IFtdOyAvLyB7IG5vZGUsIHZhbHVlIH1cbiAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlO1xuICB2YXIgbWF4Tm9kZVNpemUgPSAwO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIHZhciB2YWx1ZTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbm9kZSB2YWx1ZVxuICAgIHZhbHVlID0gb3B0aW9ucy5jb25jZW50cmljLmFwcGx5KG5vZGUsIFsgbm9kZSBdKTtcbiAgICBub2RlVmFsdWVzLnB1c2goe1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgbm9kZTogbm9kZVxuICAgIH0pO1xuXG4gICAgLy8gZm9yIHN0eWxlIG1hcHBpbmdcbiAgICBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29uY2VudHJpYyA9IHZhbHVlO1xuICB9XG5cbiAgLy8gaW4gY2FzZSB3ZSB1c2VkIHRoZSBgY29uY2VudHJpY2AgaW4gc3R5bGVcbiAgbm9kZXMudXBkYXRlU3R5bGUoKTtcblxuICAvLyBjYWxjdWxhdGUgbWF4IHNpemUgbm93IGJhc2VkIG9uIHBvdGVudGlhbGx5IHVwZGF0ZWQgbWFwcGVyc1xuICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICB2YXIgbmJiID0gbm9kZS5ib3VuZGluZ0JveCgpO1xuXG4gICAgbWF4Tm9kZVNpemUgPSBNYXRoLm1heCggbWF4Tm9kZVNpemUsIG5iYi53LCBuYmIuaCApO1xuICB9XG5cbiAgLy8gc29ydCBub2RlIHZhbHVlcyBpbiBkZXNjcmVhc2luZyBvcmRlclxuICBub2RlVmFsdWVzLnNvcnQoZnVuY3Rpb24oYSwgYil7XG4gICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICB9KTtcblxuICB2YXIgbGV2ZWxXaWR0aCA9IG9wdGlvbnMubGV2ZWxXaWR0aCggbm9kZXMgKTtcblxuICAvLyBwdXQgdGhlIHZhbHVlcyBpbnRvIGxldmVsc1xuICB2YXIgbGV2ZWxzID0gWyBbXSBdO1xuICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzWzBdO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVWYWx1ZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgdmFsID0gbm9kZVZhbHVlc1tpXTtcblxuICAgIGlmKCBjdXJyZW50TGV2ZWwubGVuZ3RoID4gMCApe1xuICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyggY3VycmVudExldmVsWzBdLnZhbHVlIC0gdmFsLnZhbHVlICk7XG5cbiAgICAgIGlmKCBkaWZmID49IGxldmVsV2lkdGggKXtcbiAgICAgICAgY3VycmVudExldmVsID0gW107XG4gICAgICAgIGxldmVscy5wdXNoKCBjdXJyZW50TGV2ZWwgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50TGV2ZWwucHVzaCggdmFsICk7XG4gIH1cblxuICAvLyBjcmVhdGUgcG9zaXRpb25zIGZyb20gbGV2ZWxzXG5cbiAgdmFyIG1pbkRpc3QgPSBtYXhOb2RlU2l6ZSArIG9wdGlvbnMubWluTm9kZVNwYWNpbmc7IC8vIG1pbiBkaXN0IGJldHdlZW4gbm9kZXNcblxuICBpZiggIW9wdGlvbnMuYXZvaWRPdmVybGFwICl7IC8vIHRoZW4gc3RyaWN0bHkgY29uc3RyYWluIHRvIGJiXG4gICAgdmFyIGZpcnN0THZsSGFzTXVsdGkgPSBsZXZlbHMubGVuZ3RoID4gMCAmJiBsZXZlbHNbMF0ubGVuZ3RoID4gMTtcbiAgICB2YXIgbWF4UiA9ICggTWF0aC5taW4oYmIudywgYmIuaCkgLyAyIC0gbWluRGlzdCApO1xuICAgIHZhciByU3RlcCA9IG1heFIgLyAoIGxldmVscy5sZW5ndGggKyBmaXJzdEx2bEhhc011bHRpID8gMSA6IDAgKTtcblxuICAgIG1pbkRpc3QgPSBNYXRoLm1pbiggbWluRGlzdCwgclN0ZXAgKTtcbiAgfVxuXG4gIC8vIGZpbmQgdGhlIG1ldHJpY3MgZm9yIGVhY2ggbGV2ZWxcbiAgdmFyIHIgPSAwO1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICB2YXIgc3dlZXAgPSBvcHRpb25zLnN3ZWVwID09PSB1bmRlZmluZWQgPyAyKk1hdGguUEkgLSAyKk1hdGguUEkvbGV2ZWwubGVuZ3RoIDogb3B0aW9ucy5zd2VlcDtcbiAgICB2YXIgZFRoZXRhID0gbGV2ZWwuZFRoZXRhID0gc3dlZXAgLyAoIE1hdGgubWF4KDEsIGxldmVsLmxlbmd0aCAtIDEpICk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuICAgIGlmKCBsZXZlbC5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7IC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgICB2YXIgck1pbiA9IE1hdGguc3FydCggbWluRGlzdCAqIG1pbkRpc3QgLyAoIGRjb3MqZGNvcyArIGRzaW4qZHNpbiApICk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcblxuICAgICAgciA9IE1hdGgubWF4KCByTWluLCByICk7XG4gICAgfVxuXG4gICAgbGV2ZWwuciA9IHI7XG5cbiAgICByICs9IG1pbkRpc3Q7XG4gIH1cblxuICBpZiggb3B0aW9ucy5lcXVpZGlzdGFudCApe1xuICAgIHZhciByRGVsdGFNYXggPSAwO1xuICAgIHZhciByID0gMDtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICB2YXIgckRlbHRhID0gbGV2ZWwuciAtIHI7XG5cbiAgICAgIHJEZWx0YU1heCA9IE1hdGgubWF4KCByRGVsdGFNYXgsIHJEZWx0YSApO1xuICAgIH1cblxuICAgIHIgPSAwO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG5cbiAgICAgIGlmKCBpID09PSAwICl7XG4gICAgICAgIHIgPSBsZXZlbC5yO1xuICAgICAgfVxuXG4gICAgICBsZXZlbC5yID0gcjtcblxuICAgICAgciArPSByRGVsdGFNYXg7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBub2RlIHBvc2l0aW9uc1xuICB2YXIgcG9zID0ge307IC8vIGlkID0+IHBvc2l0aW9uXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgIHZhciBkVGhldGEgPSBsZXZlbC5kVGhldGE7XG4gICAgdmFyIHIgPSBsZXZlbC5yO1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBsZXZlbC5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHZhbCA9IGxldmVsW2pdO1xuICAgICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlICsgKGNsb2Nrd2lzZSA/IDEgOiAtMSkgKiBkVGhldGEgKiBqO1xuXG4gICAgICB2YXIgcCA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyByICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICB5OiBjZW50ZXIueSArIHIgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgIH07XG5cbiAgICAgIHBvc1sgdmFsLm5vZGUuaWQoKSBdID0gcDtcbiAgICB9XG4gIH1cblxuICAvLyBwb3NpdGlvbiB0aGUgbm9kZXNcbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGlkID0gdGhpcy5pZCgpO1xuXG4gICAgcmV0dXJuIHBvc1tpZF07XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25jZW50cmljTGF5b3V0O1xuXG59LHtcIi4uLy4uL21hdGhcIjo3OSxcIi4uLy4uL3V0aWxcIjo5NH1dLDQ4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLypcblRoZSBDb1NFIGxheW91dCB3YXMgd3JpdHRlbiBieSBHZXJhcmRvIEh1Y2suXG5odHRwczovL3d3dy5saW5rZWRpbi5jb20vaW4vZ2VyYXJkb2h1Y2svXG5cbkJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgYXJ0aWNsZTpcbmh0dHA6Ly9kbC5hY20ub3JnL2NpdGF0aW9uLmNmbT9pZD0xNDk4MDQ3XG5cbk1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4qL1xuXG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uLy4uL3V0aWwnKTtcbnZhciBtYXRoID0gX2RlcmVxXygnLi4vLi4vbWF0aCcpO1xudmFyIFRocmVhZCA9IF9kZXJlcV8oJy4uLy4uL3RocmVhZCcpO1xudmFyIGlzID0gX2RlcmVxXygnLi4vLi4vaXMnKTtcblxudmFyIERFQlVHO1xuXG4vKipcbiAqIEBicmllZiA6ICBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gKi9cbnZhciBkZWZhdWx0cyA9IHtcbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRyZWFkeWBcbiAgcmVhZHkgICAgICAgICAgICAgICA6IGZ1bmN0aW9uKCkge30sXG5cbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRzdG9wYFxuICBzdG9wICAgICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7fSxcblxuICAvLyBXaGV0aGVyIHRvIGFuaW1hdGUgd2hpbGUgcnVubmluZyB0aGUgbGF5b3V0XG4gIGFuaW1hdGUgICAgICAgICAgICAgOiB0cnVlLFxuXG4gIC8vIFRoZSBsYXlvdXQgYW5pbWF0ZXMgb25seSBhZnRlciB0aGlzIG1hbnkgbWlsbGlzZWNvbmRzXG4gIC8vIChwcmV2ZW50cyBmbGFzaGluZyBvbiBmYXN0IHJ1bnMpXG4gIGFuaW1hdGlvblRocmVzaG9sZCAgOiAyNTAsXG5cbiAgLy8gTnVtYmVyIG9mIGl0ZXJhdGlvbnMgYmV0d2VlbiBjb25zZWN1dGl2ZSBzY3JlZW4gcG9zaXRpb25zIHVwZGF0ZVxuICAvLyAoMCAtPiBvbmx5IHVwZGF0ZWQgb24gdGhlIGVuZClcbiAgcmVmcmVzaCAgICAgICAgICAgICA6IDIwLFxuXG4gIC8vIFdoZXRoZXIgdG8gZml0IHRoZSBuZXR3b3JrIHZpZXcgYWZ0ZXIgd2hlbiBkb25lXG4gIGZpdCAgICAgICAgICAgICAgICAgOiB0cnVlLFxuXG4gIC8vIFBhZGRpbmcgb24gZml0XG4gIHBhZGRpbmcgICAgICAgICAgICAgOiAzMCxcblxuICAvLyBDb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYm91bmRpbmdCb3ggICAgICAgICA6IHVuZGVmaW5lZCxcblxuICAvLyBFeHRyYSBzcGFjaW5nIGJldHdlZW4gY29tcG9uZW50cyBpbiBub24tY29tcG91bmQgZ3JhcGhzXG4gIGNvbXBvbmVudFNwYWNpbmcgICAgOiAxMDAsXG5cbiAgLy8gTm9kZSByZXB1bHNpb24gKG5vbiBvdmVybGFwcGluZykgbXVsdGlwbGllclxuICBub2RlUmVwdWxzaW9uICAgICAgIDogZnVuY3Rpb24oIG5vZGUgKXsgcmV0dXJuIDQwMDAwMDsgfSxcblxuICAvLyBOb2RlIHJlcHVsc2lvbiAob3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZU92ZXJsYXAgICAgICAgICA6IDEwLFxuXG4gIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICBpZGVhbEVkZ2VMZW5ndGggICAgIDogZnVuY3Rpb24oIGVkZ2UgKXsgcmV0dXJuIDEwOyB9LFxuXG4gIC8vIERpdmlzb3IgdG8gY29tcHV0ZSBlZGdlIGZvcmNlc1xuICBlZGdlRWxhc3RpY2l0eSAgICAgIDogZnVuY3Rpb24oIGVkZ2UgKXsgcmV0dXJuIDEwMDsgfSxcblxuICAvLyBOZXN0aW5nIGZhY3RvciAobXVsdGlwbGllcikgdG8gY29tcHV0ZSBpZGVhbCBlZGdlIGxlbmd0aCBmb3IgbmVzdGVkIGVkZ2VzXG4gIG5lc3RpbmdGYWN0b3IgICAgICAgOiA1LFxuXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KVxuICBncmF2aXR5ICAgICAgICAgICAgIDogODAsXG5cbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gIG51bUl0ZXIgICAgICAgICAgICAgOiAxMDAwLFxuXG4gIC8vIEluaXRpYWwgdGVtcGVyYXR1cmUgKG1heGltdW0gbm9kZSBkaXNwbGFjZW1lbnQpXG4gIGluaXRpYWxUZW1wICAgICAgICAgOiAyMDAsXG5cbiAgLy8gQ29vbGluZyBmYWN0b3IgKGhvdyB0aGUgdGVtcGVyYXR1cmUgaXMgcmVkdWNlZCBiZXR3ZWVuIGNvbnNlY3V0aXZlIGl0ZXJhdGlvbnNcbiAgY29vbGluZ0ZhY3RvciAgICAgICA6IDAuOTUsXG5cbiAgLy8gTG93ZXIgdGVtcGVyYXR1cmUgdGhyZXNob2xkIChiZWxvdyB0aGlzIHBvaW50IHRoZSBsYXlvdXQgd2lsbCBlbmQpXG4gIG1pblRlbXAgICAgICAgICAgICAgOiAxLjAsXG5cbiAgLy8gV2hldGhlciB0byB1c2UgdGhyZWFkaW5nIHRvIHNwZWVkIHVwIHRoZSBsYXlvdXRcbiAgdXNlTXVsdGl0YXNraW5nICAgICA6IHRydWVcbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgICAgICAgOiBjb25zdHJ1Y3RvclxuICogQGFyZyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gQ29zZUxheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zLmxheW91dCA9IHRoaXM7XG59XG5cblxuLyoqXG4gKiBAYnJpZWYgOiBydW5zIHRoZSBsYXlvdXRcbiAqL1xuQ29zZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgY3kgICAgICA9IG9wdGlvbnMuY3k7XG4gIHZhciBsYXlvdXQgID0gdGhpcztcbiAgdmFyIHRocmVhZCAgPSB0aGlzLnRocmVhZDtcblxuICBpZiggIXRocmVhZCB8fCB0aHJlYWQuc3RvcHBlZCgpICl7XG4gICAgdGhyZWFkID0gdGhpcy50aHJlYWQgPSBUaHJlYWQoeyBkaXNhYmxlZDogIW9wdGlvbnMudXNlTXVsdGl0YXNraW5nIH0pO1xuICB9XG5cbiAgbGF5b3V0LnN0b3BwZWQgPSBmYWxzZTtcblxuICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gIC8vIFNldCBERUJVRyAtIEdsb2JhbCB2YXJpYWJsZVxuICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5kZWJ1Zykge1xuICAgIERFQlVHID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBERUJVRyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBsYXlvdXQgaW5mb1xuICB2YXIgbGF5b3V0SW5mbyA9IGNyZWF0ZUxheW91dEluZm8oY3ksIGxheW91dCwgb3B0aW9ucyk7XG5cbiAgLy8gU2hvdyBMYXlvdXRJbmZvIGNvbnRlbnRzIGlmIGRlYnVnZ2luZ1xuICBpZiAoREVCVUcpIHtcbiAgICBwcmludExheW91dEluZm8obGF5b3V0SW5mbyk7XG4gIH1cblxuICAvLyBJZiByZXF1aXJlZCwgcmFuZG9taXplIG5vZGUgcG9zaXRpb25zXG4gIC8vIGlmICh0cnVlID09PSBvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgIHJhbmRvbWl6ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSk7XG4gIC8vIH1cblxuICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgdmFyIHJlZnJlc2hSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgdmFyIHJlZnJlc2ggPSBmdW5jdGlvbiggck9wdHMgKXtcbiAgICByT3B0cyA9IHJPcHRzIHx8IHt9O1xuXG4gICAgaWYoIHJlZnJlc2hSZXF1ZXN0ZWQgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiggIXJPcHRzLmZvcmNlICYmIERhdGUubm93KCkgLSBzdGFydFRpbWUgPCBvcHRpb25zLmFuaW1hdGlvblRocmVzaG9sZCApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlZnJlc2hSZXF1ZXN0ZWQgPSB0cnVlO1xuXG4gICAgdXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgIHJlZnJlc2hQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuXG4gICAgICAvLyBGaXQgdGhlIGdyYXBoIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHRydWUgPT09IG9wdGlvbnMuZml0KSB7XG4gICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICB9XG5cbiAgICAgIHJlZnJlc2hSZXF1ZXN0ZWQgPSBmYWxzZTtcblxuICAgICAgaWYoIHJPcHRzLm5leHQgKXsgck9wdHMubmV4dCgpOyB9XG4gICAgfSk7XG4gIH07XG5cbiAgdGhyZWFkLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24oIGUgKXtcbiAgICB2YXIgbGF5b3V0Tm9kZXMgPSBlLm1lc3NhZ2U7XG5cbiAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzID0gbGF5b3V0Tm9kZXM7XG4gICAgcmVmcmVzaCgpO1xuICB9KTtcblxuICB0aHJlYWQucGFzcyh7XG4gICAgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBhbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsXG4gICAgICByZWZyZXNoOiBvcHRpb25zLnJlZnJlc2gsXG4gICAgICBjb21wb25lbnRTcGFjaW5nOiBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmcsXG4gICAgICBub2RlT3ZlcmxhcDogb3B0aW9ucy5ub2RlT3ZlcmxhcCxcbiAgICAgIG5lc3RpbmdGYWN0b3I6IG9wdGlvbnMubmVzdGluZ0ZhY3RvcixcbiAgICAgIGdyYXZpdHk6IG9wdGlvbnMuZ3Jhdml0eSxcbiAgICAgIG51bUl0ZXI6IG9wdGlvbnMubnVtSXRlcixcbiAgICAgIGluaXRpYWxUZW1wOiBvcHRpb25zLmluaXRpYWxUZW1wLFxuICAgICAgY29vbGluZ0ZhY3Rvcjogb3B0aW9ucy5jb29saW5nRmFjdG9yLFxuICAgICAgbWluVGVtcDogb3B0aW9ucy5taW5UZW1wXG4gICAgfVxuICB9KS5ydW4oZnVuY3Rpb24oIHBhc3MgKXtcbiAgICB2YXIgbGF5b3V0SW5mbyA9IHBhc3MubGF5b3V0SW5mbztcbiAgICB2YXIgb3B0aW9ucyA9IHBhc3Mub3B0aW9ucztcbiAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmICAgICAgICAgIDogUGVyZm9ybXMgb25lIGl0ZXJhdGlvbiBvZiB0aGUgcGh5c2ljYWwgc2ltdWxhdGlvblxuICAgICAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAgKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gICAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICAgKi9cbiAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uKGxheW91dEluZm8sIG9wdGlvbnMsIHN0ZXApIHtcbiAgICAgIC8vIHZhciBzID0gXCJcXG5cXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXCI7XG4gICAgICAvLyBzICs9IFwiXFxuU1RFUDogXCIgKyBzdGVwO1xuICAgICAgLy8gcyArPSBcIlxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcXG5cIjtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgbm9kZSByZXB1bHNpb25zXG4gICAgICBjYWxjdWxhdGVOb2RlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgLy8gQ2FsY3VsYXRlIGVkZ2UgZm9yY2VzXG4gICAgICBjYWxjdWxhdGVFZGdlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgLy8gQ2FsY3VsYXRlIGdyYXZpdHkgZm9yY2VzXG4gICAgICBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgLy8gUHJvcGFnYXRlIGZvcmNlcyBmcm9tIHBhcmVudCB0byBjaGlsZFxuICAgICAgcHJvcGFnYXRlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgLy8gVXBkYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiBjYWxjdWxhdGVkIGZvcmNlc1xuICAgICAgdXBkYXRlUG9zaXRpb25zKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBDb21wdXRlcyB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzXG4gICAgICovXG4gICAgdmFyIGNhbGN1bGF0ZU5vZGVGb3JjZXMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgICAvLyBHbyB0aHJvdWdoIGVhY2ggb2YgdGhlIGdyYXBocyBpbiBncmFwaFNldFxuICAgICAgLy8gTm9kZXMgb25seSByZXBlbCBlYWNoIG90aGVyIGlmIHRoZXkgYmVsb25nIHRvIHRoZSBzYW1lIGdyYXBoXG4gICAgICAvLyB2YXIgcyA9ICdjYWxjdWxhdGVOb2RlRm9yY2VzJztcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIgZ3JhcGggICAgPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgICAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAgIC8vIE5vdyBnZXQgYWxsIHRoZSBwYWlycyBvZiBub2Rlc1xuICAgICAgICAvLyBPbmx5IGdldCBlYWNoIHBhaXIgb25jZSwgKEEsIEIpID0gKEIsIEEpXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICAgIHZhciBub2RlMSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcblxuICAgICAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IG51bU5vZGVzOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlMiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhba11dXTtcblxuICAgICAgICAgICAgbm9kZVJlcHVsc2lvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBDb21wdXRlIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXMgYmV0d2VlbiBhIHBhaXIgb2Ygbm9kZXNcbiAgICAgKi9cbiAgICB2YXIgbm9kZVJlcHVsc2lvbiA9IGZ1bmN0aW9uKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgICAgLy8gdmFyIHMgPSBcIk5vZGUgcmVwdWxzaW9uLiBOb2RlMTogXCIgKyBub2RlMS5pZCArIFwiIE5vZGUyOiBcIiArIG5vZGUyLmlkO1xuXG4gICAgICB2YXIgY21wdElkMSA9IG5vZGUxLmNtcHRJZDtcbiAgICAgIHZhciBjbXB0SWQyID0gbm9kZTIuY21wdElkO1xuXG4gICAgICBpZiggY21wdElkMSAhPT0gY21wdElkMiAmJiAhbGF5b3V0SW5mby5pc0NvbXBvdW5kICl7IHJldHVybjsgfVxuXG4gICAgICAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuICAgICAgdmFyIGRpcmVjdGlvblggPSBub2RlMi5wb3NpdGlvblggLSBub2RlMS5wb3NpdGlvblg7XG4gICAgICB2YXIgZGlyZWN0aW9uWSA9IG5vZGUyLnBvc2l0aW9uWSAtIG5vZGUxLnBvc2l0aW9uWTtcbiAgICAgIC8vIHMgKz0gXCJcXG5kaXJlY3Rpb25YOiBcIiArIGRpcmVjdGlvblggKyBcIiwgZGlyZWN0aW9uWTogXCIgKyBkaXJlY3Rpb25ZO1xuXG4gICAgICAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBhcHBseSBhIHJhbmRvbSBmb3JjZVxuICAgICAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgICAgICAvLyBzICs9IFwiXFxuTm9kZXMgaGF2ZSB0aGUgc2FtZSBwb3NpdGlvbi5cIjtcbiAgICAgICAgcmV0dXJuOyAvLyBUT0RPIGNvdWxkIGJlIGltcHJvdmVkIHdpdGggcmFuZG9tIGZvcmNlXG4gICAgICB9XG5cbiAgICAgIHZhciBvdmVybGFwID0gbm9kZXNPdmVybGFwKG5vZGUxLCBub2RlMiwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG5cbiAgICAgIGlmIChvdmVybGFwID4gMCkge1xuICAgICAgICAvLyBzICs9IFwiXFxuTm9kZXMgRE8gb3ZlcmxhcC5cIjtcbiAgICAgICAgLy8gcyArPSBcIlxcbk92ZXJsYXA6IFwiICsgb3ZlcmxhcDtcbiAgICAgICAgLy8gSWYgbm9kZXMgb3ZlcmxhcCwgcmVwdWxzaW9uIGZvcmNlIGlzIHByb3BvcnRpb25hbFxuICAgICAgICAvLyB0byB0aGUgb3ZlcmxhcFxuICAgICAgICB2YXIgZm9yY2UgICAgPSBvcHRpb25zLm5vZGVPdmVybGFwICogb3ZlcmxhcDtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlyZWN0aW9uWCAqIGRpcmVjdGlvblggKyBkaXJlY3Rpb25ZICogZGlyZWN0aW9uWSk7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcbiAgICAgICAgdmFyIGZvcmNlWCAgID0gZm9yY2UgKiBkaXJlY3Rpb25YIC8gZGlzdGFuY2U7XG4gICAgICAgIHZhciBmb3JjZVkgICA9IGZvcmNlICogZGlyZWN0aW9uWSAvIGRpc3RhbmNlO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzICs9IFwiXFxuTm9kZXMgZG8gTk9UIG92ZXJsYXAuXCI7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gb3ZlcmxhcCwgZm9yY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbFxuICAgICAgICAvLyB0byBzcXVhcmVkIGRpc3RhbmNlXG5cbiAgICAgICAgLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuICAgICAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTEsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgICAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTIsIC0xICogZGlyZWN0aW9uWCwgLTEgKiBkaXJlY3Rpb25ZKTtcblxuICAgICAgICAvLyBVc2UgY2xpcHBpbmcgcG9pbnRzIHRvIGNvbXB1dGUgZGlzdGFuY2VcbiAgICAgICAgdmFyIGRpc3RhbmNlWCAgID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICAgICAgdmFyIGRpc3RhbmNlWSAgID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICAgICAgdmFyIGRpc3RhbmNlU3FyID0gZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZO1xuICAgICAgICB2YXIgZGlzdGFuY2UgICAgPSBNYXRoLnNxcnQoZGlzdGFuY2VTcXIpO1xuICAgICAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcbiAgICAgICAgdmFyIGZvcmNlICA9ICggbm9kZTEubm9kZVJlcHVsc2lvbiArIG5vZGUyLm5vZGVSZXB1bHNpb24gKSAvIGRpc3RhbmNlU3FyO1xuICAgICAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBkaXN0YW5jZVggLyBkaXN0YW5jZTtcbiAgICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogZGlzdGFuY2VZIC8gZGlzdGFuY2U7XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IGZvcmNlXG4gICAgICBpZiggIW5vZGUxLmlzTG9ja2VkICl7XG4gICAgICAgIG5vZGUxLm9mZnNldFggLT0gZm9yY2VYO1xuICAgICAgICBub2RlMS5vZmZzZXRZIC09IGZvcmNlWTtcbiAgICAgIH1cblxuICAgICAgaWYoICFub2RlMi5pc0xvY2tlZCApe1xuICAgICAgICBub2RlMi5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgICAgbm9kZTIub2Zmc2V0WSArPSBmb3JjZVk7XG4gICAgICB9XG5cbiAgICAgIC8vIHMgKz0gXCJcXG5Gb3JjZVg6IFwiICsgZm9yY2VYICsgXCIgRm9yY2VZOiBcIiArIGZvcmNlWTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiAgOiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIG5vZGVzIG92ZXJsYXAgb3Igbm90XG4gICAgICogQHJldHVybiA6IEFtb3VudCBvZiBvdmVybGFwcGluZyAoMCA9PiBubyBvdmVybGFwKVxuICAgICAqL1xuICAgIHZhciBub2Rlc092ZXJsYXAgPSBmdW5jdGlvbihub2RlMSwgbm9kZTIsIGRYLCBkWSkge1xuXG4gICAgICBpZiAoZFggPiAwKSB7XG4gICAgICAgIHZhciBvdmVybGFwWCA9IG5vZGUxLm1heFggLSBub2RlMi5taW5YO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG92ZXJsYXBYID0gbm9kZTIubWF4WCAtIG5vZGUxLm1pblg7XG4gICAgICB9XG5cbiAgICAgIGlmIChkWSA+IDApIHtcbiAgICAgICAgdmFyIG92ZXJsYXBZID0gbm9kZTEubWF4WSAtIG5vZGUyLm1pblk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMi5tYXhZIC0gbm9kZTEubWluWTtcbiAgICAgIH1cblxuICAgICAgaWYgKG92ZXJsYXBYID49IDAgJiYgb3ZlcmxhcFkgPj0gMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KG92ZXJsYXBYICogb3ZlcmxhcFggKyBvdmVybGFwWSAqIG92ZXJsYXBZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBGaW5kcyB0aGUgcG9pbnQgaW4gd2hpY2ggYW4gZWRnZSAoZGlyZWN0aW9uIGRYLCBkWSkgaW50ZXJzZWN0c1xuICAgICAqICAgICAgICAgIHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBib3ggb2YgaXQncyBzb3VyY2UvdGFyZ2V0IG5vZGVcbiAgICAgKi9cbiAgICB2YXIgZmluZENsaXBwaW5nUG9pbnQgPSBmdW5jdGlvbihub2RlLCBkWCwgZFkpIHtcblxuICAgICAgLy8gU2hvcmN1dHNcbiAgICAgIHZhciBYID0gbm9kZS5wb3NpdGlvblg7XG4gICAgICB2YXIgWSA9IG5vZGUucG9zaXRpb25ZO1xuICAgICAgdmFyIEggPSBub2RlLmhlaWdodCB8fCAxO1xuICAgICAgdmFyIFcgPSBub2RlLndpZHRoIHx8IDE7XG4gICAgICB2YXIgZGlyU2xvcGUgICAgID0gZFkgLyBkWDtcbiAgICAgIHZhciBub2RlU2xvcGUgICAgPSBIIC8gVztcblxuICAgICAgLy8gdmFyIHMgPSAnQ29tcHV0aW5nIGNsaXBwaW5nIHBvaW50IG9mIG5vZGUgJyArIG5vZGUuaWQgK1xuICAgICAgLy8gICBcIiAuIEhlaWdodDogIFwiICsgSCArIFwiLCBXaWR0aDogXCIgKyBXICtcbiAgICAgIC8vICAgXCJcXG5EaXJlY3Rpb24gXCIgKyBkWCArIFwiLCBcIiArIGRZO1xuICAgICAgLy9cbiAgICAgIC8vIENvbXB1dGUgaW50ZXJzZWN0aW9uXG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICBkbyB7XG4gICAgICAgIC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAodXApXG4gICAgICAgIGlmICgwID09PSBkWCAmJiAwIDwgZFkpIHtcbiAgICAgICAgICByZXMueCA9IFg7XG4gICAgICAgICAgLy8gcyArPSBcIlxcblVwIGRpcmVjdGlvblwiO1xuICAgICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uIChkb3duKVxuICAgICAgICBpZiAoMCA9PT0gZFggJiYgMCA+IGRZKSB7XG4gICAgICAgICAgcmVzLnggPSBYO1xuICAgICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5Eb3duIGRpcmVjdGlvblwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgcmlnaHQgYm9yZGVyXG4gICAgICAgIGlmICgwIDwgZFggJiZcbiAgICAgICAgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiZcbiAgICAgICAgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgICAgICAgcmVzLnggPSBYICsgVyAvIDI7XG4gICAgICAgICAgcmVzLnkgPSBZICsgKFcgKiBkWSAvIDIgLyBkWCk7XG4gICAgICAgICAgLy8gcyArPSBcIlxcblJpZ2h0Ym9yZGVyXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBsZWZ0IGJvcmRlclxuICAgICAgICBpZiAoMCA+IGRYICYmXG4gICAgICAgIC0xICogbm9kZVNsb3BlIDw9IGRpclNsb3BlICYmXG4gICAgICAgIGRpclNsb3BlIDw9IG5vZGVTbG9wZSkge1xuICAgICAgICAgIHJlcy54ID0gWCAtIFcgLyAyO1xuICAgICAgICAgIHJlcy55ID0gWSAtIChXICogZFkgLyAyIC8gZFgpO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5MZWZ0Ym9yZGVyXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSB0b3AgYm9yZGVyXG4gICAgICAgIGlmICgwIDwgZFkgJiZcbiAgICAgICAgKCBkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fFxuICAgICAgICAgIGRpclNsb3BlID49IG5vZGVTbG9wZSApKSB7XG4gICAgICAgICAgcmVzLnggPSBYICsgKEggKiBkWCAvIDIgLyBkWSk7XG4gICAgICAgICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgICAgICAgLy8gcyArPSBcIlxcblRvcCBib3JkZXJcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGJvdHRvbSBib3JkZXJcbiAgICAgICAgaWYgKDAgPiBkWSAmJlxuICAgICAgICAoIGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8XG4gICAgICAgICAgZGlyU2xvcGUgPj0gbm9kZVNsb3BlICkpIHtcbiAgICAgICAgICByZXMueCA9IFggLSAoSCAqIGRYIC8gMiAvIGRZKTtcbiAgICAgICAgICByZXMueSA9IFkgLSBIIC8gMjtcbiAgICAgICAgICAvLyBzICs9IFwiXFxuQm90dG9tIGJvcmRlclwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIH0gd2hpbGUgKGZhbHNlKTtcblxuICAgICAgLy8gcyArPSBcIlxcbkNsaXBwaW5nIHBvaW50IGZvdW5kIGF0IFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogQ2FsY3VsYXRlcyBhbGwgZWRnZSBmb3JjZXNcbiAgICAgKi9cbiAgICB2YXIgY2FsY3VsYXRlRWRnZUZvcmNlcyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrKSB7XG4gICAgICAgIC8vIEdldCBlZGdlLCBzb3VyY2UgJiB0YXJnZXQgbm9kZXNcbiAgICAgICAgdmFyIGVkZ2UgICAgID0gbGF5b3V0SW5mby5sYXlvdXRFZGdlc1tpXTtcbiAgICAgICAgdmFyIHNvdXJjZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS5zb3VyY2VJZF07XG4gICAgICAgIHZhciBzb3VyY2UgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuICAgICAgICB2YXIgdGFyZ2V0SXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtlZGdlLnRhcmdldElkXTtcbiAgICAgICAgdmFyIHRhcmdldCAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1t0YXJnZXRJeF07XG5cbiAgICAgICAgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcbiAgICAgICAgdmFyIGRpcmVjdGlvblggPSB0YXJnZXQucG9zaXRpb25YIC0gc291cmNlLnBvc2l0aW9uWDtcbiAgICAgICAgdmFyIGRpcmVjdGlvblkgPSB0YXJnZXQucG9zaXRpb25ZIC0gc291cmNlLnBvc2l0aW9uWTtcblxuICAgICAgICAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBkbyBub3RoaW5nLlxuICAgICAgICAvLyBBIHJhbmRvbSBmb3JjZSBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgYXMgbm9kZSByZXB1bHNpb25cbiAgICAgICAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG4gICAgICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludChzb3VyY2UsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgICAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQodGFyZ2V0LCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG5cblxuICAgICAgICB2YXIgbHggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgICAgICB2YXIgbHkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgICAgICB2YXIgbCAgPSBNYXRoLnNxcnQobHggKiBseCArIGx5ICogbHkpO1xuXG4gICAgICAgIHZhciBmb3JjZSAgPSBNYXRoLnBvdyhlZGdlLmlkZWFsTGVuZ3RoIC0gbCwgMikgLyBlZGdlLmVsYXN0aWNpdHk7XG5cbiAgICAgICAgaWYgKDAgIT09IGwpIHtcbiAgICAgICAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBseCAvIGw7XG4gICAgICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogbHkgLyBsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmb3JjZVggPSAwO1xuICAgICAgICAgIHZhciBmb3JjZVkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoaXMgZm9yY2UgdG8gdGFyZ2V0IGFuZCBzb3VyY2Ugbm9kZXNcbiAgICAgICAgaWYoICFzb3VyY2UuaXNMb2NrZWQgKXtcbiAgICAgICAgICBzb3VyY2Uub2Zmc2V0WCArPSBmb3JjZVg7XG4gICAgICAgICAgc291cmNlLm9mZnNldFkgKz0gZm9yY2VZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICF0YXJnZXQuaXNMb2NrZWQgKXtcbiAgICAgICAgICB0YXJnZXQub2Zmc2V0WCAtPSBmb3JjZVg7XG4gICAgICAgICAgdGFyZ2V0Lm9mZnNldFkgLT0gZm9yY2VZO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFyIHMgPSAnRWRnZSBmb3JjZSBiZXR3ZWVuIG5vZGVzICcgKyBzb3VyY2UuaWQgKyAnIGFuZCAnICsgdGFyZ2V0LmlkO1xuICAgICAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgbCArIFwiIEZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIilcIjtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IENvbXB1dGVzIGdyYXZpdHkgZm9yY2VzIGZvciBhbGwgbm9kZXNcbiAgICAgKi9cbiAgICB2YXIgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBkaXN0VGhyZXNob2xkID0gMTtcblxuICAgICAgLy8gdmFyIHMgPSAnY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyc7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIGdyYXBoICAgID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICAgICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoO1xuXG4gICAgICAgIC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgICAvLyBDb21wdXRlIGdyYXBoIGNlbnRlclxuICAgICAgICBpZiAoMCA9PT0gaSkge1xuICAgICAgICAgIHZhciBjZW50ZXJYICAgPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodCAvIDI7XG4gICAgICAgICAgdmFyIGNlbnRlclkgICA9IGxheW91dEluZm8uY2xpZW50V2lkdGggIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBHZXQgUGFyZW50IG5vZGUgZm9yIHRoaXMgZ3JhcGgsIGFuZCB1c2UgaXRzIHBvc2l0aW9uIGFzIGNlbnRlclxuICAgICAgICAgIHZhciB0ZW1wICAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFswXV1dO1xuICAgICAgICAgIHZhciBwYXJlbnQgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wLnBhcmVudElkXV07XG4gICAgICAgICAgdmFyIGNlbnRlclggPSBwYXJlbnQucG9zaXRpb25YO1xuICAgICAgICAgIHZhciBjZW50ZXJZID0gcGFyZW50LnBvc2l0aW9uWTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzID0gXCJDZW50ZXIgZm91bmQgYXQ6IFwiICsgY2VudGVyWCArIFwiLCBcIiArIGNlbnRlclk7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAgIC8vIEFwcGx5IGZvcmNlIHRvIGFsbCBub2RlcyBpbiBncmFwaFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcbiAgICAgICAgICAvLyBzID0gXCJOb2RlOiBcIiArIG5vZGUuaWQ7XG5cbiAgICAgICAgICBpZiggbm9kZS5pc0xvY2tlZCApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdmFyIGR4ID0gY2VudGVyWCAtIG5vZGUucG9zaXRpb25YO1xuICAgICAgICAgIHZhciBkeSA9IGNlbnRlclkgLSBub2RlLnBvc2l0aW9uWTtcbiAgICAgICAgICB2YXIgZCAgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgIGlmIChkID4gZGlzdFRocmVzaG9sZCkge1xuICAgICAgICAgICAgdmFyIGZ4ID0gb3B0aW9ucy5ncmF2aXR5ICogZHggLyBkO1xuICAgICAgICAgICAgdmFyIGZ5ID0gb3B0aW9ucy5ncmF2aXR5ICogZHkgLyBkO1xuICAgICAgICAgICAgbm9kZS5vZmZzZXRYICs9IGZ4O1xuICAgICAgICAgICAgbm9kZS5vZmZzZXRZICs9IGZ5O1xuICAgICAgICAgICAgLy8gcyArPSBcIjogQXBwbGllZCBmb3JjZTogXCIgKyBmeCArIFwiLCBcIiArIGZ5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzICs9IFwiOiBza3lwcGVkIHNpbmNlIGl0J3MgdG9vIGNsb3NlIHRvIGNlbnRlclwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgICAgICAgICAgOiBUaGlzIGZ1bmN0aW9uIHByb3BhZ2F0ZXMgdGhlIGV4aXN0aW5nIG9mZnNldHMgZnJvbVxuICAgICAqICAgICAgICAgICAgICAgICAgIHBhcmVudCBub2RlcyB0byBpdHMgZGVzY2VuZGVudHMuXG4gICAgICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBPYmplY3RcbiAgICAgKiBAYXJnIGN5ICAgICAgICAgOiBjeXRvc2NhcGUgT2JqZWN0XG4gICAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICAgKi9cbiAgICB2YXIgcHJvcGFnYXRlRm9yY2VzID0gZnVuY3Rpb24obGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgICAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICB2YXIgc3RhcnQgPSAwOyAgIC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG4gICAgICB2YXIgZW5kICAgPSAtMTsgIC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gICAgICAvLyBsb2dEZWJ1ZygncHJvcGFnYXRlRm9yY2VzJyk7XG5cbiAgICAgIC8vIFN0YXJ0IGJ5IHZpc2l0aW5nIHRoZSBub2RlcyBpbiB0aGUgcm9vdCBncmFwaFxuICAgICAgcXVldWUucHVzaC5hcHBseShxdWV1ZSwgbGF5b3V0SW5mby5ncmFwaFNldFswXSk7XG4gICAgICBlbmQgKz0gbGF5b3V0SW5mby5ncmFwaFNldFswXS5sZW5ndGg7XG5cbiAgICAgIC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsXG4gICAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICAgICAgdmFyIG5vZGVJZCAgICA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgICAgICB2YXIgbm9kZUluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZUlkXTtcbiAgICAgICAgdmFyIG5vZGUgICAgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUluZGV4XTtcbiAgICAgICAgdmFyIGNoaWxkcmVuICA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIHByb2Nlc3MgdGhlIG5vZGUgaWYgaXQncyBjb21wb3VuZFxuICAgICAgICBpZiAoMCA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhbm9kZS5pc0xvY2tlZCkge1xuICAgICAgICAgIHZhciBvZmZYID0gbm9kZS5vZmZzZXRYO1xuICAgICAgICAgIHZhciBvZmZZID0gbm9kZS5vZmZzZXRZO1xuXG4gICAgICAgICAgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG9mZnNldCBmcm9tIHBhcmVudCBub2RlIDogXCIgKyBub2RlLmlkICtcbiAgICAgICAgICAvLyAgIFwiLiBPZmZzZXRYOiBcIiArIG9mZlggKyBcIi4gT2Zmc2V0WTogXCIgKyBvZmZZO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG4gQ2hpbGRyZW46IFwiICsgY2hpbGRyZW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2NoaWxkcmVuW2ldXV07XG4gICAgICAgICAgICAvLyBQcm9wYWdhdGUgb2Zmc2V0XG4gICAgICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WCArPSBvZmZYO1xuICAgICAgICAgICAgY2hpbGROb2RlLm9mZnNldFkgKz0gb2ZmWTtcbiAgICAgICAgICAgIC8vIEFkZCBjaGlsZHJlbiB0byBxdWV1ZSB0byBiZSB2aXNpdGVkXG4gICAgICAgICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXNldCBwYXJlbnQgb2Zmc2V0c1xuICAgICAgICAgIG5vZGUub2Zmc2V0WCA9IDA7XG4gICAgICAgICAgbm9kZS5vZmZzZXRZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IFVwZGF0ZXMgdGhlIGxheW91dCBtb2RlbCBwb3NpdGlvbnMsIGJhc2VkIG9uXG4gICAgICogICAgICAgICAgdGhlIGFjY3VtdWxhdGVkIGZvcmNlc1xuICAgICAqL1xuICAgIHZhciB1cGRhdGVQb3NpdGlvbnMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgICAvLyB2YXIgcyA9ICdVcGRhdGluZyBwb3NpdGlvbnMnO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIC8vIFJlc2V0IGJvdW5kYXJpZXMgZm9yIGNvbXBvdW5kIG5vZGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIlJlc2V0dGluZyBib3VuZGFyaWVzIG9mIGNvbXBvdW5kIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICAgICAgbi5tYXhYID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG4ubWluWCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuLm1heFkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbi5taW5ZID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCB8fCBuLmlzTG9ja2VkKSB7XG4gICAgICAgICAgLy8gTm8gbmVlZCB0byBzZXQgY29tcG91bmQgb3IgbG9ja2VkIG5vZGUgcG9zaXRpb25cbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIlNraXBwaW5nIHBvc2l0aW9uIHVwZGF0ZSBvZiBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHMgPSBcIk5vZGU6IFwiICsgbi5pZCArIFwiIFByZXZpb3VzIHBvc2l0aW9uOiAoXCIgK1xuICAgICAgICAvLyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuXG4gICAgICAgIC8vIExpbWl0IGRpc3BsYWNlbWVudCBpbiBvcmRlciB0byBpbXByb3ZlIHN0YWJpbGl0eVxuICAgICAgICB2YXIgdGVtcEZvcmNlID0gbGltaXRGb3JjZShuLm9mZnNldFgsIG4ub2Zmc2V0WSwgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG4gICAgICAgIG4ucG9zaXRpb25YICs9IHRlbXBGb3JjZS54O1xuICAgICAgICBuLnBvc2l0aW9uWSArPSB0ZW1wRm9yY2UueTtcbiAgICAgICAgbi5vZmZzZXRYID0gMDtcbiAgICAgICAgbi5vZmZzZXRZID0gMDtcbiAgICAgICAgbi5taW5YICAgID0gbi5wb3NpdGlvblggLSBuLndpZHRoO1xuICAgICAgICBuLm1heFggICAgPSBuLnBvc2l0aW9uWCArIG4ud2lkdGg7XG4gICAgICAgIG4ubWluWSAgICA9IG4ucG9zaXRpb25ZIC0gbi5oZWlnaHQ7XG4gICAgICAgIG4ubWF4WSAgICA9IG4ucG9zaXRpb25ZICsgbi5oZWlnaHQ7XG4gICAgICAgIC8vIHMgKz0gXCIgTmV3IFBvc2l0aW9uOiAoXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgICAvLyBVcGRhdGUgYW5jZXN0cnkgYm91ZGFyaWVzXG4gICAgICAgIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhuLCBsYXlvdXRJbmZvKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHNpemUsIHBvc2l0aW9uIG9mIGNvbXB1bmQgbm9kZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgICAgaWYgKCAwIDwgbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQgKSB7XG4gICAgICAgICAgbi5wb3NpdGlvblggPSAobi5tYXhYICsgbi5taW5YKSAvIDI7XG4gICAgICAgICAgbi5wb3NpdGlvblkgPSAobi5tYXhZICsgbi5taW5ZKSAvIDI7XG4gICAgICAgICAgbi53aWR0aCAgICAgPSBuLm1heFggLSBuLm1pblg7XG4gICAgICAgICAgbi5oZWlnaHQgICAgPSBuLm1heFkgLSBuLm1pblk7XG4gICAgICAgICAgLy8gcyA9IFwiVXBkYXRpbmcgcG9zaXRpb24sIHNpemUgb2YgY29tcG91bmQgbm9kZSBcIiArIG4uaWQ7XG4gICAgICAgICAgLy8gcyArPSBcIlxcblBvc2l0aW9uWDogXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBQb3NpdGlvblk6IFwiICsgbi5wb3NpdGlvblk7XG4gICAgICAgICAgLy8gcyArPSBcIlxcbldpZHRoOiBcIiArIG4ud2lkdGggKyBcIiwgSGVpZ2h0OiBcIiArIG4uaGVpZ2h0O1xuICAgICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IExpbWl0cyBhIGZvcmNlIChmb3JjZVgsIGZvcmNlWSkgdG8gYmUgbm90XG4gICAgICogICAgICAgICAgZ3JlYXRlciAoaW4gbW9kdWxvKSB0aGFuIG1heC5cbiAgICAgOCAgICAgICAgICBQcmVzZXJ2ZXMgZm9yY2UgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIHZhciBsaW1pdEZvcmNlID0gZnVuY3Rpb24oZm9yY2VYLCBmb3JjZVksIG1heCkge1xuICAgICAgLy8gdmFyIHMgPSBcIkxpbWl0aW5nIGZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIikuIE1heDogXCIgKyBtYXg7XG4gICAgICB2YXIgZm9yY2UgPSBNYXRoLnNxcnQoZm9yY2VYICogZm9yY2VYICsgZm9yY2VZICogZm9yY2VZKTtcblxuICAgICAgaWYgKGZvcmNlID4gbWF4KSB7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgIHggOiBtYXggKiBmb3JjZVggLyBmb3JjZSxcbiAgICAgICAgeSA6IG1heCAqIGZvcmNlWSAvIGZvcmNlXG4gICAgICAgIH07XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgIHggOiBmb3JjZVgsXG4gICAgICAgIHkgOiBmb3JjZVlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gcyArPSBcIi5cXG5SZXN1bHQ6IChcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnkgKyBcIilcIjtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBGdW5jdGlvbiB1c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGNvbXBvdW5kIG5vZGVcbiAgICAgKiAgICAgICAgICBzaXplcywgc2luY2UgdGhleSBzaG91bGQgYm91bmQgYWxsIHRoZWlyIHN1Ym5vZGVzLlxuICAgICAqL1xuICAgIHZhciB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMgPSBmdW5jdGlvbihub2RlLCBsYXlvdXRJbmZvKSB7XG4gICAgICAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgbmV3IHBvc2l0aW9uL3NpemUgb2Ygbm9kZSBcIiArIG5vZGUuaWQ7XG4gICAgICB2YXIgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuICAgICAgaWYgKG51bGwgPT0gcGFyZW50SWQpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlIGFyZSBkb25lXG4gICAgICAgIC8vIHMgKz0gXCIuIE5vIHBhcmVudCBub2RlLlwiO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgUGFyZW50IE5vZGVcbiAgICAgIHZhciBwID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwYXJlbnRJZF1dO1xuICAgICAgdmFyIGZsYWcgPSBmYWxzZTtcblxuICAgICAgLy8gTWF4WFxuICAgICAgaWYgKG51bGwgPT0gcC5tYXhYIHx8IG5vZGUubWF4WCArIHAucGFkUmlnaHQgPiBwLm1heFgpIHtcbiAgICAgICAgcC5tYXhYID0gbm9kZS5tYXhYICsgcC5wYWRSaWdodDtcbiAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWF4WCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhYO1xuICAgICAgfVxuXG4gICAgICAvLyBNaW5YXG4gICAgICBpZiAobnVsbCA9PSBwLm1pblggfHwgbm9kZS5taW5YIC0gcC5wYWRMZWZ0IDwgcC5taW5YKSB7XG4gICAgICAgIHAubWluWCA9IG5vZGUubWluWCAtIHAucGFkTGVmdDtcbiAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWluWCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5YO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXhZXG4gICAgICBpZiAobnVsbCA9PSBwLm1heFkgfHwgbm9kZS5tYXhZICsgcC5wYWRCb3R0b20gPiBwLm1heFkpIHtcbiAgICAgICAgcC5tYXhZID0gbm9kZS5tYXhZICsgcC5wYWRCb3R0b207XG4gICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAvLyBzICs9IFwiXFxuTmV3IG1heFkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WTtcbiAgICAgIH1cblxuICAgICAgLy8gTWluWVxuICAgICAgaWYgKG51bGwgPT0gcC5taW5ZIHx8IG5vZGUubWluWSAtIHAucGFkVG9wIDwgcC5taW5ZKSB7XG4gICAgICAgIHAubWluWSA9IG5vZGUubWluWSAtIHAucGFkVG9wO1xuICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5ldyBtaW5ZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHVwZGF0ZWQgYm91bmRhcmllcywgcHJvcGFnYXRlIGNoYW5nZXMgdXB3YXJkXG4gICAgICBpZiAoZmxhZykge1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhwLCBsYXlvdXRJbmZvKTtcbiAgICAgIH1cblxuICAgICAgLy8gcyArPSBcIi4gTm8gY2hhbmdlcyBpbiBib3VuZGFyaWVzL3Bvc2l0aW9uIG9mIHBhcmVudCBub2RlIFwiICsgcC5pZDtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICB2YXIgc2VwYXJhdGVDb21wb25lbnRzID0gZnVuY3Rpb24obGF5dXRJbmZvLCBvcHRpb25zKXtcbiAgICAgIHZhciBub2RlcyA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXM7XG4gICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBjaWQgPSBub2RlLmNtcHRJZDtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbIGNpZCBdID0gY29tcG9uZW50c1sgY2lkIF0gfHwgW107XG5cbiAgICAgICAgY29tcG9uZW50LnB1c2goIG5vZGUgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsQSA9IDA7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgYyA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgIGMueDEgPSBJbmZpbml0eTtcbiAgICAgICAgYy54MiA9IC1JbmZpbml0eTtcbiAgICAgICAgYy55MSA9IEluZmluaXR5O1xuICAgICAgICBjLnkyID0gLUluZmluaXR5O1xuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBuID0gY1tqXTtcblxuICAgICAgICAgIGMueDEgPSBNYXRoLm1pbiggYy54MSwgbi5wb3NpdGlvblggLSBuLndpZHRoLzIgKTtcbiAgICAgICAgICBjLngyID0gTWF0aC5tYXgoIGMueDIsIG4ucG9zaXRpb25YICsgbi53aWR0aC8yICk7XG4gICAgICAgICAgYy55MSA9IE1hdGgubWluKCBjLnkxLCBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0LzIgKTtcbiAgICAgICAgICBjLnkyID0gTWF0aC5tYXgoIGMueTIsIG4ucG9zaXRpb25ZICsgbi5oZWlnaHQvMiApO1xuICAgICAgICB9XG5cbiAgICAgICAgYy53ID0gYy54MiAtIGMueDE7XG4gICAgICAgIGMuaCA9IGMueTIgLSBjLnkxO1xuXG4gICAgICAgIHRvdGFsQSArPSBjLncgKiBjLmg7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudHMuc29ydChmdW5jdGlvbiggYzEsIGMyICl7XG4gICAgICAgIHJldHVybiBjMi53KmMyLmggLSBjMS53KmMxLmg7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHggPSAwO1xuICAgICAgdmFyIHkgPSAwO1xuICAgICAgdmFyIHVzZWRXID0gMDtcbiAgICAgIHZhciByb3dIID0gMDtcbiAgICAgIHZhciBtYXhSb3dXID0gTWF0aC5zcXJ0KCB0b3RhbEEgKSAqIGxheW91dEluZm8uY2xpZW50V2lkdGggLyBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgbiA9IGNbal07XG5cbiAgICAgICAgICBpZiggIW4uaXNMb2NrZWQgKXtcbiAgICAgICAgICAgIG4ucG9zaXRpb25YICs9IHg7XG4gICAgICAgICAgICBuLnBvc2l0aW9uWSArPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHggKz0gYy53ICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgICB1c2VkVyArPSBjLncgKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgICAgIHJvd0ggPSBNYXRoLm1heCggcm93SCwgYy5oICk7XG5cbiAgICAgICAgaWYoIHVzZWRXID4gbWF4Um93VyApe1xuICAgICAgICAgIHkgKz0gcm93SCArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICB1c2VkVyA9IDA7XG4gICAgICAgICAgcm93SCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG1haW5Mb29wID0gZnVuY3Rpb24oaSl7XG4gICAgICBpZiggc3RvcHBlZCApe1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIkxheW91dCBtYW51YWxseSBzdG9wcGVkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gRG8gb25lIHN0ZXAgaW4gdGhlIHBoaXNpY2FsIHNpbXVsYXRpb25cbiAgICAgIHN0ZXAobGF5b3V0SW5mbywgb3B0aW9ucywgaSk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0ZW1wZXJhdHVyZVxuICAgICAgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSA9IGxheW91dEluZm8udGVtcGVyYXR1cmUgKiBvcHRpb25zLmNvb2xpbmdGYWN0b3I7XG4gICAgICAvLyBsb2dEZWJ1ZyhcIk5ldyB0ZW1wZXJhdHVyZTogXCIgKyBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcblxuICAgICAgaWYgKGxheW91dEluZm8udGVtcGVyYXR1cmUgPCBvcHRpb25zLm1pblRlbXApIHtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJUZW1wZXJhdHVyZSBkcm9wIGJlbG93IG1pbmltdW0gdGhyZXNob2xkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbG9vcFJldDtcblxuICAgIGRvIHtcbiAgICAgIHZhciBmID0gMDtcblxuICAgICAgd2hpbGUoIGYgPCBvcHRpb25zLnJlZnJlc2ggJiYgaSA8IG9wdGlvbnMubnVtSXRlciApe1xuICAgICAgICB2YXIgbG9vcFJldCA9IG1haW5Mb29wKGkpO1xuICAgICAgICBpZiggIWxvb3BSZXQgKXsgYnJlYWs7IH1cblxuICAgICAgICBmKys7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgaWYoIG9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgICBicm9hZGNhc3QoIGxheW91dEluZm8ubGF5b3V0Tm9kZXMgKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICB9XG5cbiAgICB9IHdoaWxlICggbG9vcFJldCAmJiBpICsgMSA8IG9wdGlvbnMubnVtSXRlciApO1xuXG4gICAgc2VwYXJhdGVDb21wb25lbnRzKCBsYXlvdXRJbmZvLCBvcHRpb25zICk7XG5cbiAgICByZXR1cm4gbGF5b3V0SW5mbztcbiAgfSkudGhlbihmdW5jdGlvbiggbGF5b3V0SW5mb1VwZGF0ZWQgKXtcbiAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzID0gbGF5b3V0SW5mb1VwZGF0ZWQubGF5b3V0Tm9kZXM7IC8vIGdldCB0aGUgcG9zaXRpb25zXG5cbiAgICB0aHJlYWQuc3RvcCgpO1xuICAgIGRvbmUoKTtcbiAgfSk7XG5cbiAgdmFyIGRvbmUgPSBmdW5jdGlvbigpe1xuICAgIHJlZnJlc2goeyBcbiAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgbmV4dDogZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gTGF5b3V0IGhhcyBmaW5pc2hlZFxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuXG4vKipcbiAqIEBicmllZiA6IGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICovXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblxuICBpZiggdGhpcy50aHJlYWQgKXtcbiAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gIH1cblxuICB0aGlzLnRyaWdnZXIoJ2xheW91dHN0b3AnKTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbkNvc2VMYXlvdXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICBpZiggdGhpcy50aHJlYWQgKXtcbiAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgICAgIDogQ3JlYXRlcyBhbiBvYmplY3Qgd2hpY2ggaXMgY29udGFpbnMgYWxsIHRoZSBkYXRhXG4gKiAgICAgICAgICAgICAgdXNlZCBpbiB0aGUgbGF5b3V0IHByb2Nlc3NcbiAqIEBhcmcgY3kgICAgOiBjeXRvc2NhcGUuanMgb2JqZWN0XG4gKiBAcmV0dXJuICAgIDogbGF5b3V0SW5mbyBvYmplY3QgaW5pdGlhbGl6ZWRcbiAqL1xudmFyIGNyZWF0ZUxheW91dEluZm8gPSBmdW5jdGlvbihjeSwgbGF5b3V0LCBvcHRpb25zKSB7XG4gIC8vIFNob3J0Y3V0XG4gIHZhciBlZGdlcyA9IG9wdGlvbnMuZWxlcy5lZGdlcygpO1xuICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcblxuICB2YXIgbGF5b3V0SW5mbyAgID0ge1xuICAgIGlzQ29tcG91bmQgICA6IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSxcbiAgICBsYXlvdXROb2RlcyAgOiBbXSxcbiAgICBpZFRvSW5kZXggICAgOiB7fSxcbiAgICBub2RlU2l6ZSAgICAgOiBub2Rlcy5zaXplKCksXG4gICAgZ3JhcGhTZXQgICAgIDogW10sXG4gICAgaW5kZXhUb0dyYXBoIDogW10sXG4gICAgbGF5b3V0RWRnZXMgIDogW10sXG4gICAgZWRnZVNpemUgICAgIDogZWRnZXMuc2l6ZSgpLFxuICAgIHRlbXBlcmF0dXJlICA6IG9wdGlvbnMuaW5pdGlhbFRlbXAsXG4gICAgY2xpZW50V2lkdGggIDogY3kud2lkdGgoKSxcbiAgICBjbGllbnRIZWlnaHQgOiBjeS53aWR0aCgpLFxuICAgIGJvdW5kaW5nQm94ICA6IG1hdGgubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgICAgICAgICAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICAgICAgICAgICAgICAgICB9IClcbiAgfTtcblxuICB2YXIgY29tcG9uZW50cyA9IG9wdGlvbnMuZWxlcy5jb21wb25lbnRzKCk7XG4gIHZhciBpZDJjbXB0SWQgPSB7fTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFtqXTtcblxuICAgICAgaWQyY21wdElkWyBub2RlLmlkKCkgXSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBub2RlcywgY3JlYXRpbmcgbGF5b3V0IG5vZGVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICB2YXIgbmJiID0gbi5ib3VuZGluZ0JveCgpO1xuXG4gICAgdmFyIHRlbXBOb2RlICAgICAgICA9IHt9O1xuICAgIHRlbXBOb2RlLmlzTG9ja2VkICAgPSBuLmxvY2tlZCgpO1xuICAgIHRlbXBOb2RlLmlkICAgICAgICAgPSBuLmRhdGEoJ2lkJyk7XG4gICAgdGVtcE5vZGUucGFyZW50SWQgICA9IG4uZGF0YSgncGFyZW50Jyk7XG4gICAgdGVtcE5vZGUuY21wdElkICAgICA9IGlkMmNtcHRJZFsgbi5pZCgpIF07XG4gICAgdGVtcE5vZGUuY2hpbGRyZW4gICA9IFtdO1xuICAgIHRlbXBOb2RlLnBvc2l0aW9uWCAgPSBuLnBvc2l0aW9uKCd4Jyk7XG4gICAgdGVtcE5vZGUucG9zaXRpb25ZICA9IG4ucG9zaXRpb24oJ3knKTtcbiAgICB0ZW1wTm9kZS5vZmZzZXRYICAgID0gMDtcbiAgICB0ZW1wTm9kZS5vZmZzZXRZICAgID0gMDtcbiAgICB0ZW1wTm9kZS5oZWlnaHQgICAgID0gbmJiLnc7XG4gICAgdGVtcE5vZGUud2lkdGggICAgICA9IG5iYi5oO1xuICAgIHRlbXBOb2RlLm1heFggICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblggKyB0ZW1wTm9kZS53aWR0aCAgLyAyO1xuICAgIHRlbXBOb2RlLm1pblggICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblggLSB0ZW1wTm9kZS53aWR0aCAgLyAyO1xuICAgIHRlbXBOb2RlLm1heFkgICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblkgKyB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgIHRlbXBOb2RlLm1pblkgICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblkgLSB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgIHRlbXBOb2RlLnBhZExlZnQgICAgPSBwYXJzZUZsb2F0KCBuLnN0eWxlKCdwYWRkaW5nLWxlZnQnKSApO1xuICAgIHRlbXBOb2RlLnBhZFJpZ2h0ICAgPSBwYXJzZUZsb2F0KCBuLnN0eWxlKCdwYWRkaW5nLXJpZ2h0JykgKTtcbiAgICB0ZW1wTm9kZS5wYWRUb3AgICAgID0gcGFyc2VGbG9hdCggbi5zdHlsZSgncGFkZGluZy10b3AnKSApO1xuICAgIHRlbXBOb2RlLnBhZEJvdHRvbSAgPSBwYXJzZUZsb2F0KCBuLnN0eWxlKCdwYWRkaW5nLWJvdHRvbScpICk7XG5cbiAgICAvLyBmb3JjZXNcbiAgICB0ZW1wTm9kZS5ub2RlUmVwdWxzaW9uID0gaXMuZm4oIG9wdGlvbnMubm9kZVJlcHVsc2lvbiApID8gb3B0aW9ucy5ub2RlUmVwdWxzaW9uLmNhbGwoIG4sIG4gKSA6IG9wdGlvbnMubm9kZVJlcHVsc2lvbjtcblxuICAgIC8vIEFkZCBuZXcgbm9kZVxuICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXMucHVzaCh0ZW1wTm9kZSk7XG4gICAgLy8gQWRkIGVudHJ5IHRvIGlkLWluZGV4IG1hcFxuICAgIGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLmlkXSA9IGk7XG4gIH1cblxuICAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG4gIHZhciBxdWV1ZSA9IFtdO1xuICB2YXIgc3RhcnQgPSAwOyAgIC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG4gIHZhciBlbmQgICA9IC0xOyAgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgdmFyIHRlbXBHcmFwaCA9IFtdO1xuXG4gIC8vIFNlY29uZCBwYXNzIHRvIGFkZCBjaGlsZCBpbmZvcm1hdGlvbiBhbmRcbiAgLy8gaW5pdGlhbGl6ZSBxdWV1ZSBmb3IgaGllcmFyY2hpY2FsIHRyYXZlcnNhbFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICB2YXIgcF9pZCA9IG4ucGFyZW50SWQ7XG4gICAgLy8gQ2hlY2sgaWYgbm9kZSBuIGhhcyBhIHBhcmVudCBub2RlXG4gICAgaWYgKG51bGwgIT0gcF9pZCkge1xuICAgIC8vIEFkZCBub2RlIElkIHRvIHBhcmVudCdzIGxpc3Qgb2YgY2hpbGRyZW5cbiAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BfaWRdXS5jaGlsZHJlbi5wdXNoKG4uaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgLy8gSWYgYSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgdGhlbiBpdCdzIGluIHRoZSByb290IGdyYXBoXG4gICAgcXVldWVbKytlbmRdID0gbi5pZDtcbiAgICB0ZW1wR3JhcGgucHVzaChuLmlkKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcm9vdCBncmFwaCB0byBncmFwaFNldFxuICBsYXlvdXRJbmZvLmdyYXBoU2V0LnB1c2godGVtcEdyYXBoKTtcblxuICAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLFxuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgIHZhciBub2RlX2lkICA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgIHZhciBub2RlX2l4ICA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVfaWRdO1xuICAgIHZhciBub2RlICAgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZV9peF07XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgIC8vIEFkZCBjaGlsZHJlbiBub2RlcyBhcyBhIG5ldyBncmFwaCB0byBncmFwaCBzZXRcbiAgICBsYXlvdXRJbmZvLmdyYXBoU2V0LnB1c2goY2hpbGRyZW4pO1xuICAgIC8vIEFkZCBjaGlsZHJlbiB0byBxdWUgcXVldWUgdG8gYmUgdmlzaXRlZFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgaW5kZXhUb0dyYXBoIG1hcFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JhcGgubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgaW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV07XG4gICAgbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbaW5kZXhdID0gaTtcbiAgICB9XG4gIH1cblxuICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzLCBjcmVhdGluZyBMYXlvdXQgRWRnZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKyspIHtcbiAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgIHZhciB0ZW1wRWRnZSA9IHt9O1xuICAgIHRlbXBFZGdlLmlkICAgICAgID0gZS5kYXRhKCdpZCcpO1xuICAgIHRlbXBFZGdlLnNvdXJjZUlkID0gZS5kYXRhKCdzb3VyY2UnKTtcbiAgICB0ZW1wRWRnZS50YXJnZXRJZCA9IGUuZGF0YSgndGFyZ2V0Jyk7XG5cbiAgICAvLyBDb21wdXRlIGlkZWFsIGxlbmd0aFxuICAgIHZhciBpZGVhbExlbmd0aCA9IGlzLmZuKCBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCApID8gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGguY2FsbCggZSwgZSApIDogb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7XG4gICAgdmFyIGVsYXN0aWNpdHkgPSBpcy5mbiggb3B0aW9ucy5lZGdlRWxhc3RpY2l0eSApID8gb3B0aW9ucy5lZGdlRWxhc3RpY2l0eS5jYWxsKCBlLCBlICkgOiBvcHRpb25zLmVkZ2VFbGFzdGljaXR5O1xuXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBpbnRlciBncmFwaCBlZGdlXG4gICAgdmFyIHNvdXJjZUl4ICAgID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2Uuc291cmNlSWRdO1xuICAgIHZhciB0YXJnZXRJeCAgICA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnRhcmdldElkXTtcbiAgICB2YXIgc291cmNlR3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtzb3VyY2VJeF07XG4gICAgdmFyIHRhcmdldEdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbdGFyZ2V0SXhdO1xuXG4gICAgaWYgKHNvdXJjZUdyYXBoICE9IHRhcmdldEdyYXBoKSB7XG4gICAgICAvLyBGaW5kIGxvd2VzdCBjb21tb24gZ3JhcGggYW5jZXN0b3JcbiAgICAgIHZhciBsY2EgPSBmaW5kTENBKHRlbXBFZGdlLnNvdXJjZUlkLCB0ZW1wRWRnZS50YXJnZXRJZCwgbGF5b3V0SW5mbyk7XG5cbiAgICAgIC8vIENvbXB1dGUgc3VtIG9mIG5vZGUgZGVwdGhzLCByZWxhdGl2ZSB0byBsY2EgZ3JhcGhcbiAgICAgIHZhciBsY2FHcmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbbGNhXTtcbiAgICAgIHZhciBkZXB0aCAgICA9IDA7XG5cbiAgICAgIC8vIFNvdXJjZSBkZXB0aFxuICAgICAgdmFyIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tzb3VyY2VJeF07XG4gICAgICB3aGlsZSAoIC0xID09PSBsY2FHcmFwaC5pbmRleE9mKHRlbXBOb2RlLmlkKSApIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhcmdldCBkZXB0aFxuICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTtcbiAgICAgIHdoaWxlICggLTEgPT09IGxjYUdyYXBoLmluZGV4T2YodGVtcE5vZGUuaWQpICkge1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cblxuICAgICAgLy8gbG9nRGVidWcoJ0xDQSBvZiBub2RlcyAnICsgdGVtcEVkZ2Uuc291cmNlSWQgKyAnIGFuZCAnICsgdGVtcEVkZ2UudGFyZ2V0SWQgK1xuICAgICAgICAvLyAgXCIuIEluZGV4OiBcIiArIGxjYSArIFwiIENvbnRlbnRzOiBcIiArIGxjYUdyYXBoLnRvU3RyaW5nKCkgK1xuICAgICAgICAvLyAgXCIuIERlcHRoOiBcIiArIGRlcHRoKTtcblxuICAgICAgLy8gVXBkYXRlIGlkZWFsTGVuZ3RoXG4gICAgICBpZGVhbExlbmd0aCAqPSBkZXB0aCAqIG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgICB9XG5cbiAgICB0ZW1wRWRnZS5pZGVhbExlbmd0aCA9IGlkZWFsTGVuZ3RoO1xuICAgIHRlbXBFZGdlLmVsYXN0aWNpdHkgPSBlbGFzdGljaXR5O1xuXG4gICAgbGF5b3V0SW5mby5sYXlvdXRFZGdlcy5wdXNoKHRlbXBFZGdlKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHJldHVybiBsYXlvdXRJbmZvIG9iamVjdFxuICByZXR1cm4gbGF5b3V0SW5mbztcbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgOiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbG93ZXN0IGNvbW1vblxuICogICAgICAgICAgZ3JhcGggYW5jZXN0b3IgYmV0d2VlbiAyIG5vZGVzIGluIHRoZSBzdWJ0cmVlXG4gKiAgICAgICAgICAoZnJvbSB0aGUgZ3JhcGggaGllcmFyY2h5IGluZHVjZWQgdHJlZSkgd2hvc2VcbiAqICAgICAgICAgIHJvb3QgaXMgZ3JhcGhJeFxuICpcbiAqIEBhcmcgbm9kZTE6IG5vZGUxJ3MgSURcbiAqIEBhcmcgbm9kZTI6IG5vZGUyJ3MgSURcbiAqIEBhcmcgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyBvYmplY3RcbiAqXG4gKi9cbnZhciBmaW5kTENBID0gZnVuY3Rpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvKSB7XG4gIC8vIEZpbmQgdGhlaXIgY29tbW9uIGFuY2VzdGVyLCBzdGFydGluZyBmcm9tIHRoZSByb290IGdyYXBoXG4gIHZhciByZXMgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIDAsIGxheW91dEluZm8pO1xuICBpZiAoMiA+IHJlcy5jb3VudCkge1xuICAgIC8vIElmIGF1eCBmdW5jdGlvbiBjb3VsZG4ndCBmaW5kIHRoZSBjb21tb24gYW5jZXN0ZXIsXG4gICAgLy8gdGhlbiBpdCBpcyB0aGUgcm9vdCBncmFwaFxuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXMuZ3JhcGg7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBBdXhpbGlhcnkgZnVuY3Rpb24gdXNlZCBmb3IgTENBIGNvbXB1dGF0aW9uXG4gKlxuICogQGFyZyBub2RlMSAgICAgIDogbm9kZTEncyBJRFxuICogQGFyZyBub2RlMiAgICAgIDogbm9kZTIncyBJRFxuICogQGFyZyBncmFwaEl4ICAgIDogc3ViZ3JhcGggaW5kZXhcbiAqIEBhcmcgbGF5b3V0SW5mbyA6IGxheW91dEluZm8gb2JqZWN0XG4gKlxuICogQHJldHVybiAgICAgICAgIDogb2JqZWN0IG9mIHRoZSBmb3JtIHtjb3VudDogWCwgZ3JhcGg6IFl9LCB3aGVyZTpcbiAqICAgICAgICAgICAgICAgICAgIFggaXMgdGhlIG51bWJlciBvZiBhbmNlc3RlcnMgKG1heDogMikgZm91bmQgaW5cbiAqICAgICAgICAgICAgICAgICAgIGdyYXBoSXggKGFuZCBpdCdzIHN1YmdyYXBocyksXG4gKiAgICAgICAgICAgICAgICAgICBZIGlzIHRoZSBncmFwaCBpbmRleCBvZiB0aGUgbG93ZXN0IGdyYXBoIGNvbnRhaW5pbmdcbiAqICAgICAgICAgICAgICAgICAgIGFsbCBYIG5vZGVzXG4gKi9cbnZhciBmaW5kTENBX2F1eCA9IGZ1bmN0aW9uKG5vZGUxLCBub2RlMiwgZ3JhcGhJeCwgbGF5b3V0SW5mbykge1xuICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2dyYXBoSXhdO1xuICAvLyBJZiBib3RoIG5vZGVzIGJlbG9uZ3MgdG8gZ3JhcGhJeFxuICBpZiAoLTEgPCBncmFwaC5pbmRleE9mKG5vZGUxKSAmJiAtMSA8IGdyYXBoLmluZGV4T2Yobm9kZTIpKSB7XG4gICAgcmV0dXJuIHtjb3VudDoyLCBncmFwaDpncmFwaEl4fTtcbiAgfVxuXG4gIC8vIE1ha2UgcmVjdXJzaXZlIGNhbGxzIGZvciBhbGwgc3ViZ3JhcGhzXG4gIHZhciBjID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlSWQgICA9IGdyYXBoW2ldO1xuICAgIHZhciBub2RlSXggICA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgdmFyIGNoaWxkcmVuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSXhdLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBza2lwIGl0XG4gICAgaWYgKDAgPT09IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZEdyYXBoSXggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlblswXV1dO1xuICAgIHZhciByZXN1bHQgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIGNoaWxkR3JhcGhJeCwgbGF5b3V0SW5mbyk7XG4gICAgaWYgKDAgPT09IHJlc3VsdC5jb3VudCkge1xuICAgIC8vIE5laXRoZXIgbm9kZTEgbm9yIG5vZGUyIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKDEgPT09IHJlc3VsdC5jb3VudCkge1xuICAgIC8vIE9uZSBvZiAobm9kZTEsIG5vZGUyKSBpcyBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICBjKys7XG4gICAgaWYgKDIgPT09IGMpIHtcbiAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgZm91bmQgYm90aCBub2Rlcywgbm8gbmVlZCB0byBrZWVwIHNlYXJjaGluZ1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIH0gZWxzZSB7XG4gICAgLy8gQm90aCBub2RlcyBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge2NvdW50OmMsIGdyYXBoOmdyYXBoSXh9O1xufTtcblxuXG4vKipcbiAqIEBicmllZjogcHJpbnRzTGF5b3V0SW5mbyBpbnRvIGpzIGNvbnNvbGVcbiAqICAgICAgICAgT25seSB1c2VkIGZvciBkZWJidWdpbmdcbiAqL1xudmFyIHByaW50TGF5b3V0SW5mbyA9IGZ1bmN0aW9uKGxheW91dEluZm8pIHtcbiAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuXG4gIGlmICghREVCVUcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS5kZWJ1ZyhcImxheW91dE5vZGVzOlwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgdmFyIHMgPVxuICAgIFwiXFxuaW5kZXg6IFwiICAgICArIGkgK1xuICAgIFwiXFxuSWQ6IFwiICAgICAgICArIG4uaWQgK1xuICAgIFwiXFxuQ2hpbGRyZW46IFwiICArIG4uY2hpbGRyZW4udG9TdHJpbmcoKSArXG4gICAgXCJcXG5wYXJlbnRJZDogXCIgICsgbi5wYXJlbnRJZCAgK1xuICAgIFwiXFxucG9zaXRpb25YOiBcIiArIG4ucG9zaXRpb25YICtcbiAgICBcIlxcbnBvc2l0aW9uWTogXCIgKyBuLnBvc2l0aW9uWSArXG4gICAgXCJcXG5PZmZzZXRYOiBcIiArIG4ub2Zmc2V0WCArXG4gICAgXCJcXG5PZmZzZXRZOiBcIiArIG4ub2Zmc2V0WSArXG4gICAgXCJcXG5wYWRMZWZ0OiBcIiArIG4ucGFkTGVmdCArXG4gICAgXCJcXG5wYWRSaWdodDogXCIgKyBuLnBhZFJpZ2h0ICtcbiAgICBcIlxcbnBhZFRvcDogXCIgKyBuLnBhZFRvcCArXG4gICAgXCJcXG5wYWRCb3R0b206IFwiICsgbi5wYWRCb3R0b207XG5cbiAgICBjb25zb2xlLmRlYnVnKHMpO1xuICB9XG5cbiAgY29uc29sZS5kZWJ1ZygnaWRUb0luZGV4Jyk7XG4gIGZvciAodmFyIGkgaW4gbGF5b3V0SW5mby5pZFRvSW5kZXgpIHtcbiAgICBjb25zb2xlLmRlYnVnKFwiSWQ6IFwiICsgaSArIFwiXFxuSW5kZXg6IFwiICsgbGF5b3V0SW5mby5pZFRvSW5kZXhbaV0pO1xuICB9XG5cbiAgY29uc29sZS5kZWJ1ZygnR3JhcGggU2V0Jyk7XG4gIHZhciBzZXQgPSBsYXlvdXRJbmZvLmdyYXBoU2V0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKyspIHtcbiAgICBjb25zb2xlLmRlYnVnKFwiU2V0IDogXCIgKyBpICsgXCI6IFwiICsgc2V0W2ldLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgdmFyIHMgPSAnSW5kZXhUb0dyYXBoJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaC5sZW5ndGg7IGkgKyspIHtcbiAgICBzICs9IFwiXFxuSW5kZXggOiBcIiArIGkgKyBcIiBHcmFwaDogXCIrIGxheW91dEluZm8uaW5kZXhUb0dyYXBoW2ldO1xuICB9XG4gIGNvbnNvbGUuZGVidWcocyk7XG5cbiAgcyA9ICdMYXlvdXQgRWRnZXMnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubGF5b3V0RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZSA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbaV07XG4gICAgcyArPSBcIlxcbkVkZ2UgSW5kZXg6IFwiICsgaSArIFwiIElEOiBcIiArIGUuaWQgK1xuICAgIFwiIFNvdWNlSUQ6IFwiICsgZS5zb3VyY2VJZCArIFwiIFRhcmdldElkOiBcIiArIGUudGFyZ2V0SWQgK1xuICAgIFwiIElkZWFsIExlbmd0aDogXCIgKyBlLmlkZWFsTGVuZ3RoO1xuICB9XG4gIGNvbnNvbGUuZGVidWcocyk7XG5cbiAgcyA9ICBcIm5vZGVTaXplOiBcIiArIGxheW91dEluZm8ubm9kZVNpemU7XG4gIHMgKz0gXCJcXG5lZGdlU2l6ZTogXCIgKyBsYXlvdXRJbmZvLmVkZ2VTaXplO1xuICBzICs9IFwiXFxudGVtcGVyYXR1cmU6IFwiICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZTtcbiAgY29uc29sZS5kZWJ1ZyhzKTtcblxuICByZXR1cm47XG4gIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG59O1xuXG5cbi8qKlxuICogQGJyaWVmIDogUmFuZG9taXplcyB0aGUgcG9zaXRpb24gb2YgYWxsIG5vZGVzXG4gKi9cbnZhciByYW5kb21pemVQb3NpdGlvbnMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSkge1xuICB2YXIgd2lkdGggICAgID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCAgICA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuXG4gICAgLy8gTm8gbmVlZCB0byByYW5kb21pemUgY29tcG91bmQgbm9kZXMgb3IgbG9ja2VkIG5vZGVzXG4gICAgaWYgKCAwID09PSBuLmNoaWxkcmVuLmxlbmd0aCAmJiAhbi5pc0xvY2tlZCApIHtcbiAgICAgIG4ucG9zaXRpb25YID0gTWF0aC5yYW5kb20oKSAqIHdpZHRoO1xuICAgICAgbi5wb3NpdGlvblkgPSBNYXRoLnJhbmRvbSgpICogaGVpZ2h0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IFVwZGF0ZXMgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBpbiB0aGUgbmV0d29ya1xuICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3RcbiAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gKi9cbnZhciByZWZyZXNoUG9zaXRpb25zID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHtcbiAgLy8gdmFyIHMgPSAnUmVmcmVzaGluZyBwb3NpdGlvbnMnO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuICB2YXIgbGF5b3V0ID0gb3B0aW9ucy5sYXlvdXQ7XG4gIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICB2YXIgYmIgPSBsYXlvdXRJbmZvLmJvdW5kaW5nQm94O1xuICB2YXIgY29zZUJCID0geyB4MTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkxOiBJbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9O1xuXG4gIGlmKCBvcHRpb25zLmJvdW5kaW5nQm94ICl7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiggbm9kZSApe1xuICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlLmRhdGEoJ2lkJyldXTtcblxuICAgICAgY29zZUJCLngxID0gTWF0aC5taW4oIGNvc2VCQi54MSwgbG5vZGUucG9zaXRpb25YICk7XG4gICAgICBjb3NlQkIueDIgPSBNYXRoLm1heCggY29zZUJCLngyLCBsbm9kZS5wb3NpdGlvblggKTtcblxuICAgICAgY29zZUJCLnkxID0gTWF0aC5taW4oIGNvc2VCQi55MSwgbG5vZGUucG9zaXRpb25ZICk7XG4gICAgICBjb3NlQkIueTIgPSBNYXRoLm1heCggY29zZUJCLnkyLCBsbm9kZS5wb3NpdGlvblkgKTtcbiAgICB9KTtcblxuICAgIGNvc2VCQi53ID0gY29zZUJCLngyIC0gY29zZUJCLngxO1xuICAgIGNvc2VCQi5oID0gY29zZUJCLnkyIC0gY29zZUJCLnkxO1xuICB9XG5cbiAgbm9kZXMucG9zaXRpb25zKGZ1bmN0aW9uKGksIGVsZSkge1xuICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZWxlLmRhdGEoJ2lkJyldXTtcbiAgICAvLyBzID0gXCJOb2RlOiBcIiArIGxub2RlLmlkICsgXCIuIFJlZnJlc2hlZCBwb3NpdGlvbjogKFwiICtcbiAgICAvLyBsbm9kZS5wb3NpdGlvblggKyBcIiwgXCIgKyBsbm9kZS5wb3NpdGlvblkgKyBcIikuXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCApeyAvLyB0aGVuIGFkZCBleHRyYSBib3VuZGluZyBib3ggY29uc3RyYWludFxuICAgICAgdmFyIHBjdFggPSAobG5vZGUucG9zaXRpb25YIC0gY29zZUJCLngxKSAvIGNvc2VCQi53O1xuICAgICAgdmFyIHBjdFkgPSAobG5vZGUucG9zaXRpb25ZIC0gY29zZUJCLnkxKSAvIGNvc2VCQi5oO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSArIHBjdFggKiBiYi53LFxuICAgICAgICB5OiBiYi55MSArIHBjdFkgKiBiYi5oXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsbm9kZS5wb3NpdGlvblgsXG4gICAgICAgIHk6IGxub2RlLnBvc2l0aW9uWVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRyaWdnZXIgbGF5b3V0UmVhZHkgb25seSBvbiBmaXJzdCBjYWxsXG4gIGlmICh0cnVlICE9PSBsYXlvdXRJbmZvLnJlYWR5KSB7XG4gICAgLy8gcyA9ICdUcmlnZ2VyaW5nIGxheW91dHJlYWR5JztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICBsYXlvdXRJbmZvLnJlYWR5ID0gdHJ1ZTtcbiAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiB0aGlzIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiA6IExvZ3MgYSBkZWJ1ZyBtZXNzYWdlIGluIEpTIGNvbnNvbGUsIGlmIERFQlVHIGlzIE9OXG4gKi9cbi8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKHRleHQpIHtcbi8vICAgaWYgKERFQlVHKSB7XG4vLyAgICAgY29uc29sZS5kZWJ1Zyh0ZXh0KTtcbi8vICAgfVxuLy8gfTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb3NlTGF5b3V0O1xuXG59LHtcIi4uLy4uL2lzXCI6NzcsXCIuLi8uLi9tYXRoXCI6NzksXCIuLi8uLi90aHJlYWRcIjo5MixcIi4uLy4uL3V0aWxcIjo5NH1dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi8uLi91dGlsJyk7XG52YXIgbWF0aCA9IF9kZXJlcV8oJy4uLy4uL21hdGgnKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgdXNlZCBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBhdm9pZE92ZXJsYXBQYWRkaW5nOiAxMCwgLy8gZXh0cmEgc3BhY2luZyBhcm91bmQgbm9kZXMgd2hlbiBhdm9pZE92ZXJsYXA6IHRydWVcbiAgY29uZGVuc2U6IGZhbHNlLCAvLyB1c2VzIGFsbCBhdmFpbGFibGUgc3BhY2Ugb24gZmFsc2UsIHVzZXMgbWluaW1hbCBzcGFjZSBvbiB0cnVlXG4gIHJvd3M6IHVuZGVmaW5lZCwgLy8gZm9yY2UgbnVtIG9mIHJvd3MgaW4gdGhlIGdyaWRcbiAgY29sczogdW5kZWZpbmVkLCAvLyBmb3JjZSBudW0gb2YgY29sdW1ucyBpbiB0aGUgZ3JpZFxuICBwb3NpdGlvbjogZnVuY3Rpb24oIG5vZGUgKXt9LCAvLyByZXR1cm5zIHsgcm93LCBjb2wgfSBmb3IgZWxlbWVudFxuICBzb3J0OiB1bmRlZmluZWQsIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLCAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3Bcbn07XG5cbmZ1bmN0aW9uIEdyaWRMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblxuR3JpZExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG5cbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuXG4gIGlmKCBvcHRpb25zLnNvcnQgKXtcbiAgICBub2RlcyA9IG5vZGVzLnNvcnQoIG9wdGlvbnMuc29ydCApO1xuICB9XG5cbiAgdmFyIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSApO1xuXG4gIGlmKCBiYi5oID09PSAwIHx8IGJiLncgPT09IDApe1xuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHsgeDogYmIueDEsIHk6IGJiLnkxIH07XG4gICAgfSk7XG5cbiAgfSBlbHNlIHtcblxuICAgIC8vIHdpZHRoL2hlaWdodCAqIHNwbGl0c14yID0gY2VsbHMgd2hlcmUgc3BsaXRzIGlzIG51bWJlciBvZiB0aW1lcyB0byBzcGxpdCB3aWR0aFxuICAgIHZhciBjZWxscyA9IG5vZGVzLnNpemUoKTtcbiAgICB2YXIgc3BsaXRzID0gTWF0aC5zcXJ0KCBjZWxscyAqIGJiLmgvYmIudyApO1xuICAgIHZhciByb3dzID0gTWF0aC5yb3VuZCggc3BsaXRzICk7XG4gICAgdmFyIGNvbHMgPSBNYXRoLnJvdW5kKCBiYi53L2JiLmggKiBzcGxpdHMgKTtcblxuICAgIHZhciBzbWFsbCA9IGZ1bmN0aW9uKHZhbCl7XG4gICAgICBpZiggdmFsID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgICBpZiggbWluID09IHJvd3MgKXtcbiAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxhcmdlID0gZnVuY3Rpb24odmFsKXtcbiAgICAgIGlmKCB2YWwgPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgocm93cywgY29scyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgocm93cywgY29scyk7XG4gICAgICAgIGlmKCBtYXggPT0gcm93cyApe1xuICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb1Jvd3MgPSBvcHRpb25zLnJvd3M7XG4gICAgdmFyIG9Db2xzID0gb3B0aW9ucy5jb2xzICE9IG51bGwgPyBvcHRpb25zLmNvbHMgOiBvcHRpb25zLmNvbHVtbnM7XG5cbiAgICAvLyBpZiByb3dzIG9yIGNvbHVtbnMgd2VyZSBzZXQgaW4gb3B0aW9ucywgdXNlIHRob3NlIHZhbHVlc1xuICAgIGlmKCBvUm93cyAhPSBudWxsICYmIG9Db2xzICE9IG51bGwgKXtcbiAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgIGNvbHMgPSBvQ29scztcbiAgICB9IGVsc2UgaWYoIG9Sb3dzICE9IG51bGwgJiYgb0NvbHMgPT0gbnVsbCApe1xuICAgICAgcm93cyA9IG9Sb3dzO1xuICAgICAgY29scyA9IE1hdGguY2VpbCggY2VsbHMgLyByb3dzICk7XG4gICAgfSBlbHNlIGlmKCBvUm93cyA9PSBudWxsICYmIG9Db2xzICE9IG51bGwgKXtcbiAgICAgIGNvbHMgPSBvQ29scztcbiAgICAgIHJvd3MgPSBNYXRoLmNlaWwoIGNlbGxzIC8gY29scyApO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIGF1dG9tYXRpYyB2YWx1ZXMgYW5kIGFkanVzdCBhY2NvcmRpbmdseVxuXG4gICAgLy8gaWYgcm91bmRpbmcgd2FzIHVwLCBzZWUgaWYgd2UgY2FuIHJlZHVjZSByb3dzIG9yIGNvbHVtbnNcbiAgICBlbHNlIGlmKCBjb2xzICogcm93cyA+IGNlbGxzICl7XG4gICAgICB2YXIgc20gPSBzbWFsbCgpO1xuICAgICAgdmFyIGxnID0gbGFyZ2UoKTtcblxuICAgICAgLy8gcmVkdWNpbmcgdGhlIHNtYWxsIHNpZGUgdGFrZXMgYXdheSB0aGUgbW9zdCBjZWxscywgc28gdHJ5IGl0IGZpcnN0XG4gICAgICBpZiggKHNtIC0gMSkgKiBsZyA+PSBjZWxscyApe1xuICAgICAgICBzbWFsbChzbSAtIDEpO1xuICAgICAgfSBlbHNlIGlmKCAobGcgLSAxKSAqIHNtID49IGNlbGxzICl7XG4gICAgICAgIGxhcmdlKGxnIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gaWYgcm91bmRpbmcgd2FzIHRvbyBsb3csIGFkZCByb3dzIG9yIGNvbHVtbnNcbiAgICAgIHdoaWxlKCBjb2xzICogcm93cyA8IGNlbGxzICl7XG4gICAgICAgIHZhciBzbSA9IHNtYWxsKCk7XG4gICAgICAgIHZhciBsZyA9IGxhcmdlKCk7XG5cbiAgICAgICAgLy8gdHJ5IHRvIGFkZCB0byBsYXJnZXIgc2lkZSBmaXJzdCAoYWRkcyBsZXNzIGluIG11bHRpcGxpY2F0aW9uKVxuICAgICAgICBpZiggKGxnICsgMSkgKiBzbSA+PSBjZWxscyApe1xuICAgICAgICAgIGxhcmdlKGxnICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc21hbGwoc20gKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjZWxsV2lkdGggPSBiYi53IC8gY29scztcbiAgICB2YXIgY2VsbEhlaWdodCA9IGJiLmggLyByb3dzO1xuXG4gICAgaWYoIG9wdGlvbnMuY29uZGVuc2UgKXtcbiAgICAgIGNlbGxXaWR0aCA9IDA7XG4gICAgICBjZWxsSGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICBpZiggb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgaWYoIHBvcy54ID09IG51bGwgfHwgcG9zLnkgPT0gbnVsbCApeyAvLyBmb3IgYmJcbiAgICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgICAgcG9zLnkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5iYiA9IG5vZGUuYm91bmRpbmdCb3goKTtcbiAgICAgICAgdmFyIHAgPSBvcHRpb25zLmF2b2lkT3ZlcmxhcFBhZGRpbmc7XG5cbiAgICAgICAgdmFyIHcgPSBuYmIudyArIHA7XG4gICAgICAgIHZhciBoID0gbmJiLmggKyBwO1xuXG4gICAgICAgIGNlbGxXaWR0aCA9IE1hdGgubWF4KCBjZWxsV2lkdGgsIHcgKTtcbiAgICAgICAgY2VsbEhlaWdodCA9IE1hdGgubWF4KCBjZWxsSGVpZ2h0LCBoICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNlbGxVc2VkID0ge307IC8vIGUuZy4gJ2MtMC0yJyA9PiB0cnVlXG5cbiAgICB2YXIgdXNlZCA9IGZ1bmN0aW9uKHJvdywgY29sKXtcbiAgICAgIHJldHVybiBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA/IHRydWUgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHVzZSA9IGZ1bmN0aW9uKHJvdywgY29sKXtcbiAgICAgIGNlbGxVc2VkWydjLScgKyByb3cgKyAnLScgKyBjb2xdID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gdG8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGNlbGwgcG9zaXRpb25cbiAgICB2YXIgcm93ID0gMDtcbiAgICB2YXIgY29sID0gMDtcbiAgICB2YXIgbW92ZVRvTmV4dENlbGwgPSBmdW5jdGlvbigpe1xuICAgICAgY29sKys7XG4gICAgICBpZiggY29sID49IGNvbHMgKXtcbiAgICAgICAgY29sID0gMDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGdldCBhIGNhY2hlIG9mIGFsbCB0aGUgbWFudWFsIHBvc2l0aW9uc1xuICAgIHZhciBpZDJtYW5Qb3MgPSB7fTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIHJjUG9zID0gb3B0aW9ucy5wb3NpdGlvbiggbm9kZSApO1xuXG4gICAgICBpZiggcmNQb3MgJiYgKHJjUG9zLnJvdyAhPT0gdW5kZWZpbmVkIHx8IHJjUG9zLmNvbCAhPT0gdW5kZWZpbmVkKSApeyAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgcm93IG9yIGNvbCBkZWYnZFxuICAgICAgICB2YXIgcG9zID0ge1xuICAgICAgICAgIHJvdzogcmNQb3Mucm93LFxuICAgICAgICAgIGNvbDogcmNQb3MuY29sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIHBvcy5jb2wgPT09IHVuZGVmaW5lZCApeyAvLyBmaW5kIHVudXNlZCBjb2xcbiAgICAgICAgICBwb3MuY29sID0gMDtcblxuICAgICAgICAgIHdoaWxlKCB1c2VkKHBvcy5yb3csIHBvcy5jb2wpICl7XG4gICAgICAgICAgICBwb3MuY29sKys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIHBvcy5yb3cgPT09IHVuZGVmaW5lZCApeyAvLyBmaW5kIHVudXNlZCByb3dcbiAgICAgICAgICBwb3Mucm93ID0gMDtcblxuICAgICAgICAgIHdoaWxlKCB1c2VkKHBvcy5yb3csIHBvcy5jb2wpICl7XG4gICAgICAgICAgICBwb3Mucm93Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWQybWFuUG9zWyBub2RlLmlkKCkgXSA9IHBvcztcbiAgICAgICAgdXNlKCBwb3Mucm93LCBwb3MuY29sICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uKGksIGVsZW1lbnQpe1xuICAgICAgdmFyIHgsIHk7XG5cbiAgICAgIGlmKCBlbGVtZW50LmxvY2tlZCgpIHx8IGVsZW1lbnQuaXNGdWxsQXV0b1BhcmVudCgpICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gc2VlIGlmIHdlIGhhdmUgYSBtYW51YWwgcG9zaXRpb24gc2V0XG4gICAgICB2YXIgcmNQb3MgPSBpZDJtYW5Qb3NbIGVsZW1lbnQuaWQoKSBdO1xuICAgICAgaWYoIHJjUG9zICl7XG4gICAgICAgIHggPSByY1Bvcy5jb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGgvMiArIGJiLngxO1xuICAgICAgICB5ID0gcmNQb3Mucm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQvMiArIGJiLnkxO1xuXG4gICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2Ugc2V0IGF1dG9tYXRpY2FsbHlcblxuICAgICAgICB3aGlsZSggdXNlZChyb3csIGNvbCkgKXtcbiAgICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9IGNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aC8yICsgYmIueDE7XG4gICAgICAgIHkgPSByb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodC8yICsgYmIueTE7XG4gICAgICAgIHVzZSggcm93LCBjb2wgKTtcblxuICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG5cbiAgICB9O1xuXG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBnZXRQb3MgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWRMYXlvdXQ7XG5cbn0se1wiLi4vLi4vbWF0aFwiOjc5LFwiLi4vLi4vdXRpbFwiOjk0fV0sNTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgeyBuYW1lOiAnYnJlYWR0aGZpcnN0JywgaW1wbDogX2RlcmVxXygnLi9icmVhZHRoZmlyc3QnKSB9LFxuICB7IG5hbWU6ICdjaXJjbGUnLCBpbXBsOiBfZGVyZXFfKCcuL2NpcmNsZScpIH0sXG4gIHsgbmFtZTogJ2NvbmNlbnRyaWMnLGltcGw6IF9kZXJlcV8oJy4vY29uY2VudHJpYycpIH0sXG4gIHsgbmFtZTogJ2Nvc2UnLCBpbXBsOiBfZGVyZXFfKCcuL2Nvc2UnKSB9LFxuICB7IG5hbWU6ICdncmlkJywgaW1wbDogX2RlcmVxXygnLi9ncmlkJykgfSxcbiAgeyBuYW1lOiAnbnVsbCcsIGltcGw6IF9kZXJlcV8oJy4vbnVsbCcpIH0sXG4gIHsgbmFtZTogJ3ByZXNldCcsIGltcGw6IF9kZXJlcV8oJy4vcHJlc2V0JykgfSxcbiAgeyBuYW1lOiAncmFuZG9tJywgaW1wbDogX2RlcmVxXygnLi9yYW5kb20nKSB9XG5dO1xuXG59LHtcIi4vYnJlYWR0aGZpcnN0XCI6NDUsXCIuL2NpcmNsZVwiOjQ2LFwiLi9jb25jZW50cmljXCI6NDcsXCIuL2Nvc2VcIjo0OCxcIi4vZ3JpZFwiOjQ5LFwiLi9udWxsXCI6NTEsXCIuL3ByZXNldFwiOjUyLFwiLi9yYW5kb21cIjo1M31dLDUxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi8uLi91dGlsJyk7XG5cbi8vIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbnZhciBkZWZhdWx0cyA9IHtcbiAgcmVhZHk6IGZ1bmN0aW9uKCl7fSwgLy8gb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogZnVuY3Rpb24oKXt9IC8vIG9uIGxheW91dHN0b3Bcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG4vLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbmZ1bmN0aW9uIE51bGxMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblxuLy8gcnVucyB0aGUgbGF5b3V0XG5OdWxsTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7IC8vIGVsZW1lbnRzIHRvIGNvbnNpZGVyIGluIHRoZSBsYXlvdXRcbiAgdmFyIGxheW91dCA9IHRoaXM7XG5cbiAgLy8gY3kgaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZWQgZm9yIHVzIGluIHRoZSBjb25zdHJ1Y3RvclxuICB2YXIgY3kgPSBvcHRpb25zLmN5OyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICBsYXlvdXQudHJpZ2dlcignbGF5b3V0c3RhcnQnKTtcblxuICAvLyBwdXRzIGFsbCBub2RlcyBhdCAoMCwgMClcbiAgZWxlcy5ub2RlcygpLnBvc2l0aW9ucyhmdW5jdGlvbigpe1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH0pO1xuXG4gIC8vIHRyaWdnZXIgbGF5b3V0cmVhZHkgd2hlbiBlYWNoIG5vZGUgaGFzIGhhZCBpdHMgcG9zaXRpb24gc2V0IGF0IGxlYXN0IG9uY2VcbiAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgbGF5b3V0LnRyaWdnZXIoJ2xheW91dHJlYWR5Jyk7XG5cbiAgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcbiAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gIGxheW91dC50cmlnZ2VyKCdsYXlvdXRzdG9wJyk7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbk51bGxMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTnVsbExheW91dDtcblxufSx7XCIuLi8uLi91dGlsXCI6OTR9XSw1MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gX2RlcmVxXygnLi4vLi4vdXRpbCcpO1xudmFyIGlzID0gX2RlcmVxXygnLi4vLi4vaXMnKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBwb3NpdGlvbnM6IHVuZGVmaW5lZCwgLy8gbWFwIG9mIChub2RlIGlkKSA9PiAocG9zaXRpb24gb2JqKTsgb3IgZnVuY3Rpb24obm9kZSl7IHJldHVybiBzb21Qb3M7IH1cbiAgem9vbTogdW5kZWZpbmVkLCAvLyB0aGUgem9vbSBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gIHBhbjogdW5kZWZpbmVkLCAvLyB0aGUgcGFuIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyBvbiBmaXRcbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxufTtcblxuZnVuY3Rpb24gUHJlc2V0TGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG59XG5cblByZXNldExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuXG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgdmFyIHBvc0lzRm4gPSBpcy5mbiggb3B0aW9ucy5wb3NpdGlvbnMgKTtcblxuICBmdW5jdGlvbiBnZXRQb3NpdGlvbihub2RlKXtcbiAgICBpZiggb3B0aW9ucy5wb3NpdGlvbnMgPT0gbnVsbCApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYoIHBvc0lzRm4gKXtcbiAgICAgIHJldHVybiBvcHRpb25zLnBvc2l0aW9ucy5hcHBseSggbm9kZSwgWyBub2RlIF0gKTtcbiAgICB9XG5cbiAgICB2YXIgcG9zID0gb3B0aW9ucy5wb3NpdGlvbnNbbm9kZS5fcHJpdmF0ZS5kYXRhLmlkXTtcblxuICAgIGlmKCBwb3MgPT0gbnVsbCApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcztcbiAgfVxuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbihpLCBub2RlKXtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihub2RlKTtcblxuICAgIGlmKCBub2RlLmxvY2tlZCgpIHx8IHBvc2l0aW9uID09IG51bGwgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcmVzZXRMYXlvdXQ7XG5cbn0se1wiLi4vLi4vaXNcIjo3NyxcIi4uLy4uL3V0aWxcIjo5NH1dLDUzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi8uLi91dGlsJyk7XG52YXIgbWF0aCA9IF9kZXJlcV8oJy4uLy4uL21hdGgnKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gIHBhZGRpbmc6IDMwLCAvLyBmaXQgcGFkZGluZ1xuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxufTtcblxuZnVuY3Rpb24gUmFuZG9tTGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG59XG5cblJhbmRvbUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG5cbiAgdmFyIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSApO1xuXG4gIHZhciBnZXRQb3MgPSBmdW5jdGlvbiggaSwgbm9kZSApe1xuICAgIHJldHVybiB7XG4gICAgICB4OiBiYi54MSArIE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiBiYi53ICksXG4gICAgICB5OiBiYi55MSArIE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiBiYi5oIClcbiAgICB9O1xuICB9O1xuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyggdGhpcywgb3B0aW9ucywgZ2V0UG9zICk7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbUxheW91dDtcblxufSx7XCIuLi8uLi9tYXRoXCI6NzksXCIuLi8uLi91dGlsXCI6OTR9XSw1NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0gX2RlcmVxXygnLi4vLi4vLi4vbWF0aCcpO1xudmFyIGlzID0gX2RlcmVxXygnLi4vLi4vLi4vaXMnKTtcbnZhciB1dGlsID0gX2RlcmVxXygnLi4vLi4vLi4vdXRpbCcpO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5hcnJvd1NoYXBlSGVpZ2h0ID0gMC4zO1xuXG5CUnAucmVnaXN0ZXJBcnJvd1NoYXBlcyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhcnJvd1NoYXBlcyA9IHRoaXMuYXJyb3dTaGFwZXMgPSB7fTtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcblxuICAvLyBDb250cmFjdCBmb3IgYXJyb3cgc2hhcGVzOlxuICAvLyAwLCAwIGlzIGFycm93IHRpcFxuICAvLyAoMCwgMSkgaXMgZGlyZWN0aW9uIHRvd2FyZHMgbm9kZVxuICAvLyAoMSwgMCkgaXMgcmlnaHRcbiAgLy9cbiAgLy8gZnVuY3Rpb25hbCBhcGk6XG4gIC8vIGNvbGxpZGU6IGNoZWNrIHgsIHkgaW4gc2hhcGVcbiAgLy8gcm91Z2hDb2xsaWRlOiBjYWxsZWQgYmVmb3JlIGNvbGxpZGUsIG5vIGZhbHNlIG5lZ2F0aXZlc1xuICAvLyBkcmF3OiBkcmF3XG4gIC8vIHNwYWNpbmc6IGRpc3QoYXJyb3dUaXAsIG5vZGVCb3VuZGFyeSlcbiAgLy8gZ2FwOiBkaXN0KGVkZ2VUaXAsIG5vZGVCb3VuZGFyeSksIGVkZ2VUaXAgbWF5ICE9IGFycm93VGlwXG5cbiAgdmFyIGJiQ29sbGlkZSA9IGZ1bmN0aW9uKCB4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcgKXtcbiAgICB2YXIgeDEgPSB0cmFuc2xhdGlvbi54IC0gc2l6ZS8yIC0gcGFkZGluZztcbiAgICB2YXIgeDIgPSB0cmFuc2xhdGlvbi54ICsgc2l6ZS8yICsgcGFkZGluZztcbiAgICB2YXIgeTEgPSB0cmFuc2xhdGlvbi55IC0gc2l6ZS8yIC0gcGFkZGluZztcbiAgICB2YXIgeTIgPSB0cmFuc2xhdGlvbi55ICsgc2l6ZS8yICsgcGFkZGluZztcblxuICAgIHZhciBpbnNpZGUgPSAoeDEgPD0geCAmJiB4IDw9IHgyKSAmJiAoeTEgPD0geSAmJiB5IDw9IHkyKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG4gIH07XG5cbiAgdmFyIHRyYW5zZm9ybSA9IGZ1bmN0aW9uKCB4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKXtcbiAgICB2YXIgeFJvdGF0ZWQgPSB4ICogTWF0aC5jb3MoYW5nbGUpIC0geSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgeVJvdGF0ZWQgPSB4ICogTWF0aC5zaW4oYW5nbGUpICsgeSAqIE1hdGguY29zKGFuZ2xlKTtcblxuICAgIHZhciB4U2NhbGVkID0geFJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB5U2NhbGVkID0geVJvdGF0ZWQgKiBzaXplO1xuXG4gICAgdmFyIHhUcmFuc2xhdGVkID0geFNjYWxlZCArIHRyYW5zbGF0aW9uLng7XG4gICAgdmFyIHlUcmFuc2xhdGVkID0geVNjYWxlZCArIHRyYW5zbGF0aW9uLnk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeFRyYW5zbGF0ZWQsXG4gICAgICB5OiB5VHJhbnNsYXRlZFxuICAgIH07XG4gIH07XG5cbiAgdmFyIHRyYW5zZm9ybVBvaW50cyA9IGZ1bmN0aW9uKCBwdHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgIHZhciByZXRQdHMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSArPSAyICl7XG4gICAgICB2YXIgeCA9IHB0c1tpXTtcbiAgICAgIHZhciB5ID0gcHRzW2kgKyAxXTtcblxuICAgICAgcmV0UHRzLnB1c2goIHRyYW5zZm9ybSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFB0cztcbiAgfTtcblxuICB2YXIgcG9pbnRzVG9BcnIgPSBmdW5jdGlvbiggcHRzICl7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwID0gcHRzW2ldO1xuXG4gICAgICByZXQucHVzaCggcC54LCBwLnkgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHZhciBkZWZpbmVBcnJvd1NoYXBlID0gZnVuY3Rpb24oIG5hbWUsIGRlZm4gKXtcbiAgICBpZiggaXMuc3RyaW5nKGRlZm4pICl7XG4gICAgICBkZWZuID0gYXJyb3dTaGFwZXNbIGRlZm4gXTtcbiAgICB9XG5cbiAgICBhcnJvd1NoYXBlc1sgbmFtZSBdID0gdXRpbC5leHRlbmQoIHtcbiAgICAgIG5hbWU6IG5hbWUsXG5cbiAgICAgIHBvaW50czogW1xuICAgICAgICAtMC4xNSwgLTAuMyxcbiAgICAgICAgMC4xNSwgLTAuMyxcbiAgICAgICAgMC4xNSwgMC4zLFxuICAgICAgICAtMC4xNSwgMC4zXG4gICAgICBdLFxuXG4gICAgICBjb2xsaWRlOiBmdW5jdGlvbiggeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBwYWRkaW5nICl7XG4gICAgICAgIHZhciBwb2ludHMgPSBwb2ludHNUb0FyciggdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSArIDIqcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uICkgKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKCB4LCB5LCBwb2ludHMgKTtcblxuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgfSxcblxuICAgICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG5cbiAgICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKXtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKCdwb2x5Z29uJykoIGNvbnRleHQsIHBvaW50cyApO1xuICAgICAgfSxcblxuICAgICAgc3BhY2luZzogZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuXG4gICAgICBnYXA6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnBmVmFsdWUgKiAyO1xuICAgICAgfVxuICAgIH0sIGRlZm4gKTtcbiAgfTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAnbm9uZScsIHtcbiAgICBjb2xsaWRlOiB1dGlsLmZhbHNpZnksXG5cbiAgICByb3VnaENvbGxpZGU6IHV0aWwuZmFsc2lmeSxcblxuICAgIGRyYXc6IHV0aWwubm9vcCxcblxuICAgIHNwYWNpbmc6IHV0aWwuemVyb2lmeSxcblxuICAgIGdhcDogdXRpbC56ZXJvaWZ5XG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAndHJpYW5nbGUnLCB7XG4gICAgcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zXG4gICAgXVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ2Fycm93JywgJ3RyaWFuZ2xlJyApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICd0cmlhbmdsZS1iYWNrY3VydmUnLCB7XG4gICAgcG9pbnRzOiBhcnJvd1NoYXBlc1sndHJpYW5nbGUnXS5wb2ludHMsXG5cbiAgICBjb250cm9sUG9pbnQ6IFsgMCwgLTAuMTUgXSxcblxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuXG4gICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgICAgdmFyIHB0c1RyYW5zID0gdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG4gICAgICB2YXIgY3RybFB0ID0gdGhpcy5jb250cm9sUG9pbnQ7XG4gICAgICB2YXIgY3RybFB0VHJhbnMgPSB0cmFuc2Zvcm0oIGN0cmxQdFswXSwgY3RybFB0WzFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwoIHRoaXMubmFtZSApKCBjb250ZXh0LCBwdHNUcmFucywgY3RybFB0VHJhbnMgKTtcbiAgICB9LFxuXG4gICAgZ2FwOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucGZWYWx1ZTtcbiAgICB9XG4gIH0gKTtcblxuXG4gIGRlZmluZUFycm93U2hhcGUoICd0cmlhbmdsZS10ZWUnLCB7XG4gICAgcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zLFxuICAgICAgLTAuMTUsIC0wLjNcbiAgICBdLFxuXG4gICAgcG9pbnRzVGVlOiBbXG4gICAgICAtMC4xNSwgLTAuNCxcbiAgICAgIC0wLjE1LCAtMC41LFxuICAgICAgMC4xNSwgLTAuNSxcbiAgICAgIDAuMTUsIC0wLjRcbiAgICBdLFxuXG4gICAgY29sbGlkZTogZnVuY3Rpb24oIHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgcGFkZGluZyApe1xuICAgICAgdmFyIHRyaVB0cyA9IHBvaW50c1RvQXJyKCB0cmFuc2Zvcm1Qb2ludHMoIHRoaXMucG9pbnRzLCBzaXplICsgMipwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24gKSApO1xuICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKCB0cmFuc2Zvcm1Qb2ludHMoIHRoaXMucG9pbnRzVGVlLCBzaXplICsgMipwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24gKSApO1xuXG4gICAgICB2YXIgaW5zaWRlID0gbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoIHgsIHksIHRyaVB0cyApIHx8IG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKCB4LCB5LCB0ZWVQdHMgKTtcblxuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuICAgICAgdmFyIHRlZVB0cyA9IHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHNUZWUsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCggdGhpcy5uYW1lICkoIGNvbnRleHQsIHRyaVB0cywgdGVlUHRzICk7XG4gICAgfVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ3ZlZScsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4zLFxuICAgICAgMCwgMCxcbiAgICAgIDAuMTUsIC0wLjMsXG4gICAgICAwLCAtMC4xNVxuICAgIF0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5wZlZhbHVlO1xuICAgIH1cbiAgfSApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICdoYWxmLXRyaWFuZ2xlLW92ZXJzaG90Jywge1xuICAgIHBvaW50czogW1xuICAgICAgMCwgLTAuMjUsXG4gICAgICAtMC41LCAtMC4yNSxcbiAgICAgIDAuNSwgMC4yNVxuICAgIF0sXG5cbiAgICBsZWF2ZVBhdGhPcGVuOiB0cnVlLFxuXG4gICAgbWF0Y2hFZGdlV2lkdGg6IHRydWVcbiAgfSApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICdjaXJjbGUnLCB7XG4gICAgcmFkaXVzOiAwLjE1LFxuXG4gICAgY29sbGlkZTogZnVuY3Rpb24oIHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgcGFkZGluZyApe1xuICAgICAgdmFyIHQgPSB0cmFuc2xhdGlvbjtcbiAgICAgIHZhciBpbnNpZGUgPSAoIE1hdGgucG93KHQueCAtIHgsIDIpICsgTWF0aC5wb3codC55IC0geSwgMikgPD0gTWF0aC5wb3coKHNpemUgKyAyKnBhZGRpbmcpICogdGhpcy5yYWRpdXMsIDIpICk7XG5cbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKXtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKCB0aGlzLm5hbWUgKSggY29udGV4dCwgdHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSwgdGhpcy5yYWRpdXMgKiBzaXplICk7XG4gICAgfSxcblxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0QXJyb3dXaWR0aChlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnBmVmFsdWUpXG4gICAgICAgICogdGhpcy5yYWRpdXM7XG4gICAgfVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ2luaGliaXRvcicsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjI1LCAwLFxuICAgICAgLTAuMjUsIC0wLjEsXG4gICAgICAwLjI1LCAtMC4xLFxuICAgICAgMC4yNSwgMFxuICAgIF0sXG5cbiAgICBzcGFjaW5nOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIGdhcDogZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICd0ZWUnLCAnaW5oaWJpdG9yJyApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICdzcXVhcmUnLCB7XG4gICAgcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgMC4wMCxcbiAgICAgIDAuMTUsIDAuMDAsXG4gICAgICAwLjE1LCAtMC4zLFxuICAgICAgLTAuMTUsIC0wLjNcbiAgICBdXG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAnZGlhbW9uZCcsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4xNSxcbiAgICAgIDAsIC0wLjMsXG4gICAgICAwLjE1LCAtMC4xNSxcbiAgICAgIDAsIDBcbiAgICBdLFxuXG4gICAgZ2FwOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucGZWYWx1ZTtcbiAgICB9XG4gIH0gKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG5cbn0se1wiLi4vLi4vLi4vaXNcIjo3NyxcIi4uLy4uLy4uL21hdGhcIjo3OSxcIi4uLy4uLy4uL3V0aWxcIjo5NH1dLDU1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEJScCA9IHt9O1xuXG52YXIgZGVsRWxlQ2FjaGUgPSBmdW5jdGlvbiggciApe1xuICByLmVsZUVhY2hlID0gbnVsbDtcbn07XG5cbnZhciBnZXRFbGVDYWNoZSA9IGZ1bmN0aW9uKCByICl7XG4gIGlmKCAhci5lbGVFYWNoZSApe1xuICAgIHIuZWxlRWFjaGUgPSB7XG4gICAgICBub2Rlczogci5jeS5ub2RlcygpLFxuICAgICAgZWRnZXM6IHIuY3kuZWRnZXMoKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gci5lbGVFYWNoZTtcbn07XG5cbkJScC5nZXRDYWNoZWRFbGVtZW50cyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBnZXRFbGVDYWNoZSggdGhpcyApO1xufTtcblxuQlJwLmdldENhY2hlZE5vZGVzID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGdldEVsZUNhY2hlKCB0aGlzICkubm9kZXM7XG59O1xuXG5CUnAuZ2V0Q2FjaGVkRWRnZXMgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gZ2V0RWxlQ2FjaGUoIHRoaXMgKS5lZGdlcztcbn07XG5cbkJScC51cGRhdGVFbGVtZW50c0NhY2hlID0gZnVuY3Rpb24oKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGRlbEVsZUNhY2hlKCByICk7XG5cbiAgcmV0dXJuIGdldEVsZUNhY2hlKCByICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcblxufSx7fV0sNTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0aCA9IF9kZXJlcV8oJy4uLy4uLy4uL21hdGgnKTtcbnZhciBpcyA9IF9kZXJlcV8oJy4uLy4uLy4uL2lzJyk7XG52YXIgekluZGV4U29ydCA9IF9kZXJlcV8oJy4uLy4uLy4uL2NvbGxlY3Rpb24venNvcnQnKTtcblxudmFyIEJScCA9IHt9O1xuXG4vLyBQcm9qZWN0IG1vdXNlXG5CUnAucHJvamVjdEludG9WaWV3cG9ydCA9IGZ1bmN0aW9uKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgdmFyIG9mZnNldHMgPSB0aGlzLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXRzWzBdO1xuICB2YXIgb2Zmc2V0VG9wID0gb2Zmc2V0c1sxXTtcblxuICB2YXIgeCA9IGNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICB2YXIgeSA9IGNsaWVudFkgLSBvZmZzZXRUb3A7XG5cbiAgeCAtPSB0aGlzLmN5LnBhbigpLng7IHkgLT0gdGhpcy5jeS5wYW4oKS55OyB4IC89IHRoaXMuY3kuem9vbSgpOyB5IC89IHRoaXMuY3kuem9vbSgpO1xuICByZXR1cm4gW3gsIHldO1xufTtcblxuQlJwLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuXG4gIHZhciBiYiA9IHRoaXMuY29udGFpbmVyQkIgPSB0aGlzLmNvbnRhaW5lckJCIHx8IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICByZXR1cm4gW2JiLmxlZnQsIGJiLnRvcCwgYmIucmlnaHQgLSBiYi5sZWZ0LCBiYi5ib3R0b20gLSBiYi50b3BdO1xufTtcblxuQlJwLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY29udGFpbmVyQkIgPSBudWxsO1xufTtcblxuLy8gRmluZCBuZWFyZXN0IGVsZW1lbnRcbkJScC5maW5kTmVhcmVzdEVsZW1lbnQgPSBmdW5jdGlvbih4LCB5LCB2aXNpYmxlRWxlbWVudHNPbmx5LCBpc1RvdWNoKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICB2YXIgbmVhciA9IFtdO1xuICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICB2YXIgaGFzQ29tcG91bmRzID0gci5jeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBlZGdlVGhyZXNob2xkID0gKGlzVG91Y2ggPyAyNCA6IDgpIC8gem9vbTtcbiAgdmFyIG5vZGVUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDggOiAyKSAvIHpvb207XG4gIHZhciBsYWJlbFRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcblxuICBmdW5jdGlvbiBjaGVja05vZGUobm9kZSl7XG4gICAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcblxuICAgIGlmKCBfcC5zdHlsZVsnZXZlbnRzJ10uc3RyVmFsdWUgPT09ICdubycgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgd2lkdGggPSBub2RlLm91dGVyV2lkdGgoKSArIDIqbm9kZVRocmVzaG9sZDtcbiAgICB2YXIgaGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpICsgMipub2RlVGhyZXNob2xkO1xuICAgIHZhciBodyA9IHdpZHRoLzI7XG4gICAgdmFyIGhoID0gaGVpZ2h0LzI7XG4gICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uO1xuXG4gICAgaWYoXG4gICAgICBwb3MueCAtIGh3IDw9IHggJiYgeCA8PSBwb3MueCArIGh3IC8vIGJiIGNoZWNrIHhcbiAgICAgICAgJiZcbiAgICAgIHBvcy55IC0gaGggPD0geSAmJiB5IDw9IHBvcy55ICsgaGggLy8gYmIgY2hlY2sgeVxuICAgICl7XG4gICAgICB2YXIgdmlzaWJsZSA9ICF2aXNpYmxlRWxlbWVudHNPbmx5IHx8ICggbm9kZS52aXNpYmxlKCkgJiYgIW5vZGUudHJhbnNwYXJlbnQoKSApO1xuXG4gICAgICAvLyBleGl0IGVhcmx5IGlmIGludmlzaWJsZSBlZGdlIGFuZCBtdXN0IGJlIHZpc2libGVcbiAgICAgIGlmKCB2aXNpYmxlRWxlbWVudHNPbmx5ICYmICF2aXNpYmxlICl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNoYXBlID0gci5ub2RlU2hhcGVzWyBzZWxmLmdldE5vZGVTaGFwZShub2RlKSBdO1xuXG4gICAgICBpZihcbiAgICAgICAgc2hhcGUuY2hlY2tQb2ludCh4LCB5LCAwLCB3aWR0aCwgaGVpZ2h0LCBwb3MueCwgcG9zLnkpXG4gICAgICApe1xuICAgICAgICBuZWFyLnB1c2goIG5vZGUgKTtcbiAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRWRnZShlZGdlKXtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuXG4gICAgaWYoIF9wLnN0eWxlWydldmVudHMnXS5zdHJWYWx1ZSA9PT0gJ25vJyApeyByZXR1cm47IH1cblxuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuICAgIHZhciB3aWR0aCA9IHN0eWxlWyd3aWR0aCddLnBmVmFsdWUvMiArIGVkZ2VUaHJlc2hvbGQ7IC8vIG1vcmUgbGlrZSBhIGRpc3RhbmNlIHJhZGl1cyBmcm9tIGNlbnRyZVxuICAgIHZhciB3aWR0aFNxID0gd2lkdGggKiB3aWR0aDtcbiAgICB2YXIgd2lkdGgyID0gd2lkdGggKiAyO1xuICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICB2YXIgaW5FZGdlQkIgPSBmYWxzZTtcbiAgICB2YXIgc3FEaXN0O1xuXG4gICAgLy8gZXhpdCBlYXJseSBpZiBpbnZpc2libGUgZWRnZSBhbmQgbXVzdCBiZSB2aXNpYmxlXG4gICAgdmFyIHBhc3NlZFZpc2liaWxpdHlDaGVjaztcbiAgICB2YXIgcGFzc2VzVmlzaWJpbGl0eUNoZWNrID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmKCBwYXNzZWRWaXNpYmlsaXR5Q2hlY2sgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gcGFzc2VkVmlzaWJpbGl0eUNoZWNrO1xuICAgICAgfVxuXG4gICAgICBpZiggIXZpc2libGVFbGVtZW50c09ubHkgKXtcbiAgICAgICAgcGFzc2VkVmlzaWJpbGl0eUNoZWNrID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB2aXNpYmxlID0gZWRnZS52aXNpYmxlKCkgJiYgIWVkZ2UudHJhbnNwYXJlbnQoKTtcbiAgICAgIGlmKCB2aXNpYmxlICl7XG4gICAgICAgIHBhc3NlZFZpc2liaWxpdHlDaGVjayA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwYXNzZWRWaXNpYmlsaXR5Q2hlY2sgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnIHx8IHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnIHx8IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snICl7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSArIDMgPCBwdHMubGVuZ3RoOyBpICs9IDIgKXtcbiAgICAgICAgaWYoXG4gICAgICAgICAgKGluRWRnZUJCID0gbWF0aC5pbkxpbmVWaWNpbml0eSh4LCB5LCBwdHNbaV0sIHB0c1tpKzFdLCBwdHNbaSsyXSwgcHRzW2krM10sIHdpZHRoMikpXG4gICAgICAgICAgICAmJiBwYXNzZXNWaXNpYmlsaXR5Q2hlY2soKSAmJlxuICAgICAgICAgIHdpZHRoU3EgPiAoIHNxRGlzdCA9IG1hdGguc3FEaXN0YW5jZVRvRmluaXRlTGluZSh4LCB5LCBwdHNbaV0sIHB0c1tpKzFdLCBwdHNbaSsyXSwgcHRzW2krM10pIClcbiAgICAgICAgKXtcbiAgICAgICAgICBuZWFyLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJyApe1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCApe1xuICAgICAgICBpZihcbiAgICAgICAgICAoaW5FZGdlQkIgPSBtYXRoLmluQmV6aWVyVmljaW5pdHkoeCwgeSwgcHRzW2ldLCBwdHNbaSsxXSwgcHRzW2krMl0sIHB0c1tpKzNdLCBwdHNbaSs0XSwgcHRzW2krNV0sIHdpZHRoMikpXG4gICAgICAgICAgICAmJiBwYXNzZXNWaXNpYmlsaXR5Q2hlY2soKSAmJlxuICAgICAgICAgICh3aWR0aFNxID4gKHNxRGlzdCA9IG1hdGguc3FEaXN0YW5jZVRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHB0c1tpXSwgcHRzW2krMV0sIHB0c1tpKzJdLCBwdHNbaSszXSwgcHRzW2krNF0sIHB0c1tpKzVdKSkgKVxuICAgICAgICApe1xuICAgICAgICAgIG5lYXIucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgY2xvc2UgdG8gdGhlIGVkZ2UgYnV0IGRpZG4ndCBoaXQgaXQsIG1heWJlIHdlIGhpdCBpdHMgYXJyb3dzXG4gICAgaWYoIGluRWRnZUJCICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmIG5lYXIubGVuZ3RoID09PSAwIHx8IG5lYXJbbmVhci5sZW5ndGggLSAxXSAhPT0gZWRnZSApe1xuICAgICAgdmFyIHNyYyA9IHNyYyB8fCBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gdGd0IHx8IF9wLnRhcmdldDtcblxuICAgICAgdmFyIGVXaWR0aCA9IHN0eWxlWyd3aWR0aCddLnBmVmFsdWU7XG4gICAgICB2YXIgYXJTaXplID0gc2VsZi5nZXRBcnJvd1dpZHRoKCBlV2lkdGggKTtcblxuICAgICAgdmFyIGFycm93cyA9IFtcbiAgICAgICAgeyBuYW1lOiAnc291cmNlJywgeDogcnMuYXJyb3dTdGFydFgsIHk6IHJzLmFycm93U3RhcnRZLCBhbmdsZTogcnMuc3JjQXJyb3dBbmdsZSB9LFxuICAgICAgICB7IG5hbWU6ICd0YXJnZXQnLCB4OiBycy5hcnJvd0VuZFgsIHk6IHJzLmFycm93RW5kWSwgYW5nbGU6IHJzLnRndEFycm93QW5nbGUgfSxcbiAgICAgICAgeyBuYW1lOiAnbWlkLXNvdXJjZScsIHg6IHJzLm1pZFgsIHk6IHJzLm1pZFksIGFuZ2xlOiBycy5taWRzcmNBcnJvd0FuZ2xlIH0sXG4gICAgICAgIHsgbmFtZTogJ21pZC10YXJnZXQnLCB4OiBycy5taWRYLCB5OiBycy5taWRZLCBhbmdsZTogcnMubWlkdGd0QXJyb3dBbmdsZSB9XG4gICAgICBdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFycm93cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgYXIgPSBhcnJvd3NbaV07XG4gICAgICAgIHZhciBzaGFwZSA9IHIuYXJyb3dTaGFwZXNbIHN0eWxlW2FyLm5hbWUrJy1hcnJvdy1zaGFwZSddLnZhbHVlIF07XG5cbiAgICAgICAgaWYoXG4gICAgICAgICAgc2hhcGUucm91Z2hDb2xsaWRlKHgsIHksIGFyU2l6ZSwgYXIuYW5nbGUsIHsgeDogYXIueCwgeTogYXIueSB9LCBlZGdlVGhyZXNob2xkKVxuICAgICAgICAgICAmJlxuICAgICAgICAgIHNoYXBlLmNvbGxpZGUoeCwgeSwgYXJTaXplLCBhci5hbmdsZSwgeyB4OiBhci54LCB5OiBhci55IH0sIGVkZ2VUaHJlc2hvbGQpXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBlZGdlICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmb3IgY29tcG91bmQgZ3JhcGhzLCBoaXR0aW5nIGVkZ2UgbWF5IGFjdHVhbGx5IHdhbnQgYSBjb25uZWN0ZWQgbm9kZSBpbnN0ZWFkIChiL2MgZWRnZSBtYXkgaGF2ZSBncmVhdGVyIHotaW5kZXggcHJlY2VkZW5jZSlcbiAgICBpZiggaGFzQ29tcG91bmRzICYmICBuZWFyLmxlbmd0aCA+IDAgJiYgbmVhclsgbmVhci5sZW5ndGggLSAxIF0gPT09IGVkZ2UgKXtcbiAgICAgIGNoZWNrTm9kZSggc3JjICk7XG4gICAgICBjaGVja05vZGUoIHRndCApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrTGFiZWwoZWxlKXtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHRoID0gbGFiZWxUaHJlc2hvbGQ7XG5cbiAgICBpZiggX3Auc3R5bGVbJ3RleHQtZXZlbnRzJ10uc3RyVmFsdWUgPT09ICdubycgKXsgcmV0dXJuOyB9XG5cbiAgICAvLyBhZGp1c3QgYmIgdy8gYW5nbGVcbiAgICBpZiggX3AuZ3JvdXAgPT09ICdlZGdlcycgJiYgX3Auc3R5bGVbJ2VkZ2UtdGV4dC1yb3RhdGlvbiddLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZScgKXtcblxuICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICAgIHZhciBsdyA9IHJzdHlsZS5sYWJlbFdpZHRoICsgMip0aDtcbiAgICAgIHZhciBsaCA9IHJzdHlsZS5sYWJlbEhlaWdodCArIDIqdGg7XG4gICAgICB2YXIgbHggPSByc3R5bGUubGFiZWxYO1xuICAgICAgdmFyIGx5ID0gcnN0eWxlLmxhYmVsWTtcblxuICAgICAgdmFyIHRoZXRhID0gX3AucnNjcmF0Y2gubGFiZWxBbmdsZTtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyggdGhldGEgKTtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICAgICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uKCB4LCB5ICl7XG4gICAgICAgIHggPSB4IC0gbHg7XG4gICAgICAgIHkgPSB5IC0gbHk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4KmNvcyAtIHkqc2luICsgbHgsXG4gICAgICAgICAgeTogeCpzaW4gKyB5KmNvcyArIGx5XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICB2YXIgbHgxID0gbHggLSBsdy8yO1xuICAgICAgdmFyIGx4MiA9IGx4ICsgbHcvMjtcbiAgICAgIHZhciBseTEgPSBseSAtIGxoLzI7XG4gICAgICB2YXIgbHkyID0gbHkgKyBsaC8yO1xuXG4gICAgICB2YXIgcHgxeTEgPSByb3RhdGUoIGx4MSwgbHkxICk7XG4gICAgICB2YXIgcHgxeTIgPSByb3RhdGUoIGx4MSwgbHkyICk7XG4gICAgICB2YXIgcHgyeTEgPSByb3RhdGUoIGx4MiwgbHkxICk7XG4gICAgICB2YXIgcHgyeTIgPSByb3RhdGUoIGx4MiwgbHkyICk7XG5cbiAgICAgIHZhciBwb2ludHMgPSBbXG4gICAgICAgIHB4MXkxLngsIHB4MXkxLnksXG4gICAgICAgIHB4MnkxLngsIHB4MnkxLnksXG4gICAgICAgIHB4MnkyLngsIHB4MnkyLnksXG4gICAgICAgIHB4MXkyLngsIHB4MXkyLnlcbiAgICAgIF07XG5cbiAgICAgIGlmKCBtYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyggeCwgeSwgcG9pbnRzICkgKXtcbiAgICAgICAgbmVhci5wdXNoKCBlbGUgKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYmIgPSBlbGUuYm91bmRpbmdCb3goe1xuICAgICAgICBpbmNsdWRlTGFiZWxzOiB0cnVlLFxuICAgICAgICBpbmNsdWRlTm9kZXM6IGZhbHNlLFxuICAgICAgICBpbmNsdWRlRWRnZXM6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgLy8gYWRqdXN0IGJiIHcvIHRocmVzaG9sZFxuICAgICAgYmIueDEgLT0gdGg7XG4gICAgICBiYi55MSAtPSB0aDtcbiAgICAgIGJiLngyICs9IHRoO1xuICAgICAgYmIueTIgKz0gdGg7XG4gICAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuXG4gICAgICBpZiggbWF0aC5pbkJvdW5kaW5nQm94KCBiYiwgeCwgeSApICl7XG4gICAgICAgIG5lYXIucHVzaCggZWxlICk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBmb3IoIHZhciBpID0gZWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApeyAvLyByZXZlcnNlIG9yZGVyIGZvciBwcmVjZWRlbmNlXG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gICAgaWYoIG5lYXIubGVuZ3RoID4gMCApeyBicmVhazsgfSAvLyBzaW5jZSB3ZSBjaGVjayBpbiB6LW9yZGVyLCBmaXJzdCBmb3VuZCBpcyB0b3AgYW5kIGJlc3QgcmVzdWx0ID0+IGV4aXQgZWFybHlcblxuICAgIGlmKCBfcC5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgY2hlY2tOb2RlKCBlbGUgKTtcblxuICAgIH0gZWxzZSAgeyAvLyB0aGVuIGVkZ2VcbiAgICAgIGNoZWNrRWRnZSggZWxlICk7XG4gICAgfVxuXG4gICAgY2hlY2tMYWJlbCggZWxlICk7XG5cbiAgfVxuXG5cbiAgaWYoIG5lYXIubGVuZ3RoID4gMCApe1xuICAgIHJldHVybiBuZWFyWyBuZWFyLmxlbmd0aCAtIDEgXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLy8gJ0dpdmUgbWUgZXZlcnl0aGluZyBmcm9tIHRoaXMgYm94J1xuQlJwLmdldEFsbEluQm94ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIG5vZGVzID0gdGhpcy5nZXRDYWNoZWROb2RlcygpO1xuICB2YXIgZWRnZXMgPSB0aGlzLmdldENhY2hlZEVkZ2VzKCk7XG4gIHZhciBib3ggPSBbXTtcblxuICB2YXIgeDFjID0gTWF0aC5taW4oeDEsIHgyKTtcbiAgdmFyIHgyYyA9IE1hdGgubWF4KHgxLCB4Mik7XG4gIHZhciB5MWMgPSBNYXRoLm1pbih5MSwgeTIpO1xuICB2YXIgeTJjID0gTWF0aC5tYXgoeTEsIHkyKTtcblxuICB4MSA9IHgxYztcbiAgeDIgPSB4MmM7XG4gIHkxID0geTFjO1xuICB5MiA9IHkyYztcblxuICB2YXIgYm94QmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCh7XG4gICAgeDE6IHgxLCB5MTogeTEsXG4gICAgeDI6IHgyLCB5MjogeTJcbiAgfSk7XG5cbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIHZhciBub2RlQmIgPSBub2RlLmJvdW5kaW5nQm94KHtcbiAgICAgIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgICAgIGluY2x1ZGVFZGdlczogZmFsc2UsXG4gICAgICBpbmNsdWRlTGFiZWxzOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgaWYoIG1hdGguYm91bmRpbmdCb3hlc0ludGVyc2VjdChib3hCYiwgbm9kZUJiKSApe1xuICAgICAgYm94LnB1c2gobm9kZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGZvciggdmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKysgKXtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2VdO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICBpZiggcnMuc3RhcnRYICE9IG51bGwgJiYgcnMuc3RhcnRZICE9IG51bGwgJiYgIW1hdGguaW5Cb3VuZGluZ0JveCggYm94QmIsIHJzLnN0YXJ0WCwgcnMuc3RhcnRZICkgKXsgY29udGludWU7IH1cbiAgICBpZiggcnMuZW5kWCAhPSBudWxsICYmIHJzLmVuZFkgIT0gbnVsbCAmJiAhbWF0aC5pbkJvdW5kaW5nQm94KCBib3hCYiwgcnMuZW5kWCwgcnMuZW5kWSApICl7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgfHwgcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgKXtcblxuICAgICAgdmFyIHB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHMgfHwgX3AucnN0eWxlLmxpbmVQdHMgfHwgX3AucnN0eWxlLmhheXN0YWNrUHRzO1xuICAgICAgdmFyIGFsbEluc2lkZSA9IHRydWU7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCAhbWF0aC5wb2ludEluQm91bmRpbmdCb3goIGJveEJiLCBwdHNbaV0gKSApe1xuICAgICAgICAgIGFsbEluc2lkZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBhbGxJbnNpZGUgKXtcbiAgICAgICAgYm94LnB1c2goIGVkZ2UgKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiggcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcgKXtcbiAgICAgIGJveC5wdXNoKCBlZGdlICk7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gYm94O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNoYXBlIG9mIHRoZSBnaXZlbiBub2RlLiBJZiB0aGUgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSBnaXZlbiBub2RlXG4gKiBpcyBzZXQgdG8gYXV0bywgdGhlIG5vZGUgaXMgY29uc2lkZXJlZCB0byBiZSBhIGNvbXBvdW5kLlxuICpcbiAqIEBwYXJhbSBub2RlICAgICAgICAgIGEgbm9kZVxuICogQHJldHVybiB7U3RyaW5nfSAgICAgc2hhcGUgb2YgdGhlIG5vZGVcbiAqL1xuQlJwLmdldE5vZGVTaGFwZSA9IGZ1bmN0aW9uKCBub2RlICl7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHN0eWxlID0gbm9kZS5fcHJpdmF0ZS5zdHlsZTtcbiAgdmFyIHNoYXBlID0gc3R5bGVbJ3NoYXBlJ10udmFsdWU7XG5cbiAgaWYoIG5vZGUuaXNQYXJlbnQoKSApe1xuICAgIGlmKCBzaGFwZSA9PT0gJ3JlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdyb3VuZHJlY3RhbmdsZScgKXtcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBzaGFwZSA9PT0gJ3BvbHlnb24nICl7XG4gICAgdmFyIHBvaW50cyA9IHN0eWxlWydzaGFwZS1wb2x5Z29uLXBvaW50cyddLnZhbHVlO1xuXG4gICAgcmV0dXJuIHIubm9kZVNoYXBlcy5tYWtlUG9seWdvbiggcG9pbnRzICkubmFtZTtcbiAgfVxuXG4gIHJldHVybiBzaGFwZTtcbn07XG5cbkJScC51cGRhdGVDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoIHRydWUgKTtcbn07XG5cbkJScC5nZXRDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uKCBmb3JjZVJlY2FsYyApe1xuICB2YXIgbGFzdE5vZGVzID0gdGhpcy5sYXN0Wk9yZGVyQ2FjaGVkTm9kZXM7XG4gIHZhciBsYXN0RWRnZXMgPSB0aGlzLmxhc3RaT3JkZXJDYWNoZWRFZGdlcztcbiAgdmFyIG5vZGVzID0gdGhpcy5nZXRDYWNoZWROb2RlcygpO1xuICB2YXIgZWRnZXMgPSB0aGlzLmdldENhY2hlZEVkZ2VzKCk7XG4gIHZhciBlbGVzID0gW107XG5cbiAgaWYoIGZvcmNlUmVjYWxjIHx8ICFsYXN0Tm9kZXMgfHwgIWxhc3RFZGdlcyB8fCBsYXN0Tm9kZXMgIT09IG5vZGVzIHx8IGxhc3RFZGdlcyAhPT0gZWRnZXMgKXtcbiAgICAvL2NvbnNvbGUudGltZSgnY2FjaGV6b3JkZXInKVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcblxuICAgICAgaWYoIG4uYW5pbWF0ZWQoKSB8fCAobi52aXNpYmxlKCkgJiYgIW4udHJhbnNwYXJlbnQoKSkgKXtcbiAgICAgICAgZWxlcy5wdXNoKCBuICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcblxuICAgICAgaWYoIGUuYW5pbWF0ZWQoKSB8fCAoZS52aXNpYmxlKCkgJiYgIWUudHJhbnNwYXJlbnQoKSkgKXtcbiAgICAgICAgZWxlcy5wdXNoKCBlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlcy5zb3J0KCB6SW5kZXhTb3J0ICk7XG4gICAgdGhpcy5jYWNoZWRaU29ydGVkRWxlcyA9IGVsZXM7XG4gICAgLy9jb25zb2xlLmxvZygnbWFrZSBjYWNoZScpXG5cbiAgICAvL2NvbnNvbGUudGltZUVuZCgnY2FjaGV6b3JkZXInKVxuICB9IGVsc2Uge1xuICAgIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuICAgIC8vY29uc29sZS5sb2coJ3JlYWQgY2FjaGUnKVxuICB9XG5cbiAgdGhpcy5sYXN0Wk9yZGVyQ2FjaGVkTm9kZXMgPSBub2RlcztcbiAgdGhpcy5sYXN0Wk9yZGVyQ2FjaGVkRWRnZXMgPSBlZGdlcztcblxuICByZXR1cm4gZWxlcztcbn07XG5cbmZ1bmN0aW9uIHB1c2hCZXppZXJQdHMoZWRnZSwgcHRzKXtcbiAgdmFyIHFiZXppZXJBdCA9IGZ1bmN0aW9uKCBwMSwgcDIsIHAzLCB0ICl7IHJldHVybiBtYXRoLnFiZXppZXJBdChwMSwgcDIsIHAzLCB0KTsgfTtcbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzO1xuXG4gIGJwdHMucHVzaCh7XG4gICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjA1ICksXG4gICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjA1IClcbiAgfSk7XG5cbiAgYnB0cy5wdXNoKHtcbiAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuMjUgKSxcbiAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuMjUgKVxuICB9KTtcblxuICBicHRzLnB1c2goe1xuICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC40ICksXG4gICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjQgKVxuICB9KTtcblxuICBicHRzLnB1c2goe1xuICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC41ICksXG4gICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjUgKVxuICB9KTtcblxuICBicHRzLnB1c2goe1xuICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC42ICksXG4gICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjYgKVxuICB9KTtcblxuICBicHRzLnB1c2goe1xuICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC43NSApLFxuICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC43NSApXG4gIH0pO1xuXG4gIGJwdHMucHVzaCh7XG4gICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjk1ICksXG4gICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjk1IClcbiAgfSk7XG59XG5cbkJScC5wcm9qZWN0TGluZXMgPSBmdW5jdGlvbiggZWRnZSApe1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7XG5cbiAgaWYoIGV0ID09PSAnbXVsdGliZXppZXInIHx8ICBldCA9PT0gJ2JlemllcicgfHwgIGV0ID09PSAnc2VsZicgfHwgIGV0ID09PSAnY29tcG91bmQnICl7XG4gICAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzID0gW107IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0ICl7XG4gICAgICBwdXNoQmV6aWVyUHRzKCBlZGdlLCBycy5hbGxwdHMuc2xpY2UoaSwgaSs2KSApO1xuICAgIH1cbiAgfSBlbHNlIGlmKCAgZXQgPT09ICdzZWdtZW50cycgKXtcbiAgICB2YXIgbHB0cyA9IF9wLnJzdHlsZS5saW5lUHRzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSArIDEgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDIgKXtcbiAgICAgIGxwdHMucHVzaCh7XG4gICAgICAgIHg6IHJzLmFsbHB0c1tpXSxcbiAgICAgICAgeTogcnMuYWxscHRzW2krMV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmKCBldCA9PT0gJ2hheXN0YWNrJyApe1xuICAgIHZhciBocHRzID0gcnMuaGF5c3RhY2tQdHM7XG5cbiAgICBfcC5yc3R5bGUuaGF5c3RhY2tQdHMgPSBbXG4gICAgICB7IHg6IGhwdHNbMF0sIHk6IGhwdHNbMV0gfSxcbiAgICAgIHsgeDogaHB0c1syXSwgeTogaHB0c1szXSB9XG4gICAgXTtcbiAgfVxufTtcblxuQlJwLnByb2plY3RCZXppZXIgPSBCUnAucHJvamVjdExpbmVzO1xuXG5CUnAucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uID0gZnVuY3Rpb24oIG5vZGUgKXtcbiAgdmFyIGNvbnRlbnQgPSBub2RlLl9wcml2YXRlLnN0eWxlWydsYWJlbCddLnN0clZhbHVlO1xuICBpZiggIWNvbnRlbnQgfHwgY29udGVudC5tYXRjaCgvXlxccyskLykgKXsgcmV0dXJuOyB9XG5cbiAgdmFyIHRleHRYLCB0ZXh0WTtcbiAgdmFyIG5vZGVXaWR0aCA9IG5vZGUub3V0ZXJXaWR0aCgpO1xuICB2YXIgbm9kZUhlaWdodCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcbiAgdmFyIG5vZGVQb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuICB2YXIgdGV4dEhhbGlnbiA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3RleHQtaGFsaWduJ10uc3RyVmFsdWU7XG4gIHZhciB0ZXh0VmFsaWduID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsndGV4dC12YWxpZ24nXS5zdHJWYWx1ZTtcbiAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHJzdHlsZSA9IG5vZGUuX3ByaXZhdGUucnN0eWxlO1xuXG4gIHN3aXRjaCggdGV4dEhhbGlnbiApe1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggLSBub2RlV2lkdGggLyAyO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueCArIG5vZGVXaWR0aCAvIDI7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6IC8vIGUuZy4gY2VudGVyXG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueDtcbiAgfVxuXG4gIHN3aXRjaCggdGV4dFZhbGlnbiApe1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueSAtIG5vZGVIZWlnaHQgLyAyO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgdGV4dFkgPSBub2RlUG9zLnkgKyBub2RlSGVpZ2h0IC8gMjtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDogLy8gZS5nLiBtaWRkbGVcbiAgICAgIHRleHRZID0gbm9kZVBvcy55O1xuICB9XG5cbiAgcnMubGFiZWxYID0gdGV4dFg7XG4gIHJzLmxhYmVsWSA9IHRleHRZO1xuICByc3R5bGUubGFiZWxYID0gdGV4dFg7XG4gIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcblxuICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKCBub2RlICk7XG59O1xuXG5CUnAucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9uID0gZnVuY3Rpb24oIGVkZ2UgKXtcbiAgdmFyIGNvbnRlbnQgPSBlZGdlLl9wcml2YXRlLnN0eWxlWydsYWJlbCddLnN0clZhbHVlO1xuICBpZiggIWNvbnRlbnQgfHwgY29udGVudC5tYXRjaCgvXlxccyskLykgKXsgcmV0dXJuOyB9XG5cbiAgdmFyIHRleHRYLCB0ZXh0WTtcbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIC8vdmFyIHN0eWxlID0gX3Auc3R5bGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG5cbiAgdGV4dFggPSBycy5taWRYO1xuICB0ZXh0WSA9IHJzLm1pZFk7XG5cbiAgLy8gYWRkIGNlbnRlciBwb2ludCB0byBzdHlsZSBzbyBib3VuZGluZyBib3ggY2FsY3VsYXRpb25zIGNhbiB1c2UgaXRcbiAgcnMubGFiZWxYID0gdGV4dFg7XG4gIHJzLmxhYmVsWSA9IHRleHRZO1xuICByc3R5bGUubGFiZWxYID0gdGV4dFg7XG4gIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcblxuICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKCBlZGdlICk7XG59O1xuXG5CUnAuYXBwbHlMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiggZWxlICl7XG4gIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHJzdHlsZSA9IGVsZS5fcHJpdmF0ZS5yc3R5bGU7XG5cbiAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dCggZWxlICk7XG4gIHZhciBsYWJlbERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyggZWxlLCB0ZXh0ICk7XG5cbiAgcnN0eWxlLmxhYmVsV2lkdGggPSBsYWJlbERpbXMud2lkdGg7XG4gIHJzLmxhYmVsV2lkdGggPSBsYWJlbERpbXMud2lkdGg7XG5cbiAgcnN0eWxlLmxhYmVsSGVpZ2h0ID0gbGFiZWxEaW1zLmhlaWdodDtcbiAgcnMubGFiZWxIZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0O1xufTtcblxuQlJwLmdldExhYmVsVGV4dCA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICB2YXIgdGV4dCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsnbGFiZWwnXS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRUcmFuc2Zvcm0gPSBzdHlsZVsndGV4dC10cmFuc2Zvcm0nXS52YWx1ZTtcbiAgdmFyIHJzY3JhdGNoID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gIGlmICh0ZXh0VHJhbnNmb3JtID09ICdub25lJykge1xuICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ3VwcGVyY2FzZScpIHtcbiAgICB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ2xvd2VyY2FzZScpIHtcbiAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgaWYoIHN0eWxlWyd0ZXh0LXdyYXAnXS52YWx1ZSA9PT0gJ3dyYXAnICl7XG4gICAgLy9jb25zb2xlLmxvZygnd3JhcCcpO1xuXG4gICAgLy8gc2F2ZSByZWNhbGMgaWYgdGhlIGxhYmVsIGlzIHRoZSBzYW1lIGFzIGJlZm9yZVxuICAgIGlmKCByc2NyYXRjaC5sYWJlbFdyYXBLZXkgPT09IHJzY3JhdGNoLmxhYmVsS2V5ICl7XG4gICAgICAvLyBjb25zb2xlLmxvZygnd3JhcCBjYWNoZSBoaXQnKTtcbiAgICAgIHJldHVybiByc2NyYXRjaC5sYWJlbFdyYXBDYWNoZWRUZXh0O1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnd3JhcCBjYWNoZSBtaXNzJyk7XG5cbiAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgbWF4VyA9IHN0eWxlWyd0ZXh0LW1heC13aWR0aCddLnBmVmFsdWU7XG4gICAgdmFyIHdyYXBwZWRMaW5lcyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKyApe1xuICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsXTtcbiAgICAgIHZhciBsaW5lRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKCBlbGUsIGxpbmUsICdsaW5lPScgKyBsaW5lICk7XG4gICAgICB2YXIgbGluZVcgPSBsaW5lRGltcy53aWR0aDtcblxuICAgICAgaWYoIGxpbmVXID4gbWF4VyApeyAvLyBsaW5lIGlzIHRvbyBsb25nXG4gICAgICAgIHZhciB3b3JkcyA9IGxpbmUuc3BsaXQoL1xccysvKTsgLy8gTkI6IGFzc3VtZSBjb2xsYXBzZWQgd2hpdGVzcGFjZSBpbnRvIHNpbmdsZSBzcGFjZVxuICAgICAgICB2YXIgc3VibGluZSA9ICcnO1xuXG4gICAgICAgIGZvciggdmFyIHcgPSAwOyB3IDwgd29yZHMubGVuZ3RoOyB3KysgKXtcbiAgICAgICAgICB2YXIgd29yZCA9IHdvcmRzW3ddO1xuICAgICAgICAgIHZhciB0ZXN0TGluZSA9IHN1YmxpbmUubGVuZ3RoID09PSAwID8gd29yZCA6IHN1YmxpbmUgKyAnICcgKyB3b3JkO1xuICAgICAgICAgIHZhciB0ZXN0RGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKCBlbGUsIHRlc3RMaW5lLCAndGVzdExpbmU9JyArIHRlc3RMaW5lICk7XG4gICAgICAgICAgdmFyIHRlc3RXID0gdGVzdERpbXMud2lkdGg7XG5cbiAgICAgICAgICBpZiggdGVzdFcgPD0gbWF4VyApeyAvLyB3b3JkIGZpdHMgb24gY3VycmVudCBsaW5lXG4gICAgICAgICAgICBzdWJsaW5lICs9IHdvcmQgKyAnICc7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gd29yZCBzdGFydHMgbmV3IGxpbmVcbiAgICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKCBzdWJsaW5lICk7XG4gICAgICAgICAgICBzdWJsaW5lID0gd29yZCArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSdzIHJlbWFpbmluZyB0ZXh0LCBwdXQgaXQgaW4gYSB3cmFwcGVkIGxpbmVcbiAgICAgICAgaWYoICFzdWJsaW5lLm1hdGNoKC9eXFxzKyQvKSApe1xuICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKCBzdWJsaW5lICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7IC8vIGxpbmUgaXMgYWxyZWFkeSBzaG9ydCBlbm91Z2hcbiAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goIGxpbmUgKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvclxuXG4gICAgcnNjcmF0Y2gubGFiZWxXcmFwQ2FjaGVkTGluZXMgPSB3cmFwcGVkTGluZXM7XG4gICAgcnNjcmF0Y2gubGFiZWxXcmFwQ2FjaGVkVGV4dCA9IHRleHQgPSB3cmFwcGVkTGluZXMuam9pbignXFxuJyk7XG4gICAgcnNjcmF0Y2gubGFiZWxXcmFwS2V5ID0gcnNjcmF0Y2gubGFiZWxLZXk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyh0ZXh0KVxuICB9IC8vIGlmIHdyYXBcblxuICByZXR1cm4gdGV4dDtcbn07XG5cbkJScC5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiggZWxlLCB0ZXh0LCBleHRyYUtleSApe1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgdmFyIGZTdHlsZSA9IHN0eWxlWydmb250LXN0eWxlJ10uc3RyVmFsdWU7XG4gIHZhciBzaXplID0gc3R5bGVbJ2ZvbnQtc2l6ZSddLnBmVmFsdWUgKyAncHgnO1xuICB2YXIgZmFtaWx5ID0gc3R5bGVbJ2ZvbnQtZmFtaWx5J10uc3RyVmFsdWU7XG4gIC8vIHZhciB2YXJpYW50ID0gc3R5bGVbJ2ZvbnQtdmFyaWFudCddLnN0clZhbHVlO1xuICB2YXIgd2VpZ2h0ID0gc3R5bGVbJ2ZvbnQtd2VpZ2h0J10uc3RyVmFsdWU7XG5cbiAgdmFyIGNhY2hlS2V5ID0gZWxlLl9wcml2YXRlLmxhYmVsS2V5O1xuXG4gIGlmKCBleHRyYUtleSApe1xuICAgIGNhY2hlS2V5ICs9ICckQCQnICsgZXh0cmFLZXk7XG4gIH1cblxuICB2YXIgY2FjaGUgPSByLmxhYmVsRGltQ2FjaGUgfHwgKHIubGFiZWxEaW1DYWNoZSA9IHt9KTtcblxuICBpZiggY2FjaGVbY2FjaGVLZXldICl7XG4gICAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XTtcbiAgfVxuXG4gIHZhciBkaXYgPSB0aGlzLmxhYmVsQ2FsY0RpdjtcblxuICBpZiggIWRpdiApe1xuICAgIGRpdiA9IHRoaXMubGFiZWxDYWxjRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggZGl2ICk7XG4gIH1cblxuICB2YXIgZHMgPSBkaXYuc3R5bGU7XG5cbiAgLy8gZnJvbSBlbGUgc3R5bGVcbiAgZHMuZm9udEZhbWlseSA9IGZhbWlseTtcbiAgZHMuZm9udFN0eWxlID0gZlN0eWxlO1xuICBkcy5mb250U2l6ZSA9IHNpemU7XG4gIC8vIGRzLmZvbnRWYXJpYW50ID0gdmFyaWFudDtcbiAgZHMuZm9udFdlaWdodCA9IHdlaWdodDtcblxuICAvLyBmb3JjZWQgc3R5bGVcbiAgZHMucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBkcy5sZWZ0ID0gJy05OTk5cHgnO1xuICBkcy50b3AgPSAnLTk5OTlweCc7XG4gIGRzLnpJbmRleCA9ICctMSc7XG4gIGRzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgZHMucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgZHMucGFkZGluZyA9ICcwJztcbiAgZHMubGluZUhlaWdodCA9ICcxJztcblxuICBpZiggc3R5bGVbJ3RleHQtd3JhcCddLnZhbHVlID09PSAnd3JhcCcgKXtcbiAgICBkcy53aGl0ZVNwYWNlID0gJ3ByZSc7IC8vIHNvIG5ld2xpbmVzIGFyZSB0YWtlbiBpbnRvIGFjY291bnRcbiAgfSBlbHNlIHtcbiAgICBkcy53aGl0ZVNwYWNlID0gJ25vcm1hbCc7XG4gIH1cblxuICAvLyBwdXQgbGFiZWwgY29udGVudCBpbiBkaXZcbiAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcblxuICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgd2lkdGg6IGRpdi5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGRpdi5jbGllbnRIZWlnaHRcbiAgfTtcblxuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldO1xufTtcblxuQlJwLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gIHZhciBlZGdlcyA9IFtdO1xuICB2YXIgbm9kZXMgPSBbXTtcbiAgdmFyIGhhbmRsZWRFZGdlID0ge307XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIGlkID0gX3AuZGF0YS5pZDtcbiAgICB2YXIgYmJTdHlsZVNhbWUgPSBycy5ib3VuZGluZ0JveEtleSAhPSBudWxsICYmIF9wLmJvdW5kaW5nQm94S2V5ID09PSBycy5ib3VuZGluZ0JveEtleTtcbiAgICB2YXIgbGFiZWxTdHlsZVNhbWUgPSBycy5sYWJlbEtleSAhPSBudWxsICYmIF9wLmxhYmVsS2V5ID09PSBycy5sYWJlbEtleTtcbiAgICB2YXIgc3R5bGVTYW1lID0gYmJTdHlsZVNhbWUgJiYgbGFiZWxTdHlsZVNhbWU7XG5cbiAgICBpZiggX3AuZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcbiAgICAgIHZhciBwb3NTYW1lID0gcnN0eWxlLm5vZGVYICE9IG51bGwgJiYgcnN0eWxlLm5vZGVZICE9IG51bGwgJiYgcG9zLnggPT09IHJzdHlsZS5ub2RlWCAmJiBwb3MueSA9PT0gcnN0eWxlLm5vZGVZO1xuICAgICAgdmFyIHdTYW1lID0gcnN0eWxlLm5vZGVXICE9IG51bGwgJiYgcnN0eWxlLm5vZGVXID09PSBzdHlsZVsnd2lkdGgnXS5wZlZhbHVlO1xuICAgICAgdmFyIGhTYW1lID0gcnN0eWxlLm5vZGVIICE9IG51bGwgJiYgcnN0eWxlLm5vZGVIID09PSBzdHlsZVsnaGVpZ2h0J10ucGZWYWx1ZTtcblxuICAgICAgaWYoICFwb3NTYW1lIHx8ICFzdHlsZVNhbWUgfHwgIXdTYW1lIHx8ICFoU2FtZSApe1xuICAgICAgICBub2Rlcy5wdXNoKCBlbGUgKTtcbiAgICAgIH1cblxuICAgICAgcnN0eWxlLm5vZGVYID0gcG9zLng7XG4gICAgICByc3R5bGUubm9kZVkgPSBwb3MueTtcbiAgICAgIHJzdHlsZS5ub2RlVyA9IHN0eWxlWyd3aWR0aCddLnBmVmFsdWU7XG4gICAgICByc3R5bGUubm9kZUggPSBzdHlsZVsnaGVpZ2h0J10ucGZWYWx1ZTtcbiAgICB9IGVsc2UgeyAvLyBlZGdlc1xuXG4gICAgICB2YXIgc3JjUG9zID0gX3Auc291cmNlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgdmFyIHRndFBvcyA9IF9wLnRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgIHZhciBzcmNTYW1lID0gcnN0eWxlLnNyY1ggIT0gbnVsbCAmJiByc3R5bGUuc3JjWSAhPSBudWxsICYmIHNyY1Bvcy54ID09PSByc3R5bGUuc3JjWCAmJiBzcmNQb3MueSA9PT0gcnN0eWxlLnNyY1k7XG4gICAgICB2YXIgdGd0U2FtZSA9IHJzdHlsZS50Z3RYICE9IG51bGwgJiYgcnN0eWxlLnRndFkgIT0gbnVsbCAmJiB0Z3RQb3MueCA9PT0gcnN0eWxlLnRndFggJiYgdGd0UG9zLnkgPT09IHJzdHlsZS50Z3RZO1xuICAgICAgdmFyIHBvc2l0aW9uc1NhbWUgPSBzcmNTYW1lICYmIHRndFNhbWU7XG5cbiAgICAgIGlmKCAhcG9zaXRpb25zU2FtZSB8fCAhc3R5bGVTYW1lICl7XG4gICAgICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJyApe1xuICAgICAgICAgIGlmKCAhaGFuZGxlZEVkZ2VbIGlkIF0gKXtcbiAgICAgICAgICAgIGVkZ2VzLnB1c2goIGVsZSApO1xuICAgICAgICAgICAgaGFuZGxlZEVkZ2VbIGlkIF0gPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgcGFyYWxsZWxFZGdlcyA9IGVsZS5wYXJhbGxlbEVkZ2VzKCk7XG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmFsbGVsRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgdmFyIHBFZGdlID0gcGFyYWxsZWxFZGdlc1tpXTtcbiAgICAgICAgICAgICAgdmFyIHBJZCA9IHBFZGdlLl9wcml2YXRlLmRhdGEuaWQ7XG5cbiAgICAgICAgICAgICAgaWYoICFoYW5kbGVkRWRnZVsgcElkIF0gKXtcbiAgICAgICAgICAgICAgICBlZGdlcy5wdXNoKCBwRWRnZSApO1xuICAgICAgICAgICAgICAgIGhhbmRsZWRFZGdlWyBwSWQgXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGdlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBpZiBwb3NpdGlvbnMgZGlmZlxuXG4gICAgICAvLyB1cGRhdGUgcnN0eWxlIHBvc2l0aW9uc1xuICAgICAgcnN0eWxlLnNyY1ggPSBzcmNQb3MueDtcbiAgICAgIHJzdHlsZS5zcmNZID0gc3JjUG9zLnk7XG4gICAgICByc3R5bGUudGd0WCA9IHRndFBvcy54O1xuICAgICAgcnN0eWxlLnRndFkgPSB0Z3RQb3MueTtcblxuICAgIH0gLy8gaWYgZWRnZXNcblxuICAgIHJzLmJvdW5kaW5nQm94S2V5ID0gX3AuYm91bmRpbmdCb3hLZXk7XG4gICAgcnMubGFiZWxLZXkgPSBfcC5sYWJlbEtleTtcbiAgfVxuXG4gIHRoaXMucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMoIGVkZ2VzICk7XG4gIHRoaXMucmVjYWxjdWxhdGVMYWJlbFByb2plY3Rpb25zKCBub2RlcywgZWRnZXMgKTtcbn07XG5cbkJScC5yZWNhbGN1bGF0ZUxhYmVsUHJvamVjdGlvbnMgPSBmdW5jdGlvbiggbm9kZXMsIGVkZ2VzICl7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbiggbm9kZXNbaV0gKTtcbiAgfVxuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbiggZWRnZXNbaV0gKTtcbiAgfVxufTtcblxuQlJwLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zID0gZnVuY3Rpb24oIGVkZ2VzICl7XG4gIHRoaXMuZmluZEVkZ2VDb250cm9sUG9pbnRzKCBlZGdlcyApO1xufTtcblxuXG4vLyBGaW5kIGVkZ2UgY29udHJvbCBwb2ludHNcbkJScC5maW5kRWRnZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbihlZGdlcykge1xuICBpZiggIWVkZ2VzIHx8IGVkZ2VzLmxlbmd0aCA9PT0gMCApeyByZXR1cm47IH1cblxuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBoYXNoVGFibGUgPSB7fTtcbiAgdmFyIHBhaXJJZHMgPSBbXTtcbiAgdmFyIGhheXN0YWNrRWRnZXMgPSBbXTtcbiAgdmFyIGF1dG9yb3RhdGVFZGdlcyA9IFtdO1xuXG4gIC8vIGNyZWF0ZSBhIHRhYmxlIG9mIGVkZ2UgKHNyYywgdGd0KSA9PiBsaXN0IG9mIGVkZ2VzIGJldHdlZW4gdGhlbVxuICB2YXIgcGFpcklkO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKXtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIGRhdGEgPSBfcC5kYXRhO1xuICAgIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuICAgIHZhciBjdXJ2ZVN0eWxlID0gc3R5bGVbJ2N1cnZlLXN0eWxlJ10udmFsdWU7XG4gICAgdmFyIGVkZ2VJc1VuYnVuZGxlZCA9IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnO1xuXG4gICAgLy8gaWdub3JlIGVkZ2VzIHdobyBhcmUgbm90IHRvIGJlIGRpc3BsYXllZFxuICAgIC8vIHRoZXkgc2hvdWxkbid0IHRha2UgdXAgc3BhY2VcbiAgICBpZiggc3R5bGUuZGlzcGxheS52YWx1ZSA9PT0gJ25vbmUnICl7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiggc3R5bGVbJ2VkZ2UtdGV4dC1yb3RhdGlvbiddLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZScgKXtcbiAgICAgIGF1dG9yb3RhdGVFZGdlcy5wdXNoKCBlZGdlICk7XG4gICAgfVxuXG4gICAgaWYoIGN1cnZlU3R5bGUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgIGhheXN0YWNrRWRnZXMucHVzaCggZWRnZSApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHNyY0lkID0gZGF0YS5zb3VyY2U7XG4gICAgdmFyIHRndElkID0gZGF0YS50YXJnZXQ7XG5cbiAgICBwYWlySWQgPSBzcmNJZCA+IHRndElkID9cbiAgICAgIHRndElkICsgJyQtJCcgKyBzcmNJZCA6XG4gICAgICBzcmNJZCArICckLSQnICsgdGd0SWQgO1xuXG4gICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgcGFpcklkID0gJ3VuYnVuZGxlZCcgKyAnJC0kJyArIGRhdGEuaWQ7XG4gICAgfVxuXG4gICAgaWYoIGhhc2hUYWJsZVtwYWlySWRdID09IG51bGwgKXtcbiAgICAgIGhhc2hUYWJsZVtwYWlySWRdID0gW107XG4gICAgICBwYWlySWRzLnB1c2goIHBhaXJJZCApO1xuICAgIH1cblxuICAgIGhhc2hUYWJsZVtwYWlySWRdLnB1c2goIGVkZ2UgKTtcblxuICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgIGhhc2hUYWJsZVtwYWlySWRdLmhhc1VuYnVuZGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNyYywgdGd0LCBzcmNfcCwgdGd0X3AsIHNyY1BvcywgdGd0UG9zLCBzcmNXLCBzcmNILCB0Z3RXLCB0Z3RILCBzcmNTaGFwZSwgdGd0U2hhcGU7XG4gIHZhciB2ZWN0b3JOb3JtSW52ZXJzZTtcbiAgdmFyIGJhZEJlemllcjtcblxuICAvLyBmb3IgZWFjaCBwYWlyIChzcmMsIHRndCksIGNyZWF0ZSB0aGUgY3RybCBwdHNcbiAgLy8gTmVzdGVkIGZvciBsb29wIGlzIE9LOyB0b3RhbCBudW1iZXIgb2YgaXRlcmF0aW9ucyBmb3IgYm90aCBsb29wcyA9IGVkZ2VDb3VudFxuICBmb3IgKHZhciBwID0gMDsgcCA8IHBhaXJJZHMubGVuZ3RoOyBwKyspIHtcbiAgICBwYWlySWQgPSBwYWlySWRzW3BdO1xuICAgIHZhciBwYWlyRWRnZXMgPSBoYXNoVGFibGVbcGFpcklkXTtcblxuICAgIC8vIGZvciBlYWNoIHBhaXIgaWQsIHRoZSBlZGdlcyBzaG91bGQgYmUgc29ydGVkIGJ5IGluZGV4XG4gICAgcGFpckVkZ2VzLnNvcnQoZnVuY3Rpb24oZWRnZTEsIGVkZ2UyKXtcbiAgICAgIHJldHVybiBlZGdlMS5fcHJpdmF0ZS5pbmRleCAtIGVkZ2UyLl9wcml2YXRlLmluZGV4O1xuICAgIH0pO1xuXG4gICAgc3JjID0gcGFpckVkZ2VzWzBdLl9wcml2YXRlLnNvdXJjZTtcbiAgICB0Z3QgPSBwYWlyRWRnZXNbMF0uX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgc3JjX3AgPSBzcmMuX3ByaXZhdGU7XG4gICAgdGd0X3AgPSB0Z3QuX3ByaXZhdGU7XG5cbiAgICAvLyBtYWtlIHN1cmUgc3JjL3RndCBkaXN0aW5jdGlvbiBpcyBjb25zaXN0ZW50XG4gICAgLy8gKHNyYy90Z3QgaW4gdGhpcyBjYXNlIGFyZSBqdXN0IGZvciBjdHJscHRzIGFuZCBkb24ndCBhY3R1YWxseSBoYXZlIHRvIGJlIHRydWUgc3JjL3RndClcbiAgICBpZiggc3JjX3AuZGF0YS5pZCA+IHRndF9wLmRhdGEuaWQgKXtcbiAgICAgIHZhciB0ZW1wID0gc3JjO1xuICAgICAgc3JjID0gdGd0O1xuICAgICAgdGd0ID0gdGVtcDtcbiAgICB9XG5cbiAgICBzcmNQb3MgPSBzcmNfcC5wb3NpdGlvbjtcbiAgICB0Z3RQb3MgPSB0Z3RfcC5wb3NpdGlvbjtcblxuICAgIHNyY1cgPSBzcmMub3V0ZXJXaWR0aCgpO1xuICAgIHNyY0ggPSBzcmMub3V0ZXJIZWlnaHQoKTtcblxuICAgIHRndFcgPSB0Z3Qub3V0ZXJXaWR0aCgpO1xuICAgIHRndEggPSB0Z3Qub3V0ZXJIZWlnaHQoKTtcblxuICAgIHNyY1NoYXBlID0gci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZShzcmMpIF07XG4gICAgdGd0U2hhcGUgPSByLm5vZGVTaGFwZXNbIHRoaXMuZ2V0Tm9kZVNoYXBlKHRndCkgXTtcblxuICAgIGJhZEJlemllciA9IGZhbHNlO1xuXG5cbiAgICBpZiggKHBhaXJFZGdlcy5sZW5ndGggPiAxICYmIHNyYyAhPT0gdGd0KSB8fCBwYWlyRWRnZXMuaGFzVW5idW5kbGVkICl7XG5cbiAgICAgIC8vIHB0IG91dHNpZGUgc3JjIHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuICAgICAgdmFyIHNyY091dHNpZGUgPSBzcmNTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICBzcmNQb3MueCxcbiAgICAgICAgc3JjUG9zLnksXG4gICAgICAgIHNyY1csXG4gICAgICAgIHNyY0gsXG4gICAgICAgIHRndFBvcy54LFxuICAgICAgICB0Z3RQb3MueSxcbiAgICAgICAgMFxuICAgICAgKTtcblxuICAgICAgLy8gcHQgb3V0c2lkZSB0Z3Qgc2hhcGUgdG8gY2FsYyBkaXN0YW5jZS9kaXNwbGFjZW1lbnQgZnJvbSBzcmMgdG8gdGd0XG4gICAgICB2YXIgdGd0T3V0c2lkZSA9IHRndFNoYXBlLmludGVyc2VjdExpbmUoXG4gICAgICAgIHRndFBvcy54LFxuICAgICAgICB0Z3RQb3MueSxcbiAgICAgICAgdGd0VyxcbiAgICAgICAgdGd0SCxcbiAgICAgICAgc3JjUG9zLngsXG4gICAgICAgIHNyY1Bvcy55LFxuICAgICAgICAwXG4gICAgICApO1xuXG4gICAgICB2YXIgbWlkcHRTcmNQdHMgPSB7XG4gICAgICAgIHgxOiBzcmNPdXRzaWRlWzBdLFxuICAgICAgICB4MjogdGd0T3V0c2lkZVswXSxcbiAgICAgICAgeTE6IHNyY091dHNpZGVbMV0sXG4gICAgICAgIHkyOiB0Z3RPdXRzaWRlWzFdXG4gICAgICB9O1xuXG4gICAgICB2YXIgZHkgPSAoIHRndE91dHNpZGVbMV0gLSBzcmNPdXRzaWRlWzFdICk7XG4gICAgICB2YXIgZHggPSAoIHRndE91dHNpZGVbMF0gLSBzcmNPdXRzaWRlWzBdICk7XG4gICAgICB2YXIgbCA9IE1hdGguc3FydCggZHgqZHggKyBkeSpkeSApO1xuXG4gICAgICB2YXIgdmVjdG9yID0ge1xuICAgICAgICB4OiBkeCxcbiAgICAgICAgeTogZHlcbiAgICAgIH07XG5cbiAgICAgIHZhciB2ZWN0b3JOb3JtID0ge1xuICAgICAgICB4OiB2ZWN0b3IueC9sLFxuICAgICAgICB5OiB2ZWN0b3IueS9sXG4gICAgICB9O1xuICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSB7XG4gICAgICAgIHg6IC12ZWN0b3JOb3JtLnksXG4gICAgICAgIHk6IHZlY3Rvck5vcm0ueFxuICAgICAgfTtcblxuXG4gICAgICAvLyBpZiBzcmMgaW50ZXJzZWN0aW9uIGlzIGluc2lkZSB0Z3Qgb3IgdGd0IGludGVyc2VjdGlvbiBpcyBpbnNpZGUgc3JjLCB0aGVuIG5vIGN0cmwgcHRzIHRvIGRyYXdcbiAgICAgIGlmKFxuICAgICAgICB0Z3RTaGFwZS5jaGVja1BvaW50KCBzcmNPdXRzaWRlWzBdLCBzcmNPdXRzaWRlWzFdLCAwLCB0Z3RXLCB0Z3RILCB0Z3RQb3MueCwgdGd0UG9zLnkgKSAgfHxcbiAgICAgICAgc3JjU2hhcGUuY2hlY2tQb2ludCggdGd0T3V0c2lkZVswXSwgdGd0T3V0c2lkZVsxXSwgMCwgc3JjVywgc3JjSCwgc3JjUG9zLngsIHNyY1Bvcy55IClcbiAgICAgICl7XG4gICAgICAgIHZlY3Rvck5vcm1JbnZlcnNlID0ge307XG4gICAgICAgIGJhZEJlemllciA9IHRydWU7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgZWRnZTtcbiAgICB2YXIgZWRnZV9wO1xuICAgIHZhciBycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpckVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlZGdlID0gcGFpckVkZ2VzW2ldO1xuICAgICAgZWRnZV9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICAgIHJzID0gZWRnZV9wLnJzY3JhdGNoO1xuXG4gICAgICB2YXIgZWRnZUluZGV4MSA9IHJzLmxhc3RFZGdlSW5kZXg7XG4gICAgICB2YXIgZWRnZUluZGV4MiA9IGk7XG5cbiAgICAgIHZhciBudW1FZGdlczEgPSBycy5sYXN0TnVtRWRnZXM7XG4gICAgICB2YXIgbnVtRWRnZXMyID0gcGFpckVkZ2VzLmxlbmd0aDtcblxuICAgICAgdmFyIGVTdHlsZSA9IGVkZ2VfcC5zdHlsZTtcbiAgICAgIHZhciBzdHlsZSA9IGVTdHlsZTtcbiAgICAgIHZhciBjdXJ2ZVN0eWxlID0gZVN0eWxlWydjdXJ2ZS1zdHlsZSddLnZhbHVlO1xuICAgICAgdmFyIGN0cmxwdERpc3RzID0gZVN0eWxlWydjb250cm9sLXBvaW50LWRpc3RhbmNlcyddO1xuICAgICAgdmFyIGN0cmxwdFdzID0gZVN0eWxlWydjb250cm9sLXBvaW50LXdlaWdodHMnXTtcbiAgICAgIHZhciBiZXppZXJOID0gY3RybHB0RGlzdHMgJiYgY3RybHB0V3MgPyBNYXRoLm1pbiggY3RybHB0RGlzdHMudmFsdWUubGVuZ3RoLCBjdHJscHRXcy52YWx1ZS5sZW5ndGggKSA6IDE7XG4gICAgICB2YXIgc3RlcFNpemUgPSBlU3R5bGVbJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJ10ucGZWYWx1ZTtcbiAgICAgIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgIT09IHVuZGVmaW5lZCA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY3RybHB0V2VpZ2h0ID0gY3RybHB0V3MudmFsdWVbMF07XG4gICAgICB2YXIgZWRnZUlzVW5idW5kbGVkID0gY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICdzZWdtZW50cyc7XG5cbiAgICAgIHZhciBzd2FwcGVkRGlyZWN0aW9uID0gZWRnZV9wLnNvdXJjZSAhPT0gc3JjO1xuXG4gICAgICBpZiggc3dhcHBlZERpcmVjdGlvbiAmJiBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgICAgY3RybHB0RGlzdCAqPSAtMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNyY1gxID0gcnMubGFzdFNyY0N0bFB0WDtcbiAgICAgIHZhciBzcmNYMiA9IHNyY1Bvcy54O1xuICAgICAgdmFyIHNyY1kxID0gcnMubGFzdFNyY0N0bFB0WTtcbiAgICAgIHZhciBzcmNZMiA9IHNyY1Bvcy55O1xuICAgICAgdmFyIHNyY1cxID0gcnMubGFzdFNyY0N0bFB0VztcbiAgICAgIHZhciBzcmNXMiA9IHNyYy5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgc3JjSDEgPSBycy5sYXN0U3JjQ3RsUHRIO1xuICAgICAgdmFyIHNyY0gyID0gc3JjLm91dGVySGVpZ2h0KCk7XG5cbiAgICAgIHZhciB0Z3RYMSA9IHJzLmxhc3RUZ3RDdGxQdFg7XG4gICAgICB2YXIgdGd0WDIgPSB0Z3RQb3MueDtcbiAgICAgIHZhciB0Z3RZMSA9IHJzLmxhc3RUZ3RDdGxQdFk7XG4gICAgICB2YXIgdGd0WTIgPSB0Z3RQb3MueTtcbiAgICAgIHZhciB0Z3RXMSA9IHJzLmxhc3RUZ3RDdGxQdFc7XG4gICAgICB2YXIgdGd0VzIgPSB0Z3Qub3V0ZXJXaWR0aCgpO1xuICAgICAgdmFyIHRndEgxID0gcnMubGFzdFRndEN0bFB0SDtcbiAgICAgIHZhciB0Z3RIMiA9IHRndC5vdXRlckhlaWdodCgpO1xuXG4gICAgICB2YXIgd2lkdGgxID0gcnMubGFzdFc7XG4gICAgICB2YXIgd2lkdGgyID0gZVN0eWxlWydjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSddLnBmVmFsdWU7XG5cbiAgICAgIGlmKCBiYWRCZXppZXIgKXtcbiAgICAgICAgcnMuYmFkQmV6aWVyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmJhZEJlemllciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiggc3JjWDEgPT09IHNyY1gyICYmIHNyY1kxID09PSBzcmNZMiAmJiBzcmNXMSA9PT0gc3JjVzIgJiYgc3JjSDEgPT09IHNyY0gyXG4gICAgICAmJiAgdGd0WDEgPT09IHRndFgyICYmIHRndFkxID09PSB0Z3RZMiAmJiB0Z3RXMSA9PT0gdGd0VzIgJiYgdGd0SDEgPT09IHRndEgyXG4gICAgICAmJiAgd2lkdGgxID09PSB3aWR0aDJcbiAgICAgICYmICAoKGVkZ2VJbmRleDEgPT09IGVkZ2VJbmRleDIgJiYgbnVtRWRnZXMxID09PSBudW1FZGdlczIpIHx8IGVkZ2VJc1VuYnVuZGxlZCkgKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2VkZ2UgY3RybCBwdCBjYWNoZSBISVQnKVxuICAgICAgICBjb250aW51ZTsgLy8gdGhlbiB0aGUgY29udHJvbCBwb2ludHMgaGF2ZW4ndCBjaGFuZ2VkIGFuZCB3ZSBjYW4gc2tpcCBjYWxjdWxhdGluZyB0aGVtXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5sYXN0U3JjQ3RsUHRYID0gc3JjWDI7XG4gICAgICAgIHJzLmxhc3RTcmNDdGxQdFkgPSBzcmNZMjtcbiAgICAgICAgcnMubGFzdFNyY0N0bFB0VyA9IHNyY1cyO1xuICAgICAgICBycy5sYXN0U3JjQ3RsUHRIID0gc3JjSDI7XG4gICAgICAgIHJzLmxhc3RUZ3RDdGxQdFggPSB0Z3RYMjtcbiAgICAgICAgcnMubGFzdFRndEN0bFB0WSA9IHRndFkyO1xuICAgICAgICBycy5sYXN0VGd0Q3RsUHRXID0gdGd0VzI7XG4gICAgICAgIHJzLmxhc3RUZ3RDdGxQdEggPSB0Z3RIMjtcbiAgICAgICAgcnMubGFzdEVkZ2VJbmRleCA9IGVkZ2VJbmRleDI7XG4gICAgICAgIHJzLmxhc3ROdW1FZGdlcyA9IG51bUVkZ2VzMjtcbiAgICAgICAgcnMubGFzdFdpZHRoID0gd2lkdGgyO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZWRnZSBjdHJsIHB0IGNhY2hlIE1JU1MnKVxuICAgICAgfVxuXG4gICAgICBpZiggc3JjID09PSB0Z3QgKXtcbiAgICAgICAgLy8gU2VsZi1lZGdlXG5cbiAgICAgICAgcnMuZWRnZVR5cGUgPSAnc2VsZic7XG5cbiAgICAgICAgdmFyIGogPSBpO1xuICAgICAgICB2YXIgbG9vcERpc3QgPSBzdGVwU2l6ZTtcblxuICAgICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgbG9vcERpc3QgPSBjdHJscHREaXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgcnMuY3RybHB0cyA9IFtcbiAgICAgICAgICBzcmNQb3MueCxcbiAgICAgICAgICBzcmNQb3MueSAtICgxICsgTWF0aC5wb3coc3JjSCwgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSxcblxuICAgICAgICAgIHNyY1Bvcy54IC0gKDEgKyBNYXRoLnBvdyhzcmNXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLFxuICAgICAgICAgIHNyY1Bvcy55XG4gICAgICAgIF07XG5cbiAgICAgIH0gZWxzZSBpZihcbiAgICAgICAgaGFzQ29tcG91bmRzICYmXG4gICAgICAgICggc3JjLmlzUGFyZW50KCkgfHwgc3JjLmlzQ2hpbGQoKSB8fCB0Z3QuaXNQYXJlbnQoKSB8fCB0Z3QuaXNDaGlsZCgpICkgJiZcbiAgICAgICAgKCBzcmMucGFyZW50cygpLmFueVNhbWUodGd0KSB8fCB0Z3QucGFyZW50cygpLmFueVNhbWUoc3JjKSApXG4gICAgICApe1xuICAgICAgICAvLyBDb21wb3VuZCBlZGdlXG5cbiAgICAgICAgcnMuZWRnZVR5cGUgPSAnY29tcG91bmQnO1xuXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGxpbmUgYXBwcm94aW1hdGlvbiBkb2Vzbid0IGFwcGx5IGZvciBjb21wb3VuZCBiZXppZXJzXG4gICAgICAgIC8vIChsb29wL3NlbGYgZWRnZXMgYXJlIGFscmVhZHkgZWxpZGVkIGIvYyBvZiBjaGVhcCBzcmM9PXRndCBjaGVjaylcbiAgICAgICAgcnMuYmFkQmV6aWVyID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGogPSBpO1xuICAgICAgICB2YXIgbG9vcERpc3QgPSBzdGVwU2l6ZTtcblxuICAgICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgbG9vcERpc3QgPSBjdHJscHREaXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvb3BXID0gNTA7XG5cbiAgICAgICAgdmFyIGxvb3BhUG9zID0ge1xuICAgICAgICAgIHg6IHNyY1Bvcy54IC0gc3JjVy8yLFxuICAgICAgICAgIHk6IHNyY1Bvcy55IC0gc3JjSC8yXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxvb3BiUG9zID0ge1xuICAgICAgICAgIHg6IHRndFBvcy54IC0gdGd0Vy8yLFxuICAgICAgICAgIHk6IHRndFBvcy55IC0gdGd0SC8yXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxvb3BQb3MgPSB7XG4gICAgICAgICAgeDogTWF0aC5taW4oIGxvb3BhUG9zLngsIGxvb3BiUG9zLnggKSxcbiAgICAgICAgICB5OiBNYXRoLm1pbiggbG9vcGFQb3MueSwgbG9vcGJQb3MueSApXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYXZvaWRzIGNhc2VzIHdpdGggaW1wb3NzaWJsZSBiZXppZXJzXG4gICAgICAgIHZhciBtaW5Db21wb3VuZFN0cmV0Y2ggPSAwLjU7XG4gICAgICAgIHZhciBjb21wb3VuZFN0cmV0Y2hBID0gTWF0aC5tYXgoIG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2coc3JjVyAqIDAuMDEpICk7XG4gICAgICAgIHZhciBjb21wb3VuZFN0cmV0Y2hCID0gTWF0aC5tYXgoIG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2codGd0VyAqIDAuMDEpICk7XG5cbiAgICAgICAgcnMuY3RybHB0cyA9IFtcbiAgICAgICAgICBsb29wUG9zLngsXG4gICAgICAgICAgbG9vcFBvcy55IC0gKDEgKyBNYXRoLnBvdyhsb29wVywgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSAqIGNvbXBvdW5kU3RyZXRjaEEsXG5cbiAgICAgICAgICBsb29wUG9zLnggLSAoMSArIE1hdGgucG93KGxvb3BXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogY29tcG91bmRTdHJldGNoQixcbiAgICAgICAgICBsb29wUG9zLnlcbiAgICAgICAgXTtcblxuICAgICAgfSBlbHNlIGlmKCBjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnICl7XG4gICAgICAgIC8vIFNlZ21lbnRzIChtdWx0aXBsZSBzdHJhaWdodCBsaW5lcylcblxuICAgICAgICBycy5lZGdlVHlwZSA9ICdzZWdtZW50cyc7XG4gICAgICAgIHJzLnNlZ3B0cyA9IFtdO1xuXG4gICAgICAgIHZhciBzZWdtZW50V3MgPSBlU3R5bGVbJ3NlZ21lbnQtd2VpZ2h0cyddLnBmVmFsdWU7XG4gICAgICAgIHZhciBzZWdtZW50RHMgPSBlU3R5bGVbJ3NlZ21lbnQtZGlzdGFuY2VzJ10ucGZWYWx1ZTtcbiAgICAgICAgdmFyIHNlZ21lbnRzTiA9IE1hdGgubWluKCBzZWdtZW50V3MubGVuZ3RoLCBzZWdtZW50RHMubGVuZ3RoICk7XG5cbiAgICAgICAgZm9yKCB2YXIgcyA9IDA7IHMgPCBzZWdtZW50c047IHMrKyApe1xuICAgICAgICAgIHZhciB3ID0gc2VnbWVudFdzW3NdO1xuICAgICAgICAgIHZhciBkID0gc2VnbWVudERzW3NdO1xuXG4gICAgICAgICAgLy8gZCA9IHN3YXBwZWREaXJlY3Rpb24gPyAtZCA6IGQ7XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBkID0gTWF0aC5hYnMoZCk7XG5cbiAgICAgICAgICAvLyB2YXIgdzEgPSAhc3dhcHBlZERpcmVjdGlvbiA/ICgxIC0gdykgOiB3O1xuICAgICAgICAgIC8vIHZhciB3MiA9ICFzd2FwcGVkRGlyZWN0aW9uID8gdyA6ICgxIC0gdyk7XG5cbiAgICAgICAgICB2YXIgdzEgPSAoMSAtIHcpO1xuICAgICAgICAgIHZhciB3MiA9IHc7XG5cbiAgICAgICAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgICAgICAgIHg6IG1pZHB0U3JjUHRzLngxICogdzEgKyBtaWRwdFNyY1B0cy54MiAqIHcyLFxuICAgICAgICAgICAgeTogbWlkcHRTcmNQdHMueTEgKiB3MSArIG1pZHB0U3JjUHRzLnkyICogdzJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcnMuc2VncHRzLnB1c2goXG4gICAgICAgICAgICBhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZCxcbiAgICAgICAgICAgIGFkanVzdGVkTWlkcHQueSArIHZlY3Rvck5vcm1JbnZlcnNlLnkgKiBkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBTdHJhaWdodCBlZGdlXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBwYWlyRWRnZXMubGVuZ3RoICUgMiA9PT0gMVxuICAgICAgICAmJiBpID09PSBNYXRoLmZsb29yKHBhaXJFZGdlcy5sZW5ndGggLyAyKVxuICAgICAgICAmJiAhZWRnZUlzVW5idW5kbGVkXG4gICAgICApe1xuXG4gICAgICAgIHJzLmVkZ2VUeXBlID0gJ3N0cmFpZ2h0JztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gKE11bHRpKWJlemllclxuXG4gICAgICAgIHZhciBtdWx0aSA9IGVkZ2VJc1VuYnVuZGxlZDtcblxuICAgICAgICBycy5lZGdlVHlwZSA9IG11bHRpID8gJ211bHRpYmV6aWVyJyA6ICdiZXppZXInO1xuICAgICAgICBycy5jdHJscHRzID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgYiA9IDA7IGIgPCBiZXppZXJOOyBiKysgKXtcbiAgICAgICAgICB2YXIgbm9ybWN0cmxwdERpc3QgPSAoMC41IC0gcGFpckVkZ2VzLmxlbmd0aCAvIDIgKyBpKSAqIHN0ZXBTaXplO1xuICAgICAgICAgIHZhciBtYW5jdHJscHREaXN0O1xuICAgICAgICAgIHZhciBzaWduID0gbWF0aC5zaWdudW0oIG5vcm1jdHJscHREaXN0ICk7XG5cbiAgICAgICAgICBpZiggbXVsdGkgKXtcbiAgICAgICAgICAgIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbYl0gOiBzdGVwU2l6ZTsgLy8gZmFsbCBiYWNrIG9uIHN0ZXAgc2l6ZVxuICAgICAgICAgICAgY3RybHB0V2VpZ2h0ID0gY3RybHB0V3MudmFsdWVbYl07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApeyAvLyBtdWx0aSBvciBzaW5nbGUgdW5idW5kbGVkXG4gICAgICAgICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFuY3RybHB0RGlzdCA9IGN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IHNpZ24gKiBjdHJscHREaXN0IDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkaXN0YW5jZUZyb21NaWRwb2ludCA9IG1hbmN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IG1hbmN0cmxwdERpc3QgOiBub3JtY3RybHB0RGlzdDtcblxuICAgICAgICAgIHZhciB3MSA9ICFzd2FwcGVkRGlyZWN0aW9uIHx8IGVkZ2VJc1VuYnVuZGxlZCA/ICgxIC0gY3RybHB0V2VpZ2h0KSA6IGN0cmxwdFdlaWdodDtcbiAgICAgICAgICB2YXIgdzIgPSAhc3dhcHBlZERpcmVjdGlvbiB8fCBlZGdlSXNVbmJ1bmRsZWQgPyBjdHJscHRXZWlnaHQgOiAoMSAtIGN0cmxwdFdlaWdodCk7XG5cbiAgICAgICAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgICAgICAgIHg6IG1pZHB0U3JjUHRzLngxICogdzEgKyBtaWRwdFNyY1B0cy54MiAqIHcyLFxuICAgICAgICAgICAgeTogbWlkcHRTcmNQdHMueTEgKiB3MSArIG1pZHB0U3JjUHRzLnkyICogdzJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcnMuY3RybHB0cy5wdXNoKFxuICAgICAgICAgICAgYWRqdXN0ZWRNaWRwdC54ICsgdmVjdG9yTm9ybUludmVyc2UueCAqIGRpc3RhbmNlRnJvbU1pZHBvaW50LFxuICAgICAgICAgICAgYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGRpc3RhbmNlRnJvbU1pZHBvaW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIGZpbmQgZW5kcHRzIGZvciBlZGdlXG4gICAgICB0aGlzLmZpbmRFbmRwb2ludHMoIGVkZ2UgKTtcblxuICAgICAgdmFyIGJhZFN0YXJ0ID0gIWlzLm51bWJlciggcnMuc3RhcnRYICkgfHwgIWlzLm51bWJlciggcnMuc3RhcnRZICk7XG4gICAgICB2YXIgYmFkQVN0YXJ0ID0gIWlzLm51bWJlciggcnMuYXJyb3dTdGFydFggKSB8fCAhaXMubnVtYmVyKCBycy5hcnJvd1N0YXJ0WSApO1xuICAgICAgdmFyIGJhZEVuZCA9ICFpcy5udW1iZXIoIHJzLmVuZFggKSB8fCAhaXMubnVtYmVyKCBycy5lbmRZICk7XG4gICAgICB2YXIgYmFkQUVuZCA9ICFpcy5udW1iZXIoIHJzLmFycm93RW5kWCApIHx8ICFpcy5udW1iZXIoIHJzLmFycm93RW5kWSApO1xuXG4gICAgICB2YXIgbWluQ3BBRGlzdEZhY3RvciA9IDM7XG4gICAgICB2YXIgYXJyb3dXID0gdGhpcy5nZXRBcnJvd1dpZHRoKCBlU3R5bGVbJ3dpZHRoJ10ucGZWYWx1ZSApICogdGhpcy5hcnJvd1NoYXBlSGVpZ2h0O1xuICAgICAgdmFyIG1pbkNwQURpc3QgPSBtaW5DcEFEaXN0RmFjdG9yICogYXJyb3dXO1xuXG4gICAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdiZXppZXInICl7XG4gICAgICAgIHZhciBzdGFydEFDcERpc3QgPSBtYXRoLmRpc3RhbmNlKCB7IHg6IHJzLmN0cmxwdHNbMF0sIHk6IHJzLmN0cmxwdHNbMV0gfSwgeyB4OiBycy5zdGFydFgsIHk6IHJzLnN0YXJ0WSB9ICk7XG4gICAgICAgIHZhciBjbG9zZVN0YXJ0QUNwID0gc3RhcnRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcbiAgICAgICAgdmFyIGVuZEFDcERpc3QgPSBtYXRoLmRpc3RhbmNlKCB7IHg6IHJzLmN0cmxwdHNbMF0sIHk6IHJzLmN0cmxwdHNbMV0gfSwgeyB4OiBycy5lbmRYLCB5OiBycy5lbmRZIH0gKTtcbiAgICAgICAgdmFyIGNsb3NlRW5kQUNwID0gZW5kQUNwRGlzdCA8IG1pbkNwQURpc3Q7XG5cbiAgICAgICAgdmFyIG92ZXJsYXBwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYoIGJhZFN0YXJ0IHx8IGJhZEFTdGFydCB8fCBjbG9zZVN0YXJ0QUNwICl7XG4gICAgICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSBzcmMgY2VudHJlIHRvIG91dHNpZGUgdGhlIHNyYyBzaGFwZVxuICAgICAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcbiAgICAgICAgICB2YXIgY3BEID0geyAvLyBkZWx0YVxuICAgICAgICAgICAgeDogcnMuY3RybHB0c1swXSAtIHNyY1Bvcy54LFxuICAgICAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHNyY1Bvcy55XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgY3BMID0gTWF0aC5zcXJ0KCBjcEQueCpjcEQueCArIGNwRC55KmNwRC55ICk7IC8vIGxlbmd0aCBvZiBsaW5lXG4gICAgICAgICAgdmFyIGNwTSA9IHsgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICAgICAgeDogY3BELnggLyBjcEwsXG4gICAgICAgICAgICB5OiBjcEQueSAvIGNwTFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuICAgICAgICAgIHZhciBjcFByb2ogPSB7IC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIDIgKiByYWRpdXMsXG4gICAgICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAyICogcmFkaXVzXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBzcmNDdHJsUHRJbnRuID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgICAgIHNyY1Bvcy54LFxuICAgICAgICAgICAgc3JjUG9zLnksXG4gICAgICAgICAgICBzcmNXLFxuICAgICAgICAgICAgc3JjSCxcbiAgICAgICAgICAgIGNwUHJvai54LFxuICAgICAgICAgICAgY3BQcm9qLnksXG4gICAgICAgICAgICAwXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmKCBjbG9zZVN0YXJ0QUNwICl7XG4gICAgICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIGNwTS54ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICAgICAgcnMuY3RybHB0c1sxXSA9IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnMuY3RybHB0c1swXSA9IHNyY0N0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgICBycy5jdHJscHRzWzFdID0gc3JjQ3RybFB0SW50blsxXSArIGNwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggYmFkRW5kIHx8IGJhZEFFbmQgfHwgY2xvc2VFbmRBQ3AgKXtcbiAgICAgICAgICBvdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgICAgICAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHRndCBjZW50cmUgdG8gb3V0c2lkZSB0aGUgdGd0IHNoYXBlXG4gICAgICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuICAgICAgICAgIHZhciBjcEQgPSB7IC8vIGRlbHRhXG4gICAgICAgICAgICB4OiBycy5jdHJscHRzWzBdIC0gdGd0UG9zLngsXG4gICAgICAgICAgICB5OiBycy5jdHJscHRzWzFdIC0gdGd0UG9zLnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBjcEwgPSBNYXRoLnNxcnQoIGNwRC54KmNwRC54ICsgY3BELnkqY3BELnkgKTsgLy8gbGVuZ3RoIG9mIGxpbmVcbiAgICAgICAgICB2YXIgY3BNID0geyAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgICAgICB4OiBjcEQueCAvIGNwTCxcbiAgICAgICAgICAgIHk6IGNwRC55IC8gY3BMXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG4gICAgICAgICAgdmFyIGNwUHJvaiA9IHsgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICAgICAgeDogcnMuY3RybHB0c1swXSArIGNwTS54ICogMiAqIHJhZGl1cyxcbiAgICAgICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIDIgKiByYWRpdXNcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHRndEN0cmxQdEludG4gPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICAgICAgdGd0UG9zLngsXG4gICAgICAgICAgICB0Z3RQb3MueSxcbiAgICAgICAgICAgIHRndFcsXG4gICAgICAgICAgICB0Z3RILFxuICAgICAgICAgICAgY3BQcm9qLngsXG4gICAgICAgICAgICBjcFByb2oueSxcbiAgICAgICAgICAgIDBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYoIGNsb3NlRW5kQUNwICl7XG4gICAgICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIGNwTS54ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBycy5jdHJscHRzWzBdID0gdGd0Q3RybFB0SW50blswXSArIGNwTS54ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSB0Z3RDdHJsUHRJbnRuWzFdICsgY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG92ZXJsYXBwaW5nICl7XG4gICAgICAgICAgLy8gcmVjYWxjIGVuZHB0c1xuICAgICAgICAgIHRoaXMuZmluZEVuZHBvaW50cyggZWRnZSApO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnICl7XG4gICAgICAgIHJzLmFsbHB0cyA9IFtdO1xuXG4gICAgICAgIHJzLmFsbHB0cy5wdXNoKCBycy5zdGFydFgsIHJzLnN0YXJ0WSApO1xuXG4gICAgICAgIGZvciggdmFyIGIgPSAwOyBiKzEgPCBycy5jdHJscHRzLmxlbmd0aDsgYiArPSAyICl7XG4gICAgICAgICAgLy8gY3RybCBwdCBpdHNlbGZcbiAgICAgICAgICBycy5hbGxwdHMucHVzaCggcnMuY3RybHB0c1tiXSwgcnMuY3RybHB0c1tiKzFdICk7XG5cbiAgICAgICAgICAvLyB0aGUgbWlkcHQgYmV0d2VlbiBjdHJscHRzIGFzIGludGVybWVkaWF0ZSBkZXN0aW5hdGlvbiBwdHNcbiAgICAgICAgICBpZiggYiArIDMgPCBycy5jdHJscHRzLmxlbmd0aCApe1xuICAgICAgICAgICAgcnMuYWxscHRzLnB1c2goIChycy5jdHJscHRzW2JdICsgcnMuY3RybHB0c1tiKzJdKS8yLCAocnMuY3RybHB0c1tiKzFdICsgcnMuY3RybHB0c1tiKzNdKS8yICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnMuYWxscHRzLnB1c2goIHJzLmVuZFgsIHJzLmVuZFkgKTtcblxuICAgICAgICB2YXIgbSwgbXQ7XG4gICAgICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgKXtcbiAgICAgICAgICBycy5taWRYID0gbWF0aC5xYmV6aWVyQXQoIHJzLmFycm93U3RhcnRYLCBycy5jdHJscHRzWzBdLCBycy5hcnJvd0VuZFgsIDAuNSApO1xuICAgICAgICAgIHJzLm1pZFkgPSBtYXRoLnFiZXppZXJBdCggcnMuYXJyb3dTdGFydFksIHJzLmN0cmxwdHNbMV0sIHJzLmFycm93RW5kWSwgMC41ICk7XG4gICAgICAgIH0gZWxzZSBpZiggcnMuY3RybHB0cy5sZW5ndGgvMiAlIDIgPT09IDAgKXtcbiAgICAgICAgICBtID0gcnMuYWxscHRzLmxlbmd0aC8yIC0gMTtcblxuICAgICAgICAgIHJzLm1pZFggPSBycy5hbGxwdHNbbV07XG4gICAgICAgICAgcnMubWlkWSA9IHJzLmFsbHB0c1ttKzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoLzIgLSAzO1xuICAgICAgICAgIG10ID0gMC41O1xuXG4gICAgICAgICAgcnMubWlkWCA9IG1hdGgucWJlemllckF0KCBycy5hbGxwdHNbbV0sIHJzLmFsbHB0c1ttKzJdLCBycy5hbGxwdHNbbSs0XSwgbXQgKTtcbiAgICAgICAgICBycy5taWRZID0gbWF0aC5xYmV6aWVyQXQoIHJzLmFsbHB0c1ttKzFdLCBycy5hbGxwdHNbbSszXSwgcnMuYWxscHRzW20rNV0sIG10ICk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmKCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JyApe1xuICAgICAgICAvLyBuZWVkIHRvIGNhbGMgdGhlc2UgYWZ0ZXIgZW5kcHRzXG4gICAgICAgIHJzLmFsbHB0cyA9IFsgcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmVuZFgsIHJzLmVuZFkgXTtcblxuICAgICAgICAvLyBkZWZhdWx0IG1pZHB0IGZvciBsYWJlbHMgZXRjXG4gICAgICAgIHJzLm1pZFggPSAoIHJzLmFycm93U3RhcnRYICsgcnMuYXJyb3dFbmRYICkvMjtcbiAgICAgICAgcnMubWlkWSA9ICggcnMuYXJyb3dTdGFydFkgKyBycy5hcnJvd0VuZFkgKS8yO1xuXG4gICAgICB9IGVsc2UgaWYoIHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnICl7XG4gICAgICAgIHJzLmFsbHB0cyA9IFtdO1xuICAgICAgICBycy5hbGxwdHMucHVzaCggcnMuc3RhcnRYLCBycy5zdGFydFkgKTtcbiAgICAgICAgcnMuYWxscHRzLnB1c2guYXBwbHkoIHJzLmFsbHB0cywgcnMuc2VncHRzICk7XG4gICAgICAgIHJzLmFsbHB0cy5wdXNoKCBycy5lbmRYLCBycy5lbmRZICk7XG5cbiAgICAgICAgaWYoIHJzLnNlZ3B0cy5sZW5ndGggJSA0ID09PSAwICl7XG4gICAgICAgICAgdmFyIGkyID0gcnMuc2VncHRzLmxlbmd0aCAvIDI7XG4gICAgICAgICAgdmFyIGkxID0gaTIgLSAyO1xuXG4gICAgICAgICAgcnMubWlkWCA9ICggcnMuc2VncHRzW2kxXSArIHJzLnNlZ3B0c1tpMl0gKSAvIDI7XG4gICAgICAgICAgcnMubWlkWSA9ICggcnMuc2VncHRzW2kxKzFdICsgcnMuc2VncHRzW2kyKzFdICkgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpMSA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyIC0gMTtcblxuICAgICAgICAgIHJzLm1pZFggPSBycy5zZWdwdHNbaTFdO1xuICAgICAgICAgIHJzLm1pZFkgPSBycy5zZWdwdHNbaTErMV07XG4gICAgICAgIH1cblxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvamVjdExpbmVzKCBlZGdlICk7XG4gICAgICB0aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKCBlZGdlICk7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbiggZWRnZSApO1xuXG4gICAgfVxuICB9XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBoYXlzdGFja0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVkZ2UgPSBoYXlzdGFja0VkZ2VzW2ldO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHN0eWxlID0gX3Auc3R5bGU7XG4gICAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHJzID0gcnNjcmF0Y2g7XG5cbiAgICBpZiggIXJzY3JhdGNoLmhheXN0YWNrICl7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG5cbiAgICAgIHJzY3JhdGNoLnNvdXJjZSA9IHtcbiAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSlcbiAgICAgIH07XG5cbiAgICAgIHZhciBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcblxuICAgICAgcnNjcmF0Y2gudGFyZ2V0ID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcblxuICAgIH1cblxuICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICB2YXIgc3JjUG9zID0gc3JjLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgIHZhciB0Z3RQb3MgPSB0Z3QuX3ByaXZhdGUucG9zaXRpb247XG4gICAgdmFyIHNyY1cgPSBzcmMud2lkdGgoKTtcbiAgICB2YXIgdGd0VyA9IHRndC53aWR0aCgpO1xuICAgIHZhciBzcmNIID0gc3JjLmhlaWdodCgpO1xuICAgIHZhciB0Z3RIID0gdGd0LmhlaWdodCgpO1xuICAgIHZhciByYWRpdXMgPSBzdHlsZVsnaGF5c3RhY2stcmFkaXVzJ10udmFsdWU7XG4gICAgdmFyIGhhbGZSYWRpdXMgPSByYWRpdXMvMjsgLy8gYi9jIGhhdmUgdG8gaGFsZiB3aWR0aC9oZWlnaHRcblxuICAgIHJzLmhheXN0YWNrUHRzID0gcnMuYWxscHRzID0gW1xuICAgICAgcnMuc291cmNlLnggKiBzcmNXICogaGFsZlJhZGl1cyArIHNyY1Bvcy54LFxuICAgICAgcnMuc291cmNlLnkgKiBzcmNIICogaGFsZlJhZGl1cyArIHNyY1Bvcy55LFxuICAgICAgcnMudGFyZ2V0LnggKiB0Z3RXICogaGFsZlJhZGl1cyArIHRndFBvcy54LFxuICAgICAgcnMudGFyZ2V0LnkgKiB0Z3RIICogaGFsZlJhZGl1cyArIHRndFBvcy55XG4gICAgXTtcblxuICAgIHJzLm1pZFggPSAocnMuYWxscHRzWzBdICsgcnMuYWxscHRzWzJdKS8yO1xuICAgIHJzLm1pZFkgPSAocnMuYWxscHRzWzFdICsgcnMuYWxscHRzWzNdKS8yO1xuXG4gICAgLy8gYWx3YXlzIG92ZXJyaWRlIGFzIGhheXN0YWNrIGluIGNhc2Ugc2V0IHRvIGRpZmZlcmVudCB0eXBlIHByZXZpb3VzbHlcbiAgICByc2NyYXRjaC5lZGdlVHlwZSA9ICdoYXlzdGFjayc7XG4gICAgcnNjcmF0Y2guaGF5c3RhY2sgPSB0cnVlO1xuXG4gICAgdGhpcy5wcm9qZWN0TGluZXMoIGVkZ2UgKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKCBlZGdlICk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb24oIGVkZ2UgKTtcbiAgfVxuXG4gIGZvciggdmFyIGkgPSAwIDsgaSA8IGF1dG9yb3RhdGVFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlZGdlID0gYXV0b3JvdGF0ZUVkZ2VzW2ldO1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICBycy5sYWJlbEFuZ2xlID0gTWF0aC5hdGFuKCBycy5taWREaXNwWSAvIHJzLm1pZERpc3BYICk7XG4gIH1cblxuICByZXR1cm4gaGFzaFRhYmxlO1xufTtcblxudmFyIGdldEFuZ2xlRnJvbURpc3AgPSBmdW5jdGlvbiggZGlzcFgsIGRpc3BZICl7XG4gIHJldHVybiBNYXRoLmF0YW4yKCBkaXNwWSwgZGlzcFggKSAtIE1hdGguUEkvMjtcbn07XG5cbkJScC5jYWxjdWxhdGVBcnJvd0FuZ2xlcyA9IGZ1bmN0aW9uKCBlZGdlICl7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG4gIHZhciBpc011bHRpYmV6aWVyID0gcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcic7XG4gIHZhciBpc1NlZ21lbnRzID0gcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cyc7XG4gIHZhciBpc0NvbXBvdW5kID0gcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCc7XG4gIHZhciBpc1NlbGYgPSBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnO1xuXG4gIC8vIERpc3BsYWNlbWVudCBnaXZlcyBkaXJlY3Rpb24gZm9yIGFycm93aGVhZCBvcmllbnRhdGlvblxuICB2YXIgZGlzcFgsIGRpc3BZO1xuICB2YXIgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFk7XG5cbiAgdmFyIHNyY1BvcyA9IGVkZ2Uuc291cmNlKCkucG9zaXRpb24oKTtcbiAgdmFyIHRndFBvcyA9IGVkZ2UudGFyZ2V0KCkucG9zaXRpb24oKTtcblxuICBpZiggaXNIYXlzdGFjayApe1xuICAgIHN0YXJ0WCA9IHJzLmhheXN0YWNrUHRzWzBdO1xuICAgIHN0YXJ0WSA9IHJzLmhheXN0YWNrUHRzWzFdO1xuICAgIGVuZFggPSBycy5oYXlzdGFja1B0c1syXTtcbiAgICBlbmRZID0gcnMuaGF5c3RhY2tQdHNbM107XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgc3RhcnRZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgZW5kWCA9IHJzLmFycm93RW5kWDtcbiAgICBlbmRZID0gcnMuYXJyb3dFbmRZO1xuICB9XG5cbiAgLy8gc291cmNlXG4gIC8vXG5cbiAgZGlzcFggPSBzcmNQb3MueCAtIHN0YXJ0WDtcbiAgZGlzcFkgPSBzcmNQb3MueSAtIHN0YXJ0WTtcblxuICBycy5zcmNBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcCggZGlzcFgsIGRpc3BZICk7XG5cbiAgLy8gbWlkIHRhcmdldFxuICAvL1xuXG4gIHZhciBtaWRYID0gcnMubWlkWDtcbiAgdmFyIG1pZFkgPSBycy5taWRZO1xuXG4gIGlmKCBpc0hheXN0YWNrICl7XG4gICAgbWlkWCA9ICggc3RhcnRYICsgZW5kWCApLzI7XG4gICAgbWlkWSA9ICggc3RhcnRZICsgZW5kWSApLzI7XG4gIH1cblxuICBkaXNwWCA9IGVuZFggLSBzdGFydFg7XG4gIGRpc3BZID0gZW5kWSAtIHN0YXJ0WTtcblxuICBpZiggaXNTZWxmICl7XG4gICAgZGlzcFggPSAtMTtcbiAgICBkaXNwWSA9IDE7XG4gIH0gZWxzZSBpZiggaXNTZWdtZW50cyApe1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICBpZiggcHRzLmxlbmd0aCAvIDIgJSAyID09PSAwICl7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMjtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcblxuICAgICAgZGlzcFggPSAoIHB0c1tpMl0gLSBwdHNbaTFdICk7XG4gICAgICBkaXNwWSA9ICggcHRzW2kyKzFdIC0gcHRzW2kxKzFdICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgIHZhciBpMyA9IGkyICsgMjtcblxuICAgICAgZGlzcFggPSAoIHB0c1tpMl0gLSBwdHNbaTFdICk7XG4gICAgICBkaXNwWSA9ICggcHRzW2kyKzFdIC0gcHRzW2kxKzFdICk7XG4gICAgfVxuICB9IGVsc2UgaWYoIGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCApe1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgdmFyIGNwdHMgPSBycy5jdHJscHRzO1xuICAgIHZhciBicDB4LCBicDB5O1xuICAgIHZhciBicDF4LCBicDF5O1xuXG4gICAgaWYoIGNwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDAgKXtcbiAgICAgIHZhciBwMCA9IHB0cy5sZW5ndGggLyAyIC0gMTsgLy8gc3RhcnRwdFxuICAgICAgdmFyIGljID0gcDAgKyAyO1xuICAgICAgdmFyIHAxID0gaWMgKyAyO1xuXG4gICAgICBicDB4ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuMCApO1xuICAgICAgYnAweSA9IG1hdGgucWJlemllckF0KCBwdHNbcDArMV0sIHB0c1tpYysxXSwgcHRzW3AxKzFdLCAwLjAgKTtcblxuICAgICAgYnAxeCA9IG1hdGgucWJlemllckF0KCBwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjAwMDEgKTtcbiAgICAgIGJwMXkgPSBtYXRoLnFiZXppZXJBdCggcHRzW3AwKzFdLCBwdHNbaWMrMV0sIHB0c1twMSsxXSwgMC4wMDAxICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpYyA9IHB0cy5sZW5ndGggLyAyIC0gMTsgLy8gY3RycHRcbiAgICAgIHZhciBwMCA9IGljIC0gMjsgLy8gc3RhcnRwdFxuICAgICAgdmFyIHAxID0gaWMgKyAyOyAvLyBlbmRwdFxuXG4gICAgICBicDB4ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuNDk5OSApO1xuICAgICAgYnAweSA9IG1hdGgucWJlemllckF0KCBwdHNbcDArMV0sIHB0c1tpYysxXSwgcHRzW3AxKzFdLCAwLjQ5OTkgKTtcblxuICAgICAgYnAxeCA9IG1hdGgucWJlemllckF0KCBwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjUgKTtcbiAgICAgIGJwMXkgPSBtYXRoLnFiZXppZXJBdCggcHRzW3AwKzFdLCBwdHNbaWMrMV0sIHB0c1twMSsxXSwgMC41ICk7XG4gICAgfVxuXG4gICAgZGlzcFggPSAoIGJwMXggLSBicDB4ICk7XG4gICAgZGlzcFkgPSAoIGJwMXkgLSBicDB5ICk7XG4gIH1cblxuICBycy5taWR0Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcCggZGlzcFgsIGRpc3BZICk7XG5cbiAgcnMubWlkRGlzcFggPSBkaXNwWDtcbiAgcnMubWlkRGlzcFkgPSBkaXNwWTtcblxuICAvLyBtaWQgc291cmNlXG4gIC8vXG5cbiAgZGlzcFggKj0gLTE7XG4gIGRpc3BZICo9IC0xO1xuXG4gIGlmKCBpc1NlZ21lbnRzICl7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgIGlmKCBwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDAgKXtcbiAgICAgIC8vIGFscmVhZHkgb2tcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgdmFyIGkzID0gaTIgKyAyO1xuXG4gICAgICBkaXNwWCA9IC0oIHB0c1tpM10gLSBwdHNbaTJdICk7XG4gICAgICBkaXNwWSA9IC0oIHB0c1tpMysxXSAtIHB0c1tpMisxXSApO1xuICAgIH1cbiAgfVxuXG4gIHJzLm1pZHNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKCBkaXNwWCwgZGlzcFkgKTtcblxuICAvLyB0YXJnZXRcbiAgLy9cblxuICBkaXNwWCA9IHRndFBvcy54IC0gZW5kWDtcbiAgZGlzcFkgPSB0Z3RQb3MueSAtIGVuZFk7XG5cbiAgcnMudGd0QXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoIGRpc3BYLCBkaXNwWSApO1xufTtcblxuXG5CUnAuZmluZEVuZHBvaW50cyA9IGZ1bmN0aW9uKCBlZGdlICl7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGludGVyc2VjdDtcblxuICB2YXIgc291cmNlID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgdmFyIHRhcmdldCA9IGVkZ2UudGFyZ2V0KClbMF07XG5cbiAgdmFyIHNyY19wID0gc291cmNlLl9wcml2YXRlO1xuICB2YXIgdGd0X3AgPSB0YXJnZXQuX3ByaXZhdGU7XG5cbiAgdmFyIHNyY1BvcyA9IHNyY19wLnBvc2l0aW9uO1xuICB2YXIgdGd0UG9zID0gdGd0X3AucG9zaXRpb247XG5cbiAgdmFyIHRndEFyU2hhcGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlWyd0YXJnZXQtYXJyb3ctc2hhcGUnXS52YWx1ZTtcbiAgdmFyIHNyY0FyU2hhcGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlWydzb3VyY2UtYXJyb3ctc2hhcGUnXS52YWx1ZTtcblxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gIHZhciBldCA9IHJzLmVkZ2VUeXBlO1xuICB2YXIgYmV6aWVyID0gZXQgPT09ICdiZXppZXInIHx8IGV0ID09PSAnbXVsdGliZXppZXInIHx8IGV0ID09PSAnc2VsZicgfHwgZXQgPT09ICdjb21wb3VuZCc7XG4gIHZhciBtdWx0aSA9IGV0ICE9PSAnYmV6aWVyJztcbiAgdmFyIGxpbmVzID0gZXQgPT09ICdzdHJhaWdodCcgfHwgZXQgPT09ICdzZWdtZW50cyc7XG4gIHZhciBzZWdtZW50cyA9IGV0ID09PSAnc2VnbWVudHMnO1xuXG4gIHZhciBwMSwgcDI7XG5cbiAgaWYoIGJlemllciApe1xuICAgIHZhciBjcFN0YXJ0ID0gWyBycy5jdHJscHRzWzBdLCBycy5jdHJscHRzWzFdIF07XG4gICAgdmFyIGNwRW5kID0gbXVsdGkgPyBbIHJzLmN0cmxwdHNbcnMuY3RybHB0cy5sZW5ndGggLSAyXSwgcnMuY3RybHB0c1tycy5jdHJscHRzLmxlbmd0aCAtIDFdIF0gOiBjcFN0YXJ0O1xuXG4gICAgcDEgPSBjcEVuZDtcbiAgICBwMiA9IGNwU3RhcnQ7XG4gIH0gZWxzZSBpZiggbGluZXMgKXtcbiAgICB2YXIgc3JjQXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbIHRndFBvcy54LCB0Z3RQb3MueSBdIDogcnMuc2VncHRzLnNsaWNlKCAwLCAyICk7XG4gICAgdmFyIHRndEFycm93RnJvbVB0ID0gIXNlZ21lbnRzID8gWyBzcmNQb3MueCwgc3JjUG9zLnkgXSA6IHJzLnNlZ3B0cy5zbGljZSggcnMuc2VncHRzLmxlbmd0aCAtIDIgKTtcblxuICAgIHAxID0gdGd0QXJyb3dGcm9tUHQ7XG4gICAgcDIgPSBzcmNBcnJvd0Zyb21QdDtcbiAgfVxuXG4gIGludGVyc2VjdCA9IHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZSh0YXJnZXQpXS5pbnRlcnNlY3RMaW5lKFxuICAgIHRndFBvcy54LFxuICAgIHRndFBvcy55LFxuICAgIHRhcmdldC5vdXRlcldpZHRoKCksXG4gICAgdGFyZ2V0Lm91dGVySGVpZ2h0KCksXG4gICAgcDFbMF0sXG4gICAgcDFbMV0sXG4gICAgMFxuICApO1xuXG4gIHZhciBhcnJvd0VuZCA9IG1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAxLFxuICAgIHIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uc3BhY2luZyhlZGdlKSk7XG4gIHZhciBlZGdlRW5kID0gbWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDEsXG4gICAgci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5nYXAoZWRnZSkpO1xuXG4gIHJzLmVuZFggPSBlZGdlRW5kWzBdO1xuICBycy5lbmRZID0gZWRnZUVuZFsxXTtcblxuICBycy5hcnJvd0VuZFggPSBhcnJvd0VuZFswXTtcbiAgcnMuYXJyb3dFbmRZID0gYXJyb3dFbmRbMV07XG5cbiAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHNvdXJjZSldLmludGVyc2VjdExpbmUoXG4gICAgc3JjUG9zLngsXG4gICAgc3JjUG9zLnksXG4gICAgc291cmNlLm91dGVyV2lkdGgoKSxcbiAgICBzb3VyY2Uub3V0ZXJIZWlnaHQoKSxcbiAgICBwMlswXSxcbiAgICBwMlsxXSxcbiAgICAwXG4gICk7XG5cbiAgdmFyIGFycm93U3RhcnQgPSBtYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oXG4gICAgaW50ZXJzZWN0LCBwMixcbiAgICByLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLnNwYWNpbmcoZWRnZSlcbiAgKTtcbiAgdmFyIGVkZ2VTdGFydCA9IG1hdGguc2hvcnRlbkludGVyc2VjdGlvbihcbiAgICBpbnRlcnNlY3QsIHAyLFxuICAgIHIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uZ2FwKGVkZ2UpXG4gICk7XG5cbiAgcnMuc3RhcnRYID0gZWRnZVN0YXJ0WzBdO1xuICBycy5zdGFydFkgPSBlZGdlU3RhcnRbMV07XG5cbiAgcnMuYXJyb3dTdGFydFggPSBhcnJvd1N0YXJ0WzBdO1xuICBycy5hcnJvd1N0YXJ0WSA9IGFycm93U3RhcnRbMV07XG5cbiAgaWYoIGxpbmVzICl7XG4gICAgaWYoICFpcy5udW1iZXIocnMuc3RhcnRYKSB8fCAhaXMubnVtYmVyKHJzLnN0YXJ0WSkgfHwgIWlzLm51bWJlcihycy5lbmRYKSB8fCAhaXMubnVtYmVyKHJzLmVuZFkpICl7XG4gICAgICBycy5iYWRMaW5lID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnMuYmFkTGluZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuQlJwLmdldEFycm93V2lkdGggPSBCUnAuZ2V0QXJyb3dIZWlnaHQgPSBmdW5jdGlvbihlZGdlV2lkdGgpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSB8fCB7fTtcblxuICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbZWRnZVdpZHRoXTtcbiAgaWYoIGNhY2hlZFZhbCApe1xuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH1cblxuICBjYWNoZWRWYWwgPSAgTWF0aC5tYXgoTWF0aC5wb3coZWRnZVdpZHRoICogMTMuMzcsIDAuOSksIDI5KTtcbiAgY2FjaGVbZWRnZVdpZHRoXSA9IGNhY2hlZFZhbDtcblxuICByZXR1cm4gY2FjaGVkVmFsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG5cbn0se1wiLi4vLi4vLi4vY29sbGVjdGlvbi96c29ydFwiOjI5LFwiLi4vLi4vLi4vaXNcIjo3NyxcIi4uLy4uLy4uL21hdGhcIjo3OX1dLDU3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEJScCA9IHt9O1xuXG5CUnAuZ2V0Q2FjaGVkSW1hZ2UgPSBmdW5jdGlvbih1cmwsIG9uTG9hZCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBpbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlIHx8IHt9O1xuXG4gIGlmKCBpbWFnZUNhY2hlW3VybF0gJiYgaW1hZ2VDYWNoZVt1cmxdLmltYWdlICl7XG4gICAgcmV0dXJuIGltYWdlQ2FjaGVbdXJsXS5pbWFnZTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IGltYWdlQ2FjaGVbdXJsXSA9IGltYWdlQ2FjaGVbdXJsXSB8fCB7fTtcblxuICB2YXIgaW1hZ2UgPSBjYWNoZS5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgaW1hZ2Uuc3JjID0gdXJsO1xuXG4gIHJldHVybiBpbWFnZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuXG59LHt9XSw1ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IF9kZXJlcV8oJy4uLy4uLy4uL2lzJyk7XG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uLy4uLy4uL3V0aWwnKTtcblxudmFyIEJhc2VSZW5kZXJlciA9IGZ1bmN0aW9uKCl7fTtcbnZhciBCUiA9IEJhc2VSZW5kZXJlcjtcbnZhciBCUnAgPSBCUi5wcm90b3R5cGU7XG5cbkJScC5jbGllbnRGdW5jdGlvbnMgPSBbICdyZWRyYXdIaW50JywgJ3JlbmRlcicsICdyZW5kZXJUbycsICdtYXRjaENhbnZhc1NpemUnLCAnbm9kZVNoYXBlSW1wbCcsICdhcnJvd1NoYXBlSW1wbCcgXTtcblxuQlJwLmluaXQgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgci5vcHRpb25zID0gb3B0aW9ucztcblxuICByLmN5ID0gb3B0aW9ucy5jeTtcblxuICByLmNvbnRhaW5lciA9IG9wdGlvbnMuY3kuY29udGFpbmVyKCk7XG5cbiAgci5zZWxlY3Rpb24gPSBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAwXTsgLy8gQ29vcmRpbmF0ZXMgZm9yIHNlbGVjdGlvbiBib3gsIHBsdXMgZW5hYmxlZCBmbGFnXG5cbiAgLy8tLVBvaW50ZXItcmVsYXRlZCBkYXRhXG4gIHIuaG92ZXJEYXRhID0ge2Rvd246IG51bGwsIGxhc3Q6IG51bGwsXG4gICAgICBkb3duVGltZTogbnVsbCwgdHJpZ2dlck1vZGU6IG51bGwsXG4gICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICBpbml0aWFsUGFuOiBbbnVsbCwgbnVsbF0sIGNhcHR1cmU6IGZhbHNlfTtcblxuICByLmRyYWdEYXRhID0ge3Bvc3NpYmxlRHJhZ0VsZW1lbnRzOiBbXX07XG5cbiAgci50b3VjaERhdGEgPSB7XG4gICAgICBzdGFydDogbnVsbCwgY2FwdHVyZTogZmFsc2UsXG5cbiAgICAgIC8vIFRoZXNlIDMgZmllbGRzIHJlbGF0ZWQgdG8gdGFwLCB0YXBob2xkIGV2ZW50c1xuICAgICAgc3RhcnRQb3NpdGlvbjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdLFxuICAgICAgc2luZ2xlVG91Y2hTdGFydFRpbWU6IG51bGwsXG4gICAgICBzaW5nbGVUb3VjaE1vdmVkOiB0cnVlLFxuXG4gICAgICBub3c6IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICAgIGVhcmxpZXI6IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXVxuICB9O1xuXG4gIHIucmVkcmF3cyA9IDA7XG4gIHIuc2hvd0ZwcyA9IG9wdGlvbnMuc2hvd0ZwcztcblxuICByLmhpZGVFZGdlc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gIHIuaGlkZUxhYmVsc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVMYWJlbHNPblZpZXdwb3J0O1xuICByLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgci53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICByLm1vdGlvbkJsdXJFbmFibGVkID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBvbiBieSBkZWZhdWx0XG4gIHIuZm9yY2VkUGl4ZWxSYXRpbyA9IG9wdGlvbnMucGl4ZWxSYXRpbztcbiAgci5tb3Rpb25CbHVyID0gdHJ1ZTsgLy8gZm9yIGluaXRpYWwga2ljayBvZmZcbiAgci5tb3Rpb25CbHVyT3BhY2l0eSA9IG9wdGlvbnMubW90aW9uQmx1ck9wYWNpdHk7XG4gIHIubW90aW9uQmx1clRyYW5zcGFyZW5jeSA9IDEgLSByLm1vdGlvbkJsdXJPcGFjaXR5O1xuICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgci5tYlB4UkJsdXJyeSA9IDE7IC8vMC44O1xuICByLm1pbk1iTG93UXVhbEZyYW1lcyA9IDQ7XG4gIHIuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyID0gW107XG4gIHIuZGVza3RvcFRhcFRocmVzaG9sZCA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgci5kZXNrdG9wVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCAqIG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgci50b3VjaFRhcFRocmVzaG9sZCA9IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gIHIudG91Y2hUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZCAqIG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gIHIudGFwaG9sZER1cmF0aW9uID0gNTAwO1xuXG4gIHIuYmluZGluZ3MgPSBbXTtcblxuICByLnJlZ2lzdGVyTm9kZVNoYXBlcygpO1xuICByLnJlZ2lzdGVyQXJyb3dTaGFwZXMoKTtcbiAgci5sb2FkKCk7XG59O1xuXG5CUnAubm90aWZ5ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciB0eXBlcztcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGlmKCBpcy5hcnJheSggcGFyYW1zLnR5cGUgKSApe1xuICAgIHR5cGVzID0gcGFyYW1zLnR5cGU7XG5cbiAgfSBlbHNlIHtcbiAgICB0eXBlcyA9IFsgcGFyYW1zLnR5cGUgXTtcbiAgfVxuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuXG4gICAgc3dpdGNoKCB0eXBlICl7XG4gICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgci5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAnYWRkJzpcbiAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICBjYXNlICdsb2FkJzpcbiAgICAgICAgci51cGRhdGVFbGVtZW50c0NhY2hlKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2aWV3cG9ydCc6XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgIHIudXBkYXRlQ2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYoIHR5cGUgPT09ICdsb2FkJyB8fCB0eXBlID09PSAncmVzaXplJyApe1xuICAgICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgICAgIHIubWF0Y2hDYW52YXNTaXplKHIuY29udGFpbmVyKTtcbiAgICB9XG4gIH0gLy8gZm9yXG5cbiAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gIHRoaXMuc3RhcnRSZW5kZXJMb29wKCk7XG5cbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5cbkJScC5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuXG4gIHRoaXMuY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMuYmluZGluZ3MubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbaV07XG4gICAgdmFyIGIgPSBiaW5kaW5nO1xuXG4gICAgYi50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihiLmV2ZW50LCBiLmhhbmRsZXIsIGIudXNlQ2FwdHVyZSk7XG4gIH1cblxuICBpZiggdGhpcy5yZW1vdmVPYnNlcnZlciApe1xuICAgIHRoaXMucmVtb3ZlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgaWYoIHRoaXMubGFiZWxDYWxjRGl2ICl7XG4gICAgdHJ5e1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmxhYmVsQ2FsY0Rpdik7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIC8vIGllMTAgaXNzdWUgIzEwMTRcbiAgICB9XG4gIH1cbn07XG5cbltcbiAgX2RlcmVxXygnLi9hcnJvdy1zaGFwZXMnKSxcbiAgX2RlcmVxXygnLi9jYWNoZWQtZWxlcycpLFxuICBfZGVyZXFfKCcuL2Nvb3JkLWVsZS1tYXRoJyksXG4gIF9kZXJlcV8oJy4vaW1hZ2VzJyksXG4gIF9kZXJlcV8oJy4vbG9hZC1saXN0ZW5lcnMnKSxcbiAgX2RlcmVxXygnLi9ub2RlLXNoYXBlcycpLFxuICBfZGVyZXFfKCcuL3JlZHJhdycpXG5dLmZvckVhY2goZnVuY3Rpb24oIHByb3BzICl7XG4gIHV0aWwuZXh0ZW5kKCBCUnAsIHByb3BzICk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUjtcblxufSx7XCIuLi8uLi8uLi9pc1wiOjc3LFwiLi4vLi4vLi4vdXRpbFwiOjk0LFwiLi9hcnJvdy1zaGFwZXNcIjo1NCxcIi4vY2FjaGVkLWVsZXNcIjo1NSxcIi4vY29vcmQtZWxlLW1hdGhcIjo1NixcIi4vaW1hZ2VzXCI6NTcsXCIuL2xvYWQtbGlzdGVuZXJzXCI6NTksXCIuL25vZGUtc2hhcGVzXCI6NjAsXCIuL3JlZHJhd1wiOjYxfV0sNTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi8uLi8uLi9pcycpO1xudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi8uLi8uLi91dGlsJyk7XG52YXIgRXZlbnQgPSBfZGVyZXFfKCcuLi8uLi8uLi9ldmVudCcpO1xudmFyIENvbGxlY3Rpb24gPSBfZGVyZXFfKCcuLi8uLi8uLi9jb2xsZWN0aW9uJyk7XG5cbnZhciBCUnAgPSB7fTtcblxuQlJwLnJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpe1xuICB0aGlzLmJpbmRpbmdzLnB1c2goe1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIGV2ZW50OiBldmVudCxcbiAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgIHVzZUNhcHR1cmU6IHVzZUNhcHR1cmVcbiAgfSk7XG5cbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xufTtcblxuQlJwLm5vZGVJc0RyYWdnYWJsZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKG5vZGUuX3ByaXZhdGUuc3R5bGVbJ29wYWNpdHknXS52YWx1ZSAhPT0gMFxuICAgICYmIG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3Zpc2liaWxpdHknXS52YWx1ZSA9PSAndmlzaWJsZSdcbiAgICAmJiBub2RlLl9wcml2YXRlLnN0eWxlWydkaXNwbGF5J10udmFsdWUgPT0gJ2VsZW1lbnQnXG4gICAgJiYgIW5vZGUubG9ja2VkKClcbiAgICAmJiBub2RlLmdyYWJiYWJsZSgpICkge1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5CUnAubG9hZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbiggdGFyZ2V0LCBuYW1lcywgZSwgcHJvcHMgKXtcbiAgICBpZiggdGFyZ2V0ID09IG51bGwgKXtcbiAgICAgIHRhcmdldCA9IHIuY3k7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcblxuICAgICAgdmFyIGV2ZW50ID0gRXZlbnQoIGUsIHV0aWwuZXh0ZW5kKHsgdHlwZTogbmFtZSB9LCBwcm9wcykgKTtcbiAgICAgIHRhcmdldC50cmlnZ2VyKCBldmVudCApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNNdWx0U2VsS2V5RG93biA9IGZ1bmN0aW9uKCBlICl7XG4gICAgcmV0dXJuIGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5IHx8IGUuY3RybEtleTsgLy8gbWF5YmUgZS5hbHRLZXlcbiAgfTtcblxuICB2YXIgZ2V0RHJhZ0xpc3RJZHMgPSBmdW5jdGlvbihvcHRzKXtcbiAgICB2YXIgbGlzdEhhc0lkO1xuXG4gICAgaWYoIG9wdHMuYWRkVG9MaXN0ICYmIHIuY3kuaGFzQ29tcG91bmROb2RlcygpICl7IC8vIG9ubHkgbmVlZGVkIGZvciBjb21wb3VuZCBncmFwaHNcbiAgICAgIGlmKCAhb3B0cy5hZGRUb0xpc3QuaGFzSWQgKXsgLy8gYnVpbGQgaWRzIGxvb2t1cCBpZiBkb2Vzbid0IGFscmVhZHkgZXhpc3RcbiAgICAgICAgb3B0cy5hZGRUb0xpc3QuaGFzSWQgPSB7fTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wdHMuYWRkVG9MaXN0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IG9wdHMuYWRkVG9MaXN0W2ldO1xuXG4gICAgICAgICAgb3B0cy5hZGRUb0xpc3QuaGFzSWRbIGVsZS5pZCgpIF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3RIYXNJZCA9IG9wdHMuYWRkVG9MaXN0Lmhhc0lkO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0SGFzSWQgfHwge307XG4gIH07XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBjaGlsZCBub2RlcyBhbmQgaW5uZXIgZWRnZXNcbiAgLy8gb2YgYSBjb21wb3VuZCBub2RlIHRvIGJlIGRyYWdnZWQgYXMgd2VsbCBhcyB0aGUgZ3JhYmJlZCBhbmQgc2VsZWN0ZWQgbm9kZXNcbiAgdmFyIGFkZERlc2NlbmRhbnRzVG9EcmFnID0gZnVuY3Rpb24obm9kZSwgb3B0cyl7XG4gICAgaWYoICFub2RlLl9wcml2YXRlLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyID09IG51bGwgJiYgb3B0cy5hZGRUb0xpc3QgPT0gbnVsbCApeyByZXR1cm47IH0gLy8gbm90aGluZyB0byBkb1xuXG4gICAgdmFyIGxpc3RIYXNJZCA9IGdldERyYWdMaXN0SWRzKCBvcHRzICk7XG5cbiAgICB2YXIgaW5uZXJOb2RlcyA9IG5vZGUuZGVzY2VuZGFudHMoKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgaW5uZXJOb2Rlcy5zaXplKCk7IGkrKyApe1xuICAgICAgdmFyIGlOb2RlID0gaW5uZXJOb2Rlc1tpXTtcbiAgICAgIHZhciBfcCA9IGlOb2RlLl9wcml2YXRlO1xuXG4gICAgICBpZiggb3B0cy5pbkRyYWdMYXllciApe1xuICAgICAgICBfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvcHRzLmFkZFRvTGlzdCAmJiAhbGlzdEhhc0lkWyBpTm9kZS5pZCgpIF0gKXtcbiAgICAgICAgb3B0cy5hZGRUb0xpc3QucHVzaCggaU5vZGUgKTtcbiAgICAgICAgbGlzdEhhc0lkWyBpTm9kZS5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgIF9wLmdyYWJiZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZXMgPSBfcC5lZGdlcztcbiAgICAgIGZvciggdmFyIGogPSAwOyBvcHRzLmluRHJhZ0xheWVyICYmIGogPCBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICBlZGdlc1tqXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGFkZHMgdGhlIGdpdmVuIG5vZGVzLCBhbmQgaXRzIGVkZ2VzIHRvIHRoZSBkcmFnIGxheWVyXG4gIHZhciBhZGROb2RlVG9EcmFnID0gZnVuY3Rpb24obm9kZSwgb3B0cyl7XG5cbiAgICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICAgIHZhciBsaXN0SGFzSWQgPSBnZXREcmFnTGlzdElkcyggb3B0cyApO1xuXG4gICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgKXtcbiAgICAgIF9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiggb3B0cy5hZGRUb0xpc3QgJiYgIWxpc3RIYXNJZFsgbm9kZS5pZCgpIF0gKXtcbiAgICAgIG9wdHMuYWRkVG9MaXN0LnB1c2goIG5vZGUgKTtcbiAgICAgIGxpc3RIYXNJZFsgbm9kZS5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICBfcC5ncmFiYmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZWRnZXMgPSBfcC5lZGdlcztcbiAgICBmb3IoIHZhciBpID0gMDsgb3B0cy5pbkRyYWdMYXllciAmJiBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGVkZ2VzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBhZGREZXNjZW5kYW50c1RvRHJhZyggbm9kZSwgb3B0cyApOyAvLyBhbHdheXMgYWRkIHRvIGRyYWdcblxuICAgIC8vIGFsc28gYWRkIG5vZGVzIGFuZCBlZGdlcyByZWxhdGVkIHRvIHRoZSB0b3Btb3N0IGFuY2VzdG9yXG4gICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIoIG5vZGUsIHtcbiAgICAgIGluRHJhZ0xheWVyOiBvcHRzLmluRHJhZ0xheWVyXG4gICAgfSApO1xuICB9O1xuXG4gIHZhciBmcmVlRHJhZ2dlZEVsZW1lbnRzID0gZnVuY3Rpb24oIGRyYWdnZWRFbGVtZW50cyApe1xuICAgIGlmKCAhZHJhZ2dlZEVsZW1lbnRzICl7IHJldHVybjsgfVxuXG4gICAgZm9yICh2YXIgaT0wOyBpIDwgZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIHZhciBkRWlfcCA9IGRyYWdnZWRFbGVtZW50c1tpXS5fcHJpdmF0ZTtcblxuICAgICAgaWYoZEVpX3AuZ3JvdXAgPT09ICdub2RlcycpIHtcbiAgICAgICAgZEVpX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgZEVpX3AuZ3JhYmJlZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBzRWRnZXMgPSBkRWlfcC5lZGdlcztcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzRWRnZXMubGVuZ3RoOyBqKysgKXsgc0VkZ2VzW2pdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7IH1cblxuICAgICAgICAvLyBmb3IgY29tcG91bmQgbm9kZXMsIGFsc28gcmVtb3ZlIHJlbGF0ZWQgbm9kZXMgYW5kIGVkZ2VzIGZyb20gdGhlIGRyYWcgbGF5ZXJcbiAgICAgICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIoZHJhZ2dlZEVsZW1lbnRzW2ldLCB7IGluRHJhZ0xheWVyOiBmYWxzZSB9KTtcblxuICAgICAgfSBlbHNlIGlmKCBkRWlfcC5ncm91cCA9PT0gJ2VkZ2VzJyApe1xuICAgICAgICBkRWlfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgfVxuICB9O1xuXG4gIC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggYW5jZXN0b3Igbm9kZXMgYW5kIGVkZ2VzIHNob3VsZCBnb1xuICAvLyB0byB0aGUgZHJhZyBsYXllciAob3Igc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBkcmFnIGxheWVyKS5cbiAgdmFyIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyID0gZnVuY3Rpb24obm9kZSwgb3B0cykge1xuXG4gICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsICl7IHJldHVybjsgfSAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAvLyBmaW5kIHRvcC1sZXZlbCBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gbm9kZTtcblxuICAgIGlmKCAhbm9kZS5fcHJpdmF0ZS5jeS5oYXNDb21wb3VuZE5vZGVzKCkgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSggcGFyZW50LnBhcmVudCgpLm5vbmVtcHR5KCkgKXtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQoKVswXTtcbiAgICB9XG5cbiAgICAvLyBubyBwYXJlbnQgbm9kZTogbm8gbm9kZXMgdG8gYWRkIHRvIHRoZSBkcmFnIGxheWVyXG4gICAgaWYoIHBhcmVudCA9PSBub2RlICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gcGFyZW50LmRlc2NlbmRhbnRzKClcbiAgICAgIC5tZXJnZSggcGFyZW50IClcbiAgICAgIC51bm1lcmdlKCBub2RlIClcbiAgICAgIC51bm1lcmdlKCBub2RlLmRlc2NlbmRhbnRzKCkgKVxuICAgIDtcblxuICAgIHZhciBlZGdlcyA9IG5vZGVzLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICB2YXIgbGlzdEhhc0lkID0gZ2V0RHJhZ0xpc3RJZHMoIG9wdHMgKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMuc2l6ZSgpOyBpKysgKXtcbiAgICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgbm9kZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBvcHRzLmluRHJhZ0xheWVyO1xuICAgICAgfVxuXG4gICAgICBpZiggb3B0cy5hZGRUb0xpc3QgJiYgIWxpc3RIYXNJZFsgbm9kZXNbaV0uaWQoKSBdICl7XG4gICAgICAgIG9wdHMuYWRkVG9MaXN0LnB1c2goIG5vZGVzW2ldICk7XG4gICAgICAgIGxpc3RIYXNJZFsgbm9kZXNbaV0uaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICBub2Rlc1tpXS5fcHJpdmF0ZS5ncmFiYmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IoIHZhciBqID0gMDsgb3B0cy5pbkRyYWdMYXllciAhPT0gdW5kZWZpbmVkICYmIGogPCBlZGdlcy5sZW5ndGg7IGorKyApIHtcbiAgICAgIGVkZ2VzW2pdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gb3B0cy5pbkRyYWdMYXllcjtcbiAgICB9XG4gIH07XG5cbiAgaWYoIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyApe1xuICAgIHIucmVtb3ZlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiggbXV0bnMgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbXV0bnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG11dG4gPSBtdXRuc1tpXTtcbiAgICAgICAgdmFyIHJOb2RlcyA9IG11dG4ucmVtb3ZlZE5vZGVzO1xuXG4gICAgICAgIGlmKCByTm9kZXMgKXsgZm9yKCB2YXIgaiA9IDA7IGogPCByTm9kZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgck5vZGUgPSByTm9kZXNbal07XG5cbiAgICAgICAgICBpZiggck5vZGUgPT09IHIuY29udGFpbmVyICl7XG4gICAgICAgICAgICByLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiggci5jb250YWluZXIucGFyZW50Tm9kZSApe1xuICAgICAgci5yZW1vdmVPYnNlcnZlci5vYnNlcnZlKCByLmNvbnRhaW5lci5wYXJlbnROb2RlLCB7IGNoaWxkTGlzdDogdHJ1ZSB9ICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnRE9NTm9kZVJlbW92ZWQnLCBmdW5jdGlvbihlKXtcbiAgICAgIHIuZGVzdHJveSgpO1xuICAgIH0pO1xuICB9XG5cblxuXG4gIC8vIGF1dG8gcmVzaXplXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3Jlc2l6ZScsIHV0aWwuZGVib3VuY2UoIGZ1bmN0aW9uKGUpIHtcbiAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuXG4gICAgci5tYXRjaENhbnZhc1NpemUoci5jb250YWluZXIpO1xuICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgIHIucmVkcmF3KCk7XG4gIH0sIDEwMCApICk7XG5cbiAgdmFyIGludmFsQ3RuckJCT25TY3JvbGwgPSBmdW5jdGlvbihkb21FbGUpe1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ3Njcm9sbCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgICB9ICk7XG4gIH07XG5cbiAgdmFyIGJiQ3RuciA9IHIuY3kuY29udGFpbmVyKCk7XG5cbiAgZm9yKCA7OyApe1xuXG4gICAgaW52YWxDdG5yQkJPblNjcm9sbCggYmJDdG5yICk7XG5cbiAgICBpZiggYmJDdG5yLnBhcmVudE5vZGUgKXtcbiAgICAgIGJiQ3RuciA9IGJiQ3Ruci5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgfVxuXG4gIC8vIHN0b3AgcmlnaHQgY2xpY2sgbWVudSBmcm9tIGFwcGVhcmluZyBvbiBjeVxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ2NvbnRleHRtZW51JywgZnVuY3Rpb24oZSl7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcblxuICB2YXIgaW5Cb3hTZWxlY3Rpb24gPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiByLnNlbGVjdGlvbls0XSAhPT0gMDtcbiAgfTtcblxuICAvLyBQcmltYXJ5IGtleVxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgci5ob3ZlckRhdGEud2hpY2ggPSBlLndoaWNoO1xuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuXG4gICAgci5ob3ZlckRhdGEubWRvd25Qb3MgPSBwb3M7XG5cbiAgICB2YXIgY2hlY2tGb3JUYXBob2xkID0gZnVuY3Rpb24oKXtcbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSBmYWxzZTtcblxuICAgICAgY2xlYXJUaW1lb3V0KCByLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCApO1xuXG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblxuICAgICAgICBpZiggci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCApe1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZWxlID0gci5ob3ZlckRhdGEuZG93bjtcblxuICAgICAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgICAgIGVsZS50cmlnZ2VyKCBFdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS50cmlnZ2VyKCBFdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgfTtcblxuICAgIC8vIFJpZ2h0IGNsaWNrIGJ1dHRvblxuICAgIGlmKCBlLndoaWNoID09IDMgKXtcblxuICAgICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIHZhciBjeHRFdnQgPSBFdmVudChlLCB7XG4gICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfSk7XG5cbiAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgbmVhci50cmlnZ2VyKCBjeHRFdnQgKTtcblxuICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgfVxuXG4gICAgICByLmhvdmVyRGF0YS5kb3duVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG5cbiAgICAvLyBQcmltYXJ5IGJ1dHRvblxuICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSAxKSB7XG5cbiAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gRWxlbWVudCBkcmFnZ2luZ1xuICAgICAge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgdW5kZXIgdGhlIGN1cnNvciBhbmQgaXQgaXMgZHJhZ2dhYmxlLCBwcmVwYXJlIHRvIGdyYWIgaXRcbiAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuXG4gICAgICAgICAgaWYoIHIubm9kZUlzRHJhZ2dhYmxlKG5lYXIpICl7XG5cbiAgICAgICAgICAgIHZhciBncmFiRXZlbnQgPSBFdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdncmFiJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCBuZWFyLmlzTm9kZSgpICYmICFuZWFyLnNlbGVjdGVkKCkgKXtcblxuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIG5lYXIsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHMgfSApO1xuXG4gICAgICAgICAgICAgIG5lYXIudHJpZ2dlcihncmFiRXZlbnQpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBuZWFyLmlzTm9kZSgpICYmIG5lYXIuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gWyAgXTtcblxuICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IGN5LiQoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuaXNOb2RlKCkgJiYgdGhpcy5zZWxlY3RlZCgpOyB9KTtcblxuICAgICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGVjdGVkTm9kZXMubGVuZ3RoOyBpKysgKXtcblxuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoaXMgc2VsZWN0ZWQgbm9kZSB0byBkcmFnIGlmIGl0IGlzIGRyYWdnYWJsZSwgZWcuIGhhcyBub256ZXJvIG9wYWNpdHlcbiAgICAgICAgICAgICAgICBpZiggci5ub2RlSXNEcmFnZ2FibGUoIHNlbGVjdGVkTm9kZXNbaV0gKSApe1xuICAgICAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggc2VsZWN0ZWROb2Rlc1tpXSwgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50cyB9ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBncmFiRXZlbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuZG93biA9IG5lYXI7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckV2ZW50cyggbmVhciwgWydtb3VzZWRvd24nLCAndGFwc3RhcnQnLCAndm1vdXNlZG93biddLCBlLCB7XG4gICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfSApO1xuXG4gICAgICBpZiAoIG5lYXIgPT0gbnVsbCApIHtcbiAgICAgICAgc2VsZWN0WzRdID0gMTtcblxuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9O1xuXG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0gZWxzZSBpZiggbmVhci5pc0VkZ2UoKSApe1xuICAgICAgICBzZWxlY3RbNF0gPSAxOyAvLyBmb3IgZnV0dXJlIHBhblxuICAgICAgfVxuXG4gICAgICBjaGVja0ZvclRhcGhvbGQoKTtcblxuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgc2VsZWN0aW9uIGJveCBjb29yZGluYXRlc1xuICAgIHNlbGVjdFswXSA9IHNlbGVjdFsyXSA9IHBvc1swXTtcbiAgICBzZWxlY3RbMV0gPSBzZWxlY3RbM10gPSBwb3NbMV07XG5cbiAgfSwgZmFsc2UpO1xuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICB2YXIgY2FwdHVyZSA9IHIuaG92ZXJEYXRhLmNhcHR1cmU7XG5cbiAgICAvLyBzYXZlIGN5Y2xlcyBpZiBtb3VzZSBldmVudHMgYXJlbid0IHRvIGJlIGNhcHR1cmVkXG4gICAgaWYgKCAhY2FwdHVyZSApe1xuICAgICAgdmFyIGNvbnRhaW5lclBhZ2VDb29yZHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcblxuICAgICAgaWYgKGUuY2xpZW50WCA+IGNvbnRhaW5lclBhZ2VDb29yZHNbMF0gJiYgZS5jbGllbnRYIDwgY29udGFpbmVyUGFnZUNvb3Jkc1swXSArIHIuY2FudmFzV2lkdGhcbiAgICAgICAgJiYgZS5jbGllbnRZID4gY29udGFpbmVyUGFnZUNvb3Jkc1sxXSAmJiBlLmNsaWVudFkgPCBjb250YWluZXJQYWdlQ29vcmRzWzFdICsgci5jYW52YXNIZWlnaHRcbiAgICAgICkge1xuICAgICAgICAvLyBpbnNpZGUgY29udGFpbmVyIGJvdW5kcyBzbyBPS1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3lDb250YWluZXIgPSByLmNvbnRhaW5lcjtcbiAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgIHZhciB0UGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICB2YXIgY29udGFpbmVySXNUYXJnZXQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUoIHRQYXJlbnQgKXtcbiAgICAgICAgaWYoIHRQYXJlbnQgPT09IGN5Q29udGFpbmVyICl7XG4gICAgICAgICAgY29udGFpbmVySXNUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdFBhcmVudCA9IHRQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYoICFjb250YWluZXJJc1RhcmdldCApeyByZXR1cm47IH0gLy8gaWYgdGFyZ2V0IGlzIG91dGlzZGUgY3kgY29udGFpbmVyLCB0aGVuIHRoaXMgZXZlbnQgaXMgbm90IGZvciB1c1xuICAgIH1cblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuXG4gICAgdmFyIG5lYXIgPSBudWxsO1xuICAgIGlmKCAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICl7XG4gICAgICBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIGxhc3QgPSByLmhvdmVyRGF0YS5sYXN0O1xuICAgIHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcblxuICAgIHZhciBkaXNwID0gW3Bvc1swXSAtIHNlbGVjdFsyXSwgcG9zWzFdIC0gc2VsZWN0WzNdXTtcblxuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuXG4gICAgdmFyIGR4ID0gc2VsZWN0WzJdIC0gc2VsZWN0WzBdO1xuICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgIHZhciBkeSA9IHNlbGVjdFszXSAtIHNlbGVjdFsxXTtcbiAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgdmFyIHJkaXN0MiA9IGRpc3QyICogem9vbSAqIHpvb207XG5cbiAgICB2YXIgbXVsdFNlbEtleURvd24gPSBpc011bHRTZWxLZXlEb3duKCBlICk7XG5cbiAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcblxuICAgIHZhciB1cGRhdGVEcmFnRGVsdGEgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgaWYoIGRyYWdEZWx0YS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgZHJhZ0RlbHRhLnB1c2goIGRpc3BbMF0gKTtcbiAgICAgICAgZHJhZ0RlbHRhLnB1c2goIGRpc3BbMV0gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG5cbiAgICB0cmlnZ2VyRXZlbnRzKCBuZWFyLCBbJ21vdXNlbW92ZScsICd2bW91c2Vtb3ZlJywgJ3RhcGRyYWcnXSwgZSwge1xuICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgfSApO1xuXG4gICAgLy8gdHJpZ2dlciBjb250ZXh0IGRyYWcgaWYgcm1vdXNlIGRvd25cbiAgICBpZiggci5ob3ZlckRhdGEud2hpY2ggPT09IDMgKXtcbiAgICAgIHZhciBjeHRFdnQgPSBFdmVudChlLCB7XG4gICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9KTtcblxuICAgICAgaWYoIGRvd24gKXtcbiAgICAgICAgZG93bi50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgfVxuXG4gICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgaWYoICFyLmhvdmVyRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIuaG92ZXJEYXRhLmN4dE92ZXIgKXtcblxuICAgICAgICBpZiggci5ob3ZlckRhdGEuY3h0T3ZlciApe1xuICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIudHJpZ2dlciggRXZlbnQoZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgfSkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgbmVhci50cmlnZ2VyKCBFdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ292ZXInLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgfSkgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBhcmUgZHJhZyBwYW5uaW5nIHRoZSBlbnRpcmUgZ3JhcGhcbiAgICB9IGVsc2UgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSB7XG4gICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG5cbiAgICAgIGlmKCBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICl7XG4gICAgICAgIHZhciBkZWx0YVA7XG5cbiAgICAgICAgaWYoIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuICl7XG4gICAgICAgICAgdmFyIG1kUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG5cbiAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICB4OiAoIHBvc1swXSAtIG1kUG9zWzBdICkgKiB6b29tLFxuICAgICAgICAgICAgeTogKCBwb3NbMV0gLSBtZFBvc1sxXSApICogem9vbVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IGZhbHNlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGN5LnBhbkJ5KCBkZWx0YVAgKTtcblxuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTmVlZHMgcmVwcm9qZWN0IGR1ZSB0byBwYW4gY2hhbmdpbmcgdmlld3BvcnRcbiAgICAgIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cbiAgICAvLyBDaGVja3MgcHJpbWFyeSBidXR0b24gZG93biAmIG91dCBvZiB0aW1lICYgbW91c2Ugbm90IG1vdmVkIG11Y2hcbiAgICB9IGVsc2UgaWYoXG4gICAgICAgIHNlbGVjdFs0XSA9PSAxICYmIChkb3duID09IG51bGwgfHwgZG93bi5pc0VkZ2UoKSlcbiAgICApe1xuXG4gICAgICBpZiggIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiAoIG11bHRTZWxLZXlEb3duIHx8ICFjeS5wYW5uaW5nRW5hYmxlZCgpIHx8ICFjeS51c2VyUGFubmluZ0VuYWJsZWQoKSApICl7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcblxuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuXG4gICAgICB9IGVsc2UgaWYoICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSApe1xuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gdHJ1ZTtcbiAgICAgICAgc2VsZWN0WzRdID0gMDtcblxuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9O1xuXG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBkb3duICYmIGRvd24uaXNFZGdlKCkgJiYgZG93bi5hY3RpdmUoKSApeyBkb3duLnVuYWN0aXZhdGUoKTsgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCBkb3duICYmIGRvd24uaXNFZGdlKCkgJiYgZG93bi5hY3RpdmUoKSApeyBkb3duLnVuYWN0aXZhdGUoKTsgfVxuXG4gICAgICBpZiAobmVhciAhPSBsYXN0KSB7XG5cbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKCBsYXN0LCBbJ21vdXNlb3V0JywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKCBuZWFyLCBbJ21vdXNlb3ZlcicsICd0YXBkcmFnb3ZlciddLCBlLCB7XG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgIH1cblxuICAgICAgaWYoIGRvd24gJiYgZG93bi5pc05vZGUoKSAmJiByLm5vZGVJc0RyYWdnYWJsZShkb3duKSApe1xuXG4gICAgICAgIGlmKCByZGlzdDIgPj0gci5kZXNrdG9wVGFwVGhyZXNob2xkMiApeyAvLyB0aGVuIGRyYWdcblxuICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuXG4gICAgICAgICAgaWYoIGp1c3RTdGFydGVkRHJhZyApIHtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7IC8vIGluZGljYXRlIHRoYXQgd2UgYWN0dWFsbHkgZGlkIGRyYWcgdGhlIG5vZGVcblxuICAgICAgICAgIHZhciB0b1RyaWdnZXIgPSBbXTtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZEVsZSA9IGRyYWdnZWRFbGVtZW50c1tpXTtcblxuICAgICAgICAgICAgLy8gbm93LCBhZGQgdGhlIGVsZW1lbnRzIHRvIHRoZSBkcmFnIGxheWVyIGlmIG5vdCBkb25lIGFscmVhZHlcbiAgICAgICAgICAgIGlmKCAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICl7XG4gICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIGRFbGUsIHsgaW5EcmFnTGF5ZXI6IHRydWUgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMb2NrZWQgbm9kZXMgbm90IGRyYWdnYWJsZSwgYXMgd2VsbCBhcyBub24tdmlzaWJsZSBub2Rlc1xuICAgICAgICAgICAgaWYoIGRFbGUuaXNOb2RlKCkgJiYgci5ub2RlSXNEcmFnZ2FibGUoZEVsZSkgJiYgZEVsZS5ncmFiYmVkKCkgKXtcbiAgICAgICAgICAgICAgdmFyIGRQb3MgPSBkRWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICAgICAgICAgIHRvVHJpZ2dlci5wdXNoKCBkRWxlICk7XG5cbiAgICAgICAgICAgICAgaWYoIGlzLm51bWJlcihkaXNwWzBdKSAmJiBpcy5udW1iZXIoZGlzcFsxXSkgKXtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlUG9zID0gIWRFbGUuaXNQYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgIGlmKCB1cGRhdGVQb3MgKXtcbiAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICAgICAgZFBvcy55ICs9IGRpc3BbMV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIGp1c3RTdGFydGVkRHJhZyApe1xuICAgICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgICAgaWYoIHVwZGF0ZVBvcyAmJiBpcy5udW1iZXIoZHJhZ0RlbHRhWzBdKSAmJiBpcy5udW1iZXIoZHJhZ0RlbHRhWzFdKSApe1xuICAgICAgICAgICAgICAgICAgICBkUG9zLnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciB0Y29sID0gKENvbGxlY3Rpb24oY3ksIHRvVHJpZ2dlcikpO1xuXG4gICAgICAgICAgdGNvbC51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICAgIHRjb2wudHJpZ2dlcigncG9zaXRpb24gZHJhZycpO1xuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXcoKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2Ugc2F2ZSBkcmFnIGRlbHRhIGZvciB3aGVuIHdlIGFjdHVhbGx5IHN0YXJ0IGRyYWdnaW5nIHNvIHRoZSByZWxhdGl2ZSBncmFiIHBvcyBpcyBjb25zdGFudFxuICAgICAgICAgIHVwZGF0ZURyYWdEZWx0YSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXZlbnQgdGhlIGRyYWdnaW5nIGZyb20gdHJpZ2dlcmluZyB0ZXh0IHNlbGVjdGlvbiBvbiB0aGUgcGFnZVxuICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgIH1cblxuICAgIHNlbGVjdFsyXSA9IHBvc1swXTsgc2VsZWN0WzNdID0gcG9zWzFdO1xuXG4gICAgaWYoIHByZXZlbnREZWZhdWx0ICl7XG4gICAgICBpZihlLnN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH0sIGZhbHNlKTtcblxuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcbiAgICBpZiAoIWNhcHR1cmUpIHsgcmV0dXJuOyB9XG4gICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgdmFyIGN5ID0gci5jeTsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7IHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7IHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICB2YXIgbXVsdFNlbEtleURvd24gPSBpc011bHRTZWxLZXlEb3duKCBlICk7XG5cbiAgICBpZiggci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uICl7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcblxuICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDsgLy8gbm90IGFjdGl2ZSBiZyBub3dcblxuICAgIGlmKCBkb3duICl7XG4gICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBpZiggci5ob3ZlckRhdGEud2hpY2ggPT09IDMgKXtcbiAgICAgIHZhciBjeHRFdnQgPSBFdmVudChlLCB7XG4gICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiggZG93biApe1xuICAgICAgICBkb3duLnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCApe1xuICAgICAgICB2YXIgY3h0VGFwID0gRXZlbnQoZSwge1xuICAgICAgICAgIHR5cGU6ICdjeHR0YXAnLFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiggZG93biApe1xuICAgICAgICAgIGRvd24udHJpZ2dlciggY3h0VGFwICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3h0VGFwICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEud2hpY2ggPSBudWxsO1xuXG4gICAgfSBlbHNlIGlmKCByLmhvdmVyRGF0YS53aGljaCA9PT0gMSApIHtcblxuICAgICAgLy8gRGVzZWxlY3QgYWxsIGVsZW1lbnRzIGlmIG5vdGhpbmcgaXMgY3VycmVudGx5IHVuZGVyIHRoZSBtb3VzZSBjdXJzb3IgYW5kIHdlIGFyZW4ndCBkcmFnZ2luZyBzb21ldGhpbmdcbiAgICAgIGlmICggKGRvd24gPT0gbnVsbCkgLy8gbm90IG1vdXNlZG93biBvbiBub2RlXG4gICAgICAgICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IG1vdmUgdGhlIG5vZGUgYXJvdW5kXG4gICAgICAgICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnZWQgLy8gZGlkbid0IHBhblxuICAgICAgICAmJiAhaXNNdWx0U2VsS2V5RG93biggZSApXG4gICAgICApIHtcblxuICAgICAgICBjeS4kKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQoKTtcbiAgICAgICAgfSkudW5zZWxlY3QoKTtcblxuICAgICAgICBpZiAoZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBkcmFnZ2VkRWxlbWVudHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckV2ZW50cyggbmVhciwgWydtb3VzZXVwJywgJ3RhcGVuZCcsICd2bW91c2V1cCddLCBlLCB7XG4gICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfSApO1xuXG4gICAgICBpZihcbiAgICAgICAgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSBhIG5vZGUgYXJvdW5kXG4gICAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICl7XG4gICAgICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsnY2xpY2snLCAndGFwJywgJ3ZjbGljayddLCBlLCB7XG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgIH0gKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2luZ2xlIHNlbGVjdGlvblxuICAgICAgaWYoIG5lYXIgPT0gZG93biAmJiAhci5kcmFnRGF0YS5kaWREcmFnICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgICAgaWYoIG5lYXIgIT0gbnVsbCAmJiBuZWFyLl9wcml2YXRlLnNlbGVjdGFibGUgKXtcblxuICAgICAgICAgIGlmKCByLmhvdmVyRGF0YS5kcmFnZ2luZyApe1xuICAgICAgICAgICAgLy8gaWYgcGFubmluZywgZG9uJ3QgY2hhbmdlIHNlbGVjdGlvbiBzdGF0ZVxuICAgICAgICAgIH0gZWxzZSBpZiggY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnIHx8IG11bHRTZWxLZXlEb3duICl7XG4gICAgICAgICAgICBpZiggbmVhci5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICAgIG5lYXIudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5lYXIuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCAhbXVsdFNlbEtleURvd24gKXtcbiAgICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5tZXJnZSggbmVhciApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICAgIG5lYXIuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCByLmhvdmVyRGF0YS5zZWxlY3RpbmcgKSB7XG4gICAgICAgIHZhciBuZXdseVNlbGVjdGVkID0gW107XG4gICAgICAgIHZhciBib3ggPSByLmdldEFsbEluQm94KCBzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10gKTtcblxuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICAgIGlmKCBib3gubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYm94Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgaWYoIGJveFtpXS5fcHJpdmF0ZS5zZWxlY3RhYmxlICl7XG4gICAgICAgICAgICBuZXdseVNlbGVjdGVkLnB1c2goIGJveFtpXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdseVNlbENvbCA9IENvbGxlY3Rpb24oIGN5LCBuZXdseVNlbGVjdGVkICk7XG5cbiAgICAgICAgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJyApe1xuICAgICAgICAgIG5ld2x5U2VsQ29sLnNlbGVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKCAhbXVsdFNlbEtleURvd24gKXtcbiAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLnVubWVyZ2UoIG5ld2x5U2VsQ29sICkudW5zZWxlY3QoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdseVNlbENvbC5zZWxlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsd2F5cyBuZWVkIHJlZHJhdyBpbiBjYXNlIGVsZXMgdW5zZWxlY3RhYmxlXG4gICAgICAgIHIucmVkcmF3KCk7XG5cbiAgICAgIH1cblxuICAgICAgLy8gQ2FuY2VsIGRyYWcgcGFuXG4gICAgICBpZiggci5ob3ZlckRhdGEuZHJhZ2dpbmcgKXtcbiAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcblxuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGVjdFs0XSkge1xuXG5cbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuXG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoIGRyYWdnZWRFbGVtZW50cyApO1xuXG4gICAgICAgIGlmKCBkb3duICl7IGRvd24udHJpZ2dlcignZnJlZScpOyB9XG4gICAgICB9XG5cbiAgICB9IC8vIGVsc2Ugbm90IHJpZ2h0IG1vdXNlXG5cbiAgICBzZWxlY3RbNF0gPSAwOyByLmhvdmVyRGF0YS5kb3duID0gbnVsbDtcblxuICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICByLmRyYWdEYXRhLmRpZERyYWcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gW107XG5cbiAgfSwgZmFsc2UpO1xuXG4gIHZhciB3aGVlbEhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG5cblxuICAgIGlmKCByLnNjcm9sbGluZ1BhZ2UgKXsgcmV0dXJuOyB9IC8vIHdoaWxlIHNjcm9sbGluZywgaWdub3JlIHdoZWVsLXRvLXpvb21cblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgdmFyIHJwb3MgPSBbcG9zWzBdICogY3kuem9vbSgpICsgY3kucGFuKCkueCxcbiAgICAgICAgICAgICAgICAgIHBvc1sxXSAqIGN5Lnpvb20oKSArIGN5LnBhbigpLnldO1xuXG4gICAgaWYoIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLmhvdmVyRGF0YS5jeHRTdGFydGVkIHx8IGluQm94U2VsZWN0aW9uKCkgKXsgLy8gaWYgcGFuIGRyYWdnaW5nIG9yIGN4dCBkcmFnZ2luZywgd2hlZWwgbW92ZW1lbnRzIG1ha2Ugbm8gem9vbVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKCBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kudXNlclpvb21pbmdFbmFibGVkKCkgKXtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IHRydWU7XG4gICAgICBjbGVhclRpbWVvdXQoIHIuZGF0YS53aGVlbFRpbWVvdXQgKTtcbiAgICAgIHIuZGF0YS53aGVlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSBmYWxzZTtcblxuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0sIDE1MCk7XG5cbiAgICAgIHZhciBkaWZmID0gZS5kZWx0YVkgLyAtMjUwIHx8IGUud2hlZWxEZWx0YVkgLyAxMDAwIHx8IGUud2hlZWxEZWx0YSAvIDEwMDA7XG4gICAgICBkaWZmID0gZGlmZiAqIHIud2hlZWxTZW5zaXRpdml0eTtcblxuICAgICAgdmFyIG5lZWRzV2hlZWxGaXggPSBlLmRlbHRhTW9kZSA9PT0gMTtcbiAgICAgIGlmKCBuZWVkc1doZWVsRml4ICl7IC8vIGZpeGVzIHNsb3cgd2hlZWwgZXZlbnRzIG9uIGZmL2xpbnV4IGFuZCBmZi93aW5kb3dzXG4gICAgICAgIGRpZmYgKj0gMzM7XG4gICAgICB9XG5cbiAgICAgIGN5Lnpvb20oe1xuICAgICAgICBsZXZlbDogY3kuem9vbSgpICogTWF0aC5wb3coMTAsIGRpZmYpLFxuICAgICAgICByZW5kZXJlZFBvc2l0aW9uOiB7IHg6IHJwb3NbMF0sIHk6IHJwb3NbMV0gfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH07XG5cbiAgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCB3aGV0aGVyIG1vdXNlIHdoZWVsIHNob3VsZCB0cmlnZ2VyIHpvb21pbmdcbiAgLy8gLS1cbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICd3aGVlbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG5cbiAgLy8gZGlzYWJsZSBub25zdGFuZGFyZCB3aGVlbCBldmVudHNcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZXdoZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdET01Nb3VzZVNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7IC8vIG9sZGVyIGZpcmVmb3hcblxuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdzY3JvbGwnLCBmdW5jdGlvbihlKXtcbiAgICByLnNjcm9sbGluZ1BhZ2UgPSB0cnVlO1xuXG4gICAgY2xlYXJUaW1lb3V0KCByLnNjcm9sbGluZ1BhZ2VUaW1lb3V0ICk7XG4gICAgci5zY3JvbGxpbmdQYWdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHIuc2Nyb2xsaW5nUGFnZSA9IGZhbHNlO1xuICAgIH0sIDI1MCk7XG4gIH0sIHRydWUpO1xuXG4gIC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggaGFuZGxpbmcgbW91c2VvdXQvbW91c2VvdmVyIG9uIHRoZSBDeXRvc2NhcGUgY29udGFpbmVyXG4gICAgICAgIC8vIEhhbmRsZSBtb3VzZW91dCBvbiBDeXRvc2NhcGUgY29udGFpbmVyXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2VvdXQnLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cbiAgICByLmN5LnRyaWdnZXIoRXZlbnQoZSwge1xuICAgICAgdHlwZTogJ21vdXNlb3V0JyxcbiAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgIH0pKTtcbiAgfSwgZmFsc2UpO1xuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2VvdmVyJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuXG4gICAgci5jeS50cmlnZ2VyKEV2ZW50KGUsIHtcbiAgICAgIHR5cGU6ICdtb3VzZW92ZXInLFxuICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgfSkpO1xuICB9LCBmYWxzZSk7XG5cbiAgdmFyIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTE7IC8vIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuICB2YXIgZGlzdGFuY2UxLCBkaXN0YW5jZTFTcTsgLy8gaW5pdGlhbCBkaXN0YW5jZSBiZXR3ZWVuIGZpbmdlciAxIGFuZCBmaW5nZXIgMiBmb3IgcGluY2gtdG8tem9vbVxuICB2YXIgY2VudGVyMSwgbW9kZWxDZW50ZXIxOyAvLyBjZW50ZXIgcG9pbnQgb24gc3RhcnQgcGluY2ggdG8gem9vbVxuICB2YXIgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wO1xuICB2YXIgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodDtcbiAgdmFyIHR3b0ZpbmdlcnNTdGFydEluc2lkZTtcblxuICB2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mil7XG4gICAgcmV0dXJuIE1hdGguc3FydCggKHgyLXgxKSooeDIteDEpICsgKHkyLXkxKSooeTIteTEpICk7XG4gIH07XG5cbiAgdmFyIGRpc3RhbmNlU3EgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mil7XG4gICAgcmV0dXJuICh4Mi14MSkqKHgyLXgxKSArICh5Mi15MSkqKHkyLXkxKTtcbiAgfTtcblxuICB2YXIgdG91Y2hzdGFydEhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnRIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIG5vZGVzID0gci5nZXRDYWNoZWROb2RlcygpO1xuICAgIHZhciBlZGdlcyA9IHIuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcblxuICAgIGlmIChlLnRvdWNoZXNbMF0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpOyBub3dbMl0gPSBwb3NbMF07IG5vd1szXSA9IHBvc1sxXTsgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG5cbiAgICAvLyByZWNvcmQgc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG4gICAgaWYoIGUudG91Y2hlc1sxXSApe1xuXG4gICAgICAvLyBhbnl0aGluZyBpbiB0aGUgc2V0IG9mIGRyYWdnZWQgZWxlcyBzaG91bGQgYmUgcmVsZWFzZWRcbiAgICAgIHZhciByZWxlYXNlID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgZWxlc1tpXS5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgZWxlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICAgIGlmKCBlbGVzW2ldLmFjdGl2ZSgpICl7IGVsZXNbaV0udW5hY3RpdmF0ZSgpOyB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWxlYXNlKG5vZGVzKTtcbiAgICAgIHJlbGVhc2UoZWRnZXMpO1xuXG4gICAgICB2YXIgb2Zmc2V0cyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gICAgICBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICAgICAgY29udGFpbmVyV2lkdGggPSBvZmZzZXRzWzJdO1xuICAgICAgY29udGFpbmVySGVpZ2h0ID0gb2Zmc2V0c1szXTtcblxuICAgICAgZjF4MSA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgIGYxeTEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuICAgICAgZjJ4MSA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgIGYyeTEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuICAgICAgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlID1cbiAgICAgICAgICAgMCA8PSBmMXgxICYmIGYxeDEgPD0gY29udGFpbmVyV2lkdGhcbiAgICAgICAgJiYgMCA8PSBmMngxICYmIGYyeDEgPD0gY29udGFpbmVyV2lkdGhcbiAgICAgICAgJiYgMCA8PSBmMXkxICYmIGYxeTEgPD0gY29udGFpbmVySGVpZ2h0XG4gICAgICAgICYmIDAgPD0gZjJ5MSAmJiBmMnkxIDw9IGNvbnRhaW5lckhlaWdodFxuICAgICAgO1xuXG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UoIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTEgKTtcbiAgICAgIGRpc3RhbmNlMVNxID0gZGlzdGFuY2VTcSggZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSApO1xuICAgICAgY2VudGVyMSA9IFsgKGYxeDEgKyBmMngxKS8yLCAoZjF5MSArIGYyeTEpLzIgXTtcbiAgICAgIG1vZGVsQ2VudGVyMSA9IFtcbiAgICAgICAgKGNlbnRlcjFbMF0gLSBwYW4ueCkgLyB6b29tLFxuICAgICAgICAoY2VudGVyMVsxXSAtIHBhbi55KSAvIHpvb21cbiAgICAgIF07XG5cbiAgICAgIC8vIGNvbnNpZGVyIGNvbnRleHQgdGFwXG4gICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZCA9IDIwMDtcbiAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkU3EgPSBjeHREaXN0VGhyZXNob2xkICogY3h0RGlzdFRocmVzaG9sZDtcbiAgICAgIGlmKCBkaXN0YW5jZTFTcSA8IGN4dERpc3RUaHJlc2hvbGRTcSAmJiAhZS50b3VjaGVzWzJdICl7XG5cbiAgICAgICAgdmFyIG5lYXIxID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICB2YXIgbmVhcjIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMl0sIG5vd1szXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYoIG5lYXIxICYmIG5lYXIxLmlzTm9kZSgpICl7XG4gICAgICAgICAgbmVhcjEuYWN0aXZhdGUoKS50cmlnZ2VyKCBFdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgfSkgKTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIxO1xuXG4gICAgICAgIH0gZWxzZSBpZiggbmVhcjIgJiYgbmVhcjIuaXNOb2RlKCkgKXtcbiAgICAgICAgICBuZWFyMi5hY3RpdmF0ZSgpLnRyaWdnZXIoIEV2ZW50KGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KSApO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjI7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBFdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgfSkgKTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlOyB9XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IHRydWU7XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuXG4gICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIHtcblxuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG5cbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyO1xuXG4gICAgICAgIGlmKCBuZWFyLmlzTm9kZSgpICYmIHIubm9kZUlzRHJhZ2dhYmxlKG5lYXIpICl7XG5cbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXMgPSBbXTtcblxuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgICAgaWYoIG5lYXIuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgLy8gcmVzZXQgZHJhZyBlbGVtZW50cywgc2luY2UgbmVhciB3aWxsIGJlIGFkZGVkIGFnYWluXG5cbiAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc05vZGUoKSAmJiB0aGlzLnNlbGVjdGVkKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBzZWxlY3RlZE5vZGVzLmxlbmd0aDsgaysrICl7XG4gICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGUgPSBzZWxlY3RlZE5vZGVzW2tdO1xuXG4gICAgICAgICAgICAgIGlmKCByLm5vZGVJc0RyYWdnYWJsZShzZWxlY3RlZE5vZGUpICl7XG4gICAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggc2VsZWN0ZWROb2RlLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZXMgfSApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIG5lYXIsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlcyB9ICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmVhci50cmlnZ2VyKCBFdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnZ3JhYicsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsndG91Y2hzdGFydCcsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJ10sIGUsIHtcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICB9ICk7XG5cbiAgICAgIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfTtcblxuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuXG5cbiAgICAgIC8vIFRhcCwgdGFwaG9sZFxuICAgICAgLy8gLS0tLS1cblxuICAgICAgZm9yICh2YXIgaT0wOyBpPG5vdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlYXJsaWVyW2ldID0gbm93W2ldO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uW2ldID0gbm93W2ldO1xuICAgICAgfVxuXG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaFN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICBjbGVhclRpbWVvdXQoIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ICk7XG4gICAgICByLnRvdWNoRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKFxuICAgICAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9PT0gZmFsc2VcbiAgICAgICAgICAgICYmICFyLnBpbmNoaW5nIC8vIGlmIHBpbmNoaW5nLCB0aGVuIHRhcGhvbGQgdW5zZWxlY3Qgc2hvdWxkbid0IHRha2UgZWZmZWN0XG4gICAgICAgICAgICAmJiAhci50b3VjaERhdGEuc2VsZWN0aW5nIC8vIGJveCBzZWxlY3Rpb24gc2hvdWxkbid0IGFsbG93IHRhcGhvbGQgdGhyb3VnaFxuICAgICAgICApe1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoIHIudG91Y2hEYXRhLnN0YXJ0LCBbJ3RhcGhvbGQnXSwgZSwge1xuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgfSApO1xuXG4gICAgICAgICAgaWYgKCFyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5zZWxlY3QoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSwgci50YXBob2xkRHVyYXRpb24pO1xuICAgIH1cblxuICB9LCBmYWxzZSk7XG5cbiAgdmFyIHRvdWNobW92ZUhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG5cbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdzsgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgaWYgKGUudG91Y2hlc1swXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgaWYgKGUudG91Y2hlc1sxXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgaWYgKGUudG91Y2hlc1syXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7IG5vd1s0XSA9IHBvc1swXTsgbm93WzVdID0gcG9zWzFdOyB9XG5cbiAgICB2YXIgZGlzcCA9IFtdOyBmb3IgKHZhciBqPTA7ajxub3cubGVuZ3RoO2orKykgeyBkaXNwW2pdID0gbm93W2pdIC0gZWFybGllcltqXTsgfVxuICAgIHZhciBzdGFydFBvcyA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb247XG4gICAgdmFyIGR4ID0gbm93WzBdIC0gc3RhcnRQb3NbMF07XG4gICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgdmFyIGR5ID0gbm93WzFdIC0gc3RhcnRQb3NbMV07XG4gICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tO1xuXG4gICAgLy8gY29udGV4dCBzd2lwZSBjYW5jZWxsaW5nXG4gICAgaWYoIGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0ICl7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgLy8gdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICB2YXIgZmFjdG9yU3EgPSBkaXN0YW5jZTJTcSAvIGRpc3RhbmNlMVNxO1xuXG4gICAgICB2YXIgZGlzdFRocmVzaG9sZCA9IDE1MDtcbiAgICAgIHZhciBkaXN0VGhyZXNob2xkU3EgPSBkaXN0VGhyZXNob2xkICogZGlzdFRocmVzaG9sZDtcbiAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGQgPSAxLjU7XG4gICAgICB2YXIgZmFjdG9yVGhyZXNob2xkU3EgPSBmYWN0b3JUaHJlc2hvbGQgKiBmYWN0b3JUaHJlc2hvbGQ7XG5cbiAgICAgIC8vIGNhbmNlbCBjdHggZ2VzdHVyZXMgaWYgdGhlIGRpc3RhbmNlIGIvdCB0aGUgZmluZ2VycyBpbmNyZWFzZXNcbiAgICAgIGlmKCBmYWN0b3JTcSA+PSBmYWN0b3JUaHJlc2hvbGRTcSB8fCBkaXN0YW5jZTJTcSA+PSBkaXN0VGhyZXNob2xkU3EgKXtcbiAgICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC51bmFjdGl2YXRlKCk7IHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDsgfVxuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIGN4dEV2dCA9IEV2ZW50KGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApe1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBjb250ZXh0IHN3aXBlXG4gICAgaWYoIGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0ICl7XG4gICAgICB2YXIgY3h0RXZ0ID0gRXZlbnQoZSwge1xuICAgICAgICB0eXBlOiAnY3h0ZHJhZycsXG4gICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgfSk7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgIH1cblxuICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7IHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTsgfVxuICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuXG4gICAgICBpZiggIXIudG91Y2hEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci50b3VjaERhdGEuY3h0T3ZlciApe1xuXG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5jeHRPdmVyICl7XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0T3Zlci50cmlnZ2VyKCBFdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KSApO1xuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICBuZWFyLnRyaWdnZXIoIEV2ZW50KGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgLy8gYm94IHNlbGVjdGlvblxuICAgIH0gZWxzZSBpZiggY2FwdHVyZSAmJiBlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICl7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5sYXN0VGhyZWVUb3VjaCA9ICtuZXcgRGF0ZSgpO1xuICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcblxuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgaWYoICFzZWxlY3QgfHwgc2VsZWN0Lmxlbmd0aCA9PT0gMCB8fCBzZWxlY3RbMF0gPT09IHVuZGVmaW5lZCApe1xuICAgICAgICBzZWxlY3RbMF0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKS8zO1xuICAgICAgICBzZWxlY3RbMV0gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKS8zO1xuICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKS8zICsgMTtcbiAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkvMyArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKS8zO1xuICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKS8zO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcblxuICAgICAgci5yZWRyYXcoKTtcblxuICAgIC8vIHBpbmNoIHRvIHpvb21cbiAgICB9IGVsc2UgaWYgKCBjYXB0dXJlICYmIGUudG91Y2hlc1sxXSAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclpvb21pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgKSB7IC8vIHR3byBmaW5nZXJzID0+IHBpbmNoIHRvIHpvb21cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgaWYoIGRyYWdnZWRFbGVzICl7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICBkcmFnZ2VkRWxlc1tpXS5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAoeDIsIHkyKSBmb3IgZmluZ2VycyAxIGFuZCAyXG4gICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuXG4gICAgICB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgIC8vIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgIC8vIHZhciBmYWN0b3IgPSBNYXRoLnNxcnQoIGRpc3RhbmNlMlNxICkgLyBNYXRoLnNxcnQoIGRpc3RhbmNlMVNxICk7XG4gICAgICB2YXIgZmFjdG9yID0gZGlzdGFuY2UyIC8gZGlzdGFuY2UxO1xuXG4gICAgICBpZiggZmFjdG9yICE9IDEgJiYgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlKXtcbiAgICAgICAgLy8gZGVsdGEgZmluZ2VyMVxuICAgICAgICB2YXIgZGYxeCA9IGYxeDIgLSBmMXgxO1xuICAgICAgICB2YXIgZGYxeSA9IGYxeTIgLSBmMXkxO1xuXG4gICAgICAgIC8vIGRlbHRhIGZpbmdlciAyXG4gICAgICAgIHZhciBkZjJ4ID0gZjJ4MiAtIGYyeDE7XG4gICAgICAgIHZhciBkZjJ5ID0gZjJ5MiAtIGYyeTE7XG5cbiAgICAgICAgLy8gdHJhbnNsYXRpb24gaXMgdGhlIG5vcm1hbGlzZWQgdmVjdG9yIG9mIHRoZSB0d28gZmluZ2VycyBtb3ZlbWVudFxuICAgICAgICAvLyBpLmUuIHNvIHBpbmNoaW5nIGNhbmNlbHMgb3V0IGFuZCBtb3ZpbmcgdG9nZXRoZXIgcGFuc1xuICAgICAgICB2YXIgdHggPSAoZGYxeCArIGRmMngpLzI7XG4gICAgICAgIHZhciB0eSA9IChkZjF5ICsgZGYyeSkvMjtcblxuICAgICAgICAvLyBhZGp1c3QgZmFjdG9yIGJ5IHRoZSBzcGVlZCBtdWx0aXBsaWVyXG4gICAgICAgIC8vIHZhciBzcGVlZCA9IDEuNTtcbiAgICAgICAgLy8gaWYoIGZhY3RvciA+IDEgKXtcbiAgICAgICAgLy8gICBmYWN0b3IgPSAoZmFjdG9yIC0gMSkgKiBzcGVlZCArIDE7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgZmFjdG9yID0gMSAtICgxIC0gZmFjdG9yKSAqIHNwZWVkO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gbm93IGNhbGN1bGF0ZSB0aGUgem9vbVxuICAgICAgICB2YXIgem9vbTEgPSBjeS56b29tKCk7XG4gICAgICAgIHZhciB6b29tMiA9IHpvb20xICogZmFjdG9yO1xuICAgICAgICB2YXIgcGFuMSA9IGN5LnBhbigpO1xuXG4gICAgICAgIC8vIHRoZSBtb2RlbCBjZW50ZXIgcG9pbnQgY29udmVydGVkIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVkIHBvc1xuICAgICAgICB2YXIgY3RyeCA9IG1vZGVsQ2VudGVyMVswXSAqIHpvb20xICsgcGFuMS54O1xuICAgICAgICB2YXIgY3RyeSA9IG1vZGVsQ2VudGVyMVsxXSAqIHpvb20xICsgcGFuMS55O1xuXG4gICAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICAgIHg6IC16b29tMi96b29tMSAqIChjdHJ4IC0gcGFuMS54IC0gdHgpICsgY3RyeCxcbiAgICAgICAgICB5OiAtem9vbTIvem9vbTEgKiAoY3RyeSAtIHBhbjEueSAtIHR5KSArIGN0cnlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZW1vdmUgZHJhZ2dlZCBlbGVzXG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApe1xuICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgICAgIGlmKCBkcmFnZ2VkRWxlcyApeyBmb3IoIHZhciBpID0gMDsgaSA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZEVpX3AgPSBkcmFnZ2VkRWxlc1tpXS5fcHJpdmF0ZTtcblxuICAgICAgICAgICAgZEVpX3AuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZEVpX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICB9IH1cblxuICAgICAgICAgIHZhciBzdGFydF9wID0gci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGU7XG4gICAgICAgICAgc3RhcnRfcC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICBzdGFydF9wLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICBzdGFydF9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG5cbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcblxuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0XG4gICAgICAgICAgICAudHJpZ2dlcignZnJlZScpXG4gICAgICAgICAgICAudHJpZ2dlcigndW5hY3RpdmF0ZScpXG4gICAgICAgICAgO1xuICAgICAgICB9XG5cbiAgICAgICAgY3kudmlld3BvcnQoe1xuICAgICAgICAgIHpvb206IHpvb20yLFxuICAgICAgICAgIHBhbjogcGFuMixcbiAgICAgICAgICBjYW5jZWxPbkZhaWxlZFpvb206IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UyO1xuICAgICAgICBmMXgxID0gZjF4MjtcbiAgICAgICAgZjF5MSA9IGYxeTI7XG4gICAgICAgIGYyeDEgPSBmMngyO1xuICAgICAgICBmMnkxID0gZjJ5MjtcblxuICAgICAgICByLnBpbmNoaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgaWYgKGUudG91Y2hlc1swXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG4gICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgICAgdmFyIGxhc3QgPSByLnRvdWNoRGF0YS5sYXN0O1xuICAgICAgdmFyIG5lYXIgPSBuZWFyIHx8IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgaWYoIHN0YXJ0ICE9IG51bGwgKXtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBkcmFnZ2luZyBub2Rlc1xuICAgICAgaWYoIHN0YXJ0ICE9IG51bGwgJiYgc3RhcnQuX3ByaXZhdGUuZ3JvdXAgPT0gJ25vZGVzJyAmJiByLm5vZGVJc0RyYWdnYWJsZShzdGFydCkgKXtcblxuICAgICAgICBpZiggcmRpc3QyID49IHIudG91Y2hUYXBUaHJlc2hvbGQyICl7IC8vIHRoZW4gZHJhZ2dpbmcgY2FuIGhhcHBlblxuICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuZHJhZ0RhdGEuZGlkRHJhZztcblxuICAgICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBrKysgKXtcbiAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlID0gZHJhZ2dlZEVsZXNba107XG5cbiAgICAgICAgICAgIGlmKCBqdXN0U3RhcnRlZERyYWcgKXtcbiAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggZHJhZ2dlZEVsZSwgeyBpbkRyYWdMYXllcjogdHJ1ZSB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCByLm5vZGVJc0RyYWdnYWJsZShkcmFnZ2VkRWxlKSAmJiBkcmFnZ2VkRWxlLmlzTm9kZSgpICYmIGRyYWdnZWRFbGUuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciBkUG9zID0gZHJhZ2dlZEVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZVBvcyA9ICFkcmFnZ2VkRWxlLmlzUGFyZW50KCk7XG5cbiAgICAgICAgICAgICAgaWYoIHVwZGF0ZVBvcyAmJiBpcy5udW1iZXIoZGlzcFswXSkgJiYgaXMubnVtYmVyKGRpc3BbMV0pICl7XG4gICAgICAgICAgICAgICAgZFBvcy54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgICAgZFBvcy55ICs9IGRpc3BbMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICl7XG4gICAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhO1xuXG4gICAgICAgICAgICAgICAgaWYoIHVwZGF0ZVBvcyAmJiBpcy5udW1iZXIoZHJhZ0RlbHRhWzBdKSAmJiBpcy5udW1iZXIoZHJhZ0RlbHRhWzFdKSApe1xuICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgIGRQb3MueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGNvbCA9IENvbGxlY3Rpb24oY3ksIGRyYWdnZWRFbGVzKTtcblxuICAgICAgICAgIHRjb2wudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICB0Y29sLnRyaWdnZXIoJ3Bvc2l0aW9uIGRyYWcnKTtcblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG5cbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcblxuICAgICAgICAgIGlmKFxuICAgICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSA9PSBlYXJsaWVyWzBdXG4gICAgICAgICAgICAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdID09IGVhcmxpZXJbMV1cbiAgICAgICAgICApe1xuXG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcmlzZSBrZWVwIHRyYWNrIG9mIGRyYWcgZGVsdGEgZm9yIGxhdGVyXG4gICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgICAgIGlmKCBkcmFnRGVsdGEubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgICBkcmFnRGVsdGEucHVzaCggZGlzcFswXSApO1xuICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goIGRpc3BbMV0gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdG91Y2htb3ZlXG4gICAgICB7XG4gICAgICAgIHRyaWdnZXJFdmVudHMoIChzdGFydCB8fCBuZWFyKSwgWyd0b3VjaG1vdmUnLCAndGFwZHJhZycsICd2bW91c2Vtb3ZlJ10sIGUsIHtcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIGlmIChuZWFyICE9IGxhc3QpIHtcbiAgICAgICAgICBpZiAobGFzdCkgeyBsYXN0LnRyaWdnZXIoRXZlbnQoZSwgeyB0eXBlOiAndGFwZHJhZ291dCcsIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfSB9KSk7IH1cbiAgICAgICAgICBpZiAobmVhcikgeyBuZWFyLnRyaWdnZXIoRXZlbnQoZSwgeyB0eXBlOiAndGFwZHJhZ292ZXInLCBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH0gfSkpOyB9XG4gICAgICAgIH1cblxuICAgICAgICByLnRvdWNoRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgdG8gY2FuY2VsIHRhcGhvbGRcbiAgICAgIGZvciAodmFyIGk9MDtpPG5vdy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIGlmKCBub3dbaV1cbiAgICAgICAgICAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uW2ldXG4gICAgICAgICAgJiYgcmRpc3QyID4gci50b3VjaFRhcFRocmVzaG9sZDIgKXtcblxuICAgICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHBhbm5pbmdcbiAgICAgIGlmKFxuICAgICAgICAgIGNhcHR1cmVcbiAgICAgICAgICAmJiAoIHN0YXJ0ID09IG51bGwgfHwgc3RhcnQuaXNFZGdlKCkgKVxuICAgICAgICAgICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKClcbiAgICAgICl7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmKCByLnN3aXBlUGFubmluZyApe1xuICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2UgaWYoIHJkaXN0MiA+PSByLnRvdWNoVGFwVGhyZXNob2xkMiApe1xuICAgICAgICAgIHIuc3dpcGVQYW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgIHg6IGR4ICogem9vbSxcbiAgICAgICAgICAgIHk6IGR5ICogem9vbVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG5cbiAgICAgICAgICAgIGlmKCAhci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uICl7XG4gICAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZS1wcm9qZWN0XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaj0wOyBqPG5vdy5sZW5ndGg7IGorKykgeyBlYXJsaWVyW2pdID0gbm93W2pdOyB9XG4gICAgLy9yLnJlZHJhdygpO1xuXG4gIH0sIGZhbHNlKTtcblxuICB2YXIgdG91Y2hjYW5jZWxIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaGNhbmNlbCcsIHRvdWNoY2FuY2VsSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcblxuICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSBmYWxzZTtcblxuICAgIGlmKCBzdGFydCApe1xuICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHRvdWNoZW5kSGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2hlbmQnLCB0b3VjaGVuZEhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG5cbiAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG5cbiAgICBpZiggY2FwdHVyZSApe1xuICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG5cbiAgICByLnN3aXBlUGFubmluZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcblxuICAgIGlmIChlLnRvdWNoZXNbMF0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpOyBub3dbMl0gPSBwb3NbMF07IG5vd1szXSA9IHBvc1sxXTsgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG4gICAgaWYoIHN0YXJ0ICl7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIGN0eFRhcGVuZDtcbiAgICBpZiggci50b3VjaERhdGEuY3h0ICl7XG4gICAgICBjdHhUYXBlbmQgPSBFdmVudChlLCB7XG4gICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgc3RhcnQudHJpZ2dlciggY3R4VGFwZW5kICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS50cmlnZ2VyKCBjdHhUYXBlbmQgKTtcbiAgICAgIH1cblxuICAgICAgaWYoICFyLnRvdWNoRGF0YS5jeHREcmFnZ2VkICl7XG4gICAgICAgIHZhciBjdHhUYXAgPSBFdmVudChlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCBzdGFydCApe1xuICAgICAgICAgIHN0YXJ0LnRyaWdnZXIoIGN0eFRhcCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN0eFRhcCApO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7IHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTsgfVxuICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG5cbiAgICAgIHIucmVkcmF3KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbm8gbW9yZSBib3ggc2VsZWN0aW9uIGlmIHdlIGRvbid0IGhhdmUgdGhyZWUgZmluZ2Vyc1xuICAgIGlmKCAhZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiByLnRvdWNoRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuXG4gICAgICB2YXIgbmV3bHlTZWxlY3RlZCA9IFtdO1xuICAgICAgdmFyIGJveCA9IHIuZ2V0QWxsSW5Cb3goIHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSApO1xuXG4gICAgICBzZWxlY3RbMF0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbMV0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbMl0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbM10gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbNF0gPSAwO1xuXG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaTwgYm94Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICBpZiggYm94W2ldLl9wcml2YXRlLnNlbGVjdGFibGUgKXtcbiAgICAgICAgICBuZXdseVNlbGVjdGVkLnB1c2goIGJveFtpXSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdseVNlbENvbCA9IENvbGxlY3Rpb24oIGN5LCBuZXdseVNlbGVjdGVkICk7XG5cbiAgICAgIG5ld2x5U2VsQ29sLnNlbGVjdCgpO1xuXG4gICAgICBpZiggbmV3bHlTZWxDb2wubGVuZ3RoID4gMCApIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1cGRhdGVTdGFydFN0eWxlID0gZmFsc2U7XG5cbiAgICBpZiggc3RhcnQgIT0gbnVsbCApe1xuICAgICAgc3RhcnQuX3ByaXZhdGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICB1cGRhdGVTdGFydFN0eWxlID0gdHJ1ZTtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSB7XG5cbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSkge1xuXG4gICAgLy8gTGFzdCB0b3VjaCByZWxlYXNlZFxuICAgIH0gZWxzZSBpZiAoIWUudG91Y2hlc1swXSkge1xuXG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG5cbiAgICAgIGlmIChzdGFydCAhPSBudWxsICkge1xuXG4gICAgICAgIHZhciBzdGFydFdhc0dyYWJiZWQgPSBzdGFydC5fcHJpdmF0ZS5ncmFiYmVkO1xuXG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoIGRyYWdnZWRFbGVzICk7XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuXG4gICAgICAgIGlmKCBzdGFydFdhc0dyYWJiZWQgKXtcbiAgICAgICAgICBzdGFydC50cmlnZ2VyKCdmcmVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmlnZ2VyRXZlbnRzKCBzdGFydCwgWyd0b3VjaGVuZCcsICd0YXBlbmQnLCAndm1vdXNldXAnXSwgZSwge1xuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuXG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50cyggbmVhciwgWyd0b3VjaGVuZCcsICd0YXBlbmQnLCAndm1vdXNldXAnXSwgZSwge1xuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9ICk7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIGR4ID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSAtIG5vd1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblsxXSAtIG5vd1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgdmFyIHJkaXN0MiA9IGRpc3QyICogem9vbSAqIHpvb207XG5cbiAgICAgIC8vIFByZXBhcmUgdG8gc2VsZWN0IHRoZSBjdXJyZW50bHkgdG91Y2hlZCBub2RlLCBvbmx5IGlmIGl0IGhhc24ndCBiZWVuIGRyYWdnZWQgcGFzdCBhIGNlcnRhaW4gZGlzdGFuY2VcbiAgICAgIGlmIChzdGFydCAhPSBudWxsXG4gICAgICAgICAgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgZHJhZyBub2RlcyBhcm91bmRcbiAgICAgICAgICAmJiBzdGFydC5fcHJpdmF0ZS5zZWxlY3RhYmxlXG4gICAgICAgICAgJiYgcmRpc3QyIDwgci50b3VjaFRhcFRocmVzaG9sZDJcbiAgICAgICAgICAmJiAhci5waW5jaGluZyAvLyBwaW5jaCB0byB6b29tIHNob3VsZCBub3QgYWZmZWN0IHNlbGVjdGlvblxuICAgICAgKSB7XG5cbiAgICAgICAgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ3NpbmdsZScgKXtcbiAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bm1lcmdlKCBzdGFydCApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgc3RhcnQuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoIHN0YXJ0LnNlbGVjdGVkKCkgKXtcbiAgICAgICAgICAgIHN0YXJ0LnVuc2VsZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LnNlbGVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZVN0YXJ0U3R5bGUgPSB0cnVlO1xuXG5cbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhcCBldmVudCwgcm91Z2hseSBzYW1lIGFzIG1vdXNlIGNsaWNrIGV2ZW50IGZvciB0b3VjaFxuICAgICAgaWYoICFyLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkICl7XG4gICAgICAgIHRyaWdnZXJFdmVudHMoIHN0YXJ0LCBbJ3RhcCcsICd2Y2xpY2snXSwgZSwge1xuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9ICk7XG4gICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrICl7IGVhcmxpZXJbal0gPSBub3dbal07IH1cblxuICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlOyAvLyByZXNldCBmb3IgbmV4dCBtb3VzZWRvd25cblxuICAgIGlmKCBlLnRvdWNoZXMubGVuZ3RoID09PSAwICl7XG4gICAgICByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICB9XG5cbiAgICBpZiggdXBkYXRlU3RhcnRTdHlsZSAmJiBzdGFydCApe1xuICAgICAgc3RhcnQudXBkYXRlU3R5bGUoZmFsc2UpO1xuICAgIH1cblxuICAgIGlmKCBlLnRvdWNoZXMubGVuZ3RoIDwgMiApe1xuICAgICAgci5waW5jaGluZyA9IGZhbHNlO1xuICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cblxuICAgIC8vci5yZWRyYXcoKTtcblxuICB9LCBmYWxzZSk7XG5cbiAgLy8gZmFsbGJhY2sgY29tcGF0aWJpbGl0eSBsYXllciBmb3IgbXMgcG9pbnRlciBldmVudHNcbiAgaWYoIHR5cGVvZiBUb3VjaEV2ZW50ID09PSAndW5kZWZpbmVkJyApe1xuXG4gICAgdmFyIHBvaW50ZXJzID0gW107XG5cbiAgICB2YXIgbWFrZVRvdWNoID0gZnVuY3Rpb24oIGUgKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgICAgICBmb3JjZTogMSxcbiAgICAgICAgaWRlbnRpZmllcjogZS5wb2ludGVySWQsXG4gICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICBwYWdlWTogZS5wYWdlWSxcbiAgICAgICAgcmFkaXVzWDogZS53aWR0aC8yLFxuICAgICAgICByYWRpdXNZOiBlLmhlaWdodC8yLFxuICAgICAgICBzY3JlZW5YOiBlLnNjcmVlblgsXG4gICAgICAgIHNjcmVlblk6IGUuc2NyZWVuWSxcbiAgICAgICAgdGFyZ2V0OiBlLnRhcmdldFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIG1ha2VQb2ludGVyID0gZnVuY3Rpb24oIGUgKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50OiBlLFxuICAgICAgICB0b3VjaDogbWFrZVRvdWNoKGUpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYWRkUG9pbnRlciA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICBwb2ludGVycy5wdXNoKCBtYWtlUG9pbnRlcihlKSApO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwID0gcG9pbnRlcnNbaV07XG5cbiAgICAgICAgaWYoIHAuZXZlbnQucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCApe1xuICAgICAgICAgIHBvaW50ZXJzLnNwbGljZSggaSwgMSApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlUG9pbnRlciA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICB2YXIgcCA9IHBvaW50ZXJzLmZpbHRlcihmdW5jdGlvbiggcCApe1xuICAgICAgICByZXR1cm4gcC5ldmVudC5wb2ludGVySWQgPT09IGUucG9pbnRlcklkO1xuICAgICAgfSlbMF07XG5cbiAgICAgIHAuZXZlbnQgPSBlO1xuICAgICAgcC50b3VjaCA9IG1ha2VUb3VjaChlKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFRvdWNoZXNUb0V2ZW50ID0gZnVuY3Rpb24oIGUgKXtcbiAgICAgIGUudG91Y2hlcyA9IHBvaW50ZXJzLm1hcChmdW5jdGlvbiggcCApe1xuICAgICAgICByZXR1cm4gcC50b3VjaDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgcG9pbnRlcklzTW91c2UgPSBmdW5jdGlvbiggZSApe1xuICAgICAgcmV0dXJuIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZS5wb2ludGVyVHlwZSA9PT0gNDtcbiAgICB9O1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVyZG93bicsIGZ1bmN0aW9uKGUpe1xuICAgICAgaWYoIHBvaW50ZXJJc01vdXNlKGUpICl7IHJldHVybjsgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBhZGRQb2ludGVyKCBlICk7XG5cbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KCBlICk7XG4gICAgICB0b3VjaHN0YXJ0SGFuZGxlciggZSApO1xuICAgIH0pO1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVydXAnLCBmdW5jdGlvbihlKXtcbiAgICAgIGlmKCBwb2ludGVySXNNb3VzZShlKSApeyByZXR1cm47IH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIHJlbW92ZVBvaW50ZXIoIGUgKTtcblxuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoIGUgKTtcbiAgICAgIHRvdWNoZW5kSGFuZGxlciggZSApO1xuICAgIH0pO1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVyY2FuY2VsJywgZnVuY3Rpb24oZSl7XG4gICAgICBpZiggcG9pbnRlcklzTW91c2UoZSkgKXsgcmV0dXJuOyB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICByZW1vdmVQb2ludGVyKCBlICk7XG5cbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KCBlICk7XG4gICAgICB0b3VjaGNhbmNlbEhhbmRsZXIoIGUgKTtcbiAgICB9KTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcm1vdmUnLCBmdW5jdGlvbihlKXtcbiAgICAgIGlmKCBwb2ludGVySXNNb3VzZShlKSApeyByZXR1cm47IH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdXBkYXRlUG9pbnRlciggZSApO1xuXG4gICAgICBhZGRUb3VjaGVzVG9FdmVudCggZSApO1xuICAgICAgdG91Y2htb3ZlSGFuZGxlciggZSApO1xuICAgIH0pO1xuXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuXG59LHtcIi4uLy4uLy4uL2NvbGxlY3Rpb25cIjoyMyxcIi4uLy4uLy4uL2V2ZW50XCI6NDIsXCIuLi8uLi8uLi9pc1wiOjc3LFwiLi4vLi4vLi4vdXRpbFwiOjk0fV0sNjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0aCA9IF9kZXJlcV8oJy4uLy4uLy4uL21hdGgnKTtcblxudmFyIEJScCA9IHt9O1xuXG5CUnAucmVnaXN0ZXJOb2RlU2hhcGVzID0gZnVuY3Rpb24oKXtcbiAgdmFyIG5vZGVTaGFwZXMgPSB0aGlzLm5vZGVTaGFwZXMgPSB7fTtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcblxuICBub2RlU2hhcGVzWydlbGxpcHNlJ10gPSB7XG4gICAgbmFtZTogJ2VsbGlwc2UnLFxuXG4gICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKXtcbiAgICAgIHJlbmRlcmVyLm5vZGVTaGFwZUltcGwoIHRoaXMubmFtZSApKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgfSxcblxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcgKXtcbiAgICAgIHJldHVybiBtYXRoLmludGVyc2VjdExpbmVFbGxpcHNlKFxuICAgICAgICB4LCB5LFxuICAgICAgICBub2RlWCxcbiAgICAgICAgbm9kZVksXG4gICAgICAgIHdpZHRoIC8gMiArIHBhZGRpbmcsXG4gICAgICAgIGhlaWdodCAvIDIgKyBwYWRkaW5nKVxuICAgICAgO1xuICAgIH0sXG5cbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiggeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSApe1xuICAgICAgeCAtPSBjZW50ZXJYO1xuICAgICAgeSAtPSBjZW50ZXJZO1xuXG4gICAgICB4IC89ICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIHkgLz0gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcblxuICAgICAgcmV0dXJuIHgqeCArIHkqeSA8PSAxO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZVBvbHlnb24oIG5hbWUsIHBvaW50cyApe1xuICAgIHJldHVybiAoIG5vZGVTaGFwZXNbbmFtZV0gPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuXG4gICAgICBwb2ludHM6IHBvaW50cyxcblxuICAgICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKXtcbiAgICAgICAgcmVuZGVyZXIubm9kZVNoYXBlSW1wbCgncG9seWdvbicpKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLnBvaW50cyApO1xuICAgICAgfSxcblxuICAgICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24oIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZyApe1xuICAgICAgICByZXR1cm4gbWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZShcbiAgICAgICAgICAgIHgsIHksXG4gICAgICAgICAgICB0aGlzLnBvaW50cyxcbiAgICAgICAgICAgIG5vZGVYLFxuICAgICAgICAgICAgbm9kZVksXG4gICAgICAgICAgICB3aWR0aCAvIDIsIGhlaWdodCAvIDIsXG4gICAgICAgICAgICBwYWRkaW5nKVxuICAgICAgICAgIDtcbiAgICAgIH0sXG5cbiAgICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKCB4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZICl7XG4gICAgICAgIHJldHVybiBtYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBub2RlU2hhcGVzW25hbWVdLnBvaW50cyxcbiAgICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKVxuICAgICAgICA7XG4gICAgICB9XG4gICAgfSApO1xuICB9XG5cbiAgZ2VuZXJhdGVQb2x5Z29uKCAndHJpYW5nbGUnLCBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSgzLCAwKSApO1xuXG4gIGdlbmVyYXRlUG9seWdvbiggJ3NxdWFyZScsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApICk7XG4gIG5vZGVTaGFwZXNbJ3JlY3RhbmdsZSddID0gbm9kZVNoYXBlc1snc3F1YXJlJ107XG5cbiAgbm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICBuYW1lOiAncm91bmRyZWN0YW5nbGUnLFxuXG4gICAgcG9pbnRzOiBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICl7XG4gICAgICByZW5kZXJlci5ub2RlU2hhcGVJbXBsKCB0aGlzLm5hbWUgKSggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiggbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nICl7XG4gICAgICByZXR1cm4gbWF0aC5yb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoXG4gICAgICAgIHgsIHksXG4gICAgICAgIG5vZGVYLFxuICAgICAgICBub2RlWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgcGFkZGluZylcbiAgICAgIDtcbiAgICB9LFxuXG4gICAgLy8gTG9va3MgbGlrZSB0aGUgd2lkdGggcGFzc2VkIGludG8gdGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSB0aGUgdG90YWwgd2lkdGggLyAyXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24oXG4gICAgICB4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZICl7XG5cbiAgICAgIHZhciBjb3JuZXJSYWRpdXMgPSBtYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAvLyBDaGVjayBoQm94XG4gICAgICBpZiAobWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogY29ybmVyUmFkaXVzLCBbMCwgLTFdLCBwYWRkaW5nKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYgKG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIDIgKiBjb3JuZXJSYWRpdXMsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGVja0luRWxsaXBzZSA9IGZ1bmN0aW9uKCB4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nICl7XG4gICAgICAgIHggLT0gY2VudGVyWDtcbiAgICAgICAgeSAtPSBjZW50ZXJZO1xuXG4gICAgICAgIHggLz0gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgICB5IC89IChoZWlnaHQgLyAyICsgcGFkZGluZyk7XG5cbiAgICAgICAgcmV0dXJuICh4KnggKyB5KnkgPD0gMSk7XG4gICAgICB9O1xuXG5cbiAgICAgIC8vIENoZWNrIHRvcCBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSxcbiAgICAgICAgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcpICl7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHRvcCByaWdodCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksXG4gICAgICAgIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgLSBoZWlnaHQgLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nKSApe1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBib3R0b20gcmlnaHQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LFxuICAgICAgICBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZykgKXtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LFxuICAgICAgICBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZykgKXtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBnZW5lcmF0ZVBvbHlnb24oICdkaWFtb25kJywgW1xuICAgIDAsIDEsXG4gICAgMSwgMCxcbiAgICAwLCAtMSxcbiAgICAtMSwgMFxuICBdICk7XG5cbiAgZ2VuZXJhdGVQb2x5Z29uKCAncGVudGFnb24nLCBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg1LCAwKSApO1xuXG4gIGdlbmVyYXRlUG9seWdvbiggJ2hleGFnb24nLCBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg2LCAwKSApO1xuXG4gIGdlbmVyYXRlUG9seWdvbiggJ2hlcHRhZ29uJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNywgMCkgKTtcblxuICBnZW5lcmF0ZVBvbHlnb24oICdvY3RhZ29uJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoOCwgMCkgKTtcblxuICB2YXIgc3RhcjVQb2ludHMgPSBuZXcgQXJyYXkoMjApO1xuICB7XG4gICAgdmFyIG91dGVyUG9pbnRzID0gbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzKDUsIDApO1xuICAgIHZhciBpbm5lclBvaW50cyA9IG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCBNYXRoLlBJIC8gNSk7XG5cbiAgICAvLyBPdXRlciByYWRpdXMgaXMgMTsgaW5uZXIgcmFkaXVzIG9mIHN0YXIgaXMgc21hbGxlclxuICAgIHZhciBpbm5lclJhZGl1cyA9IDAuNSAqICgzIC0gTWF0aC5zcXJ0KDUpKTtcbiAgICBpbm5lclJhZGl1cyAqPSAxLjU3O1xuXG4gICAgZm9yICh2YXIgaT0wO2k8aW5uZXJQb2ludHMubGVuZ3RoLzI7aSsrICl7XG4gICAgICBpbm5lclBvaW50c1tpKjJdICo9IGlubmVyUmFkaXVzO1xuICAgICAgaW5uZXJQb2ludHNbaSoyKzFdICo9IGlubmVyUmFkaXVzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGk9MDtpPDIwLzQ7aSsrICl7XG4gICAgICBzdGFyNVBvaW50c1tpKjRdID0gb3V0ZXJQb2ludHNbaSoyXTtcbiAgICAgIHN0YXI1UG9pbnRzW2kqNCsxXSA9IG91dGVyUG9pbnRzW2kqMisxXTtcblxuICAgICAgc3RhcjVQb2ludHNbaSo0KzJdID0gaW5uZXJQb2ludHNbaSoyXTtcbiAgICAgIHN0YXI1UG9pbnRzW2kqNCszXSA9IGlubmVyUG9pbnRzW2kqMisxXTtcbiAgICB9XG4gIH1cblxuICBzdGFyNVBvaW50cyA9IG1hdGguZml0UG9seWdvblRvU3F1YXJlKCBzdGFyNVBvaW50cyApO1xuXG4gIGdlbmVyYXRlUG9seWdvbiggJ3N0YXInLCBzdGFyNVBvaW50cyApO1xuXG4gIGdlbmVyYXRlUG9seWdvbiggJ3ZlZScsIFtcbiAgICAtMSwgLTEsXG4gICAgMCwgLTAuMzMzLFxuICAgIDEsIC0xLFxuICAgIDAsIDFcbiAgXSApO1xuXG4gIGdlbmVyYXRlUG9seWdvbiggJ3Job21ib2lkJywgW1xuICAgIC0xLCAtMSxcbiAgICAwLjMzMywgLTEsXG4gICAgMSwgMSxcbiAgICAtMC4zMzMsIDFcbiAgXSApO1xuXG4gIG5vZGVTaGFwZXMubWFrZVBvbHlnb24gPSBmdW5jdGlvbiggcG9pbnRzICl7XG5cbiAgICAvLyB1c2UgY2FjaGluZyBvbiB1c2VyLXNwZWNpZmllZCBwb2x5Z29ucyBzbyB0aGV5IGFyZSBhcyBmYXN0IGFzIG5hdGl2ZSBzaGFwZXNcblxuICAgIHZhciBrZXkgPSBwb2ludHMuam9pbignJCcpO1xuICAgIHZhciBuYW1lID0gJ3BvbHlnb24tJyArIGtleTtcbiAgICB2YXIgc2hhcGU7XG5cbiAgICBpZiggKHNoYXBlID0gbm9kZVNoYXBlc1tuYW1lXSkgKXsgLy8gZ290IGNhY2hlZCBzaGFwZVxuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhbmQgY2FjaGUgbmV3IHNoYXBlXG4gICAgcmV0dXJuIGdlbmVyYXRlUG9seWdvbiggbmFtZSwgcG9pbnRzICk7XG4gIH07XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuXG59LHtcIi4uLy4uLy4uL21hdGhcIjo3OX1dLDYxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi8uLi8uLi91dGlsJyk7XG5cbnZhciBCUnAgPSB7fTtcblxuQlJwLnRpbWVUb1JlbmRlciA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLnJlZHJhd1RvdGFsVGltZSAvIHRoaXMucmVkcmF3Q291bnQ7XG59O1xuXG52YXIgbWluUmVkcmF3TGltaXQgPSAxMDAwLzYwOyAvLyBwZW9wbGUgY2FuJ3Qgc2VlIG11Y2ggYmV0dGVyIHRoYW4gNjBmcHNcbnZhciBtYXhSZWRyYXdMaW1pdCA9IDEwMDA7ICAvLyBkb24ndCBjYXAgbWF4IGIvYyBpdCdzIG1vcmUgaW1wb3J0YW50IHRvIGJlIHJlc3BvbnNpdmUgdGhhbiBzbW9vdGhcblxuQlJwLnJlZHJhdyA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHV0aWwuc3RhdGljRW1wdHlPYmplY3QoKTtcblxuICB2YXIgciA9IHRoaXM7XG4gIHZhciBmb3JjZWRDb250ZXh0ID0gb3B0aW9ucy5mb3JjZWRDb250ZXh0O1xuXG4gIGlmKCByLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQgKXsgci5hdmVyYWdlUmVkcmF3VGltZSA9IDA7IH1cbiAgaWYoIHIubGFzdFJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCApeyByLmxhc3RSZWRyYXdUaW1lID0gMDsgfVxuXG4gIHZhciByZWRyYXdMaW1pdCA9IHIubGFzdFJlZHJhd1RpbWU7IC8vIGVzdGltYXRlIHRoZSBpZGVhbCByZWRyYXcgbGltaXQgYmFzZWQgb24gaG93IGZhc3Qgd2UgY2FuIGRyYXdcbiAgcmVkcmF3TGltaXQgPSBtaW5SZWRyYXdMaW1pdCA+IHJlZHJhd0xpbWl0ID8gbWluUmVkcmF3TGltaXQgOiByZWRyYXdMaW1pdDtcbiAgcmVkcmF3TGltaXQgPSByZWRyYXdMaW1pdCA8IG1heFJlZHJhd0xpbWl0ID8gcmVkcmF3TGltaXQgOiBtYXhSZWRyYXdMaW1pdDtcblxuICBpZiggci5sYXN0RHJhd1RpbWUgPT09IHVuZGVmaW5lZCApeyByLmxhc3REcmF3VGltZSA9IDA7IH1cblxuICB2YXIgbm93VGltZSA9IERhdGUubm93KCk7XG4gIHZhciB0aW1lRWxhcHNlZCA9IG5vd1RpbWUgLSByLmxhc3REcmF3VGltZTtcbiAgdmFyIGNhbGxBZnRlckxpbWl0ID0gdGltZUVsYXBzZWQgPj0gcmVkcmF3TGltaXQ7XG5cbiAgaWYoICFmb3JjZWRDb250ZXh0ICl7XG4gICAgaWYoICFjYWxsQWZ0ZXJMaW1pdCB8fCByLmN1cnJlbnRseURyYXdpbmcgKXtcbiAgICAgIHIuc2tpcEZyYW1lID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICByLnJlcXVlc3RlZEZyYW1lID0gdHJ1ZTtcbiAgci5jdXJyZW50bHlEcmF3aW5nID0gdHJ1ZTtcbiAgci5yZW5kZXJPcHRpb25zID0gb3B0aW9ucztcbn07XG5cbkJScC5zdGFydFJlbmRlckxvb3AgPSBmdW5jdGlvbigpe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdmFyIHJlbmRlckZuID0gZnVuY3Rpb24oKXtcbiAgICBpZiggci5kZXN0cm95ZWQgKXsgcmV0dXJuOyB9XG5cbiAgICBpZiggci5yZXF1ZXN0ZWRGcmFtZSAmJiAhci5za2lwRnJhbWUgKXtcbiAgICAgIHZhciBzdGFydFRpbWUgPSB1dGlsLnBlcmZvcm1hbmNlTm93KCk7XG5cbiAgICAgIHIucmVuZGVyKCByLnJlbmRlck9wdGlvbnMgKTtcblxuICAgICAgdmFyIGVuZFRpbWUgPSByLmxhc3RSZWRyYXdUaW1lID0gdXRpbC5wZXJmb3JtYW5jZU5vdygpO1xuXG4gICAgICBpZiggci5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuXG4gICAgICBpZiggci5yZWRyYXdDb3VudCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHIucmVkcmF3Q291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICByLnJlZHJhd0NvdW50Kys7XG5cbiAgICAgIGlmKCByLnJlZHJhd1RvdGFsVGltZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHIucmVkcmF3VG90YWxUaW1lID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgci5yZWRyYXdUb3RhbFRpbWUgKz0gZHVyYXRpb247XG4gICAgICByLmxhc3RSZWRyYXdUaW1lID0gZHVyYXRpb247XG5cbiAgICAgIC8vIHVzZSBhIHdlaWdodGVkIGF2ZXJhZ2Ugd2l0aCBhIGJpYXMgZnJvbSB0aGUgcHJldmlvdXMgYXZlcmFnZSBzbyB3ZSBkb24ndCBzcGlrZSBzbyBlYXNpbHlcbiAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lLzIgKyBkdXJhdGlvbi8yO1xuXG4gICAgICByLnJlcXVlc3RlZEZyYW1lID0gZmFsc2U7XG4gICAgfVxuXG4gICAgci5za2lwRnJhbWUgPSBmYWxzZTtcblxuICAgIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByZW5kZXJGbiApO1xuICB9O1xuXG4gIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByZW5kZXJGbiApO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcblxufSx7XCIuLi8uLi8uLi91dGlsXCI6OTR9XSw2MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBDUnAgPSB7fTtcblxudmFyIGltcGw7XG5cbkNScC5hcnJvd1NoYXBlSW1wbCA9IGZ1bmN0aW9uKCBuYW1lICl7XG4gIHJldHVybiAoIGltcGwgfHwgKGltcGwgPSB7XG4gICAgJ3BvbHlnb24nOiBmdW5jdGlvbiggY29udGV4dCwgcG9pbnRzICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3RyaWFuZ2xlLWJhY2tjdXJ2ZSc6IGZ1bmN0aW9uKCBjb250ZXh0LCBwb2ludHMsIGNvbnRyb2xQb2ludCApe1xuICAgICAgdmFyIGZpcnN0UHQ7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcblxuICAgICAgICBpZiggaSA9PT0gMCApe1xuICAgICAgICAgIGZpcnN0UHQgPSBwdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyggY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBmaXJzdFB0LngsIGZpcnN0UHQueSApO1xuICAgIH0sXG5cbiAgICAndHJpYW5nbGUtdGVlJzogZnVuY3Rpb24oIGNvbnRleHQsIHRyaWFuZ2xlUG9pbnRzLCB0ZWVQb2ludHMgKXtcbiAgICAgIHZhciB0cmlQdHMgPSB0cmlhbmdsZVBvaW50cztcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdHJpUHRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwdCA9IHRyaVB0c1tpXTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyggcHQueCwgcHQueSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGVlUHRzID0gdGVlUG9pbnRzO1xuICAgICAgdmFyIGZpcnN0VGVlUHQgPSB0ZWVQb2ludHNbMF07XG4gICAgICBjb250ZXh0Lm1vdmVUbyggZmlyc3RUZWVQdC54LCBmaXJzdFRlZVB0LnkgKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0ZWVQdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHB0ID0gdGVlUHRzW2ldO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICdjaXJjbGUnOiBmdW5jdGlvbiggY29udGV4dCwgcngsIHJ5LCByICl7XG4gICAgICBjb250ZXh0LmFyYyhyeCwgcnksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgfVxuICB9KSApWyBuYW1lIF07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcblxufSx7fV0sNjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5kcmF3RWRnZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG5cbiAgLy8gaWYgYmV6aWVyIGN0cmwgcHRzIGNhbiBub3QgYmUgY2FsY3VsYXRlZCwgdGhlbiBkaWVcbiAgaWYoIHJzLmJhZEJlemllciB8fCBycy5iYWRMaW5lIHx8IGlzTmFOKCBycy5hbGxwdHNbMF0gKSApeyAvLyBpTmFOIGluIGNhc2UgZWRnZSBpcyBpbXBvc3NpYmxlIGFuZCBicm93c2VyIGJ1Z3MgKGUuZy4gc2FmYXJpKVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG5cbiAgLy8gRWRnZSBsaW5lIHdpZHRoXG4gIGlmIChzdHlsZVsnd2lkdGgnXS5wZlZhbHVlIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3ZlcmxheVBhZGRpbmcgPSBzdHlsZVsnb3ZlcmxheS1wYWRkaW5nJ10ucGZWYWx1ZTtcbiAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gc3R5bGVbJ292ZXJsYXktb3BhY2l0eSddLnZhbHVlO1xuICB2YXIgb3ZlcmxheUNvbG9yID0gc3R5bGVbJ292ZXJsYXktY29sb3InXS52YWx1ZTtcblxuICAvLyBFZGdlIGNvbG9yICYgb3BhY2l0eVxuICBpZiggZHJhd092ZXJsYXlJbnN0ZWFkICl7XG5cbiAgICBpZiggb3ZlcmxheU9wYWNpdHkgPT09IDAgKXsgLy8gZXhpdCBlYXJseSBpZiBubyBvdmVybGF5XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdHJva2VTdHlsZShjb250ZXh0LCBvdmVybGF5Q29sb3JbMF0sIG92ZXJsYXlDb2xvclsxXSwgb3ZlcmxheUNvbG9yWzJdLCBvdmVybGF5T3BhY2l0eSk7XG4gICAgY29udGV4dC5saW5lQ2FwID0gJ3JvdW5kJztcblxuICAgIGlmKCBycy5lZGdlVHlwZSA9PSAnc2VsZicgJiYgIXVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdmFyIGxpbmVDb2xvciA9IHN0eWxlWydsaW5lLWNvbG9yJ10udmFsdWU7XG5cbiAgICB0aGlzLnN0cm9rZVN0eWxlKGNvbnRleHQsIGxpbmVDb2xvclswXSwgbGluZUNvbG9yWzFdLCBsaW5lQ29sb3JbMl0sIHN0eWxlLm9wYWNpdHkudmFsdWUpO1xuXG4gICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICB9XG5cbiAgdmFyIGVkZ2VXaWR0aCA9IHN0eWxlWyd3aWR0aCddLnBmVmFsdWUgKyAoZHJhd092ZXJsYXlJbnN0ZWFkID8gMiAqIG92ZXJsYXlQYWRkaW5nIDogMCk7XG4gIHZhciBsaW5lU3R5bGUgPSBkcmF3T3ZlcmxheUluc3RlYWQgPyAnc29saWQnIDogc3R5bGVbJ2xpbmUtc3R5bGUnXS52YWx1ZTtcbiAgY29udGV4dC5saW5lV2lkdGggPSBlZGdlV2lkdGg7XG5cbiAgdmFyIHNoYWRvd0JsdXIgPSBzdHlsZVsnc2hhZG93LWJsdXInXS5wZlZhbHVlO1xuICB2YXIgc2hhZG93T3BhY2l0eSA9IHN0eWxlWydzaGFkb3ctb3BhY2l0eSddLnZhbHVlO1xuICB2YXIgc2hhZG93Q29sb3IgPSBzdHlsZVsnc2hhZG93LWNvbG9yJ10udmFsdWU7XG4gIHZhciBzaGFkb3dPZmZzZXRYID0gc3R5bGVbJ3NoYWRvdy1vZmZzZXQteCddLnBmVmFsdWU7XG4gIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGVbJ3NoYWRvdy1vZmZzZXQteSddLnBmVmFsdWU7XG5cbiAgdGhpcy5zaGFkb3dTdHlsZShjb250ZXh0LCAgc2hhZG93Q29sb3IsIGRyYXdPdmVybGF5SW5zdGVhZCA/IDAgOiBzaGFkb3dPcGFjaXR5LCBzaGFkb3dCbHVyLCBzaGFkb3dPZmZzZXRYLCBzaGFkb3dPZmZzZXRZKTtcblxuICB0aGlzLmRyYXdFZGdlUGF0aChcbiAgICBlZGdlLFxuICAgIGNvbnRleHQsXG4gICAgcnMuYWxscHRzLFxuICAgIGxpbmVTdHlsZSxcbiAgICBlZGdlV2lkdGhcbiAgKTtcblxuICB0aGlzLmRyYXdBcnJvd2hlYWRzKGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCk7XG5cbiAgdGhpcy5zaGFkb3dTdHlsZShjb250ZXh0LCAndHJhbnNwYXJlbnQnLCAwKTsgLy8gcmVzZXQgZm9yIG5leHQgZ3V5XG5cbn07XG5cblxuQ1JwLmRyYXdFZGdlUGF0aCA9IGZ1bmN0aW9uKGVkZ2UsIGNvbnRleHQsIHB0cywgdHlwZSwgd2lkdGgpIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGNhbnZhc0N4dCA9IGNvbnRleHQ7XG4gIHZhciBwYXRoO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcblxuICBpZiggdXNlUGF0aHMgKXtcbiAgICB2YXIgcGF0aENhY2hlS2V5ID0gcHRzLmpvaW4oJyQnKTtcbiAgICB2YXIga2V5TWF0Y2hlcyA9IHJzLnBhdGhDYWNoZUtleSAmJiBycy5wYXRoQ2FjaGVLZXkgPT09IHBhdGhDYWNoZUtleTtcblxuICAgIGlmKCBrZXlNYXRjaGVzICl7XG4gICAgICBwYXRoID0gY29udGV4dCA9IHJzLnBhdGhDYWNoZTtcbiAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICBpZiggY2FudmFzQ3h0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIHN3aXRjaCggdHlwZSApe1xuICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFsgMSwgMSBdKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbIDYsIDMgXSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbIF0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiggIXBhdGhDYWNoZUhpdCApe1xuICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG4gICAgY29udGV4dC5tb3ZlVG8oIHB0c1swXSwgcHRzWzFdICk7XG5cbiAgICBzd2l0Y2goIHJzLmVkZ2VUeXBlICl7XG4gICAgICBjYXNlICdiZXppZXInOlxuICAgICAgY2FzZSAnc2VsZic6XG4gICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgIGlmKCAhcnMuYmFkQmV6aWVyICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDI7IGkgKyAzIDwgcHRzLmxlbmd0aDsgaSArPSA0ICl7XG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oIHB0c1tpXSwgcHRzW2krMV0sIHB0c1tpKzJdLCBwdHNbaSszXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyYWlnaHQnOlxuICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICBpZiggIXJzLmJhZExpbmUgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMjsgaSArIDEgPCBwdHMubGVuZ3RoOyBpICs9IDIgKXtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKCBwdHNbaV0sIHB0c1tpKzFdICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbnRleHQgPSBjYW52YXNDeHQ7XG4gIGlmKCB1c2VQYXRocyApe1xuICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfVxuXG4gIC8vIHJlc2V0IGFueSBsaW5lIGRhc2hlc1xuICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gIH1cblxufTtcblxuQ1JwLmRyYXdBcnJvd2hlYWRzID0gZnVuY3Rpb24oY29udGV4dCwgZWRnZSwgZHJhd092ZXJsYXlJbnN0ZWFkKSB7XG4gIGlmKCBkcmF3T3ZlcmxheUluc3RlYWQgKXsgcmV0dXJuOyB9IC8vIGRvbid0IGRvIGFueXRoaW5nIGZvciBvdmVybGF5c1xuXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG5cbiAgaWYoICFpc0hheXN0YWNrICl7XG4gICAgdGhpcy5kcmF3QXJyb3doZWFkKCBjb250ZXh0LCBlZGdlLCAnc291cmNlJywgcnMuYXJyb3dTdGFydFgsIHJzLmFycm93U3RhcnRZLCBycy5zcmNBcnJvd0FuZ2xlICk7XG4gIH1cblxuICB0aGlzLmRyYXdBcnJvd2hlYWQoIGNvbnRleHQsIGVkZ2UsICdtaWQtdGFyZ2V0JywgcnMubWlkWCwgcnMubWlkWSwgcnMubWlkdGd0QXJyb3dBbmdsZSApO1xuXG4gIHRoaXMuZHJhd0Fycm93aGVhZCggY29udGV4dCwgZWRnZSwgJ21pZC1zb3VyY2UnLCBycy5taWRYLCBycy5taWRZLCBycy5taWRzcmNBcnJvd0FuZ2xlICk7XG5cbiAgaWYoICFpc0hheXN0YWNrICl7XG4gICAgdGhpcy5kcmF3QXJyb3doZWFkKCBjb250ZXh0LCBlZGdlLCAndGFyZ2V0JywgcnMuYXJyb3dFbmRYLCBycy5hcnJvd0VuZFksIHJzLnRndEFycm93QW5nbGUgKTtcbiAgfVxufTtcblxuQ1JwLmRyYXdBcnJvd2hlYWQgPSBmdW5jdGlvbiggY29udGV4dCwgZWRnZSwgcHJlZml4LCB4LCB5LCBhbmdsZSApe1xuICBpZiggaXNOYU4oeCkgfHwgeCA9PSBudWxsIHx8IGlzTmFOKHkpIHx8IHkgPT0gbnVsbCB8fCBpc05hTihhbmdsZSkgfHwgYW5nbGUgPT0gbnVsbCApeyByZXR1cm47IH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gIHZhciBhcnJvd1NoYXBlID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1zaGFwZSddLnZhbHVlO1xuXG4gIGlmKCBhcnJvd1NoYXBlID09PSAnbm9uZScgKXtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG5cbiAgdmFyIGFycm93Q2xlYXJGaWxsID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1maWxsJ10udmFsdWUgPT09ICdob2xsb3cnID8gJ2JvdGgnIDogJ2ZpbGxlZCc7XG4gIHZhciBhcnJvd0ZpbGwgPSBzdHlsZVtwcmVmaXggKyAnLWFycm93LWZpbGwnXS52YWx1ZTtcblxuICBpZiggYXJyb3dTaGFwZSA9PT0gJ2hhbGYtdHJpYW5nbGUtb3ZlcnNob3QnICl7XG4gICAgYXJyb3dGaWxsID0gJ2hvbGxvdyc7XG4gICAgYXJyb3dDbGVhckZpbGwgPSAnaG9sbG93JztcbiAgfVxuXG4gIGlmKCBzdHlsZS5vcGFjaXR5LnZhbHVlICE9PSAxIHx8IGFycm93RmlsbCA9PT0gJ2hvbGxvdycgKXsgLy8gdGhlbiBleHRyYSBjbGVhciBpcyBuZWVkZWRcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuXG4gICAgc2VsZi5maWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgc2VsZi5zdHJva2VTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxKTtcblxuICAgIHNlbGYuZHJhd0Fycm93U2hhcGUoIGVkZ2UsIHByZWZpeCwgY29udGV4dCxcbiAgICAgIGFycm93Q2xlYXJGaWxsLCBzdHlsZVsnd2lkdGgnXS5wZlZhbHVlLCBzdHlsZVtwcmVmaXggKyAnLWFycm93LXNoYXBlJ10udmFsdWUsXG4gICAgICB4LCB5LCBhbmdsZVxuICAgICk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgfSAvLyBvdGhlcndpc2UsIHRoZSBvcGFxdWUgYXJyb3cgY2xlYXJzIGl0IGZvciBmcmVlIDopXG5cbiAgdmFyIGNvbG9yID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1jb2xvciddLnZhbHVlO1xuICBzZWxmLmZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBzdHlsZS5vcGFjaXR5LnZhbHVlKTtcbiAgc2VsZi5zdHJva2VTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBzdHlsZS5vcGFjaXR5LnZhbHVlKTtcblxuICBzZWxmLmRyYXdBcnJvd1NoYXBlKCBlZGdlLCBwcmVmaXgsIGNvbnRleHQsXG4gICAgYXJyb3dGaWxsLCBzdHlsZVsnd2lkdGgnXS5wZlZhbHVlLCBzdHlsZVtwcmVmaXggKyAnLWFycm93LXNoYXBlJ10udmFsdWUsXG4gICAgeCwgeSwgYW5nbGVcbiAgKTtcbn07XG5cbkNScC5kcmF3QXJyb3dTaGFwZSA9IGZ1bmN0aW9uKGVkZ2UsIGFycm93VHlwZSwgY29udGV4dCwgZmlsbCwgZWRnZVdpZHRoLCBzaGFwZSwgeCwgeSwgYW5nbGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgdmFyIHBhdGg7XG4gIHZhciBjYW52YXNDb250ZXh0ID0gY29udGV4dDtcbiAgdmFyIHRyYW5zbGF0aW9uID0geyB4OiB4LCB5OiB5IH07XG4gIHZhciBzaXplID0gdGhpcy5nZXRBcnJvd1dpZHRoKCBlZGdlV2lkdGggKTtcbiAgdmFyIHNoYXBlSW1wbCA9IHIuYXJyb3dTaGFwZXNbc2hhcGVdO1xuXG4gIGlmKCB1c2VQYXRocyApe1xuICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBzaXplICsgJyQnICsgc2hhcGUgKyAnJCcgKyBhbmdsZSArICckJyArIHggKyAnJCcgKyB5O1xuICAgIHJzLmFycm93UGF0aENhY2hlS2V5ID0gcnMuYXJyb3dQYXRoQ2FjaGVLZXkgfHwge307XG4gICAgcnMuYXJyb3dQYXRoQ2FjaGUgPSBycy5hcnJvd1BhdGhDYWNoZSB8fCB7fTtcblxuICAgIHZhciBhbHJlYWR5Q2FjaGVkID0gcnMuYXJyb3dQYXRoQ2FjaGVLZXlbYXJyb3dUeXBlXSA9PT0gcGF0aENhY2hlS2V5O1xuICAgIGlmKCBhbHJlYWR5Q2FjaGVkICl7XG4gICAgICBwYXRoID0gY29udGV4dCA9IHJzLmFycm93UGF0aENhY2hlW2Fycm93VHlwZV07XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHJzLmFycm93UGF0aENhY2hlS2V5W2Fycm93VHlwZV0gPSBwYXRoQ2FjaGVLZXk7XG4gICAgICBycy5hcnJvd1BhdGhDYWNoZVthcnJvd1R5cGVdID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gIGlmKCAhcGF0aENhY2hlSGl0ICl7XG4gICAgc2hhcGVJbXBsLmRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgfVxuXG4gIGlmKCAhc2hhcGVJbXBsLmxlYXZlUGF0aE9wZW4gJiYgY29udGV4dC5jbG9zZVBhdGggKXtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG5cbiAgY29udGV4dCA9IGNhbnZhc0NvbnRleHQ7XG5cbiAgaWYoIGZpbGwgPT09ICdmaWxsZWQnIHx8IGZpbGwgPT09ICdib3RoJyApe1xuICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBmaWxsID09PSAnaG9sbG93JyB8fCBmaWxsID09PSAnYm90aCcgKXtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9ICggc2hhcGVJbXBsLm1hdGNoRWRnZVdpZHRoID8gZWRnZVdpZHRoIDogMSApO1xuICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cblxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcblxufSx7fV0sNjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5zYWZlRHJhd0ltYWdlID0gZnVuY3Rpb24oIGNvbnRleHQsIGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGggKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoIGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGggKTtcbiAgfSBjYXRjaChlKXtcbiAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbci5OT0RFXSA9IHRydWU7XG4gICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W3IuRFJBR10gPSB0cnVlO1xuXG4gICAgci5kcmF3aW5nSW1hZ2UgPSB0cnVlO1xuXG4gICAgci5yZWRyYXcoKTtcbiAgfVxufTtcblxuQ1JwLmRyYXdJbnNjcmliZWRJbWFnZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGltZywgbm9kZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBub2RlWCA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueDtcbiAgdmFyIG5vZGVZID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi55O1xuICB2YXIgc3R5bGUgPSBub2RlLl9wcml2YXRlLnN0eWxlO1xuICB2YXIgZml0ID0gc3R5bGVbJ2JhY2tncm91bmQtZml0J10udmFsdWU7XG4gIHZhciB4UG9zID0gc3R5bGVbJ2JhY2tncm91bmQtcG9zaXRpb24teCddO1xuICB2YXIgeVBvcyA9IHN0eWxlWydiYWNrZ3JvdW5kLXBvc2l0aW9uLXknXTtcbiAgdmFyIHJlcGVhdCA9IHN0eWxlWydiYWNrZ3JvdW5kLXJlcGVhdCddLnZhbHVlO1xuICB2YXIgbm9kZVcgPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSCA9IG5vZGUuaGVpZ2h0KCk7XG4gIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBjbGlwID0gc3R5bGVbJ2JhY2tncm91bmQtY2xpcCddLnZhbHVlO1xuICB2YXIgc2hvdWxkQ2xpcCA9IGNsaXAgPT09ICdub2RlJztcbiAgdmFyIGltZ09wYWNpdHkgPSBzdHlsZVsnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5J10udmFsdWU7XG5cbiAgdmFyIGltZ1cgPSBpbWcud2lkdGggfHwgaW1nLmNhY2hlZFc7XG4gIHZhciBpbWdIID0gaW1nLmhlaWdodCB8fCBpbWcuY2FjaGVkSDtcblxuICAvLyB3b3JrYXJvdW5kIGZvciBicm9rZW4gYnJvd3NlcnMgbGlrZSBpZVxuICBpZiggbnVsbCA9PSBpbWdXIHx8IG51bGwgPT0gaW1nSCApe1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIGltZyApO1xuXG4gICAgaW1nVyA9IGltZy5jYWNoZWRXID0gaW1nLndpZHRoIHx8IGltZy5vZmZzZXRXaWR0aDtcbiAgICBpbWdIID0gaW1nLmNhY2hlZEggPSBpbWcuaGVpZ2h0IHx8IGltZy5vZmZzZXRIZWlnaHQ7XG5cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKCBpbWcgKTtcbiAgfVxuXG4gIHZhciB3ID0gaW1nVztcbiAgdmFyIGggPSBpbWdIO1xuXG4gIHZhciBiZ1cgPSBzdHlsZVsnYmFja2dyb3VuZC13aWR0aCddO1xuICBpZiggYmdXLnZhbHVlICE9PSAnYXV0bycgKXtcbiAgICBpZiggYmdXLnVuaXRzID09PSAnJScgKXtcbiAgICAgIHcgPSBiZ1cudmFsdWUvMTAwICogbm9kZVc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSBiZ1cucGZWYWx1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmdIID0gc3R5bGVbJ2JhY2tncm91bmQtaGVpZ2h0J107XG4gIGlmKCBiZ0gudmFsdWUgIT09ICdhdXRvJyApe1xuICAgIGlmKCBiZ0gudW5pdHMgPT09ICclJyApe1xuICAgICAgaCA9IGJnSC52YWx1ZS8xMDAgKiBub2RlSDtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IGJnSC5wZlZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmKCB3ID09PSAwIHx8IGggPT09IDAgKXtcbiAgICByZXR1cm47IC8vIG5vIHBvaW50IGluIGRyYXdpbmcgZW1wdHkgaW1hZ2UgKGFuZCBjaHJvbWUgaXMgYnJva2VuIGluIHRoaXMgY2FzZSlcbiAgfVxuXG4gIGlmKCBmaXQgPT09ICdjb250YWluJyApe1xuICAgIHZhciBzY2FsZSA9IE1hdGgubWluKCBub2RlVy93LCBub2RlSC9oICk7XG5cbiAgICB3ICo9IHNjYWxlO1xuICAgIGggKj0gc2NhbGU7XG5cbiAgfSBlbHNlIGlmKCBmaXQgPT09ICdjb3ZlcicgKXtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1heCggbm9kZVcvdywgbm9kZUgvaCApO1xuXG4gICAgdyAqPSBzY2FsZTtcbiAgICBoICo9IHNjYWxlO1xuICB9XG5cbiAgdmFyIHggPSAobm9kZVggLSBub2RlVy8yKTsgLy8gbGVmdFxuICBpZiggeFBvcy51bml0cyA9PT0gJyUnICl7XG4gICAgeCArPSAobm9kZVcgLSB3KSAqIHhQb3MudmFsdWUvMTAwO1xuICB9IGVsc2Uge1xuICAgIHggKz0geFBvcy5wZlZhbHVlO1xuICB9XG5cbiAgdmFyIHkgPSAobm9kZVkgLSBub2RlSC8yKTsgLy8gdG9wXG4gIGlmKCB5UG9zLnVuaXRzID09PSAnJScgKXtcbiAgICB5ICs9IChub2RlSCAtIGgpICogeVBvcy52YWx1ZS8xMDA7XG4gIH0gZWxzZSB7XG4gICAgeSArPSB5UG9zLnBmVmFsdWU7XG4gIH1cblxuICBpZiggcnMucGF0aENhY2hlICl7XG4gICAgeCAtPSBub2RlWDtcbiAgICB5IC09IG5vZGVZO1xuXG4gICAgbm9kZVggPSAwO1xuICAgIG5vZGVZID0gMDtcbiAgfVxuXG4gIHZhciBnQWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuXG4gIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBpbWdPcGFjaXR5O1xuXG4gIGlmKCByZXBlYXQgPT09ICduby1yZXBlYXQnICl7XG5cbiAgICBpZiggc2hvdWxkQ2xpcCApe1xuICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgIGlmKCBycy5wYXRoQ2FjaGUgKXtcbiAgICAgICAgY29udGV4dC5jbGlwKCBycy5wYXRoQ2FjaGUgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG5vZGVYLCBub2RlWSxcbiAgICAgICAgICBub2RlVywgbm9kZUgpO1xuXG4gICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHIuc2FmZURyYXdJbWFnZSggY29udGV4dCwgaW1nLCAwLCAwLCBpbWdXLCBpbWdILCB4LCB5LCB3LCBoICk7XG5cbiAgICBpZiggc2hvdWxkQ2xpcCApe1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKCBpbWcsIHJlcGVhdCApO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVybjtcblxuICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbm9kZVgsIG5vZGVZLFxuICAgICAgICBub2RlVywgbm9kZUgpO1xuXG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxuXG4gIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBnQWxwaGE7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuXG59LHt9XSw2NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IF9kZXJlcV8oJy4uLy4uLy4uL2lzJyk7XG5cbnZhciBDUnAgPSB7fTtcblxuLy8gRHJhdyBlZGdlIHRleHRcbkNScC5kcmF3RWRnZVRleHQgPSBmdW5jdGlvbihjb250ZXh0LCBlZGdlKSB7XG4gIHZhciB0ZXh0ID0gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnbGFiZWwnXS5zdHJWYWx1ZTtcblxuICBpZiggIXRleHQgfHwgdGV4dC5tYXRjaCgvXlxccyskLykgKXtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiggdGhpcy5oaWRlRWRnZXNPblZpZXdwb3J0ICYmICh0aGlzLmRyYWdEYXRhLmRpZERyYWcgfHwgdGhpcy5waW5jaGluZyB8fCB0aGlzLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCB0aGlzLmRhdGEud2hlZWwgfHwgdGhpcy5zd2lwZVBhbm5pbmcpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyBvbiBwaW5jaGluZ1xuXG4gIHZhciBjb21wdXRlZFNpemUgPSBlZGdlLl9wcml2YXRlLnN0eWxlWydmb250LXNpemUnXS5wZlZhbHVlICogZWRnZS5jeSgpLnpvb20oKTtcbiAgdmFyIG1pblNpemUgPSBlZGdlLl9wcml2YXRlLnN0eWxlWydtaW4tem9vbWVkLWZvbnQtc2l6ZSddLnBmVmFsdWU7XG5cbiAgaWYoIGNvbXB1dGVkU2l6ZSA8IG1pblNpemUgKXtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdGV4dCBkcmF3IHBvc2l0aW9uXG5cbiAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICBpZiggIWlzLm51bWJlciggcnMubGFiZWxYICkgfHwgIWlzLm51bWJlciggcnMubGFiZWxZICkgKXsgcmV0dXJuOyB9IC8vIG5vIHBvcyA9PiBsYWJlbCBjYW4ndCBiZSByZW5kZXJlZFxuXG4gIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gIHZhciBhdXRvcm90YXRlID0gc3R5bGVbJ2VkZ2UtdGV4dC1yb3RhdGlvbiddLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZSc7XG4gIHZhciB0aGV0YTtcblxuICBpZiggYXV0b3JvdGF0ZSApe1xuICAgIHRoZXRhID0gcnMubGFiZWxBbmdsZTtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKHJzLmxhYmVsWCwgcnMubGFiZWxZKTtcbiAgICBjb250ZXh0LnJvdGF0ZSh0aGV0YSk7XG5cbiAgICB0aGlzLmRyYXdUZXh0KGNvbnRleHQsIGVkZ2UsIDAsIDApO1xuXG4gICAgY29udGV4dC5yb3RhdGUoLXRoZXRhKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtcnMubGFiZWxYLCAtcnMubGFiZWxZKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRyYXdUZXh0KGNvbnRleHQsIGVkZ2UsIHJzLmxhYmVsWCwgcnMubGFiZWxZKTtcbiAgfVxuXG59O1xuXG4vLyBEcmF3IG5vZGUgdGV4dFxuQ1JwLmRyYXdOb2RlVGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQsIG5vZGUpIHtcbiAgdmFyIHRleHQgPSBub2RlLl9wcml2YXRlLnN0eWxlWydsYWJlbCddLnN0clZhbHVlO1xuXG4gIGlmICggIXRleHQgfHwgdGV4dC5tYXRjaCgvXlxccyskLykgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbXB1dGVkU2l6ZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2ZvbnQtc2l6ZSddLnBmVmFsdWUgKiBub2RlLmN5KCkuem9vbSgpO1xuICB2YXIgbWluU2l6ZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ21pbi16b29tZWQtZm9udC1zaXplJ10ucGZWYWx1ZTtcblxuICBpZiggY29tcHV0ZWRTaXplIDwgbWluU2l6ZSApe1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHRoaXMucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uKCBub2RlICk7XG5cbiAgdmFyIHRleHRIYWxpZ24gPSBub2RlLl9wcml2YXRlLnN0eWxlWyd0ZXh0LWhhbGlnbiddLnN0clZhbHVlO1xuICB2YXIgdGV4dFZhbGlnbiA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3RleHQtdmFsaWduJ10uc3RyVmFsdWU7XG4gIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIGlmKCAhaXMubnVtYmVyKCBycy5sYWJlbFggKSB8fCAhaXMubnVtYmVyKCBycy5sYWJlbFkgKSApeyByZXR1cm47IH0gLy8gbm8gcG9zID0+IGxhYmVsIGNhbid0IGJlIHJlbmRlcmVkXG5cbiAgc3dpdGNoKCB0ZXh0SGFsaWduICl7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OiAvLyBlLmcuIGNlbnRlclxuICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgfVxuXG4gIHN3aXRjaCggdGV4dFZhbGlnbiApe1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDogLy8gZS5nLiBjZW50ZXJcbiAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gIH1cblxuICB0aGlzLmRyYXdUZXh0KGNvbnRleHQsIG5vZGUsIHJzLmxhYmVsWCwgcnMubGFiZWxZKTtcbn07XG5cbkNScC5nZXRGb250Q2FjaGUgPSBmdW5jdGlvbihjb250ZXh0KXtcbiAgdmFyIGNhY2hlO1xuXG4gIHRoaXMuZm9udENhY2hlcyA9IHRoaXMuZm9udENhY2hlcyB8fCBbXTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMuZm9udENhY2hlcy5sZW5ndGg7IGkrKyApe1xuICAgIGNhY2hlID0gdGhpcy5mb250Q2FjaGVzW2ldO1xuXG4gICAgaWYoIGNhY2hlLmNvbnRleHQgPT09IGNvbnRleHQgKXtcbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gIH1cblxuICBjYWNoZSA9IHtcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHRoaXMuZm9udENhY2hlcy5wdXNoKGNhY2hlKTtcblxuICByZXR1cm4gY2FjaGU7XG59O1xuXG4vLyBzZXQgdXAgY2FudmFzIGNvbnRleHQgd2l0aCBmb250XG4vLyByZXR1cm5zIHRyYW5zZm9ybWVkIHRleHQgc3RyaW5nXG5DUnAuc2V0dXBUZXh0U3R5bGUgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbWVudCApe1xuICAvLyBGb250IHN0eWxlXG4gIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlbWVudC5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQuX3ByaXZhdGUuc3R5bGU7XG4gIHZhciBsYWJlbFN0eWxlID0gc3R5bGVbJ2ZvbnQtc3R5bGUnXS5zdHJWYWx1ZTtcbiAgdmFyIGxhYmVsU2l6ZSA9IHN0eWxlWydmb250LXNpemUnXS5wZlZhbHVlICsgJ3B4JztcbiAgdmFyIGxhYmVsRmFtaWx5ID0gc3R5bGVbJ2ZvbnQtZmFtaWx5J10uc3RyVmFsdWU7XG4gIHZhciBsYWJlbFdlaWdodCA9IHN0eWxlWydmb250LXdlaWdodCddLnN0clZhbHVlO1xuICB2YXIgb3BhY2l0eSA9IHN0eWxlWyd0ZXh0LW9wYWNpdHknXS52YWx1ZSAqIHN0eWxlWydvcGFjaXR5J10udmFsdWUgKiBwYXJlbnRPcGFjaXR5O1xuICB2YXIgb3V0bGluZU9wYWNpdHkgPSBzdHlsZVsndGV4dC1vdXRsaW5lLW9wYWNpdHknXS52YWx1ZSAqIG9wYWNpdHk7XG4gIHZhciBjb2xvciA9IHN0eWxlWydjb2xvciddLnZhbHVlO1xuICB2YXIgb3V0bGluZUNvbG9yID0gc3R5bGVbJ3RleHQtb3V0bGluZS1jb2xvciddLnZhbHVlO1xuICB2YXIgc2hhZG93Qmx1ciA9IHN0eWxlWyd0ZXh0LXNoYWRvdy1ibHVyJ10ucGZWYWx1ZTtcbiAgdmFyIHNoYWRvd09wYWNpdHkgPSBzdHlsZVsndGV4dC1zaGFkb3ctb3BhY2l0eSddLnZhbHVlO1xuICB2YXIgc2hhZG93Q29sb3IgPSBzdHlsZVsndGV4dC1zaGFkb3ctY29sb3InXS52YWx1ZTtcbiAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZVsndGV4dC1zaGFkb3ctb2Zmc2V0LXgnXS5wZlZhbHVlO1xuICB2YXIgc2hhZG93T2Zmc2V0WSA9IHN0eWxlWyd0ZXh0LXNoYWRvdy1vZmZzZXQteSddLnBmVmFsdWU7XG5cbiAgdmFyIGZvbnRDYWNoZUtleSA9IGVsZW1lbnQuX3ByaXZhdGUuZm9udEtleTtcbiAgdmFyIGNhY2hlID0gdGhpcy5nZXRGb250Q2FjaGUoY29udGV4dCk7XG5cbiAgaWYoIGNhY2hlLmtleSAhPT0gZm9udENhY2hlS2V5ICl7XG4gICAgY29udGV4dC5mb250ID0gbGFiZWxTdHlsZSArICcgJyArIGxhYmVsV2VpZ2h0ICsgJyAnICsgbGFiZWxTaXplICsgJyAnICsgbGFiZWxGYW1pbHk7XG5cbiAgICBjYWNoZS5rZXkgPSBmb250Q2FjaGVLZXk7XG4gIH1cblxuICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KCBlbGVtZW50ICk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRleHQgZHJhdyBwb3NpdGlvbiBiYXNlZCBvbiB0ZXh0IGFsaWdubWVudFxuXG4gIC8vIHNvIHRleHQgb3V0bGluZXMgYXJlbid0IGphZ2dlZFxuICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJztcblxuICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcblxuICB0aGlzLnN0cm9rZVN0eWxlKGNvbnRleHQsIG91dGxpbmVDb2xvclswXSwgb3V0bGluZUNvbG9yWzFdLCBvdXRsaW5lQ29sb3JbMl0sIG91dGxpbmVPcGFjaXR5KTtcblxuICB0aGlzLnNoYWRvd1N0eWxlKGNvbnRleHQsIHNoYWRvd0NvbG9yLCBzaGFkb3dPcGFjaXR5LCBzaGFkb3dCbHVyLCBzaGFkb3dPZmZzZXRYLCBzaGFkb3dPZmZzZXRZKTtcblxuICByZXR1cm4gdGV4dDtcbn07XG5cbmZ1bmN0aW9uIHJvdW5kUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICB2YXIgcmFkaXVzID0gcmFkaXVzIHx8IDU7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICBjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmZpbGwoKTtcbn1cblxuLy8gRHJhdyB0ZXh0XG5DUnAuZHJhd1RleHQgPSBmdW5jdGlvbihjb250ZXh0LCBlbGVtZW50LCB0ZXh0WCwgdGV4dFkpIHtcbiAgdmFyIF9wID0gZWxlbWVudC5fcHJpdmF0ZTtcbiAgdmFyIHN0eWxlID0gX3Auc3R5bGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZW1lbnQuZWZmZWN0aXZlT3BhY2l0eSgpO1xuICBpZiggcGFyZW50T3BhY2l0eSA9PT0gMCB8fCBzdHlsZVsndGV4dC1vcGFjaXR5J10udmFsdWUgPT09IDApeyByZXR1cm47IH1cblxuICB2YXIgdGV4dCA9IHRoaXMuc2V0dXBUZXh0U3R5bGUoIGNvbnRleHQsIGVsZW1lbnQgKTtcbiAgdmFyIGhhbGlnbiA9IHN0eWxlWyd0ZXh0LWhhbGlnbiddLnZhbHVlO1xuICB2YXIgdmFsaWduID0gc3R5bGVbJ3RleHQtdmFsaWduJ10udmFsdWU7XG5cbiAgaWYoIGVsZW1lbnQuaXNFZGdlKCkgKXtcbiAgICBoYWxpZ24gPSAnY2VudGVyJztcbiAgICB2YWxpZ24gPSAnY2VudGVyJztcbiAgfVxuXG4gIGlmKCBlbGVtZW50LmlzTm9kZSgpICl7XG4gICAgdmFyIHBMZWZ0ID0gc3R5bGVbJ3BhZGRpbmctbGVmdCddLnBmVmFsdWU7XG4gICAgdmFyIHBSaWdodCA9IHN0eWxlWydwYWRkaW5nLXJpZ2h0J10ucGZWYWx1ZTtcbiAgICB2YXIgcFRvcCA9IHN0eWxlWydwYWRkaW5nLXRvcCddLnBmVmFsdWU7XG4gICAgdmFyIHBCb3R0b20gPSBzdHlsZVsncGFkZGluZy1ib3R0b20nXS5wZlZhbHVlO1xuXG4gICAgdGV4dFggKz0gcExlZnQvMjtcbiAgICB0ZXh0WCAtPSBwUmlnaHQvMjtcblxuICAgIHRleHRZICs9IHBUb3AvMjtcbiAgICB0ZXh0WSAtPSBwQm90dG9tLzI7XG4gIH1cblxuICBpZiAoIHRleHQgIT0gbnVsbCAmJiAhaXNOYU4odGV4dFgpICYmICFpc05hTih0ZXh0WSkpIHtcbiAgICB2YXIgYmFja2dyb3VuZE9wYWNpdHkgPSBzdHlsZVsndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknXS52YWx1ZTtcbiAgICB2YXIgYm9yZGVyT3BhY2l0eSA9IHN0eWxlWyd0ZXh0LWJvcmRlci1vcGFjaXR5J10udmFsdWU7XG4gICAgdmFyIHRleHRCb3JkZXJXaWR0aCA9IHN0eWxlWyd0ZXh0LWJvcmRlci13aWR0aCddLnBmVmFsdWU7XG5cbiAgICBpZiggYmFja2dyb3VuZE9wYWNpdHkgPiAwIHx8ICh0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwKSApe1xuICAgICAgdmFyIG1hcmdpbiA9IDQgKyB0ZXh0Qm9yZGVyV2lkdGgvMjtcblxuICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpIHtcbiAgICAgICAgLy9Nb3ZlIHRleHRYLCB0ZXh0WSB0byBpbmNsdWRlIHRoZSBiYWNrZ3JvdW5kIG1hcmdpbnNcbiAgICAgICAgaWYgKHZhbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB0ZXh0WSAtPSBtYXJnaW47XG4gICAgICAgIH0gZWxzZSBpZiAodmFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHRleHRZICs9IG1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0ZXh0WCAtPSBtYXJnaW47XG4gICAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGV4dFggKz0gbWFyZ2luO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBiZ1dpZHRoID0gcnN0eWxlLmxhYmVsV2lkdGg7XG4gICAgICB2YXIgYmdIZWlnaHQgPSByc3R5bGUubGFiZWxIZWlnaHQ7XG4gICAgICB2YXIgYmdYID0gdGV4dFg7XG5cbiAgICAgIGlmIChoYWxpZ24pIHtcbiAgICAgICAgaWYgKGhhbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgICAgIGJnWCA9IGJnWCAtIGJnV2lkdGggLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbGlnbiA9PSAnbGVmdCcpIHtcbiAgICAgICAgICBiZ1ggPSBiZ1gtIGJnV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJnWSA9IHRleHRZO1xuXG4gICAgICBpZiAoZWxlbWVudC5pc05vZGUoKSkge1xuICAgICAgICBpZiAodmFsaWduID09ICd0b3AnKSB7XG4gICAgICAgICAgIGJnWSA9IGJnWSAtIGJnSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKHZhbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgICAgIGJnWSA9IGJnWS0gYmdIZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZ1kgPSBiZ1kgLSBiZ0hlaWdodCAvIDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZVsnZWRnZS10ZXh0LXJvdGF0aW9uJ10uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJykge1xuICAgICAgICB0ZXh0WSA9IDA7XG4gICAgICAgIGJnV2lkdGggKz0gNDtcbiAgICAgICAgYmdYID0gdGV4dFggLSBiZ1dpZHRoIC8gMjtcbiAgICAgICAgYmdZID0gdGV4dFkgLSBiZ0hlaWdodCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGp1c3Qgd2l0aCBib3JkZXIgd2lkdGggJiBtYXJnaW5cbiAgICAgICAgYmdYIC09IG1hcmdpbjtcbiAgICAgICAgYmdZIC09IG1hcmdpbjtcbiAgICAgICAgYmdIZWlnaHQgKz0gbWFyZ2luKjI7XG4gICAgICAgIGJnV2lkdGggKz0gbWFyZ2luKjI7XG4gICAgICB9XG5cbiAgICAgIGlmKCBiYWNrZ3JvdW5kT3BhY2l0eSA+IDAgKXtcbiAgICAgICAgdmFyIHRleHRGaWxsID0gY29udGV4dC5maWxsU3R5bGU7XG4gICAgICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gc3R5bGVbJ3RleHQtYmFja2dyb3VuZC1jb2xvciddLnZhbHVlO1xuXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMF0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzFdICsgJywnICsgdGV4dEJhY2tncm91bmRDb2xvclsyXSArICcsJyArIGJhY2tncm91bmRPcGFjaXR5ICogcGFyZW50T3BhY2l0eSArICcpJztcbiAgICAgICAgdmFyIHN0eWxlU2hhcGUgPSBzdHlsZVsndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJ10uc3RyVmFsdWU7XG4gICAgICAgIGlmIChzdHlsZVNoYXBlID09ICdyb3VuZHJlY3RhbmdsZScpIHtcbiAgICAgICAgICByb3VuZFJlY3QoY29udGV4dCwgYmdYLCBiZ1ksIGJnV2lkdGgsIGJnSGVpZ2h0LCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KGJnWCxiZ1ksYmdXaWR0aCxiZ0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0ZXh0RmlsbDtcbiAgICAgIH1cblxuICAgICAgaWYoIHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDAgKXtcbiAgICAgICAgdmFyIHRleHRTdHJva2UgPSBjb250ZXh0LnN0cm9rZVN0eWxlO1xuICAgICAgICB2YXIgdGV4dExpbmVXaWR0aCA9IGNvbnRleHQubGluZVdpZHRoO1xuICAgICAgICB2YXIgdGV4dEJvcmRlckNvbG9yID0gc3R5bGVbJ3RleHQtYm9yZGVyLWNvbG9yJ10udmFsdWU7XG4gICAgICAgIHZhciB0ZXh0Qm9yZGVyU3R5bGUgPSBzdHlsZVsndGV4dC1ib3JkZXItc3R5bGUnXS52YWx1ZTtcblxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHRleHRCb3JkZXJDb2xvclswXSArICcsJyArIHRleHRCb3JkZXJDb2xvclsxXSArICcsJyArIHRleHRCb3JkZXJDb2xvclsyXSArICcsJyArIGJvcmRlck9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aDtcblxuICAgICAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICBzd2l0Y2goIHRleHRCb3JkZXJTdHlsZSApe1xuICAgICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIDEsIDEgXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIDQsIDIgXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGgvNDsgLy8gNTAlIHJlc2VydmVkIGZvciB3aGl0ZSBiZXR3ZWVuIHRoZSB0d28gYm9yZGVyc1xuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChiZ1gsYmdZLGJnV2lkdGgsYmdIZWlnaHQpO1xuXG4gICAgICAgIGlmKCB0ZXh0Qm9yZGVyU3R5bGUgPT09ICdkb3VibGUnICl7XG4gICAgICAgICAgdmFyIHdoaXRlV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGgvMjtcblxuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChiZ1grd2hpdGVXaWR0aCxiZ1krd2hpdGVXaWR0aCxiZ1dpZHRoLXdoaXRlV2lkdGgqMixiZ0hlaWdodC13aGl0ZVdpZHRoKjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dExpbmVXaWR0aDtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRleHRTdHJva2U7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgbGluZVdpZHRoID0gMiAgKiBzdHlsZVsndGV4dC1vdXRsaW5lLXdpZHRoJ10ucGZWYWx1ZTsgLy8gKjIgYi9jIHRoZSBzdHJva2UgaXMgZHJhd24gY2VudHJlZCBvbiB0aGUgbWlkZGxlXG5cbiAgICBpZiggbGluZVdpZHRoID4gMCApe1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgfVxuXG4gICAgaWYoIHN0eWxlWyd0ZXh0LXdyYXAnXS52YWx1ZSA9PT0gJ3dyYXAnICl7XG4gICAgICB2YXIgbGluZXMgPSByc2NyYXRjaC5sYWJlbFdyYXBDYWNoZWRMaW5lcztcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gcnN0eWxlLmxhYmVsSGVpZ2h0IC8gbGluZXMubGVuZ3RoO1xuXG4gICAgICBzd2l0Y2goIHZhbGlnbiApe1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHRleHRZIC09IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAvLyBub3RoaW5nIHJlcXVpcmVkXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICB0ZXh0WSAtPSAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKyApe1xuICAgICAgICBpZiggbGluZVdpZHRoID4gMCApe1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCggbGluZXNbbF0sIHRleHRYLCB0ZXh0WSApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5maWxsVGV4dCggbGluZXNbbF0sIHRleHRYLCB0ZXh0WSApO1xuXG4gICAgICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIGxpbmVXaWR0aCA+IDAgKXtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KCB0ZXh0LCB0ZXh0WCwgdGV4dFkgKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5maWxsVGV4dCggdGV4dCwgdGV4dFgsIHRleHRZICk7XG4gICAgfVxuXG5cbiAgICB0aGlzLnNoYWRvd1N0eWxlKGNvbnRleHQsICd0cmFuc3BhcmVudCcsIDApOyAvLyByZXNldCBmb3IgbmV4dCBndXlcbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcblxufSx7XCIuLi8uLi8uLi9pc1wiOjc3fV0sNjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi8uLi8uLi9pcycpO1xuXG52YXIgQ1JwID0ge307XG5cbi8vIERyYXcgbm9kZVxuQ1JwLmRyYXdOb2RlID0gZnVuY3Rpb24oY29udGV4dCwgbm9kZSwgZHJhd092ZXJsYXlJbnN0ZWFkKSB7XG5cbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbm9kZVdpZHRoLCBub2RlSGVpZ2h0O1xuICB2YXIgc3R5bGUgPSBub2RlLl9wcml2YXRlLnN0eWxlO1xuICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICB2YXIgcG9zID0gX3AucG9zaXRpb247XG5cbiAgaWYoICFpcy5udW1iZXIocG9zLngpIHx8ICFpcy5udW1iZXIocG9zLnkpICl7XG4gICAgcmV0dXJuOyAvLyBjYW4ndCBkcmF3IG5vZGUgd2l0aCB1bmRlZmluZWQgcG9zaXRpb25cbiAgfVxuXG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgdmFyIGNhbnZhc0NvbnRleHQgPSBjb250ZXh0O1xuICB2YXIgcGF0aDtcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuXG4gIHZhciBvdmVybGF5UGFkZGluZyA9IHN0eWxlWydvdmVybGF5LXBhZGRpbmcnXS5wZlZhbHVlO1xuICB2YXIgb3ZlcmxheU9wYWNpdHkgPSBzdHlsZVsnb3ZlcmxheS1vcGFjaXR5J10udmFsdWU7XG4gIHZhciBvdmVybGF5Q29sb3IgPSBzdHlsZVsnb3ZlcmxheS1jb2xvciddLnZhbHVlO1xuXG4gIGlmKCBkcmF3T3ZlcmxheUluc3RlYWQgJiYgb3ZlcmxheU9wYWNpdHkgPT09IDAgKXsgLy8gZXhpdCBlYXJseSBpZiBkcmF3aW5nIG92ZXJsYXkgYnV0IG5vbmUgdG8gZHJhd1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXJlbnRPcGFjaXR5ID0gbm9kZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gIGlmKCBwYXJlbnRPcGFjaXR5ID09PSAwICl7IHJldHVybjsgfVxuXG4gIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKSArIHN0eWxlWydwYWRkaW5nLWxlZnQnXS5wZlZhbHVlICsgc3R5bGVbJ3BhZGRpbmctcmlnaHQnXS5wZlZhbHVlO1xuICBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKSArIHN0eWxlWydwYWRkaW5nLXRvcCddLnBmVmFsdWUgKyBzdHlsZVsncGFkZGluZy1ib3R0b20nXS5wZlZhbHVlO1xuXG4gIGNvbnRleHQubGluZVdpZHRoID0gc3R5bGVbJ2JvcmRlci13aWR0aCddLnBmVmFsdWU7XG5cbiAgaWYoIGRyYXdPdmVybGF5SW5zdGVhZCA9PT0gdW5kZWZpbmVkIHx8ICFkcmF3T3ZlcmxheUluc3RlYWQgKXtcblxuICAgIHZhciB1cmwgPSBzdHlsZVsnYmFja2dyb3VuZC1pbWFnZSddLnZhbHVlWzJdIHx8XG4gICAgICBzdHlsZVsnYmFja2dyb3VuZC1pbWFnZSddLnZhbHVlWzFdO1xuICAgIHZhciBpbWFnZTtcblxuICAgIGlmICh1cmwgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAvLyBnZXQgaW1hZ2UsIGFuZCBpZiBub3QgbG9hZGVkIHRoZW4gYXNrIHRvIHJlZHJhdyB3aGVuIGxhdGVyIGxvYWRlZFxuICAgICAgaW1hZ2UgPSB0aGlzLmdldENhY2hlZEltYWdlKHVybCwgZnVuY3Rpb24oKXtcbiAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbci5EUkFHXSA9IHRydWU7XG5cbiAgICAgICAgci5kcmF3aW5nSW1hZ2UgPSB0cnVlO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHByZXZCZ2luZyA9IF9wLmJhY2tncm91bmRpbmc7XG4gICAgICBfcC5iYWNrZ3JvdW5kaW5nID0gIWltYWdlLmNvbXBsZXRlO1xuXG4gICAgICBpZiggcHJldkJnaW5nICE9PSBfcC5iYWNrZ3JvdW5kaW5nICl7IC8vIHVwZGF0ZSBzdHlsZSBiL2MgOmJhY2tncm91bmRpbmcgc3RhdGUgY2hhbmdlZFxuICAgICAgICBub2RlLnVwZGF0ZVN0eWxlKCBmYWxzZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vZGUgY29sb3IgJiBvcGFjaXR5XG5cbiAgICB2YXIgYmdDb2xvciA9IHN0eWxlWydiYWNrZ3JvdW5kLWNvbG9yJ10udmFsdWU7XG4gICAgdmFyIGJvcmRlckNvbG9yID0gc3R5bGVbJ2JvcmRlci1jb2xvciddLnZhbHVlO1xuICAgIHZhciBib3JkZXJTdHlsZSA9IHN0eWxlWydib3JkZXItc3R5bGUnXS52YWx1ZTtcblxuICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIGJnQ29sb3JbMF0sIGJnQ29sb3JbMV0sIGJnQ29sb3JbMl0sIHN0eWxlWydiYWNrZ3JvdW5kLW9wYWNpdHknXS52YWx1ZSAqIHBhcmVudE9wYWNpdHkpO1xuXG4gICAgdGhpcy5zdHJva2VTdHlsZShjb250ZXh0LCBib3JkZXJDb2xvclswXSwgYm9yZGVyQ29sb3JbMV0sIGJvcmRlckNvbG9yWzJdLCBzdHlsZVsnYm9yZGVyLW9wYWNpdHknXS52YWx1ZSAqIHBhcmVudE9wYWNpdHkpO1xuXG4gICAgdmFyIHNoYWRvd0JsdXIgPSBzdHlsZVsnc2hhZG93LWJsdXInXS5wZlZhbHVlO1xuICAgIHZhciBzaGFkb3dPcGFjaXR5ID0gc3R5bGVbJ3NoYWRvdy1vcGFjaXR5J10udmFsdWU7XG4gICAgdmFyIHNoYWRvd0NvbG9yID0gc3R5bGVbJ3NoYWRvdy1jb2xvciddLnZhbHVlO1xuICAgIHZhciBzaGFkb3dPZmZzZXRYID0gc3R5bGVbJ3NoYWRvdy1vZmZzZXQteCddLnBmVmFsdWU7XG4gICAgdmFyIHNoYWRvd09mZnNldFkgPSBzdHlsZVsnc2hhZG93LW9mZnNldC15J10ucGZWYWx1ZTtcblxuICAgIHRoaXMuc2hhZG93U3R5bGUoY29udGV4dCwgc2hhZG93Q29sb3IsIHNoYWRvd09wYWNpdHksIHNoYWRvd0JsdXIsIHNoYWRvd09mZnNldFgsIHNoYWRvd09mZnNldFkpO1xuXG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7IC8vIHNvIGJvcmRlcnMgYXJlIHNxdWFyZSB3aXRoIHRoZSBub2RlIHNoYXBlXG5cbiAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgIHN3aXRjaCggYm9yZGVyU3R5bGUgKXtcbiAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgMSwgMSBdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyA0LCAyIF0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICB2YXIgc3R5bGVTaGFwZSA9IHN0eWxlWydzaGFwZSddLnN0clZhbHVlO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICB2YXIgcGF0aENhY2hlS2V5ID0gc3R5bGVTaGFwZSArICckJyArIG5vZGVXaWR0aCArJyQnICsgbm9kZUhlaWdodDtcblxuICAgICAgY29udGV4dC50cmFuc2xhdGUoIHBvcy54LCBwb3MueSApO1xuXG4gICAgICBpZiggcnMucGF0aENhY2hlS2V5ID09PSBwYXRoQ2FjaGVLZXkgKXtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5wYXRoQ2FjaGU7XG4gICAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCAhcGF0aENhY2hlSGl0ICl7XG5cbiAgICAgIHZhciBucG9zID0gcG9zO1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgbnBvcyA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG5wb3MueCxcbiAgICAgICAgICAgIG5wb3MueSxcbiAgICAgICAgICAgIG5vZGVXaWR0aCxcbiAgICAgICAgICAgIG5vZGVIZWlnaHQpO1xuICAgIH1cblxuICAgIGNvbnRleHQgPSBjYW52YXNDb250ZXh0O1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGFkb3dTdHlsZShjb250ZXh0LCAndHJhbnNwYXJlbnQnLCAwKTsgLy8gcmVzZXQgZm9yIG5leHQgZ3V5XG5cbiAgICBpZiAodXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmKCBpbWFnZS5jb21wbGV0ZSApe1xuICAgICAgICB0aGlzLmRyYXdJbnNjcmliZWRJbWFnZShjb250ZXh0LCBpbWFnZSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRhcmtuZXNzID0gc3R5bGVbJ2JhY2tncm91bmQtYmxhY2tlbiddLnZhbHVlO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IHN0eWxlWydib3JkZXItd2lkdGgnXS5wZlZhbHVlO1xuXG4gICAgaWYoIHRoaXMuaGFzUGllKG5vZGUpICl7XG4gICAgICB0aGlzLmRyYXdQaWUoIGNvbnRleHQsIG5vZGUsIHBhcmVudE9wYWNpdHkgKTtcblxuICAgICAgLy8gcmVkcmF3IHBhdGggZm9yIGJsYWNrZW4gYW5kIGJvcmRlclxuICAgICAgaWYoIGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwICl7XG5cbiAgICAgICAgaWYoICF1c2VQYXRocyApe1xuICAgICAgICAgIHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhcbiAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgcG9zLngsXG4gICAgICAgICAgICAgIHBvcy55LFxuICAgICAgICAgICAgICBub2RlV2lkdGgsXG4gICAgICAgICAgICAgIG5vZGVIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGRhcmtuZXNzID4gMCApe1xuICAgICAgdGhpcy5maWxsU3R5bGUoY29udGV4dCwgMCwgMCwgMCwgZGFya25lc3MpO1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiggZGFya25lc3MgPCAwICl7XG4gICAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAtZGFya25lc3MpO1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCb3JkZXIgd2lkdGgsIGRyYXcgYm9yZGVyXG4gICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC5zdHJva2UoIHBhdGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBib3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScgKXtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHlsZVsnYm9yZGVyLXdpZHRoJ10ucGZWYWx1ZS8zO1xuXG4gICAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcblxuICAgICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoIC1wb3MueCwgLXBvcy55ICk7XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgaW4gY2FzZSB3ZSBjaGFuZ2VkIHRoZSBib3JkZXIgc3R5bGVcbiAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICB9XG5cbiAgLy8gZHJhdyB0aGUgb3ZlcmxheVxuICB9IGVsc2Uge1xuXG4gICAgaWYoIG92ZXJsYXlPcGFjaXR5ID4gMCApe1xuICAgICAgdGhpcy5maWxsU3R5bGUoY29udGV4dCwgb3ZlcmxheUNvbG9yWzBdLCBvdmVybGF5Q29sb3JbMV0sIG92ZXJsYXlDb2xvclsyXSwgb3ZlcmxheU9wYWNpdHkpO1xuXG4gICAgICByLm5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10uZHJhdyhcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICBub2RlLl9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIG5vZGVXaWR0aCArIG92ZXJsYXlQYWRkaW5nICogMixcbiAgICAgICAgbm9kZUhlaWdodCArIG92ZXJsYXlQYWRkaW5nICogMlxuICAgICAgKTtcblxuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbi8vIGRvZXMgdGhlIG5vZGUgaGF2ZSBhdCBsZWFzdCBvbmUgcGllIHBpZWNlP1xuQ1JwLmhhc1BpZSA9IGZ1bmN0aW9uKG5vZGUpe1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5oYXNQaWU7XG59O1xuXG5DUnAuZHJhd1BpZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBub2RlLCBub2RlT3BhY2l0eSApe1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICB2YXIgY3lTdHlsZSA9IG5vZGUuY3koKS5zdHlsZSgpO1xuICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgdmFyIHBpZVNpemUgPSBzdHlsZVsncGllLXNpemUnXTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgeCA9IF9wLnBvc2l0aW9uLng7XG4gIHZhciB5ID0gX3AucG9zaXRpb24ueTtcbiAgdmFyIHJhZGl1cyA9IE1hdGgubWluKCBub2RlVywgbm9kZUggKSAvIDI7IC8vIG11c3QgZml0IGluIG5vZGVcbiAgdmFyIGxhc3RQZXJjZW50ID0gMDsgLy8gd2hhdCAlIHRvIGNvbnRpbnVlIGRyYXdpbmcgcGllIHNsaWNlcyBmcm9tIG9uIFswLCAxXVxuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG5cbiAgaWYoIHVzZVBhdGhzICl7XG4gICAgeCA9IDA7XG4gICAgeSA9IDA7XG4gIH1cblxuICBpZiggcGllU2l6ZS51bml0cyA9PT0gJyUnICl7XG4gICAgcmFkaXVzID0gcmFkaXVzICogcGllU2l6ZS52YWx1ZSAvIDEwMDtcbiAgfSBlbHNlIGlmKCBwaWVTaXplLnBmVmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgIHJhZGl1cyA9IHBpZVNpemUucGZWYWx1ZSAvIDI7XG4gIH1cblxuICBmb3IoIHZhciBpID0gMTsgaSA8PSBjeVN0eWxlLnBpZUJhY2tncm91bmROOyBpKysgKXsgLy8gMS4uTlxuICAgIHZhciBzaXplID0gc3R5bGVbJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJ10udmFsdWU7XG4gICAgdmFyIGNvbG9yID0gc3R5bGVbJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvciddLnZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gc3R5bGVbJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5J10udmFsdWUgKiBub2RlT3BhY2l0eTtcbiAgICB2YXIgcGVyY2VudCA9IHNpemUgLyAxMDA7IC8vIG1hcCBpbnRlZ2VyIHJhbmdlIFswLCAxMDBdIHRvIFswLCAxXVxuXG4gICAgLy8gcGVyY2VudCBjYW4ndCBwdXNoIGJleW9uZCAxXG4gICAgaWYoIHBlcmNlbnQgKyBsYXN0UGVyY2VudCA+IDEgKXtcbiAgICAgIHBlcmNlbnQgPSAxIC0gbGFzdFBlcmNlbnQ7XG4gICAgfVxuXG4gICAgdmFyIGFuZ2xlU3RhcnQgPSAxLjUgKiBNYXRoLlBJICsgMiAqIE1hdGguUEkgKiBsYXN0UGVyY2VudDsgLy8gc3RhcnQgYXQgMTIgbydjbG9jayBhbmQgZ28gY2xvY2t3aXNlXG4gICAgdmFyIGFuZ2xlRGVsdGEgPSAyICogTWF0aC5QSSAqIHBlcmNlbnQ7XG4gICAgdmFyIGFuZ2xlRW5kID0gYW5nbGVTdGFydCArIGFuZ2xlRGVsdGE7XG5cbiAgICAvLyBpZ25vcmUgaWZcbiAgICAvLyAtIHplcm8gc2l6ZVxuICAgIC8vIC0gd2UncmUgYWxyZWFkeSBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG4gICAgLy8gLSBhZGRpbmcgdGhlIGN1cnJlbnQgc2xpY2Ugd291bGQgZ28gYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgIGlmKCBzaXplID09PSAwIHx8IGxhc3RQZXJjZW50ID49IDEgfHwgbGFzdFBlcmNlbnQgKyBwZXJjZW50ID4gMSApe1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICBjb250ZXh0LmFyYyggeCwgeSwgcmFkaXVzLCBhbmdsZVN0YXJ0LCBhbmdsZUVuZCApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcblxuICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgbGFzdFBlcmNlbnQgKz0gcGVyY2VudDtcbiAgfVxuXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuXG59LHtcIi4uLy4uLy4uL2lzXCI6Nzd9XSw2NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBDUnAgPSB7fTtcblxudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi8uLi8uLi91dGlsJyk7XG52YXIgbWF0aCA9IF9kZXJlcV8oJy4uLy4uLy4uL21hdGgnKTtcblxudmFyIG1vdGlvbkJsdXJEZWxheSA9IDEwMDtcblxuLy8gdmFyIGlzRmlyZWZveCA9IHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG5cbkNScC5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24oKXtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmRhdGEuY29udGV4dHNbMF07XG5cbiAgaWYoIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyAhPSBudWxsICl7XG4gICAgcmV0dXJuIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbztcbiAgfVxuXG4gIHZhciBiYWNraW5nU3RvcmUgPSBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgIGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblxuICByZXR1cm4gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gYmFja2luZ1N0b3JlO1xufTtcblxuQ1JwLnBhaW50Q2FjaGUgPSBmdW5jdGlvbihjb250ZXh0KXtcbiAgdmFyIGNhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzIHx8IFtdO1xuICB2YXIgbmVlZFRvQ3JlYXRlQ2FjaGUgPSB0cnVlO1xuICB2YXIgY2FjaGU7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IGNhY2hlcy5sZW5ndGg7IGkrKyApe1xuICAgIGNhY2hlID0gY2FjaGVzW2ldO1xuXG4gICAgaWYoIGNhY2hlLmNvbnRleHQgPT09IGNvbnRleHQgKXtcbiAgICAgIG5lZWRUb0NyZWF0ZUNhY2hlID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiggbmVlZFRvQ3JlYXRlQ2FjaGUgKXtcbiAgICBjYWNoZSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9O1xuICAgIGNhY2hlcy5wdXNoKCBjYWNoZSApO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufTtcblxuQ1JwLmZpbGxTdHlsZSA9IGZ1bmN0aW9uKGNvbnRleHQsIHIsIGcsIGIsIGEpe1xuICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gIC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcblxuICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG5cbiAgLy8gdmFyIGZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gIC8vIGlmKCBjYWNoZS5maWxsU3R5bGUgIT09IGZpbGxTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuZmlsbFN0eWxlID0gY2FjaGUuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAvLyB9XG59O1xuXG5DUnAuc3Ryb2tlU3R5bGUgPSBmdW5jdGlvbihjb250ZXh0LCByLCBnLCBiLCBhKXtcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gIC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcblxuICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG5cbiAgLy8gdmFyIHN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG5cbiAgLy8gaWYoIGNhY2hlLnN0cm9rZVN0eWxlICE9PSBzdHJva2VTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjYWNoZS5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAvLyB9XG59O1xuXG5DUnAuc2hhZG93U3R5bGUgPSBmdW5jdGlvbihjb250ZXh0LCBjb2xvciwgb3BhY2l0eSwgYmx1ciwgb2Zmc2V0WCwgb2Zmc2V0WSl7XG4gIHZhciB6b29tID0gdGhpcy5jeS56b29tKCk7XG5cbiAgdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuXG4gIC8vIGRvbid0IG1ha2UgZXhwZW5zaXZlIGNoYW5nZXMgdG8gdGhlIHNoYWRvdyBzdHlsZSBpZiBpdCdzIG5vdCB1c2VkXG4gIGlmKCBjYWNoZS5zaGFkb3dPcGFjaXR5ID09PSAwICYmIG9wYWNpdHkgPT09IDAgKXtcbiAgICByZXR1cm47XG4gIH1cblxuICBjYWNoZS5zaGFkb3dPcGFjaXR5ID0gb3BhY2l0eTtcblxuICBpZiAob3BhY2l0eSA+IDApIHtcbiAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBibHVyICogem9vbTtcbiAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gXCJyZ2JhKFwiICsgY29sb3JbMF0gKyBcIixcIiArIGNvbG9yWzFdICsgXCIsXCIgKyBjb2xvclsyXSArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiO1xuICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IG9mZnNldFggKiB6b29tO1xuICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IG9mZnNldFkgKiB6b29tO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG4gICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgfVxufTtcblxuLy8gUmVzaXplIGNhbnZhc1xuQ1JwLm1hdGNoQ2FudmFzU2l6ZSA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBkYXRhID0gci5kYXRhO1xuICB2YXIgd2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpO1xuICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcblxuICBpZihcbiAgICBjb250YWluZXIgPT09IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdIHx8XG4gICAgY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXVxuICApe1xuICAgIHBpeGVsUmF0aW8gPSBtYlB4UmF0aW87XG4gIH1cblxuICB2YXIgY2FudmFzV2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICB2YXIgY2FudmFzO1xuXG4gIGlmKCBjYW52YXNXaWR0aCA9PT0gci5jYW52YXNXaWR0aCAmJiBjYW52YXNIZWlnaHQgPT09IHIuY2FudmFzSGVpZ2h0ICl7XG4gICAgcmV0dXJuOyAvLyBzYXZlIGN5Y2xlcyBpZiBzYW1lXG4gIH1cblxuICByLmZvbnRDYWNoZXMgPSBudWxsOyAvLyByZXNpemluZyByZXNldHMgdGhlIHN0eWxlXG5cbiAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IGRhdGEuY2FudmFzQ29udGFpbmVyO1xuICBjYW52YXNDb250YWluZXIuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5DQU5WQVNfTEFZRVJTOyBpKyspIHtcblxuICAgIGNhbnZhcyA9IGRhdGEuY2FudmFzZXNbaV07XG5cbiAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcblxuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuQlVGRkVSX0NPVU5UOyBpKyspIHtcblxuICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbaV07XG5cbiAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcblxuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH1cblxuICByLnRleHR1cmVNdWx0ID0gMTtcbiAgaWYoIHBpeGVsUmF0aW8gPD0gMSApe1xuICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbIHIuVEVYVFVSRV9CVUZGRVIgXTtcblxuICAgIHIudGV4dHVyZU11bHQgPSAyO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoICogci50ZXh0dXJlTXVsdDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdDtcbiAgfVxuXG4gIHIuY2FudmFzV2lkdGggPSBjYW52YXNXaWR0aDtcbiAgci5jYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG5cbn07XG5cbkNScC5yZW5kZXJUbyA9IGZ1bmN0aW9uKCBjeHQsIHpvb20sIHBhbiwgcHhSYXRpbyApe1xuICB0aGlzLnJlbmRlcih7XG4gICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgIGZvcmNlZFpvb206IHpvb20sXG4gICAgZm9yY2VkUGFuOiBwYW4sXG4gICAgZHJhd0FsbExheWVyczogdHJ1ZSxcbiAgICBmb3JjZWRQeFJhdGlvOiBweFJhdGlvXG4gIH0pO1xufTtcblxuQ1JwLnJlbmRlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB1dGlsLnN0YXRpY0VtcHR5T2JqZWN0KCk7XG5cbiAgdmFyIGZvcmNlZENvbnRleHQgPSBvcHRpb25zLmZvcmNlZENvbnRleHQ7XG4gIHZhciBkcmF3QWxsTGF5ZXJzID0gb3B0aW9ucy5kcmF3QWxsTGF5ZXJzO1xuICB2YXIgZHJhd09ubHlOb2RlTGF5ZXIgPSBvcHRpb25zLmRyYXdPbmx5Tm9kZUxheWVyO1xuICB2YXIgZm9yY2VkWm9vbSA9IG9wdGlvbnMuZm9yY2VkWm9vbTtcbiAgdmFyIGZvcmNlZFBhbiA9IG9wdGlvbnMuZm9yY2VkUGFuO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBwaXhlbFJhdGlvID0gb3B0aW9ucy5mb3JjZWRQeFJhdGlvID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFBpeGVsUmF0aW8oKSA6IG9wdGlvbnMuZm9yY2VkUHhSYXRpbztcbiAgdmFyIGN5ID0gci5jeTsgdmFyIGRhdGEgPSByLmRhdGE7XG4gIHZhciBuZWVkRHJhdyA9IGRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG4gIHZhciB0ZXh0dXJlRHJhdyA9IHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQgJiYgKHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyk7XG4gIHZhciBtb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1vdGlvbkJsdXIgOiByLm1vdGlvbkJsdXI7XG4gIHZhciBtYlB4UmF0aW8gPSByLm1vdGlvbkJsdXJQeFJhdGlvO1xuICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGluTm9kZURyYWdHZXN0dXJlID0gci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzO1xuICB2YXIgaW5Cb3hTZWxlY3Rpb24gPSByLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nID8gdHJ1ZSA6IGZhbHNlO1xuICBtb3Rpb25CbHVyID0gbW90aW9uQmx1ciAmJiAhZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJFbmFibGVkICYmICFpbkJveFNlbGVjdGlvbjtcbiAgdmFyIG1vdGlvbkJsdXJGYWRlRWZmZWN0ID0gbW90aW9uQmx1cjtcblxuICBpZiggIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyVGltZW91dCApe1xuICAgIGNsZWFyVGltZW91dCggci5tb3Rpb25CbHVyVGltZW91dCApO1xuICB9XG5cbiAgaWYoIG1vdGlvbkJsdXIgKXtcbiAgICBpZiggci5tYkZyYW1lcyA9PSBudWxsICl7XG4gICAgICByLm1iRnJhbWVzID0gMDtcbiAgICB9XG5cbiAgICBpZiggIXIuZHJhd2luZ0ltYWdlICl7IC8vIGltYWdlIGxvYWRpbmcgZnJhbWVzIGRvbid0IGNvdW50IHRvd2FyZHMgbW90aW9uIGJsdXIgYmx1cnJ5IGZyYW1lc1xuICAgICAgci5tYkZyYW1lcysrO1xuICAgIH1cblxuICAgIGlmKCByLm1iRnJhbWVzIDwgMyApeyAvLyBuZWVkIHNldmVyYWwgZnJhbWVzIGJlZm9yZSBldmVuIGhpZ2ggcXVhbGl0eSBtb3Rpb25ibHVyXG4gICAgICBtb3Rpb25CbHVyRmFkZUVmZmVjdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGdvIHRvIGxvd2VyIHF1YWxpdHkgYmx1cnJ5IGZyYW1lcyB3aGVuIHNldmVyYWwgbS9iIGZyYW1lcyBoYXZlIGJlZW4gcmVuZGVyZWQgKGF2b2lkcyBmbGFzaGluZylcbiAgICBpZiggci5tYkZyYW1lcyA+IHIubWluTWJMb3dRdWFsRnJhbWVzICl7XG4gICAgICAvL3IuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICAgICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IHIubWJQeFJCbHVycnk7XG4gICAgfVxuICB9XG5cbiAgaWYoIHIuY2xlYXJpbmdNb3Rpb25CbHVyICl7XG4gICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIH1cblxuICAvLyBiL2MgZHJhd1RvQ29udGV4dCgpIG1heSBiZSBhc3luYyB3LnIudC4gcmVkcmF3KCksIGtlZXAgdHJhY2sgb2YgbGFzdCB0ZXh0dXJlIGZyYW1lXG4gIC8vIGJlY2F1c2UgYSByb2d1ZSBhc3luYyB0ZXh0dXJlIGZyYW1lIHdvdWxkIGNsZWFyIG5lZWREcmF3XG4gIGlmKCByLnRleHR1cmVEcmF3TGFzdEZyYW1lICYmICF0ZXh0dXJlRHJhdyApe1xuICAgIG5lZWREcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICB9XG5cbiAgdmFyIGVkZ2VzID0gci5nZXRDYWNoZWRFZGdlcygpO1xuICB2YXIgY29yZVN0eWxlID0gY3kuc3R5bGUoKS5fcHJpdmF0ZS5jb3JlU3R5bGU7XG5cbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBlZmZlY3RpdmVab29tID0gZm9yY2VkWm9vbSAhPT0gdW5kZWZpbmVkID8gZm9yY2VkWm9vbSA6IHpvb207XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIGVmZmVjdGl2ZVBhbiA9IHtcbiAgICB4OiBwYW4ueCxcbiAgICB5OiBwYW4ueVxuICB9O1xuXG4gIHZhciB2cCA9IHtcbiAgICB6b29tOiB6b29tLFxuICAgIHBhbjoge1xuICAgICAgeDogcGFuLngsXG4gICAgICB5OiBwYW4ueVxuICAgIH1cbiAgfTtcbiAgdmFyIHByZXZWcCA9IHIucHJldlZpZXdwb3J0O1xuICB2YXIgdmlld3BvcnRJc0RpZmYgPSBwcmV2VnAgPT09IHVuZGVmaW5lZCB8fCB2cC56b29tICE9PSBwcmV2VnAuem9vbSB8fCB2cC5wYW4ueCAhPT0gcHJldlZwLnBhbi54IHx8IHZwLnBhbi55ICE9PSBwcmV2VnAucGFuLnk7XG5cbiAgLy8gd2Ugd2FudCB0aGUgbG93IHF1YWxpdHkgbW90aW9uYmx1ciBvbmx5IHdoZW4gdGhlIHZpZXdwb3J0IGlzIGJlaW5nIG1hbmlwdWxhdGVkIGV0YyAod2hlcmUgaXQncyBub3Qgbm90aWNlZClcbiAgaWYoICF2aWV3cG9ydElzRGlmZiAmJiAhKGluTm9kZURyYWdHZXN0dXJlICYmICFoYXNDb21wb3VuZE5vZGVzKSApe1xuICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICB9XG5cbiAgaWYoIGZvcmNlZFBhbiApe1xuICAgIGVmZmVjdGl2ZVBhbiA9IGZvcmNlZFBhbjtcbiAgfVxuXG4gIC8vIGFwcGx5IHBpeGVsIHJhdGlvXG5cbiAgZWZmZWN0aXZlWm9vbSAqPSBwaXhlbFJhdGlvO1xuICBlZmZlY3RpdmVQYW4ueCAqPSBwaXhlbFJhdGlvO1xuICBlZmZlY3RpdmVQYW4ueSAqPSBwaXhlbFJhdGlvO1xuXG4gIHZhciBlbGVzID0ge1xuICAgIGRyYWc6IHtcbiAgICAgIG5vZGVzOiBbXSxcbiAgICAgIGVkZ2VzOiBbXSxcbiAgICAgIGVsZXM6IFtdXG4gICAgfSxcbiAgICBub25kcmFnOiB7XG4gICAgICBub2RlczogW10sXG4gICAgICBlZGdlczogW10sXG4gICAgICBlbGVzOiBbXVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBtYmNsZWFyKCBjb250ZXh0LCB4LCB5LCB3LCBoICl7XG4gICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICByLmZpbGxTdHlsZSggY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgci5tb3Rpb25CbHVyVHJhbnNwYXJlbmN5ICk7XG4gICAgY29udGV4dC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBjbGVhcil7XG4gICAgdmFyIGVQYW4sIGVab29tLCB3LCBoO1xuXG4gICAgaWYoICFyLmNsZWFyaW5nTW90aW9uQmx1ciAmJiAoY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdIHx8IGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSkgKXtcbiAgICAgIGVQYW4gPSB7XG4gICAgICAgIHg6IHBhbi54ICogbWJQeFJhdGlvLFxuICAgICAgICB5OiBwYW4ueSAqIG1iUHhSYXRpb1xuICAgICAgfTtcblxuICAgICAgZVpvb20gPSB6b29tICogbWJQeFJhdGlvO1xuXG4gICAgICB3ID0gci5jYW52YXNXaWR0aCAqIG1iUHhSYXRpbztcbiAgICAgIGggPSByLmNhbnZhc0hlaWdodCAqIG1iUHhSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgZVBhbiA9IGVmZmVjdGl2ZVBhbjtcbiAgICAgIGVab29tID0gZWZmZWN0aXZlWm9vbTtcblxuICAgICAgdyA9IHIuY2FudmFzV2lkdGg7XG4gICAgICBoID0gci5jYW52YXNIZWlnaHQ7XG4gICAgfVxuXG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICBpZiggY2xlYXIgPT09ICdtb3Rpb25CbHVyJyApe1xuICAgICAgbWJjbGVhcihjb250ZXh0LCAwLCAwLCB3LCBoKTtcbiAgICB9IGVsc2UgaWYoICFmb3JjZWRDb250ZXh0ICYmIChjbGVhciA9PT0gdW5kZWZpbmVkIHx8IGNsZWFyKSApe1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgfVxuXG4gICAgaWYoICFkcmF3QWxsTGF5ZXJzICl7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSggZVBhbi54LCBlUGFuLnkgKTtcbiAgICAgIGNvbnRleHQuc2NhbGUoIGVab29tLCBlWm9vbSApO1xuICAgIH1cbiAgICBpZiggZm9yY2VkUGFuICl7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSggZm9yY2VkUGFuLngsIGZvcmNlZFBhbi55ICk7XG4gICAgfVxuICAgIGlmKCBmb3JjZWRab29tICl7XG4gICAgICBjb250ZXh0LnNjYWxlKCBmb3JjZWRab29tLCBmb3JjZWRab29tICk7XG4gICAgfVxuICB9XG5cbiAgaWYoICF0ZXh0dXJlRHJhdyApe1xuICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmKCB0ZXh0dXJlRHJhdyApe1xuICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSB0cnVlO1xuXG4gICAgdmFyIGJiO1xuXG4gICAgaWYoICFyLnRleHR1cmVDYWNoZSApe1xuICAgICAgci50ZXh0dXJlQ2FjaGUgPSB7fTtcblxuICAgICAgYmIgPSByLnRleHR1cmVDYWNoZS5iYiA9IGN5LmVsZW1lbnRzKCkuYm91bmRpbmdCb3goKTtcblxuICAgICAgci50ZXh0dXJlQ2FjaGUudGV4dHVyZSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1sgci5URVhUVVJFX0JVRkZFUiBdO1xuXG4gICAgICB2YXIgY3h0ID0gci5kYXRhLmJ1ZmZlckNvbnRleHRzWyByLlRFWFRVUkVfQlVGRkVSIF07XG5cbiAgICAgIGN4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBjeHQuY2xlYXJSZWN0KDAsIDAsIHIuY2FudmFzV2lkdGggKiByLnRleHR1cmVNdWx0LCByLmNhbnZhc0hlaWdodCAqIHIudGV4dHVyZU11bHQpO1xuXG4gICAgICByLnJlbmRlcih7XG4gICAgICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICAgICAgZHJhd09ubHlOb2RlTGF5ZXI6IHRydWUsXG4gICAgICAgIGZvcmNlZFB4UmF0aW86IHBpeGVsUmF0aW8gKiByLnRleHR1cmVNdWx0XG4gICAgICB9KTtcblxuICAgICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQgPSB7XG4gICAgICAgIHpvb206IGN5Lnpvb20oKSxcbiAgICAgICAgcGFuOiBjeS5wYW4oKSxcbiAgICAgICAgd2lkdGg6IHIuY2FudmFzV2lkdGgsXG4gICAgICAgIGhlaWdodDogci5jYW52YXNIZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIHZwLm1wYW4gPSB7XG4gICAgICAgIHg6ICgwIC0gdnAucGFuLngpL3ZwLnpvb20sXG4gICAgICAgIHk6ICgwIC0gdnAucGFuLnkpL3ZwLnpvb21cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcblxuICAgIHZhciBjb250ZXh0ID0gZGF0YS5jb250ZXh0c1tyLk5PREVdO1xuXG4gICAgdmFyIHRleHR1cmUgPSByLnRleHR1cmVDYWNoZS50ZXh0dXJlO1xuICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0O1xuICAgIGJiID0gci50ZXh0dXJlQ2FjaGUuYmI7XG5cbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgIGlmKCBtb3Rpb25CbHVyICl7XG4gICAgICBtYmNsZWFyKGNvbnRleHQsIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB2YXIgb3V0c2lkZUJnQ29sb3IgPSBjb3JlU3R5bGVbJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvciddLnZhbHVlO1xuICAgIHZhciBvdXRzaWRlQmdPcGFjaXR5ID0gY29yZVN0eWxlWydvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eSddLnZhbHVlO1xuICAgIHIuZmlsbFN0eWxlKCBjb250ZXh0LCBvdXRzaWRlQmdDb2xvclswXSwgb3V0c2lkZUJnQ29sb3JbMV0sIG91dHNpZGVCZ0NvbG9yWzJdLCBvdXRzaWRlQmdPcGFjaXR5ICk7XG4gICAgY29udGV4dC5maWxsUmVjdCggMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCApO1xuXG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0LCBmYWxzZSApO1xuXG4gICAgY29udGV4dC5jbGVhclJlY3QoIHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aC92cC56b29tL3BpeGVsUmF0aW8sIHZwLmhlaWdodC92cC56b29tL3BpeGVsUmF0aW8gKTtcbiAgICBjb250ZXh0LmRyYXdJbWFnZSggdGV4dHVyZSwgdnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoL3ZwLnpvb20vcGl4ZWxSYXRpbywgdnAuaGVpZ2h0L3ZwLnpvb20vcGl4ZWxSYXRpbyApO1xuXG4gIH0gZWxzZSBpZiggci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCApeyAvLyBjbGVhciB0aGUgY2FjaGUgc2luY2Ugd2UgZG9uJ3QgbmVlZCBpdFxuICAgIHIudGV4dHVyZUNhY2hlID0gbnVsbDtcbiAgfVxuXG4gIHZhciB2cE1hbmlwID0gKHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMpO1xuICB2YXIgaGlkZUVkZ2VzID0gci5oaWRlRWRnZXNPblZpZXdwb3J0ICYmIHZwTWFuaXA7XG4gIHZhciBoaWRlTGFiZWxzID0gci5oaWRlTGFiZWxzT25WaWV3cG9ydCAmJiB2cE1hbmlwO1xuXG4gIGlmIChuZWVkRHJhd1tyLkRSQUddIHx8IG5lZWREcmF3W3IuTk9ERV0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllcikge1xuICAgIGlmKCBoaWRlRWRnZXMgKXtcbiAgICB9IGVsc2Uge1xuICAgICAgci5maW5kRWRnZUNvbnRyb2xQb2ludHMoZWRnZXMpO1xuICAgIH1cblxuICAgIHZhciB6RWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgICB2YXIgZXh0ZW50ID0gY3kuZXh0ZW50KCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpFbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gekVsZXNbaV07XG4gICAgICB2YXIgbGlzdDtcbiAgICAgIHZhciBiYiA9IGZvcmNlZENvbnRleHQgPyBudWxsIDogZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgICB2YXIgaW5zaWRlRXh0ZW50ID0gZm9yY2VkQ29udGV4dCA/IHRydWUgOiBtYXRoLmJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoIGV4dGVudCwgYmIgKTtcblxuICAgICAgaWYoICFpbnNpZGVFeHRlbnQgKXsgY29udGludWU7IH0gLy8gbm8gbmVlZCB0byByZW5kZXJcblxuICAgICAgaWYgKCBlbGUuX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgKSB7XG4gICAgICAgIGxpc3QgPSBlbGVzLmRyYWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0ID0gZWxlcy5ub25kcmFnO1xuICAgICAgfVxuXG4gICAgICBsaXN0LmVsZXMucHVzaCggZWxlICk7XG4gICAgfVxuXG4gIH1cblxuXG4gIGZ1bmN0aW9uIGRyYXdFbGVtZW50cyggbGlzdCwgY29udGV4dCApe1xuICAgIHZhciBlbGVzID0gbGlzdC5lbGVzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgaWYoIGVsZS5pc05vZGUoKSApe1xuICAgICAgICByLmRyYXdOb2RlKGNvbnRleHQsIGVsZSk7XG5cbiAgICAgICAgaWYoICFoaWRlTGFiZWxzICl7XG4gICAgICAgICAgci5kcmF3Tm9kZVRleHQoY29udGV4dCwgZWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuZHJhd05vZGUoY29udGV4dCwgZWxlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiggIWhpZGVFZGdlcyApIHtcbiAgICAgICAgci5kcmF3RWRnZShjb250ZXh0LCBlbGUpO1xuXG4gICAgICAgIGlmKCAhaGlkZUxhYmVscyApe1xuICAgICAgICAgIHIuZHJhd0VkZ2VUZXh0KGNvbnRleHQsIGVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByLmRyYXdFZGdlKGNvbnRleHQsIGVsZSwgdHJ1ZSk7XG4gICAgICB9XG5cblxuICAgIH1cblxuICB9XG5cbiAgdmFyIG5lZWRNYkNsZWFyID0gW107XG5cbiAgbmVlZE1iQ2xlYXJbci5OT0RFXSA9ICFuZWVkRHJhd1tyLk5PREVdICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5OT0RFXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcbiAgaWYoIG5lZWRNYkNsZWFyW3IuTk9ERV0gKXsgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdID0gdHJ1ZTsgfVxuXG4gIG5lZWRNYkNsZWFyW3IuRFJBR10gPSAhbmVlZERyYXdbci5EUkFHXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG4gIGlmKCBuZWVkTWJDbGVhcltyLkRSQUddICl7IHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSA9IHRydWU7IH1cblxuICBpZiggbmVlZERyYXdbci5OT0RFXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IGRyYXdPbmx5Tm9kZUxheWVyIHx8IG5lZWRNYkNsZWFyW3IuTk9ERV0gKXtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbci5OT0RFXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICggdXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzWyByLk1PVElPTkJMVVJfQlVGRkVSX05PREUgXSA6IGRhdGEuY29udGV4dHNbci5OT0RFXSApO1xuICAgIHZhciBjbGVhciA9IG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZDtcblxuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oIGNvbnRleHQsIGNsZWFyICk7XG4gICAgZHJhd0VsZW1lbnRzKGVsZXMubm9uZHJhZywgY29udGV4dCk7XG5cbiAgICBpZiggIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIgKXtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoICFkcmF3T25seU5vZGVMYXllciAmJiAobmVlZERyYXdbci5EUkFHXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IG5lZWRNYkNsZWFyW3IuRFJBR10pICkge1xuICAgIHZhciB1c2VCdWZmZXIgPSBtb3Rpb25CbHVyICYmICFuZWVkTWJDbGVhcltyLkRSQUddICYmIG1iUHhSYXRpbyAhPT0gMTtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgKCB1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbIHIuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyBdIDogZGF0YS5jb250ZXh0c1tyLkRSQUddICk7XG5cbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0LCBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQgKTtcbiAgICBkcmF3RWxlbWVudHMoZWxlcy5kcmFnLCBjb250ZXh0KTtcblxuICAgIGlmKCAhZHJhd0FsbExheWVycyAmJiAhbW90aW9uQmx1ciApe1xuICAgICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmKCByLnNob3dGcHMgfHwgKCFkcmF3T25seU5vZGVMYXllciAmJiAobmVlZERyYXdbci5TRUxFQ1RfQk9YXSAmJiAhZHJhd0FsbExheWVycykpICkge1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCBkYXRhLmNvbnRleHRzW3IuU0VMRUNUX0JPWF07XG5cbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0ICk7XG5cbiAgICBpZiggci5zZWxlY3Rpb25bNF0gPT0gMSAmJiAoIHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcgKSApe1xuICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnXS52YWx1ZSAvIHpvb207XG5cbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwicmdiYShcIlxuICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1jb2xvciddLnZhbHVlWzBdICsgXCIsXCJcbiAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtY29sb3InXS52YWx1ZVsxXSArIFwiLFwiXG4gICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWNvbG9yJ10udmFsdWVbMl0gKyBcIixcIlxuICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1vcGFjaXR5J10udmFsdWUgKyBcIilcIjtcblxuICAgICAgY29udGV4dC5maWxsUmVjdChcbiAgICAgICAgci5zZWxlY3Rpb25bMF0sXG4gICAgICAgIHIuc2VsZWN0aW9uWzFdLFxuICAgICAgICByLnNlbGVjdGlvblsyXSAtIHIuc2VsZWN0aW9uWzBdLFxuICAgICAgICByLnNlbGVjdGlvblszXSAtIHIuc2VsZWN0aW9uWzFdKTtcblxuICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJyZ2JhKFwiXG4gICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJ10udmFsdWVbMF0gKyBcIixcIlxuICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvciddLnZhbHVlWzFdICsgXCIsXCJcbiAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InXS52YWx1ZVsyXSArIFwiLFwiXG4gICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSddLnZhbHVlICsgXCIpXCI7XG5cbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KFxuICAgICAgICAgIHIuc2VsZWN0aW9uWzBdLFxuICAgICAgICAgIHIuc2VsZWN0aW9uWzFdLFxuICAgICAgICAgIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sXG4gICAgICAgICAgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyApe1xuICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgIHZhciBwb3MgPSBkYXRhLmJnQWN0aXZlUG9zaXN0aW9uO1xuXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwicmdiYShcIlxuICAgICAgICArIGNvcmVTdHlsZVsnYWN0aXZlLWJnLWNvbG9yJ10udmFsdWVbMF0gKyBcIixcIlxuICAgICAgICArIGNvcmVTdHlsZVsnYWN0aXZlLWJnLWNvbG9yJ10udmFsdWVbMV0gKyBcIixcIlxuICAgICAgICArIGNvcmVTdHlsZVsnYWN0aXZlLWJnLWNvbG9yJ10udmFsdWVbMl0gKyBcIixcIlxuICAgICAgICArIGNvcmVTdHlsZVsnYWN0aXZlLWJnLW9wYWNpdHknXS52YWx1ZSArIFwiKVwiO1xuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMocG9zLngsIHBvcy55LCBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1zaXplJ10ucGZWYWx1ZSAvIHpvb20sIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cblxuICAgIHZhciB0aW1lVG9SZW5kZXIgPSByLmxhc3RSZWRyYXdUaW1lO1xuICAgIGlmKCByLnNob3dGcHMgJiYgdGltZVRvUmVuZGVyICl7XG4gICAgICB0aW1lVG9SZW5kZXIgPSBNYXRoLnJvdW5kKCB0aW1lVG9SZW5kZXIgKTtcbiAgICAgIHZhciBmcHMgPSBNYXRoLnJvdW5kKDEwMDAvdGltZVRvUmVuZGVyKTtcblxuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KCAnMSBmcmFtZSA9ICcgKyB0aW1lVG9SZW5kZXIgKyAnIG1zID0gJyArIGZwcyArICcgZnBzJywgMCwgMjApO1xuXG4gICAgICB2YXIgbWF4RnBzID0gNjA7XG4gICAgICBjb250ZXh0LnN0cm9rZVJlY3QoMCwgMzAsIDI1MCwgMjApO1xuICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAzMCwgMjUwICogTWF0aC5taW4oZnBzL21heEZwcywgMSksIDIwKTtcbiAgICB9XG5cbiAgICBpZiggIWRyYXdBbGxMYXllcnMgKXtcbiAgICAgIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBtb3Rpb25ibHVyOiBibGl0IHJlbmRlcmVkIGJsdXJyeSBmcmFtZXNcbiAgaWYoIG1vdGlvbkJsdXIgJiYgbWJQeFJhdGlvICE9PSAxICl7XG4gICAgdmFyIGN4dE5vZGUgPSBkYXRhLmNvbnRleHRzW3IuTk9ERV07XG4gICAgdmFyIHR4dE5vZGUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIHIuTU9USU9OQkxVUl9CVUZGRVJfTk9ERSBdO1xuXG4gICAgdmFyIGN4dERyYWcgPSBkYXRhLmNvbnRleHRzW3IuRFJBR107XG4gICAgdmFyIHR4dERyYWcgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIHIuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyBdO1xuXG4gICAgdmFyIGRyYXdNb3Rpb25CbHVyID0gZnVuY3Rpb24oIGN4dCwgdHh0LCBuZWVkQ2xlYXIgKXtcbiAgICAgIGN4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAgIGlmKCBuZWVkQ2xlYXIgfHwgIW1vdGlvbkJsdXJGYWRlRWZmZWN0ICl7XG4gICAgICAgIGN4dC5jbGVhclJlY3QoIDAsIDAsIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0ICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYmNsZWFyKCBjeHQsIDAsIDAsIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0ICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBweHIgPSBtYlB4UmF0aW87XG5cbiAgICAgIGN4dC5kcmF3SW1hZ2UoXG4gICAgICAgIHR4dCwgLy8gaW1nXG4gICAgICAgIDAsIDAsIC8vIHN4LCBzeVxuICAgICAgICByLmNhbnZhc1dpZHRoICogcHhyLCByLmNhbnZhc0hlaWdodCAqIHB4ciwgLy8gc3csIHNoXG4gICAgICAgIDAsIDAsIC8vIHgsIHlcbiAgICAgICAgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQgLy8gdywgaFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgaWYoIG5lZWREcmF3W3IuTk9ERV0gfHwgbmVlZE1iQ2xlYXJbci5OT0RFXSApe1xuICAgICAgZHJhd01vdGlvbkJsdXIoIGN4dE5vZGUsIHR4dE5vZGUsIG5lZWRNYkNsZWFyW3IuTk9ERV0gKTtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiggbmVlZERyYXdbci5EUkFHXSB8fCBuZWVkTWJDbGVhcltyLkRSQUddICl7XG4gICAgICBkcmF3TW90aW9uQmx1ciggY3h0RHJhZywgdHh0RHJhZywgbmVlZE1iQ2xlYXJbci5EUkFHXSApO1xuICAgICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHIuY3VycmVudGx5RHJhd2luZyA9IGZhbHNlO1xuXG4gIHIucHJldlZpZXdwb3J0ID0gdnA7XG5cbiAgaWYoIHIuY2xlYXJpbmdNb3Rpb25CbHVyICl7XG4gICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICByLm1vdGlvbkJsdXJDbGVhcmVkID0gdHJ1ZTtcbiAgICByLm1vdGlvbkJsdXIgPSB0cnVlO1xuICB9XG5cbiAgaWYoIG1vdGlvbkJsdXIgKXtcbiAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgci5tb3Rpb25CbHVyVGltZW91dCA9IG51bGw7XG5cbiAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5OT0RFXSA9IGZhbHNlO1xuICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLkRSQUddID0gZmFsc2U7XG4gICAgICByLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gIXRleHR1cmVEcmF3O1xuICAgICAgci5tYkZyYW1lcyA9IDA7XG5cbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgICAgbmVlZERyYXdbci5EUkFHXSA9IHRydWU7XG5cbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfSwgbW90aW9uQmx1ckRlbGF5KTtcbiAgfVxuXG4gIHIuZHJhd2luZ0ltYWdlID0gZmFsc2U7XG5cblxuICBpZiggIWZvcmNlZENvbnRleHQgJiYgIXIuaW5pdHJlbmRlciApe1xuICAgIHIuaW5pdHJlbmRlciA9IHRydWU7XG4gICAgY3kudHJpZ2dlcignaW5pdHJlbmRlcicpO1xuICB9XG5cbiAgaWYoICFmb3JjZWRDb250ZXh0ICl7XG4gICAgY3kudHJpZ2dlck9uUmVuZGVyKCk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG5cbn0se1wiLi4vLi4vLi4vbWF0aFwiOjc5LFwiLi4vLi4vLi4vdXRpbFwiOjk0fV0sNjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBtYXRoID0gX2RlcmVxXygnLi4vLi4vLi4vbWF0aCcpO1xuXG4gIHZhciBDUnAgPSB7fTtcblxuICAvLyBATyBQb2x5Z29uIGRyYXdpbmdcbiAgQ1JwLmRyYXdQb2x5Z29uUGF0aCA9IGZ1bmN0aW9uKFxuICAgIGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuXG4gICAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG5cbiAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgY29udGV4dC5tb3ZlVG8oIHggKyBoYWxmVyAqIHBvaW50c1swXSwgeSArIGhhbGZIICogcG9pbnRzWzFdICk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGNvbnRleHQubGluZVRvKCB4ICsgaGFsZlcgKiBwb2ludHNbaSAqIDJdLCB5ICsgaGFsZkggKiBwb2ludHNbaSAqIDIgKyAxXSApO1xuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgLy8gUm91bmQgcmVjdGFuZ2xlIGRyYXdpbmdcbiAgQ1JwLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbihcbiAgICBjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcblxuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgIHZhciBjb3JuZXJSYWRpdXMgPSBtYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICAgIC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcbiAgICBjb250ZXh0Lm1vdmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gICAgLy8gQXJjIGZyb20gbWlkZGxlIHRvcCB0byByaWdodCBzaWRlXG4gICAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCArIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgICAvLyBBcmMgZnJvbSByaWdodCBzaWRlIHRvIGJvdHRvbVxuICAgIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHgsIHkgKyBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICAgIC8vIEFyYyBmcm9tIGJvdHRvbSB0byBsZWZ0IHNpZGVcbiAgICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpO1xuICAgIC8vIEFyYyBmcm9tIGxlZnQgc2lkZSB0byB0b3BCb3JkZXJcbiAgICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4LCB5IC0gaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgICAvLyBKb2luIGxpbmVcbiAgICBjb250ZXh0LmxpbmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG5cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgdmFyIHNpbjAgPSBNYXRoLnNpbigwKTtcbiAgdmFyIGNvczAgPSBNYXRoLmNvcygwKTtcblxuICB2YXIgc2luID0ge307XG4gIHZhciBjb3MgPSB7fTtcblxuICB2YXIgZWxsaXBzZVN0ZXBTaXplID0gTWF0aC5QSSAvIDQwO1xuXG4gIGZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSApIHtcbiAgICBzaW5baV0gPSBNYXRoLnNpbihpKTtcbiAgICBjb3NbaV0gPSBNYXRoLmNvcyhpKTtcbiAgfVxuXG4gIENScC5kcmF3RWxsaXBzZVBhdGggPSBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KXtcbiAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgaWYoIGNvbnRleHQuZWxsaXBzZSApe1xuICAgICAgY29udGV4dC5lbGxpcHNlKCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aC8yLCBoZWlnaHQvMiwgMCwgMCwgMipNYXRoLlBJICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4UG9zLCB5UG9zO1xuICAgICAgdmFyIHJ3ID0gd2lkdGgvMjtcbiAgICAgIHZhciByaCA9IGhlaWdodC8yO1xuICAgICAgZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplICkge1xuICAgICAgICB4UG9zID0gY2VudGVyWCAtIChydyAqIHNpbltpXSkgKiBzaW4wICsgKHJ3ICogY29zW2ldKSAqIGNvczA7XG4gICAgICAgIHlQb3MgPSBjZW50ZXJZICsgKHJoICogY29zW2ldKSAqIHNpbjAgKyAocmggKiBzaW5baV0pICogY29zMDtcblxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG5cbn0se1wiLi4vLi4vLi4vbWF0aFwiOjc5fV0sNjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi8uLi8uLi9pcycpO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbih3LCBoKSB7XG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgYnVmZmVyLndpZHRoID0gdztcbiAgYnVmZmVyLmhlaWdodCA9IGg7XG5cbiAgcmV0dXJuIFtidWZmZXIsIGJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpXTtcbn07XG5cbkNScC5idWZmZXJDYW52YXNJbWFnZSA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBiYiA9IGN5LmVsZW1lbnRzKCkuYm91bmRpbmdCb3goKTtcbiAgdmFyIHdpZHRoID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKGJiLncpIDogdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoYmIuaCkgOiB0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gIHZhciBzY2FsZSA9IDE7XG5cbiAgaWYoIG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCApe1xuICAgIHdpZHRoICo9IG9wdGlvbnMuc2NhbGU7XG4gICAgaGVpZ2h0ICo9IG9wdGlvbnMuc2NhbGU7XG5cbiAgICBzY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gIH0gZWxzZSBpZiggaXMubnVtYmVyKG9wdGlvbnMubWF4V2lkdGgpIHx8IGlzLm51bWJlcihvcHRpb25zLm1heEhlaWdodCkgKXtcbiAgICB2YXIgbWF4U2NhbGVXID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFNjYWxlSCA9IEluZmluaXR5O1xuXG4gICAgaWYoIGlzLm51bWJlcihvcHRpb25zLm1heFdpZHRoKSApe1xuICAgICAgbWF4U2NhbGVXID0gc2NhbGUgKiBvcHRpb25zLm1heFdpZHRoIC8gd2lkdGg7XG4gICAgfVxuXG4gICAgaWYoIGlzLm51bWJlcihvcHRpb25zLm1heEhlaWdodCkgKXtcbiAgICAgIG1heFNjYWxlSCA9IHNjYWxlICogb3B0aW9ucy5tYXhIZWlnaHQgLyBoZWlnaHQ7XG4gICAgfVxuXG4gICAgc2NhbGUgPSBNYXRoLm1pbiggbWF4U2NhbGVXLCBtYXhTY2FsZUggKTtcblxuICAgIHdpZHRoICo9IHNjYWxlO1xuICAgIGhlaWdodCAqPSBzY2FsZTtcbiAgfVxuXG4gIHZhciBidWZmQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgYnVmZkNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBidWZmQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICBidWZmQ2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBidWZmQ2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgdmFyIGJ1ZmZDeHQgPSBidWZmQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgLy8gUmFzdGVyaXplIHRoZSBsYXllcnMsIGJ1dCBvbmx5IGlmIGNvbnRhaW5lciBoYXMgbm9uemVybyBzaXplXG4gIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuXG4gICAgYnVmZkN4dC5jbGVhclJlY3QoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuICAgIGlmKCBvcHRpb25zLmJnICl7XG4gICAgICBidWZmQ3h0LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmc7XG4gICAgICBidWZmQ3h0LnJlY3QoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcbiAgICAgIGJ1ZmZDeHQuZmlsbCgpO1xuICAgIH1cblxuICAgIGJ1ZmZDeHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcblxuICAgIGlmKCBvcHRpb25zLmZ1bGwgKXsgLy8gZHJhdyB0aGUgZnVsbCBib3VuZHMgb2YgdGhlIGdyYXBoXG4gICAgICB0aGlzLnJlbmRlcih7XG4gICAgICAgIGZvcmNlZENvbnRleHQ6IGJ1ZmZDeHQsXG4gICAgICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgICAgIGZvcmNlZFpvb206IHNjYWxlLFxuICAgICAgICBmb3JjZWRQYW46IHsgeDogLWJiLngxKnNjYWxlLCB5OiAtYmIueTEqc2NhbGUgfSxcbiAgICAgICAgZm9yY2VkUHhSYXRpbzogMVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHsgLy8gZHJhdyB0aGUgY3VycmVudCB2aWV3XG4gICAgICB2YXIgY3lQYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciBwYW4gPSB7XG4gICAgICAgIHg6IGN5UGFuLnggKiBzY2FsZSxcbiAgICAgICAgeTogY3lQYW4ueSAqIHNjYWxlXG4gICAgICB9O1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCkgKiBzY2FsZTtcblxuICAgICAgdGhpcy5yZW5kZXIoe1xuICAgICAgICBmb3JjZWRDb250ZXh0OiBidWZmQ3h0LFxuICAgICAgICBkcmF3QWxsTGF5ZXJzOiB0cnVlLFxuICAgICAgICBmb3JjZWRab29tOiB6b29tLFxuICAgICAgICBmb3JjZWRQYW46IHBhbixcbiAgICAgICAgZm9yY2VkUHhSYXRpbzogMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZDYW52YXM7XG59O1xuXG5DUnAucG5nID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgcmV0dXJuIHRoaXMuYnVmZmVyQ2FudmFzSW1hZ2UoIG9wdGlvbnMgKS50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xufTtcblxuQ1JwLmpwZyA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gIHJldHVybiB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKCBvcHRpb25zICkudG9EYXRhVVJMKCdpbWFnZS9qcGVnJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcblxufSx7XCIuLi8uLi8uLi9pc1wiOjc3fV0sNzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcblRoZSBjYW52YXMgcmVuZGVyZXIgd2FzIHdyaXR0ZW4gYnkgWXVlIERvbmcuXG5cbk1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gX2RlcmVxXygnLi4vLi4vLi4vdXRpbCcpO1xudmFyIGlzID0gX2RlcmVxXygnLi4vLi4vLi4vaXMnKTtcblxudmFyIENSID0gQ2FudmFzUmVuZGVyZXI7XG52YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG5DUnAuQ0FOVkFTX0xBWUVSUyA9IDM7XG4vL1xuQ1JwLlNFTEVDVF9CT1ggPSAwO1xuQ1JwLkRSQUcgPSAxO1xuQ1JwLk5PREUgPSAyO1xuXG5DUnAuQlVGRkVSX0NPVU5UID0gMztcbi8vXG5DUnAuVEVYVFVSRV9CVUZGRVIgPSAwO1xuQ1JwLk1PVElPTkJMVVJfQlVGRkVSX05PREUgPSAxO1xuQ1JwLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgPSAyO1xuXG5mdW5jdGlvbiBDYW52YXNSZW5kZXJlcihvcHRpb25zKSB7XG4gIHZhciByID0gdGhpcztcblxuICByLmRhdGEgPSB7XG4gICAgY2FudmFzZXM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgY29udGV4dHM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgY2FudmFzTmVlZHNSZWRyYXc6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG5cbiAgICBidWZmZXJDYW52YXNlczogbmV3IEFycmF5KENScC5CVUZGRVJfQ09VTlQpLFxuICAgIGJ1ZmZlckNvbnRleHRzOiBuZXcgQXJyYXkoQ1JwLkNBTlZBU19MQVlFUlMpXG4gIH07XG5cbiAgci5kYXRhLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgY29udGFpbmVyU3R5bGUgPSByLmRhdGEuY2FudmFzQ29udGFpbmVyLnN0eWxlO1xuICByLmRhdGEuY2FudmFzQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApOycpO1xuICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIGNvbnRhaW5lclN0eWxlLnpJbmRleCA9ICcwJztcbiAgY29udGFpbmVyU3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKCByLmRhdGEuY2FudmFzQ29udGFpbmVyICk7XG4gIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgKCBjb250YWluZXIuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8ICcnICkgKyAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApOycpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQ1JwLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgIHZhciBjYW52YXMgPSByLmRhdGEuY2FudmFzZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICByLmRhdGEuY29udGV4dHNbaV0gPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCAnc3R5bGUnLCAnLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLW1vei11c2VyLXNlbGVjdDogLW1vei1ub25lOyB1c2VyLXNlbGVjdDogbm9uZTsgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApOyBvdXRsaW5lLXN0eWxlOiBub25lOycgKyAoIGlzLm1zKCkgPyAnIC1tcy10b3VjaC1hY3Rpb246IG5vbmU7IHRvdWNoLWFjdGlvbjogbm9uZTsgJyA6ICcnICkgKTtcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgaSk7XG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IFN0cmluZyhDUnAuQ0FOVkFTX0xBWUVSUyAtIGkpO1xuICAgIHIuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcblxuICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tpXSA9IGZhbHNlO1xuICB9XG4gIHIuZGF0YS50b3BDYW52YXMgPSByLmRhdGEuY2FudmFzZXNbMF07XG5cbiAgci5kYXRhLmNhbnZhc2VzW0NScC5OT0RFXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLk5PREUgKyAnLW5vZGUnKTtcbiAgci5kYXRhLmNhbnZhc2VzW0NScC5TRUxFQ1RfQk9YXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLlNFTEVDVF9CT1ggKyAnLXNlbGVjdGJveCcpO1xuICByLmRhdGEuY2FudmFzZXNbQ1JwLkRSQUddLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuRFJBRyArICctZHJhZycpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQ1JwLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgci5kYXRhLmJ1ZmZlckNvbnRleHRzW2ldID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLmdldENvbnRleHQoJzJkJyk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2J1ZmZlcicgKyBpKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUuekluZGV4ID0gU3RyaW5nKC1pIC0gMSk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAvL3IuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldKTtcbiAgfVxuXG4gIHIucGF0aHNFbmFibGVkID0gdHJ1ZTtcbn1cblxuQ1JwLnJlZHJhd0hpbnQgPSBmdW5jdGlvbiggZ3JvdXAsIGJvb2wgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHN3aXRjaCggZ3JvdXAgKXtcbiAgICBjYXNlICdlbGVzJzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1sgQ1JwLk5PREUgXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkcmFnJzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1sgQ1JwLkRSQUcgXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3WyBDUnAuU0VMRUNUX0JPWCBdID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyB3aGV0aGVyIHRvIHVzZSBQYXRoMkQgY2FjaGluZyBmb3IgZHJhd2luZ1xudmFyIHBhdGhzSW1wbGQgPSB0eXBlb2YgUGF0aDJEICE9PSAndW5kZWZpbmVkJztcblxuQ1JwLnBhdGgyZEVuYWJsZWQgPSBmdW5jdGlvbiggb24gKXtcbiAgaWYoIG9uID09PSB1bmRlZmluZWQgKXtcbiAgICByZXR1cm4gdGhpcy5wYXRoc0VuYWJsZWQ7XG4gIH1cblxuICB0aGlzLnBhdGhzRW5hYmxlZCA9IG9uID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxuQ1JwLnVzZVBhdGhzID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHBhdGhzSW1wbGQgJiYgdGhpcy5wYXRoc0VuYWJsZWQ7XG59O1xuXG5bXG4gIF9kZXJlcV8oJy4vYXJyb3ctc2hhcGVzJyksXG4gIF9kZXJlcV8oJy4vZHJhd2luZy1lZGdlcycpLFxuICBfZGVyZXFfKCcuL2RyYXdpbmctaW1hZ2VzJyksXG4gIF9kZXJlcV8oJy4vZHJhd2luZy1sYWJlbC10ZXh0JyksXG4gIF9kZXJlcV8oJy4vZHJhd2luZy1ub2RlcycpLFxuICBfZGVyZXFfKCcuL2RyYXdpbmctcmVkcmF3JyksXG4gIF9kZXJlcV8oJy4vZHJhd2luZy1zaGFwZXMnKSxcbiAgX2RlcmVxXygnLi9leHBvcnQtaW1hZ2UnKSxcbiAgX2RlcmVxXygnLi9ub2RlLXNoYXBlcycpXG5dLmZvckVhY2goZnVuY3Rpb24oIHByb3BzICl7XG4gIHV0aWwuZXh0ZW5kKCBDUnAsIHByb3BzICk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUjtcblxufSx7XCIuLi8uLi8uLi9pc1wiOjc3LFwiLi4vLi4vLi4vdXRpbFwiOjk0LFwiLi9hcnJvdy1zaGFwZXNcIjo2MixcIi4vZHJhd2luZy1lZGdlc1wiOjYzLFwiLi9kcmF3aW5nLWltYWdlc1wiOjY0LFwiLi9kcmF3aW5nLWxhYmVsLXRleHRcIjo2NSxcIi4vZHJhd2luZy1ub2Rlc1wiOjY2LFwiLi9kcmF3aW5nLXJlZHJhd1wiOjY3LFwiLi9kcmF3aW5nLXNoYXBlc1wiOjY4LFwiLi9leHBvcnQtaW1hZ2VcIjo2OSxcIi4vbm9kZS1zaGFwZXNcIjo3MX1dLDcxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIENScCA9IHt9O1xuXG52YXIgaW1wbDtcblxuQ1JwLm5vZGVTaGFwZUltcGwgPSBmdW5jdGlvbiggbmFtZSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcmV0dXJuICggaW1wbCB8fCAoaW1wbCA9IHtcbiAgICAnZWxsaXBzZSc6IGZ1bmN0aW9uKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICl7XG4gICAgICBzZWxmLmRyYXdFbGxpcHNlUGF0aCggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApO1xuICAgIH0sXG5cbiAgICAncG9seWdvbic6IGZ1bmN0aW9uKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMgKXtcbiAgICAgIHNlbGYuZHJhd1BvbHlnb25QYXRoKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMgKTtcbiAgICB9LFxuXG4gICAgJ3JvdW5kcmVjdGFuZ2xlJzogZnVuY3Rpb24oIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKXtcbiAgICAgIHNlbGYuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aCggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgMTAgKTtcbiAgICB9XG4gIH0pIClbIG5hbWUgXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuXG59LHt9XSw3MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICB7IG5hbWU6ICdudWxsJywgaW1wbDogX2RlcmVxXygnLi9udWxsJykgfSxcbiAgeyBuYW1lOiAnYmFzZScsIGltcGw6IF9kZXJlcV8oJy4vYmFzZScpIH0sXG4gIHsgbmFtZTogJ2NhbnZhcycsIGltcGw6IF9kZXJlcV8oJy4vY2FudmFzJykgfVxuXTtcblxufSx7XCIuL2Jhc2VcIjo1OCxcIi4vY2FudmFzXCI6NzAsXCIuL251bGxcIjo3M31dLDczOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gTnVsbFJlbmRlcmVyKG9wdGlvbnMpe1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLm5vdGlmaWNhdGlvbnMgPSAwOyAvLyBmb3IgdGVzdGluZ1xufVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuTnVsbFJlbmRlcmVyLnByb3RvdHlwZSA9IHtcbiAgcmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlOiBub29wLFxuICBub3RpZnk6IGZ1bmN0aW9uKCl7IHRoaXMubm90aWZpY2F0aW9ucysrOyB9LFxuICBpbml0OiBub29wXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bGxSZW5kZXJlcjtcblxufSx7fV0sNzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuL2lzJyk7XG52YXIgdXRpbCA9IF9kZXJlcV8oJy4vdXRpbCcpO1xudmFyIFRocmVhZCA9IF9kZXJlcV8oJy4vdGhyZWFkJyk7XG52YXIgUHJvbWlzZSA9IF9kZXJlcV8oJy4vcHJvbWlzZScpO1xudmFyIGRlZmluZSA9IF9kZXJlcV8oJy4vZGVmaW5lJyk7XG5cbnZhciBGYWJyaWMgPSBmdW5jdGlvbiggTiApe1xuICBpZiggISh0aGlzIGluc3RhbmNlb2YgRmFicmljKSApe1xuICAgIHJldHVybiBuZXcgRmFicmljKCBOICk7XG4gIH1cblxuICB0aGlzLl9wcml2YXRlID0ge1xuICAgIHBhc3M6IFtdXG4gIH07XG5cbiAgdmFyIGRlZk4gPSA0O1xuXG4gIGlmKCBpcy5udW1iZXIoTikgKXtcbiAgICAvLyB0aGVuIHVzZSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB0aHJlYWRzXG4gIH0gaWYoIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5ICE9IG51bGwgKXtcbiAgICBOID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gIH0gZWxzZSB7XG4gICAgdHJ5e1xuICAgICAgTiA9IF9kZXJlcV8oJ29zJykuY3B1cygpLmxlbmd0aDtcbiAgICB9IGNhdGNoKCBlcnIgKXtcbiAgICAgIE4gPSBkZWZOO1xuICAgIH1cbiAgfSAvLyBUT0RPIGNvdWxkIHVzZSBhbiBlc3RpbWF0aW9uIGhlcmUgYnV0IHdvdWxkIHRoZSBhZGRpdGlvbmFsIGV4cGVuc2UgYmUgd29ydGggaXQ/XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBOOyBpKysgKXtcbiAgICB0aGlzW2ldID0gbmV3IFRocmVhZCgpO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSBOO1xufTtcblxudmFyIGZhYmZuID0gRmFicmljLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxudXRpbC5leHRlbmQoZmFiZm4sIHtcblxuICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24oKXsgcmV0dXJuICdmYWJyaWMnOyB9LFxuXG4gIC8vIHJlcXVpcmUgZm4gaW4gYWxsIHRocmVhZHNcbiAgcmVxdWlyZTogZnVuY3Rpb24oIGZuLCBhcyApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHRocmVhZCA9IHRoaXNbaV07XG5cbiAgICAgIHRocmVhZC5yZXF1aXJlKCBmbiwgYXMgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBnZXQgYSByYW5kb20gdGhyZWFkXG4gIHJhbmRvbTogZnVuY3Rpb24oKXtcbiAgICB2YXIgaSA9IE1hdGgucm91bmQoICh0aGlzLmxlbmd0aCAtIDEpICogTWF0aC5yYW5kb20oKSApO1xuICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuXG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfSxcblxuICAvLyBydW4gb24gcmFuZG9tIHRocmVhZFxuICBydW46IGZ1bmN0aW9uKCBmbiApe1xuICAgIHZhciBwYXNzID0gdGhpcy5fcHJpdmF0ZS5wYXNzLnNoaWZ0KCk7XG5cbiAgICByZXR1cm4gdGhpcy5yYW5kb20oKS5wYXNzKCBwYXNzICkucnVuKCBmbiApO1xuICB9LFxuXG4gIC8vIHNlbmRzIGEgcmFuZG9tIHRocmVhZCBhIG1lc3NhZ2VcbiAgbWVzc2FnZTogZnVuY3Rpb24oIG0gKXtcbiAgICByZXR1cm4gdGhpcy5yYW5kb20oKS5tZXNzYWdlKCBtICk7XG4gIH0sXG5cbiAgLy8gc2VuZCBhbGwgdGhyZWFkcyBhIG1lc3NhZ2VcbiAgYnJvYWRjYXN0OiBmdW5jdGlvbiggbSApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHRocmVhZCA9IHRoaXNbaV07XG5cbiAgICAgIHRocmVhZC5tZXNzYWdlKCBtICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgLy8gc3RvcCBhbGwgdGhyZWFkc1xuICBzdG9wOiBmdW5jdGlvbigpe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHRocmVhZCA9IHRoaXNbaV07XG5cbiAgICAgIHRocmVhZC5zdG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgLy8gcGFzcyBkYXRhIHRvIGJlIHVzZWQgd2l0aCAuc3ByZWFkKCkgZXRjLlxuICBwYXNzOiBmdW5jdGlvbiggZGF0YSApe1xuICAgIHZhciBwYXNzID0gdGhpcy5fcHJpdmF0ZS5wYXNzO1xuXG4gICAgaWYoIGlzLmFycmF5KGRhdGEpICl7XG4gICAgICBwYXNzLnB1c2goIGRhdGEgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ09ubHkgYXJyYXlzIG1heSBiZSB1c2VkIHdpdGggZmFicmljLnBhc3MoKSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgc3ByZWFkU2l6ZTogZnVuY3Rpb24oKXtcbiAgICB2YXIgc3Vic2l6ZSA9ICBNYXRoLmNlaWwoIHRoaXMuX3ByaXZhdGUucGFzc1swXS5sZW5ndGggLyB0aGlzLmxlbmd0aCApO1xuXG4gICAgc3Vic2l6ZSA9IE1hdGgubWF4KCAxLCBzdWJzaXplICk7IC8vIGRvbid0IHBhc3MgbGVzcyB0aGFuIG9uZSBlbGUgdG8gZWFjaCB0aHJlYWRcblxuICAgIHJldHVybiBzdWJzaXplO1xuICB9LFxuXG4gIC8vIHNwbGl0IHRoZSBkYXRhIGludG8gc2xpY2VzIHRvIHNwcmVhZCB0aGUgZGF0YSBlcXVhbGx5IGFtb25nIHRocmVhZHNcbiAgc3ByZWFkOiBmdW5jdGlvbiggZm4gKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIF9wID0gc2VsZi5fcHJpdmF0ZTtcbiAgICB2YXIgc3Vic2l6ZSA9IHNlbGYuc3ByZWFkU2l6ZSgpOyAvLyBudW1iZXIgb2YgcGFzcyBlbGVzIHRvIGhhbmRsZSBpbiBlYWNoIHRocmVhZFxuICAgIHZhciBwYXNzID0gX3AucGFzcy5zaGlmdCgpLmNvbmNhdChbXSk7IC8vIGtlZXAgYSBjb3B5XG4gICAgdmFyIHJ1blBzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNsaWNlID0gcGFzcy5zcGxpY2UoIDAsIHN1YnNpemUgKTtcblxuICAgICAgdmFyIHJ1blAgPSB0aHJlYWQucGFzcyggc2xpY2UgKS5ydW4oIGZuICk7XG5cbiAgICAgIHJ1blBzLnB1c2goIHJ1blAgKTtcblxuICAgICAgdmFyIGRvbmVFYXJseSA9IHBhc3MubGVuZ3RoID09PSAwO1xuICAgICAgaWYoIGRvbmVFYXJseSApeyBicmVhazsgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbCggcnVuUHMgKS50aGVuKGZ1bmN0aW9uKCB0aGVucyApe1xuICAgICAgdmFyIHBvc3RwYXNzID0gW107XG4gICAgICB2YXIgcCA9IDA7XG5cbiAgICAgIC8vIGZpbGwgcG9zdHBhc3Mgd2l0aCB0aGUgdG90YWwgcmVzdWx0IGpvaW5lZCBmcm9tIGFsbCB0aHJlYWRzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoZW5zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB0aGVuID0gdGhlbnNbaV07IC8vIGFycmF5IHJlc3VsdCBmcm9tIHRocmVhZCBpXG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCB0aGVuLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIHQgPSB0aGVuW2pdOyAvLyBhcnJheSBlbGVtZW50XG5cbiAgICAgICAgICBwb3N0cGFzc1sgcCsrIF0gPSB0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3N0cGFzcztcbiAgICB9KTtcbiAgfSxcblxuICAvLyBwYXJhbGxlbCB2ZXJzaW9uIG9mIGFycmF5Lm1hcCgpXG4gIG1hcDogZnVuY3Rpb24oIGZuICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgc2VsZi5yZXF1aXJlKCBmbiwgJ18kXyRfZmFibWFwJyApO1xuXG4gICAgcmV0dXJuIHNlbGYuc3ByZWFkKGZ1bmN0aW9uKCBzcGxpdCApe1xuICAgICAgdmFyIG1hcHBlZCA9IFtdO1xuICAgICAgdmFyIG9yaWdSZXNvbHZlID0gcmVzb2x2ZTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAgIHJlc29sdmUgPSBmdW5jdGlvbiggdmFsICl7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICBtYXBwZWQucHVzaCggdmFsICk7XG4gICAgICB9O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBvbGRMZW4gPSBtYXBwZWQubGVuZ3RoO1xuICAgICAgICB2YXIgcmV0ID0gXyRfJF9mYWJtYXAoIHNwbGl0W2ldICk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICB2YXIgbm90aGluZ0luc2RCeVJlc29sdmUgPSBvbGRMZW4gPT09IG1hcHBlZC5sZW5ndGg7XG5cbiAgICAgICAgaWYoIG5vdGhpbmdJbnNkQnlSZXNvbHZlICl7XG4gICAgICAgICAgbWFwcGVkLnB1c2goIHJldCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUgPSBvcmlnUmVzb2x2ZTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfSk7XG5cbiAgfSxcblxuICAvLyBwYXJhbGxlbCB2ZXJzaW9uIG9mIGFycmF5LmZpbHRlcigpXG4gIGZpbHRlcjogZnVuY3Rpb24oIGZuICl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgcGFzcyA9IF9wLnBhc3NbMF07XG5cbiAgICByZXR1cm4gdGhpcy5tYXAoIGZuICkudGhlbihmdW5jdGlvbiggaW5jbHVkZSApe1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhc3MubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGRhdHVtID0gcGFzc1tpXTtcbiAgICAgICAgdmFyIGluY0RhdHVtID0gaW5jbHVkZVtpXTtcblxuICAgICAgICBpZiggaW5jRGF0dW0gKXtcbiAgICAgICAgICByZXQucHVzaCggZGF0dW0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIHNvcnRzIHRoZSBwYXNzZWQgYXJyYXkgdXNpbmcgYSBkaXZpZGUgYW5kIGNvbnF1ZXIgc3RyYXRlZ3lcbiAgc29ydDogZnVuY3Rpb24oIGNtcCApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgUCA9IHRoaXMuX3ByaXZhdGUucGFzc1swXS5sZW5ndGg7XG4gICAgdmFyIHN1YnNpemUgPSB0aGlzLnNwcmVhZFNpemUoKTtcblxuICAgIGNtcCA9IGNtcCB8fCBmdW5jdGlvbiggYSwgYiApeyAvLyBkZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb25cbiAgICAgIGlmKCBhIDwgYiApe1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYoIGEgPiBiICl7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgc2VsZi5yZXF1aXJlKCBjbXAsICdfJF8kX2NtcCcgKTtcblxuICAgIHJldHVybiBzZWxmLnNwcmVhZChmdW5jdGlvbiggc3BsaXQgKXsgLy8gc29ydCBlYWNoIHNwbGl0IG5vcm1hbGx5XG4gICAgICB2YXIgc29ydGVkU3BsaXQgPSBzcGxpdC5zb3J0KCBfJF8kX2NtcCApOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgIHJlc29sdmUoIHNvcnRlZFNwbGl0ICk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgfSkudGhlbihmdW5jdGlvbiggam9pbmVkICl7XG4gICAgICAvLyBkbyBhbGwgdGhlIG1lcmdpbmcgaW4gdGhlIG1haW4gdGhyZWFkIHRvIG1pbmltaXNlIGRhdGEgdHJhbnNmZXJcblxuICAgICAgLy8gVE9ETyBjb3VsZCBkbyBtZXJnaW5nIGluIHNlcGFyYXRlIHRocmVhZHMgYnV0IHdvdWxkIGluY3VyIGFkZCdsIGNvc3Qgb2YgZGF0YSB0cmFuc2ZlclxuICAgICAgLy8gZm9yIGVhY2ggbGV2ZWwgb2YgdGhlIG1lcmdlXG5cbiAgICAgIHZhciBtZXJnZSA9IGZ1bmN0aW9uKCBpLCBqLCBtYXggKXtcbiAgICAgICAgLy8gZG9uJ3Qgb3ZlcmZsb3cgYXJyYXlcbiAgICAgICAgaiA9IE1hdGgubWluKCBqLCBQICk7XG4gICAgICAgIG1heCA9IE1hdGgubWluKCBtYXgsIFAgKTtcblxuICAgICAgICAvLyBsZWZ0IGFuZCByaWdodCBzaWRlcyBvZiBtZXJnZVxuICAgICAgICB2YXIgbCA9IGk7XG4gICAgICAgIHZhciByID0gajtcblxuICAgICAgICB2YXIgc29ydGVkID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgayA9IGw7IGsgPCBtYXg7IGsrKyApe1xuXG4gICAgICAgICAgdmFyIGVsZUkgPSBqb2luZWRbaV07XG4gICAgICAgICAgdmFyIGVsZUogPSBqb2luZWRbal07XG5cbiAgICAgICAgICBpZiggaSA8IHIgJiYgKCBqID49IG1heCB8fCBjbXAoZWxlSSwgZWxlSikgPD0gMCApICl7XG4gICAgICAgICAgICBzb3J0ZWQucHVzaCggZWxlSSApO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3J0ZWQucHVzaCggZWxlSiApO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW4gdGhlIGFycmF5IHByb3BlciwgcHV0IHRoZSBzb3J0ZWQgdmFsdWVzXG4gICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgc29ydGVkLmxlbmd0aDsgaysrICl7IC8vIGt0aCBzb3J0ZWQgaXRlbVxuICAgICAgICAgIHZhciBpbmRleCA9IGwgKyBrO1xuXG4gICAgICAgICAgam9pbmVkWyBpbmRleCBdID0gc29ydGVkW2tdO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IoIHZhciBzcGxpdEwgPSBzdWJzaXplOyBzcGxpdEwgPCBQOyBzcGxpdEwgKj0gMiApeyAvLyBtZXJnZSB1bnRpbCBhcnJheSBpcyBcInNwbGl0XCIgYXMgMVxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgUDsgaSArPSAyKnNwbGl0TCApe1xuICAgICAgICAgIG1lcmdlKCBpLCBpICsgc3BsaXRMLCBpICsgMipzcGxpdEwgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqb2luZWQ7XG4gICAgfSk7XG4gIH1cblxuXG59KTtcblxudmFyIGRlZmluZVJhbmRvbVBhc3NlciA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHJldHVybiBmdW5jdGlvbiggZm4sIGFyZzEgKXtcbiAgICB2YXIgcGFzcyA9IHRoaXMuX3ByaXZhdGUucGFzcy5zaGlmdCgpO1xuXG4gICAgcmV0dXJuIHRoaXMucmFuZG9tKCkucGFzcyggcGFzcyApWyBvcHRzLnRocmVhZEZuIF0oIGZuLCBhcmcxICk7XG4gIH07XG59O1xuXG51dGlsLmV4dGVuZChmYWJmbiwge1xuICByYW5kb21NYXA6IGRlZmluZVJhbmRvbVBhc3Nlcih7IHRocmVhZEZuOiAnbWFwJyB9KSxcblxuICByZWR1Y2U6IGRlZmluZVJhbmRvbVBhc3Nlcih7IHRocmVhZEZuOiAncmVkdWNlJyB9KSxcblxuICByZWR1Y2VSaWdodDogZGVmaW5lUmFuZG9tUGFzc2VyKHsgdGhyZWFkRm46ICdyZWR1Y2VSaWdodCcgfSlcbn0pO1xuXG4vLyBhbGlhc2VzXG52YXIgZm4gPSBmYWJmbjtcbmZuLnByb21pc2UgPSBmbi5ydW47XG5mbi50ZXJtaW5hdGUgPSBmbi5oYWx0ID0gZm4uc3RvcDtcbmZuLmluY2x1ZGUgPSBmbi5yZXF1aXJlO1xuXG4vLyBwdWxsIGluIGV2ZW50IGFwaXNcbnV0aWwuZXh0ZW5kKGZhYmZuLCB7XG4gIG9uOiBkZWZpbmUub24oKSxcbiAgb25lOiBkZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICBvZmY6IGRlZmluZS5vZmYoKSxcbiAgdHJpZ2dlcjogZGVmaW5lLnRyaWdnZXIoKVxufSk7XG5cbmRlZmluZS5ldmVudEFsaWFzZXNPbiggZmFiZm4gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWJyaWM7XG5cbn0se1wiLi9kZWZpbmVcIjo0MSxcIi4vaXNcIjo3NyxcIi4vcHJvbWlzZVwiOjgwLFwiLi90aHJlYWRcIjo5MixcIi4vdXRpbFwiOjk0LFwib3NcIjp1bmRlZmluZWR9XSw3NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKiFcblBvcnRlZCBieSBYdWVxaWFvIFh1IDx4dWVxaWFveHVAZ21haWwuY29tPjtcblxuUFNGIExJQ0VOU0UgQUdSRUVNRU5UIEZPUiBQWVRIT04gMi43LjJcblxuMS4gVGhpcyBMSUNFTlNFIEFHUkVFTUVOVCBpcyBiZXR3ZWVuIHRoZSBQeXRob24gU29mdHdhcmUgRm91bmRhdGlvbiAo4oCcUFNG4oCdKSwgYW5kIHRoZSBJbmRpdmlkdWFsIG9yIE9yZ2FuaXphdGlvbiAo4oCcTGljZW5zZWXigJ0pIGFjY2Vzc2luZyBhbmQgb3RoZXJ3aXNlIHVzaW5nIFB5dGhvbiAyLjcuMiBzb2Z0d2FyZSBpbiBzb3VyY2Ugb3IgYmluYXJ5IGZvcm0gYW5kIGl0cyBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24uXG4yLiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50LCBQU0YgaGVyZWJ5IGdyYW50cyBMaWNlbnNlZSBhIG5vbmV4Y2x1c2l2ZSwgcm95YWx0eS1mcmVlLCB3b3JsZC13aWRlIGxpY2Vuc2UgdG8gcmVwcm9kdWNlLCBhbmFseXplLCB0ZXN0LCBwZXJmb3JtIGFuZC9vciBkaXNwbGF5IHB1YmxpY2x5LCBwcmVwYXJlIGRlcml2YXRpdmUgd29ya3MsIGRpc3RyaWJ1dGUsIGFuZCBvdGhlcndpc2UgdXNlIFB5dGhvbiAyLjcuMiBhbG9uZSBvciBpbiBhbnkgZGVyaXZhdGl2ZSB2ZXJzaW9uLCBwcm92aWRlZCwgaG93ZXZlciwgdGhhdCBQU0bigJlzIExpY2Vuc2UgQWdyZWVtZW50IGFuZCBQU0bigJlzIG5vdGljZSBvZiBjb3B5cmlnaHQsIGkuZS4sIOKAnENvcHlyaWdodCDCqSAyMDAxLTIwMTIgUHl0aG9uIFNvZnR3YXJlIEZvdW5kYXRpb247IEFsbCBSaWdodHMgUmVzZXJ2ZWTigJ0gYXJlIHJldGFpbmVkIGluIFB5dGhvbiAyLjcuMiBhbG9uZSBvciBpbiBhbnkgZGVyaXZhdGl2ZSB2ZXJzaW9uIHByZXBhcmVkIGJ5IExpY2Vuc2VlLlxuMy4gSW4gdGhlIGV2ZW50IExpY2Vuc2VlIHByZXBhcmVzIGEgZGVyaXZhdGl2ZSB3b3JrIHRoYXQgaXMgYmFzZWQgb24gb3IgaW5jb3Jwb3JhdGVzIFB5dGhvbiAyLjcuMiBvciBhbnkgcGFydCB0aGVyZW9mLCBhbmQgd2FudHMgdG8gbWFrZSB0aGUgZGVyaXZhdGl2ZSB3b3JrIGF2YWlsYWJsZSB0byBvdGhlcnMgYXMgcHJvdmlkZWQgaGVyZWluLCB0aGVuIExpY2Vuc2VlIGhlcmVieSBhZ3JlZXMgdG8gaW5jbHVkZSBpbiBhbnkgc3VjaCB3b3JrIGEgYnJpZWYgc3VtbWFyeSBvZiB0aGUgY2hhbmdlcyBtYWRlIHRvIFB5dGhvbiAyLjcuMi5cbjQuIFBTRiBpcyBtYWtpbmcgUHl0aG9uIDIuNy4yIGF2YWlsYWJsZSB0byBMaWNlbnNlZSBvbiBhbiDigJxBUyBJU+KAnSBiYXNpcy4gUFNGIE1BS0VTIE5PIFJFUFJFU0VOVEFUSU9OUyBPUiBXQVJSQU5USUVTLCBFWFBSRVNTIE9SIElNUExJRUQuIEJZIFdBWSBPRiBFWEFNUExFLCBCVVQgTk9UIExJTUlUQVRJT04sIFBTRiBNQUtFUyBOTyBBTkQgRElTQ0xBSU1TIEFOWSBSRVBSRVNFTlRBVElPTiBPUiBXQVJSQU5UWSBPRiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTUyBGT1IgQU5ZIFBBUlRJQ1VMQVIgUFVSUE9TRSBPUiBUSEFUIFRIRSBVU0UgT0YgUFlUSE9OIDIuNy4yIFdJTEwgTk9UIElORlJJTkdFIEFOWSBUSElSRCBQQVJUWSBSSUdIVFMuXG41LiBQU0YgU0hBTEwgTk9UIEJFIExJQUJMRSBUTyBMSUNFTlNFRSBPUiBBTlkgT1RIRVIgVVNFUlMgT0YgUFlUSE9OIDIuNy4yIEZPUiBBTlkgSU5DSURFTlRBTCwgU1BFQ0lBTCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIExPU1MgQVMgQSBSRVNVTFQgT0YgTU9ESUZZSU5HLCBESVNUUklCVVRJTkcsIE9SIE9USEVSV0lTRSBVU0lORyBQWVRIT04gMi43LjIsIE9SIEFOWSBERVJJVkFUSVZFIFRIRVJFT0YsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgVEhFUkVPRi5cbjYuIFRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHRlcm1pbmF0ZSB1cG9uIGEgbWF0ZXJpYWwgYnJlYWNoIG9mIGl0cyB0ZXJtcyBhbmQgY29uZGl0aW9ucy5cbjcuIE5vdGhpbmcgaW4gdGhpcyBMaWNlbnNlIEFncmVlbWVudCBzaGFsbCBiZSBkZWVtZWQgdG8gY3JlYXRlIGFueSByZWxhdGlvbnNoaXAgb2YgYWdlbmN5LCBwYXJ0bmVyc2hpcCwgb3Igam9pbnQgdmVudHVyZSBiZXR3ZWVuIFBTRiBhbmQgTGljZW5zZWUuIFRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgZG9lcyBub3QgZ3JhbnQgcGVybWlzc2lvbiB0byB1c2UgUFNGIHRyYWRlbWFya3Mgb3IgdHJhZGUgbmFtZSBpbiBhIHRyYWRlbWFyayBzZW5zZSB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgb3Igc2VydmljZXMgb2YgTGljZW5zZWUsIG9yIGFueSB0aGlyZCBwYXJ0eS5cbjguIEJ5IGNvcHlpbmcsIGluc3RhbGxpbmcgb3Igb3RoZXJ3aXNlIHVzaW5nIFB5dGhvbiAyLjcuMiwgTGljZW5zZWUgYWdyZWVzIHRvIGJlIGJvdW5kIGJ5IHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50LlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOC4wXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBIZWFwLCBkZWZhdWx0Q21wLCBmbG9vciwgaGVhcGlmeSwgaGVhcHBvcCwgaGVhcHB1c2gsIGhlYXBwdXNocG9wLCBoZWFwcmVwbGFjZSwgaW5zb3J0LCBtaW4sIG5sYXJnZXN0LCBuc21hbGxlc3QsIHVwZGF0ZUl0ZW0sIF9zaWZ0ZG93biwgX3NpZnR1cDtcblxuICBmbG9vciA9IE1hdGguZmxvb3IsIG1pbiA9IE1hdGgubWluO1xuXG5cbiAgLypcbiAgRGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uIHRvIGJlIHVzZWRcbiAgICovXG5cbiAgZGVmYXVsdENtcCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA8IHkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHggPiB5KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cblxuICAvKlxuICBJbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYW5kIGtlZXAgaXQgc29ydGVkIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxuXG4gIElmIHggaXMgYWxyZWFkeSBpbiBhLCBpbnNlcnQgaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgeC5cblxuICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBhLmxlbmd0aCkgYm91bmQgdGhlIHNsaWNlXG4gIG9mIGEgdG8gYmUgc2VhcmNoZWQuXG4gICAqL1xuXG4gIGluc29ydCA9IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSwgY21wKSB7XG4gICAgdmFyIG1pZDtcbiAgICBpZiAobG8gPT0gbnVsbCkge1xuICAgICAgbG8gPSAwO1xuICAgIH1cbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChsbyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICB9XG4gICAgaWYgKGhpID09IG51bGwpIHtcbiAgICAgIGhpID0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBtaWQgPSBmbG9vcigobG8gKyBoaSkgLyAyKTtcbiAgICAgIGlmIChjbXAoeCwgYVttaWRdKSA8IDApIHtcbiAgICAgICAgaGkgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoW10uc3BsaWNlLmFwcGx5KGEsIFtsbywgbG8gLSBsb10uY29uY2F0KHgpKSwgeCk7XG4gIH07XG5cblxuICAvKlxuICBQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwdXNoID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgYXJyYXkucHVzaChpdGVtKTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAxLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcG9wID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbGFzdGVsdCA9IGFycmF5LnBvcCgpO1xuICAgIGlmIChhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICAgIGFycmF5WzBdID0gbGFzdGVsdDtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cblxuICBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmVcbiAgbW9yZSBhcHByb3ByaWF0ZSB3aGVuIHVzaW5nIGEgZml4ZWQgc2l6ZSBoZWFwLiBOb3RlIHRoYXQgdGhlIHZhbHVlXG4gIHJldHVybmVkIG1heSBiZSBsYXJnZXIgdGhhbiBpdGVtISBUaGF0IGNvbnN0cmFpbnMgcmVhc29uYWJsZSB1c2Ugb2ZcbiAgdGhpcyByb3V0aW5lIHVubGVzcyB3cml0dGVuIGFzIHBhcnQgb2YgYSBjb25kaXRpb25hbCByZXBsYWNlbWVudDpcbiAgICAgIGlmIGl0ZW0gPiBhcnJheVswXVxuICAgICAgICBpdGVtID0gaGVhcHJlcGxhY2UoYXJyYXksIGl0ZW0pXG4gICAqL1xuXG4gIGhlYXByZXBsYWNlID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuICAgIGFycmF5WzBdID0gaXRlbTtcbiAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIHJldHVybiByZXR1cm5pdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgRmFzdCB2ZXJzaW9uIG9mIGEgaGVhcHB1c2ggZm9sbG93ZWQgYnkgYSBoZWFwcG9wLlxuICAgKi9cblxuICBoZWFwcHVzaHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggJiYgY21wKGFycmF5WzBdLCBpdGVtKSA8IDApIHtcbiAgICAgIF9yZWYgPSBbYXJyYXlbMF0sIGl0ZW1dLCBpdGVtID0gX3JlZlswXSwgYXJyYXlbMF0gPSBfcmVmWzFdO1xuICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH07XG5cblxuICAvKlxuICBUcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8oYXJyYXkubGVuZ3RoKSB0aW1lLlxuICAgKi9cblxuICBoZWFwaWZ5ID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBpLCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cywgX3Jlc3VsdHMxO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgX3JlZjEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgIGZvciAodmFyIF9qID0gMCwgX3JlZiA9IGZsb29yKGFycmF5Lmxlbmd0aCAvIDIpOyAwIDw9IF9yZWYgPyBfaiA8IF9yZWYgOiBfaiA+IF9yZWY7IDAgPD0gX3JlZiA/IF9qKysgOiBfai0tKXsgX3Jlc3VsdHMxLnB1c2goX2opOyB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgIH0pLmFwcGx5KHRoaXMpLnJldmVyc2UoKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGkgPSBfcmVmMVtfaV07XG4gICAgICBfcmVzdWx0cy5wdXNoKF9zaWZ0dXAoYXJyYXksIGksIGNtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cblxuICAvKlxuICBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBpdGVtIGluIHRoZSBoZWFwLlxuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgaXRlbSBpcyBiZWluZyBtb2RpZmllZC5cbiAgICovXG5cbiAgdXBkYXRlSXRlbSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgcG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcG9zID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfc2lmdGRvd24oYXJyYXksIDAsIHBvcywgY21wKTtcbiAgICByZXR1cm4gX3NpZnR1cChhcnJheSwgcG9zLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgRmluZCB0aGUgbiBsYXJnZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbmxhcmdlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG4gICAgdmFyIGVsZW0sIHJlc3VsdCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKTtcbiAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkocmVzdWx0LCBjbXApO1xuICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgIGhlYXBwdXNocG9wKHJlc3VsdCwgZWxlbSwgY21wKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCkucmV2ZXJzZSgpO1xuICB9O1xuXG5cbiAgLypcbiAgRmluZCB0aGUgbiBzbWFsbGVzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gICAqL1xuXG4gIG5zbWFsbGVzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgaSwgbG9zLCByZXN1bHQsIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKG4gKiAxMCA8PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pLnNvcnQoY21wKTtcbiAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICAgIGlmIChjbXAoZWxlbSwgbG9zKSA8IDApIHtcbiAgICAgICAgICBpbnNvcnQocmVzdWx0LCBlbGVtLCAwLCBudWxsLCBjbXApO1xuICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoZWFwaWZ5KGFycmF5LCBjbXApO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChpID0gX2ogPSAwLCBfcmVmMSA9IG1pbihuLCBhcnJheS5sZW5ndGgpOyAwIDw9IF9yZWYxID8gX2ogPCBfcmVmMSA6IF9qID4gX3JlZjE7IGkgPSAwIDw9IF9yZWYxID8gKytfaiA6IC0tX2opIHtcbiAgICAgIF9yZXN1bHRzLnB1c2goaGVhcHBvcChhcnJheSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBfc2lmdGRvd24gPSBmdW5jdGlvbihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKSB7XG4gICAgdmFyIG5ld2l0ZW0sIHBhcmVudCwgcGFyZW50cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgd2hpbGUgKHBvcyA+IHN0YXJ0cG9zKSB7XG4gICAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMTtcbiAgICAgIHBhcmVudCA9IGFycmF5W3BhcmVudHBvc107XG4gICAgICBpZiAoY21wKG5ld2l0ZW0sIHBhcmVudCkgPCAwKSB7XG4gICAgICAgIGFycmF5W3Bvc10gPSBwYXJlbnQ7XG4gICAgICAgIHBvcyA9IHBhcmVudHBvcztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICB9O1xuXG4gIF9zaWZ0dXAgPSBmdW5jdGlvbihhcnJheSwgcG9zLCBjbXApIHtcbiAgICB2YXIgY2hpbGRwb3MsIGVuZHBvcywgbmV3aXRlbSwgcmlnaHRwb3MsIHN0YXJ0cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgZW5kcG9zID0gYXJyYXkubGVuZ3RoO1xuICAgIHN0YXJ0cG9zID0gcG9zO1xuICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgd2hpbGUgKGNoaWxkcG9zIDwgZW5kcG9zKSB7XG4gICAgICByaWdodHBvcyA9IGNoaWxkcG9zICsgMTtcbiAgICAgIGlmIChyaWdodHBvcyA8IGVuZHBvcyAmJiAhKGNtcChhcnJheVtjaGlsZHBvc10sIGFycmF5W3JpZ2h0cG9zXSkgPCAwKSkge1xuICAgICAgICBjaGlsZHBvcyA9IHJpZ2h0cG9zO1xuICAgICAgfVxuICAgICAgYXJyYXlbcG9zXSA9IGFycmF5W2NoaWxkcG9zXTtcbiAgICAgIHBvcyA9IGNoaWxkcG9zO1xuICAgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB9XG4gICAgYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKTtcbiAgfTtcblxuICBIZWFwID0gKGZ1bmN0aW9uKCkge1xuICAgIEhlYXAucHVzaCA9IGhlYXBwdXNoO1xuXG4gICAgSGVhcC5wb3AgPSBoZWFwcG9wO1xuXG4gICAgSGVhcC5yZXBsYWNlID0gaGVhcHJlcGxhY2U7XG5cbiAgICBIZWFwLnB1c2hwb3AgPSBoZWFwcHVzaHBvcDtcblxuICAgIEhlYXAuaGVhcGlmeSA9IGhlYXBpZnk7XG5cbiAgICBIZWFwLnVwZGF0ZUl0ZW0gPSB1cGRhdGVJdGVtO1xuXG4gICAgSGVhcC5ubGFyZ2VzdCA9IG5sYXJnZXN0O1xuXG4gICAgSGVhcC5uc21hbGxlc3QgPSBuc21hbGxlc3Q7XG5cbiAgICBmdW5jdGlvbiBIZWFwKGNtcCkge1xuICAgICAgdGhpcy5jbXAgPSBjbXAgIT0gbnVsbCA/IGNtcCA6IGRlZmF1bHRDbXA7XG4gICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGhlYXBwb3AodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKHgpICE9PSAtMTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcmVwbGFjZSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnB1c2hwb3AgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHB1c2hwb3AodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oZWFwaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcGlmeSh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnVwZGF0ZUl0ZW0gPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdXBkYXRlSXRlbSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlcyA9IFtdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaGVhcDtcbiAgICAgIGhlYXAgPSBuZXcgSGVhcCgpO1xuICAgICAgaGVhcC5ub2RlcyA9IHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICByZXR1cm4gaGVhcDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmluc2VydCA9IEhlYXAucHJvdG90eXBlLnB1c2g7XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b3AgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuZnJvbnQgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaGFzID0gSGVhcC5wcm90b3R5cGUuY29udGFpbnM7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb3B5ID0gSGVhcC5wcm90b3R5cGUuY2xvbmU7XG5cbiAgICByZXR1cm4gSGVhcDtcblxuICB9KSgpO1xuXG4gIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgcmV0dXJuIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJvb3QuSGVhcCA9IGZhY3RvcnkoKTtcbiAgICB9XG4gIH0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBIZWFwO1xuICB9KTtcblxufSkuY2FsbCh0aGlzKTtcblxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxufSx7fV0sNzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2luZG93ID0gX2RlcmVxXygnLi93aW5kb3cnKTtcbnZhciBpcyA9IF9kZXJlcV8oJy4vaXMnKTtcbnZhciBDb3JlID0gX2RlcmVxXygnLi9jb3JlJyk7XG52YXIgZXh0ZW5zaW9uID0gX2RlcmVxXygnLi9leHRlbnNpb24nKTtcbnZhciByZWdpc3RlckpxdWVyeSA9IF9kZXJlcV8oJy4vanF1ZXJ5LXBsdWdpbicpO1xudmFyIFN0eWxlc2hlZXQgPSBfZGVyZXFfKCcuL3N0eWxlc2hlZXQnKTtcbnZhciBUaHJlYWQgPSBfZGVyZXFfKCcuL3RocmVhZCcpO1xudmFyIEZhYnJpYyA9IF9kZXJlcV8oJy4vZmFicmljJyk7XG5cbnZhciBjeXRvc2NhcGUgPSBmdW5jdGlvbiggb3B0aW9ucyApeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgLy8gaWYgbm8gb3B0aW9ucyBzcGVjaWZpZWQsIHVzZSBkZWZhdWx0XG4gIGlmKCBvcHRpb25zID09PSB1bmRlZmluZWQgKXtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICAvLyBjcmVhdGUgaW5zdGFuY2VcbiAgaWYoIGlzLnBsYWluT2JqZWN0KCBvcHRpb25zICkgKXtcbiAgICByZXR1cm4gbmV3IENvcmUoIG9wdGlvbnMgKTtcbiAgfVxuXG4gIC8vIGFsbG93IGZvciByZWdpc3RyYXRpb24gb2YgZXh0ZW5zaW9uc1xuICBlbHNlIGlmKCBpcy5zdHJpbmcoIG9wdGlvbnMgKSApIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9uLmFwcGx5KGV4dGVuc2lvbiwgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuLy8gcmVwbGFjZWQgYnkgYnVpbGQgc3lzdGVtXG5jeXRvc2NhcGUudmVyc2lvbiA9ICcyLjUuNSc7XG5cbi8vIHRyeSB0byByZWdpc3RlciB3LyBqcXVlcnlcbmlmKCB3aW5kb3cgJiYgd2luZG93LmpRdWVyeSApe1xuICByZWdpc3RlckpxdWVyeSggd2luZG93LmpRdWVyeSwgY3l0b3NjYXBlICk7XG59XG5cbi8vIGV4cG9zZSByZWdpc3RlciBhcGlcbmN5dG9zY2FwZS5yZWdpc3RlckpxdWVyeSA9IGZ1bmN0aW9uKCBqUXVlcnkgKXtcbiAgcmVnaXN0ZXJKcXVlcnkoIGpRdWVyeSwgY3l0b3NjYXBlICk7XG59O1xuXG4vLyBleHBvc2UgcHVibGljIGFwaXMgKG1vc3RseSBmb3IgZXh0ZW5zaW9ucylcbmN5dG9zY2FwZS5zdHlsZXNoZWV0ID0gY3l0b3NjYXBlLlN0eWxlc2hlZXQgPSBTdHlsZXNoZWV0O1xuY3l0b3NjYXBlLnRocmVhZCA9IGN5dG9zY2FwZS5UaHJlYWQgPSBUaHJlYWQ7XG5jeXRvc2NhcGUuZmFicmljID0gY3l0b3NjYXBlLkZhYnJpYyA9IEZhYnJpYztcblxubW9kdWxlLmV4cG9ydHMgPSBjeXRvc2NhcGU7XG5cbn0se1wiLi9jb3JlXCI6MzQsXCIuL2V4dGVuc2lvblwiOjQzLFwiLi9mYWJyaWNcIjo3NCxcIi4vaXNcIjo3NyxcIi4vanF1ZXJ5LXBsdWdpblwiOjc4LFwiLi9zdHlsZXNoZWV0XCI6OTEsXCIuL3RocmVhZFwiOjkyLFwiLi93aW5kb3dcIjoxMDB9XSw3NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB3aW5kb3cgPSBfZGVyZXFfKCcuL3dpbmRvdycpO1xudmFyIG5hdmlnYXRvciA9IHdpbmRvdyA/IHdpbmRvdy5uYXZpZ2F0b3IgOiBudWxsO1xuXG52YXIgdHlwZW9mc3RyID0gdHlwZW9mICcnO1xudmFyIHR5cGVvZm9iaiA9IHR5cGVvZiB7fTtcbnZhciB0eXBlb2ZmbiA9IHR5cGVvZiBmdW5jdGlvbigpe307XG52YXIgdHlwZW9maHRtbGVsZSA9IHR5cGVvZiBIVE1MRWxlbWVudDtcblxudmFyIGluc3RhbmNlU3RyID0gZnVuY3Rpb24oIG9iaiApe1xuICByZXR1cm4gb2JqICYmIG9iai5pbnN0YW5jZVN0cmluZyAmJiBpcy5mbiggb2JqLmluc3RhbmNlU3RyaW5nICkgPyBvYmouaW5zdGFuY2VTdHJpbmcoKSA6IG51bGw7XG59O1xuXG52YXIgaXMgPSB7XG4gIGRlZmluZWQ6IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsOyAvLyBub3QgdW5kZWZpbmVkIG9yIG51bGxcbiAgfSxcblxuICBzdHJpbmc6IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT0gdHlwZW9mc3RyO1xuICB9LFxuXG4gIGZuOiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2ZmbjtcbiAgfSxcblxuICBhcnJheTogZnVuY3Rpb24ob2JqKXtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkob2JqKSA6IG9iaiAhPSBudWxsICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5O1xuICB9LFxuXG4gIHBsYWluT2JqZWN0OiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2ZvYmogJiYgIWlzLmFycmF5KG9iaikgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gIH0sXG5cbiAgb2JqZWN0OiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2ZvYmo7XG4gIH0sXG5cbiAgbnVtYmVyOiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2YgMSAmJiAhaXNOYU4ob2JqKTtcbiAgfSxcblxuICBpbnRlZ2VyOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIGlzLm51bWJlcihvYmopICYmIE1hdGguZmxvb3Iob2JqKSA9PT0gb2JqO1xuICB9LFxuXG4gIGJvb2w6IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZiB0cnVlO1xuICB9LFxuXG4gIGh0bWxFbGVtZW50OiBmdW5jdGlvbihvYmope1xuICAgIGlmKCAndW5kZWZpbmVkJyA9PT0gdHlwZW9maHRtbGVsZSApe1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGwgIT0gb2JqICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgfSxcblxuICBlbGVtZW50T3JDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBpcy5lbGVtZW50KG9iaikgfHwgaXMuY29sbGVjdGlvbihvYmopO1xuICB9LFxuXG4gIGVsZW1lbnQ6IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb2xsZWN0aW9uJyAmJiBvYmouX3ByaXZhdGUuc2luZ2xlO1xuICB9LFxuXG4gIGNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb2xsZWN0aW9uJyAmJiAhb2JqLl9wcml2YXRlLnNpbmdsZTtcbiAgfSxcblxuICBjb3JlOiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnY29yZSc7XG4gIH0sXG5cbiAgc3R5bGU6IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdzdHlsZSc7XG4gIH0sXG5cbiAgc3R5bGVzaGVldDogZnVuY3Rpb24ob2JqKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ3N0eWxlc2hlZXQnO1xuICB9LFxuXG4gIGV2ZW50OiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnZXZlbnQnO1xuICB9LFxuXG4gIHRocmVhZDogZnVuY3Rpb24ob2JqKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ3RocmVhZCc7XG4gIH0sXG5cbiAgZmFicmljOiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnZmFicmljJztcbiAgfSxcblxuICBlbXB0eVN0cmluZzogZnVuY3Rpb24ob2JqKXtcbiAgICBpZiggIW9iaiApeyAvLyBudWxsIGlzIGVtcHR5XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYoIGlzLnN0cmluZyhvYmopICl7XG4gICAgICBpZiggb2JqID09PSAnJyB8fCBvYmoubWF0Y2goL15cXHMrJC8pICl7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSBzdHJpbmcgaXMgZW1wdHlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7IC8vIG90aGVyd2lzZSwgd2UgZG9uJ3Qga25vdyB3aGF0IHdlJ3ZlIGdvdFxuICB9LFxuXG4gIG5vbmVtcHR5U3RyaW5nOiBmdW5jdGlvbihvYmope1xuICAgIGlmKCBvYmogJiYgaXMuc3RyaW5nKG9iaikgJiYgb2JqICE9PSAnJyAmJiAhb2JqLm1hdGNoKC9eXFxzKyQvKSApe1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGRvbUVsZW1lbnQ6IGZ1bmN0aW9uKG9iail7XG4gICAgaWYoIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgKXtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgbm90IGluIGEgYnJvd3NlciBzbyBpdCBkb2Vzbid0IG1hdHRlclxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgfVxuICB9LFxuXG4gIGJvdW5kaW5nQm94OiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBpcy5wbGFpbk9iamVjdChvYmopICYmXG4gICAgICBpcy5udW1iZXIob2JqLngxKSAmJiBpcy5udW1iZXIob2JqLngyKSAmJlxuICAgICAgaXMubnVtYmVyKG9iai55MSkgJiYgaXMubnVtYmVyKG9iai55MilcbiAgICA7XG4gIH0sXG5cbiAgcHJvbWlzZTogZnVuY3Rpb24ob2JqKXtcbiAgICByZXR1cm4gaXMub2JqZWN0KG9iaikgJiYgaXMuZm4ob2JqLnRoZW4pO1xuICB9LFxuXG4gIHRvdWNoOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB3aW5kb3cgJiYgKCAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2ggKTtcbiAgfSxcblxuICBnZWNrbzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJyB8fCAoJ01vekFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG4gIH0sXG5cbiAgd2Via2l0OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0eXBlb2Ygd2Via2l0VVJMICE9PSAndW5kZWZpbmVkJyB8fCAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG4gIH0sXG5cbiAgY2hyb21pdW06IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHR5cGVvZiBjaHJvbWUgIT09ICd1bmRlZmluZWQnO1xuICB9LFxuXG4gIGtodG1sOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnZlbmRvci5tYXRjaCgva2RlL2kpOyAvLyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRoaXMuLi5cbiAgfSxcblxuICBraHRtbEV0YzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gaXMua2h0bWwoKSB8fCBpcy53ZWJraXQoKSB8fCBpcy5jaHJvbWl1bSgpO1xuICB9LFxuXG4gIG1zOiBmdW5jdGlvbigpe1xuICAgICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL21zaWV8dHJpZGVudHxlZGdlL2kpOyAvLyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRoaXMuLi5cbiAgfSxcblxuICB3aW5kb3dzOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL1dpbi9pKTtcbiAgfSxcblxuICBtYWM6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvTWFjL2kpO1xuICB9LFxuXG4gIGxpbnV4OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL0xpbnV4L2kpO1xuICB9LFxuXG4gIHVuaXg6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvWDExL2kpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzO1xuXG59LHtcIi4vd2luZG93XCI6MTAwfV0sNzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuL2lzJyk7XG5cbnZhciBjeVJlZyA9IGZ1bmN0aW9uKCAkZWxlICl7XG4gIHZhciBkID0gJGVsZVswXS5fY3lyZWcgPSAkZWxlWzBdLl9jeXJlZyB8fCB7fTtcblxuICByZXR1cm4gZDtcbn07XG5cbnZhciByZWdpc3RlckpxdWVyeSA9IGZ1bmN0aW9uKCAkLCBjeXRvc2NhcGUgKXtcbiAgaWYoICEkICl7IHJldHVybjsgfSAvLyBubyBqcXVlcnkgPT4gZG9uJ3QgbmVlZCB0aGlzXG5cbiAgaWYoICQuZm4uY3l0b3NjYXBlICl7IHJldHVybjsgfSAvLyBhbHJlYWR5IHJlZ2lzdGVyZWRcblxuICAvLyBhbGxvdyBjYWxscyBvbiBhIGpRdWVyeSBzZWxlY3RvciBieSBwcm94eWluZyBjYWxscyB0byAkLmN5dG9zY2FwZVxuICAvLyBlLmcuICQoXCIjZm9vXCIpLmN5dG9zY2FwZShvcHRpb25zKSA9PiAkLmN5dG9zY2FwZShvcHRpb25zKSBvbiAjZm9vXG4gICQuZm4uY3l0b3NjYXBlID0gZnVuY3Rpb24ob3B0cyl7XG4gICAgdmFyICR0aGlzID0gJCh0aGlzKTtcblxuICAgIC8vIGdldCBvYmplY3RcbiAgICBpZiggb3B0cyA9PT0gJ2dldCcgKXtcbiAgICAgIHJldHVybiBjeVJlZyggJHRoaXMgKS5jeTtcbiAgICB9XG5cbiAgICAvLyBiaW5kIHRvIHJlYWR5XG4gICAgZWxzZSBpZiggaXMuZm4ob3B0cykgKXtcblxuICAgICAgdmFyIHJlYWR5ID0gb3B0cztcbiAgICAgIHZhciBjeSA9IGN5UmVnKCAkdGhpcyApLmN5O1xuXG4gICAgICBpZiggY3kgJiYgY3kuaXNSZWFkeSgpICl7IC8vIGFscmVhZHkgcmVhZHkgc28ganVzdCB0cmlnZ2VyIG5vd1xuICAgICAgICBjeS50cmlnZ2VyKCdyZWFkeScsIFtdLCByZWFkeSk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIG5vdCB5ZXQgcmVhZHksIHNvIGFkZCB0byByZWFkaWVzIGxpc3RcbiAgICAgICAgdmFyIGRhdGEgPSBjeVJlZyggJHRoaXMgKTtcbiAgICAgICAgdmFyIHJlYWRpZXMgPSBkYXRhLnJlYWRpZXMgPSBkYXRhLnJlYWRpZXMgfHwgW107XG5cbiAgICAgICAgcmVhZGllcy5wdXNoKCByZWFkeSApO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gcHJveHkgdG8gY3JlYXRlIGluc3RhbmNlXG4gICAgZWxzZSBpZiggaXMucGxhaW5PYmplY3Qob3B0cykgKXtcbiAgICAgIHJldHVybiAkdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIG9wdHMsIHtcbiAgICAgICAgICBjb250YWluZXI6ICQodGhpcylbMF1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3l0b3NjYXBlKG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGFsbG93IGFjY2VzcyB0byB0aGUgZ2xvYmFsIGN5dG9zY2FwZSBvYmplY3QgdW5kZXIganF1ZXJ5IGZvciBsZWdhY3kgcmVhc29uc1xuICAkLmN5dG9zY2FwZSA9IGN5dG9zY2FwZTtcblxuICAvLyB1c2Ugc2hvcnQgYWxpYXMgKGN5KSBpZiBub3QgYWxyZWFkeSBkZWZpbmVkXG4gIGlmKCAkLmZuLmN5ID09IG51bGwgJiYgJC5jeSA9PSBudWxsICl7XG4gICAgJC5mbi5jeSA9ICQuZm4uY3l0b3NjYXBlO1xuICAgICQuY3kgPSAkLmN5dG9zY2FwZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlckpxdWVyeTtcblxufSx7XCIuL2lzXCI6Nzd9XSw3OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0ge307XG5cbm1hdGguc2lnbnVtID0gZnVuY3Rpb24oeCl7XG4gIGlmKCB4ID4gMCApe1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYoIHggPCAwICl7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG5tYXRoLmRpc3RhbmNlID0gZnVuY3Rpb24oIHAxLCBwMiApe1xuICByZXR1cm4gTWF0aC5zcXJ0KCBtYXRoLnNxRGlzdGFuY2UocDEsIHAyKSApO1xufTtcblxubWF0aC5zcURpc3RhbmNlID0gZnVuY3Rpb24oIHAxLCBwMiApe1xuICB2YXIgZHggPSBwMi54IC0gcDEueDtcbiAgdmFyIGR5ID0gcDIueSAtIHAxLnk7XG5cbiAgcmV0dXJuIGR4KmR4ICsgZHkqZHk7XG59O1xuXG4vLyBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQsOpemllcl9jdXJ2ZSNRdWFkcmF0aWNfY3VydmVzXG5tYXRoLnFiZXppZXJBdCA9IGZ1bmN0aW9uKHAwLCBwMSwgcDIsIHQpe1xuICByZXR1cm4gKDEgLSB0KSooMSAtIHQpKnAwICsgMiooMSAtIHQpKnQqcDEgKyB0KnQqcDI7XG59O1xuXG5tYXRoLnFiZXppZXJQdEF0ID0gZnVuY3Rpb24ocDAsIHAxLCBwMiwgdCl7XG4gIHJldHVybiB7XG4gICAgeDogbWF0aC5xYmV6aWVyQXQoIHAwLngsIHAxLngsIHAyLngsIHQgKSxcbiAgICB5OiBtYXRoLnFiZXppZXJBdCggcDAueSwgcDEueSwgcDIueSwgdCApXG4gIH07XG59O1xuXG4vLyBtYWtlcyBhIGZ1bGwgYmIgKHgxLCB5MSwgeDIsIHkyLCB3LCBoKSBmcm9tIGltcGxpY2l0IHBhcmFtc1xubWF0aC5tYWtlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIgKXtcbiAgaWYoIGJiLngxICE9IG51bGwgJiYgYmIueTEgIT0gbnVsbCApe1xuICAgIGlmKCBiYi54MiAhPSBudWxsICYmIGJiLnkyICE9IG51bGwgJiYgYmIueDIgPj0gYmIueDEgJiYgYmIueTIgPj0gYmIueTEgKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICB4MjogYmIueDIsXG4gICAgICAgIHkyOiBiYi55MixcbiAgICAgICAgdzogYmIueDIgLSBiYi54MSxcbiAgICAgICAgaDogYmIueTIgLSBiYi55MVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoIGJiLncgIT0gbnVsbCAmJiBiYi5oICE9IG51bGwgJiYgYmIudyA+PSAwICYmIGJiLmggPj0gMCApe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICB5MTogYmIueTEsXG4gICAgICAgIHgyOiBiYi54MSArIGJiLncsXG4gICAgICAgIHkyOiBiYi55MSArIGJiLmgsXG4gICAgICAgIHc6IGJiLncsXG4gICAgICAgIGg6IGJiLmhcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuXG5tYXRoLmJvdW5kaW5nQm94ZXNJbnRlcnNlY3QgPSBmdW5jdGlvbiggYmIxLCBiYjIgKXtcbiAgLy8gY2FzZTogb25lIGJiIHRvIHJpZ2h0IG9mIG90aGVyXG4gIGlmKCBiYjEueDEgPiBiYjIueDIgKXsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmKCBiYjIueDEgPiBiYjEueDIgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY2FzZTogb25lIGJiIHRvIGxlZnQgb2Ygb3RoZXJcbiAgaWYoIGJiMS54MiA8IGJiMi54MSApeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYoIGJiMi54MiA8IGJiMS54MSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjYXNlOiBvbmUgYmIgYWJvdmUgb3RoZXJcbiAgaWYoIGJiMS55MiA8IGJiMi55MSApeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYoIGJiMi55MiA8IGJiMS55MSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjYXNlOiBvbmUgYmIgYmVsb3cgb3RoZXJcbiAgaWYoIGJiMS55MSA+IGJiMi55MiApeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYoIGJiMi55MSA+IGJiMS55MiApeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBvdGhlcndpc2UsIG11c3QgaGF2ZSBzb21lIG92ZXJsYXBcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5tYXRoLmluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIsIHgsIHkgKXtcbiAgcmV0dXJuIGJiLngxIDw9IHggJiYgeCA8PSBiYi54MiAmJiBiYi55MSA8PSB5ICYmIHkgPD0gYmIueTI7XG59O1xuXG5tYXRoLnBvaW50SW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCBiYiwgcHQgKXtcbiAgcmV0dXJuIHRoaXMuaW5Cb3VuZGluZ0JveCggYmIsIHB0LngsIHB0LnkgKTtcbn07XG5cbm1hdGgucm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24oXG4gIHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuXG4gIHZhciBjb3JuZXJSYWRpdXMgPSB0aGlzLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuXG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblxuICAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggc3RyYWlnaHQgbGluZSBzZWdtZW50c1xuICB2YXIgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcblxuICAvLyBUb3Agc2VnbWVudCwgbGVmdCB0byByaWdodFxuICB7XG4gICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgdG9wU3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0IC0gcGFkZGluZztcbiAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgdG9wRW5kWSA9IHRvcFN0YXJ0WTtcblxuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuXG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gUmlnaHQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICB7XG4gICAgdmFyIHJpZ2h0U3RhcnRYID0gbm9kZVggKyBoYWxmV2lkdGggKyBwYWRkaW5nO1xuICAgIHZhciByaWdodFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIHJpZ2h0RW5kWCA9IHJpZ2h0U3RhcnRYO1xuICAgIHZhciByaWdodEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuXG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksIHJpZ2h0U3RhcnRYLCByaWdodFN0YXJ0WSwgcmlnaHRFbmRYLCByaWdodEVuZFksIGZhbHNlKTtcblxuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJvdHRvbSBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG4gIHtcbiAgICB2YXIgYm90dG9tU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciBib3R0b21TdGFydFkgPSBub2RlWSArIGhhbGZIZWlnaHQgKyBwYWRkaW5nO1xuICAgIHZhciBib3R0b21FbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciBib3R0b21FbmRZID0gYm90dG9tU3RhcnRZO1xuXG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbVN0YXJ0WCwgYm90dG9tU3RhcnRZLCBib3R0b21FbmRYLCBib3R0b21FbmRZLCBmYWxzZSk7XG5cbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBMZWZ0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cbiAge1xuICAgIHZhciBsZWZ0U3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggLSBwYWRkaW5nO1xuICAgIHZhciBsZWZ0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgbGVmdEVuZFggPSBsZWZ0U3RhcnRYO1xuICAgIHZhciBsZWZ0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG5cbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgbGVmdFN0YXJ0WCwgbGVmdFN0YXJ0WSwgbGVmdEVuZFgsIGxlZnRFbmRZLCBmYWxzZSk7XG5cbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggYXJjIHNlZ21lbnRzXG4gIHZhciBhcmNJbnRlcnNlY3Rpb25zO1xuXG4gIC8vIFRvcCBMZWZ0XG4gIHtcbiAgICB2YXIgdG9wTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICB2YXIgdG9wTGVmdENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSxcbiAgICAgIHRvcExlZnRDZW50ZXJYLCB0b3BMZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IHRvcExlZnRDZW50ZXJYXG4gICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdIDw9IHRvcExlZnRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRvcCBSaWdodFxuICB7XG4gICAgdmFyIHRvcFJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgIHZhciB0b3BSaWdodENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSxcbiAgICAgIHRvcFJpZ2h0Q2VudGVyWCwgdG9wUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gdG9wUmlnaHRDZW50ZXJYXG4gICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdIDw9IHRvcFJpZ2h0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH1cblxuICAvLyBCb3R0b20gUmlnaHRcbiAge1xuICAgIHZhciBib3R0b21SaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICB2YXIgYm90dG9tUmlnaHRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksXG4gICAgICBib3R0b21SaWdodENlbnRlclgsIGJvdHRvbVJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IGJvdHRvbVJpZ2h0Q2VudGVyWFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21SaWdodENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9XG5cbiAgLy8gQm90dG9tIExlZnRcbiAge1xuICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gdGhpcy5pbnRlcnNlY3RMaW5lQ2lyY2xlKFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLFxuICAgICAgYm90dG9tTGVmdENlbnRlclgsIGJvdHRvbUxlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gYm90dG9tTGVmdENlbnRlclhcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPj0gYm90dG9tTGVmdENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtdOyAvLyBpZiBub3RoaW5nXG59O1xuXG5tYXRoLmluTGluZVZpY2luaXR5ID0gZnVuY3Rpb24oeCwgeSwgbHgxLCBseTEsIGx4MiwgbHkyLCB0b2xlcmFuY2Upe1xuICB2YXIgdCA9IHRvbGVyYW5jZTtcblxuICB2YXIgeDEgPSBNYXRoLm1pbihseDEsIGx4Mik7XG4gIHZhciB4MiA9IE1hdGgubWF4KGx4MSwgbHgyKTtcbiAgdmFyIHkxID0gTWF0aC5taW4obHkxLCBseTIpO1xuICB2YXIgeTIgPSBNYXRoLm1heChseTEsIGx5Mik7XG5cbiAgcmV0dXJuIHgxIC0gdCA8PSB4ICYmIHggPD0geDIgKyB0XG4gICAgJiYgeTEgLSB0IDw9IHkgJiYgeSA8PSB5MiArIHQ7XG59O1xuXG5tYXRoLmluQmV6aWVyVmljaW5pdHkgPSBmdW5jdGlvbihcbiAgeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlKSB7XG5cbiAgdmFyIGJiID0ge1xuICAgIHgxOiBNYXRoLm1pbiggeDEsIHgzLCB4MiApIC0gdG9sZXJhbmNlLFxuICAgIHgyOiBNYXRoLm1heCggeDEsIHgzLCB4MiApICsgdG9sZXJhbmNlLFxuICAgIHkxOiBNYXRoLm1pbiggeTEsIHkzLCB5MiApIC0gdG9sZXJhbmNlLFxuICAgIHkyOiBNYXRoLm1heCggeTEsIHkzLCB5MiApICsgdG9sZXJhbmNlXG4gIH07XG5cbiAgLy8gaWYgb3V0c2lkZSB0aGUgcm91Z2ggYm91bmRpbmcgYm94IGZvciB0aGUgYmV6aWVyLCB0aGVuIGl0IGNhbid0IGJlIGEgaGl0XG4gIGlmKCB4IDwgYmIueDEgfHwgeCA+IGJiLngyIHx8IHkgPCBiYi55MSB8fCB5ID4gYmIueTIgKXtcbiAgICAvLyBjb25zb2xlLmxvZygnYmV6aWVyIG91dCBvZiByb3VnaCBiYicpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIGNvbnNvbGUubG9nKCdkbyBtb3JlIGV4cGVuc2l2ZSBjaGVjaycpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn07XG5cbm1hdGguc29sdmVDdWJpYyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHJlc3VsdCkge1xuXG4gIC8vIFNvbHZlcyBhIGN1YmljIGZ1bmN0aW9uLCByZXR1cm5zIHJvb3QgaW4gZm9ybSBbcjEsIGkxLCByMiwgaTIsIHIzLCBpM10sIHdoZXJlXG4gIC8vIHIgaXMgdGhlIHJlYWwgY29tcG9uZW50LCBpIGlzIHRoZSBpbWFnaW5hcnkgY29tcG9uZW50XG5cbiAgLy8gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIENhcmRhbm8gbWV0aG9kIGZyb20gdGhlIHllYXIgMTU0NVxuICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX2Z1bmN0aW9uI1RoZV9uYXR1cmVfb2ZfdGhlX3Jvb3RzXG5cbiAgYiAvPSBhO1xuICBjIC89IGE7XG4gIGQgLz0gYTtcblxuICB2YXIgZGlzY3JpbWluYW50LCBxLCByLCBkdW0xLCBzLCB0LCB0ZXJtMSwgcjEzO1xuXG4gIHEgPSAoMy4wICogYyAtIChiICogYikpIC8gOS4wO1xuICByID0gLSgyNy4wICogZCkgKyBiICogKDkuMCAqIGMgLSAyLjAgKiAoYiAqIGIpKTtcbiAgciAvPSA1NC4wO1xuXG4gIGRpc2NyaW1pbmFudCA9IHEgKiBxICogcSArIHIgKiByO1xuICByZXN1bHRbMV0gPSAwO1xuICB0ZXJtMSA9IChiIC8gMy4wKTtcblxuICBpZiAoZGlzY3JpbWluYW50ID4gMCkge1xuICAgIHMgPSByICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgcyA9ICgocyA8IDApID8gLU1hdGgucG93KC1zLCAoMS4wIC8gMy4wKSkgOiBNYXRoLnBvdyhzLCAoMS4wIC8gMy4wKSkpO1xuICAgIHQgPSByIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgdCA9ICgodCA8IDApID8gLU1hdGgucG93KC10LCAoMS4wIC8gMy4wKSkgOiBNYXRoLnBvdyh0LCAoMS4wIC8gMy4wKSkpO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIHMgKyB0O1xuICAgIHRlcm0xICs9IChzICsgdCkgLyAyLjA7XG4gICAgcmVzdWx0WzRdID0gcmVzdWx0WzJdID0gLXRlcm0xO1xuICAgIHRlcm0xID0gTWF0aC5zcXJ0KDMuMCkgKiAoLXQgKyBzKSAvIDI7XG4gICAgcmVzdWx0WzNdID0gdGVybTE7XG4gICAgcmVzdWx0WzVdID0gLXRlcm0xO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlc3VsdFs1XSA9IHJlc3VsdFszXSA9IDA7XG5cbiAgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xuICAgIHIxMyA9ICgociA8IDApID8gLU1hdGgucG93KC1yLCAoMS4wIC8gMy4wKSkgOiBNYXRoLnBvdyhyLCAoMS4wIC8gMy4wKSkpO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIDIuMCAqIHIxMztcbiAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtKHIxMyArIHRlcm0xKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBxID0gLXE7XG4gIGR1bTEgPSBxICogcSAqIHE7XG4gIGR1bTEgPSBNYXRoLmFjb3MociAvIE1hdGguc3FydChkdW0xKSk7XG4gIHIxMyA9IDIuMCAqIE1hdGguc3FydChxKTtcbiAgcmVzdWx0WzBdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoZHVtMSAvIDMuMCk7XG4gIHJlc3VsdFsyXSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKChkdW0xICsgMi4wICogTWF0aC5QSSkgLyAzLjApO1xuICByZXN1bHRbNF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDQuMCAqIE1hdGguUEkpIC8gMy4wKTtcblxuICByZXR1cm47XG59O1xuXG5tYXRoLnNxRGlzdGFuY2VUb1F1YWRyYXRpY0JlemllciA9IGZ1bmN0aW9uKFxuICB4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG5cbiAgLy8gRmluZCBtaW5pbXVtIGRpc3RhbmNlIGJ5IHVzaW5nIHRoZSBtaW5pbXVtIG9mIHRoZSBkaXN0YW5jZVxuICAvLyBmdW5jdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludCBhbmQgdGhlIGN1cnZlXG5cbiAgLy8gVGhpcyBnaXZlcyB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSByZXN1bHRpbmcgY3ViaWMgZXF1YXRpb25cbiAgLy8gd2hvc2Ugcm9vdHMgdGVsbCB1cyB3aGVyZSBhIHBvc3NpYmxlIG1pbmltdW0gaXNcbiAgLy8gKENvZWZmaWNpZW50cyBhcmUgZGl2aWRlZCBieSA0KVxuXG4gIHZhciBhID0gMS4wICogeDEqeDEgLSA0KngxKngyICsgMip4MSp4MyArIDQqeDIqeDIgLSA0KngyKngzICsgeDMqeDNcbiAgICArIHkxKnkxIC0gNCp5MSp5MiArIDIqeTEqeTMgKyA0KnkyKnkyIC0gNCp5Mip5MyArIHkzKnkzO1xuXG4gIHZhciBiID0gMS4wICogOSp4MSp4MiAtIDMqeDEqeDEgLSAzKngxKngzIC0gNip4Mip4MiArIDMqeDIqeDNcbiAgICArIDkqeTEqeTIgLSAzKnkxKnkxIC0gMyp5MSp5MyAtIDYqeTIqeTIgKyAzKnkyKnkzO1xuXG4gIHZhciBjID0gMS4wICogMyp4MSp4MSAtIDYqeDEqeDIgKyB4MSp4MyAtIHgxKnggKyAyKngyKngyICsgMip4Mip4IC0geDMqeFxuICAgICsgMyp5MSp5MSAtIDYqeTEqeTIgKyB5MSp5MyAtIHkxKnkgKyAyKnkyKnkyICsgMip5Mip5IC0geTMqeTtcblxuICB2YXIgZCA9IDEuMCAqIHgxKngyIC0geDEqeDEgKyB4MSp4IC0geDIqeFxuICAgICsgeTEqeTIgLSB5MSp5MSArIHkxKnkgLSB5Mip5O1xuXG4gIC8vIGRlYnVnKFwiY29lZmZpY2llbnRzOiBcIiArIGEgLyBhICsgXCIsIFwiICsgYiAvIGEgKyBcIiwgXCIgKyBjIC8gYSArIFwiLCBcIiArIGQgLyBhKTtcblxuICB2YXIgcm9vdHMgPSBbXTtcblxuICAvLyBVc2UgdGhlIGN1YmljIHNvbHZpbmcgYWxnb3JpdGhtXG4gIHRoaXMuc29sdmVDdWJpYyhhLCBiLCBjLCBkLCByb290cyk7XG5cbiAgdmFyIHplcm9UaHJlc2hvbGQgPSAwLjAwMDAwMDE7XG5cbiAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCA2OyBpbmRleCArPSAyKSB7XG4gICAgaWYgKE1hdGguYWJzKHJvb3RzW2luZGV4ICsgMV0pIDwgemVyb1RocmVzaG9sZFxuICAgICAgICAmJiByb290c1tpbmRleF0gPj0gMFxuICAgICAgICAmJiByb290c1tpbmRleF0gPD0gMS4wKSB7XG4gICAgICBwYXJhbXMucHVzaChyb290c1tpbmRleF0pO1xuICAgIH1cbiAgfVxuXG4gIHBhcmFtcy5wdXNoKDEuMCk7XG4gIHBhcmFtcy5wdXNoKDAuMCk7XG5cbiAgdmFyIG1pbkRpc3RhbmNlU3F1YXJlZCA9IC0xO1xuICB2YXIgY2xvc2VzdFBhcmFtO1xuXG4gIHZhciBjdXJYLCBjdXJZLCBkaXN0U3F1YXJlZDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjdXJYID0gTWF0aC5wb3coMS4wIC0gcGFyYW1zW2ldLCAyLjApICogeDFcbiAgICAgICsgMi4wICogKDEgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeDJcbiAgICAgICsgcGFyYW1zW2ldICogcGFyYW1zW2ldICogeDM7XG5cbiAgICBjdXJZID0gTWF0aC5wb3coMSAtIHBhcmFtc1tpXSwgMi4wKSAqIHkxXG4gICAgICArIDIgKiAoMS4wIC0gcGFyYW1zW2ldKSAqIHBhcmFtc1tpXSAqIHkyXG4gICAgICArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHkzO1xuXG4gICAgZGlzdFNxdWFyZWQgPSBNYXRoLnBvdyhjdXJYIC0geCwgMikgKyBNYXRoLnBvdyhjdXJZIC0geSwgMik7XG4gICAgLy8gZGVidWcoJ2Rpc3RhbmNlIGZvciBwYXJhbSAnICsgcGFyYW1zW2ldICsgXCI6IFwiICsgTWF0aC5zcXJ0KGRpc3RTcXVhcmVkKSk7XG4gICAgaWYgKG1pbkRpc3RhbmNlU3F1YXJlZCA+PSAwKSB7XG4gICAgICBpZiAoZGlzdFNxdWFyZWQgPCBtaW5EaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICAgIGNsb3Nlc3RQYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICBjbG9zZXN0UGFyYW0gPSBwYXJhbXNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbkRpc3RhbmNlU3F1YXJlZDtcbn07XG5cbm1hdGguc3FEaXN0YW5jZVRvRmluaXRlTGluZSA9IGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBvZmZzZXQgPSBbeCAtIHgxLCB5IC0geTFdO1xuICB2YXIgbGluZSA9IFt4MiAtIHgxLCB5MiAtIHkxXTtcblxuICB2YXIgbGluZVNxID0gbGluZVswXSAqIGxpbmVbMF0gKyBsaW5lWzFdICogbGluZVsxXTtcbiAgdmFyIGh5cFNxID0gb2Zmc2V0WzBdICogb2Zmc2V0WzBdICsgb2Zmc2V0WzFdICogb2Zmc2V0WzFdO1xuXG4gIHZhciBkb3RQcm9kdWN0ID0gb2Zmc2V0WzBdICogbGluZVswXSArIG9mZnNldFsxXSAqIGxpbmVbMV07XG4gIHZhciBhZGpTcSA9IGRvdFByb2R1Y3QgKiBkb3RQcm9kdWN0IC8gbGluZVNxO1xuXG4gIGlmIChkb3RQcm9kdWN0IDwgMCkge1xuICAgIHJldHVybiBoeXBTcTtcbiAgfVxuXG4gIGlmIChhZGpTcSA+IGxpbmVTcSkge1xuICAgIHJldHVybiAoeCAtIHgyKSAqICh4IC0geDIpICsgKHkgLSB5MikgKiAoeSAtIHkyKTtcbiAgfVxuXG4gIHJldHVybiBoeXBTcSAtIGFkalNxO1xufTtcblxubWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMgPSBmdW5jdGlvbih4LCB5LCBwb2ludHMpe1xuICB2YXIgeDEsIHkxLCB4MiwgeTI7XG4gIHZhciB5MztcblxuICAvLyBJbnRlcnNlY3Qgd2l0aCB2ZXJ0aWNhbCBsaW5lIHRocm91Z2ggKHgsIHkpXG4gIHZhciB1cCA9IDA7XG4gIHZhciBkb3duID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG5cbiAgICB4MSA9IHBvaW50c1tpICogMl07XG4gICAgeTEgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgIGlmIChpICsgMSA8IHBvaW50cy5sZW5ndGggLyAyKSB7XG4gICAgICB4MiA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICB5MiA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyXTtcbiAgICAgIHkyID0gcG9pbnRzWyhpICsgMSAtIHBvaW50cy5sZW5ndGggLyAyKSAqIDIgKyAxXTtcbiAgICB9XG5cbiAgICBpZiAoeDEgPT0geCAmJiB4MiA9PSB4KSB7XG5cbiAgICB9IGVsc2UgaWYgKCh4MSA+PSB4ICYmIHggPj0geDIpXG4gICAgICB8fCAoeDEgPD0geCAmJiB4IDw9IHgyKSkge1xuXG4gICAgICB5MyA9ICh4IC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG5cbiAgICAgIGlmICh5MyA+IHkpIHtcbiAgICAgICAgdXArKztcbiAgICAgIH1cblxuICAgICAgaWYgKHkzIDwgeSkge1xuICAgICAgICBkb3duKys7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gIH1cblxuICBpZiAodXAgJSAyID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5tYXRoLnBvaW50SW5zaWRlUG9seWdvbiA9IGZ1bmN0aW9uKFxuICB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcblxuICAvL3ZhciBkaXJlY3Rpb24gPSBhcmd1bWVudHNbNl07XG4gIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG5cbiAgLy8gR2l2ZXMgbmVnYXRpdmUgYW5nbGVcbiAgdmFyIGFuZ2xlO1xuXG4gIGlmKCBkaXJlY3Rpb25bMF0gIT0gbnVsbCApe1xuICAgIGFuZ2xlID0gTWF0aC5hdGFuKGRpcmVjdGlvblsxXSAvIGRpcmVjdGlvblswXSk7XG5cbiAgICBpZiAoZGlyZWN0aW9uWzBdIDwgMCkge1xuICAgICAgYW5nbGUgPSBhbmdsZSArIE1hdGguUEkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZSA9IC1hbmdsZSAtIE1hdGguUEkgLyAyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhbmdsZSA9IGRpcmVjdGlvbjtcbiAgfVxuXG4gIHZhciBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICB2YXIgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblxuICAvLyAgICBjb25zb2xlLmxvZyhcImJhc2U6IFwiICsgYmFzZVBvaW50cyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID1cbiAgICAgIHdpZHRoIC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyXSAqIGNvc1xuICAgICAgICAtIGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIHNpbik7XG5cbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID1cbiAgICAgIGhlaWdodCAvIDIgKiAoYmFzZVBvaW50c1tpICogMiArIDFdICogY29zXG4gICAgICAgICsgYmFzZVBvaW50c1tpICogMl0gKiBzaW4pO1xuXG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdICs9IGNlbnRlclg7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSArPSBjZW50ZXJZO1xuICB9XG5cbiAgdmFyIHBvaW50cztcblxuICBpZiAocGFkZGluZyA+IDApIHtcbiAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gdGhpcy5leHBhbmRQb2x5Z29uKFxuICAgICAgdHJhbnNmb3JtZWRQb2ludHMsXG4gICAgICAtcGFkZGluZyk7XG5cbiAgICBwb2ludHMgPSB0aGlzLmpvaW5MaW5lcyhleHBhbmRlZExpbmVTZXQpO1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICB9XG5cbiAgcmV0dXJuIG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKCB4LCB5LCBwb2ludHMgKTtcbn07XG5cbm1hdGguam9pbkxpbmVzID0gZnVuY3Rpb24obGluZVNldCkge1xuXG4gIHZhciB2ZXJ0aWNlcyA9IG5ldyBBcnJheShsaW5lU2V0Lmxlbmd0aCAvIDIpO1xuXG4gIHZhciBjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZO1xuICB2YXIgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLCBuZXh0TGluZUVuZFgsIG5leHRMaW5lRW5kWTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVTZXQubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgY3VycmVudExpbmVTdGFydFggPSBsaW5lU2V0W2kgKiA0XTtcbiAgICBjdXJyZW50TGluZVN0YXJ0WSA9IGxpbmVTZXRbaSAqIDQgKyAxXTtcbiAgICBjdXJyZW50TGluZUVuZFggPSBsaW5lU2V0W2kgKiA0ICsgMl07XG4gICAgY3VycmVudExpbmVFbmRZID0gbGluZVNldFtpICogNCArIDNdO1xuXG4gICAgaWYgKGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQgLSAxKSB7XG4gICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbKGkgKyAxKSAqIDRdO1xuICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMV07XG4gICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgM107XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFswXTtcbiAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsxXTtcbiAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WzNdO1xuICAgIH1cblxuICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgY3VycmVudExpbmVTdGFydFgsIGN1cnJlbnRMaW5lU3RhcnRZLFxuICAgICAgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFksXG4gICAgICBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksXG4gICAgICBuZXh0TGluZUVuZFgsIG5leHRMaW5lRW5kWSxcbiAgICAgIHRydWUpO1xuXG4gICAgdmVydGljZXNbaSAqIDJdID0gaW50ZXJzZWN0aW9uWzBdO1xuICAgIHZlcnRpY2VzW2kgKiAyICsgMV0gPSBpbnRlcnNlY3Rpb25bMV07XG4gIH1cblxuICByZXR1cm4gdmVydGljZXM7XG59O1xuXG5tYXRoLmV4cGFuZFBvbHlnb24gPSBmdW5jdGlvbihwb2ludHMsIHBhZCkge1xuXG4gIHZhciBleHBhbmRlZExpbmVTZXQgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuXG4gIHZhciBjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZLCBuZXh0UG9pbnRYLCBuZXh0UG9pbnRZO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIGN1cnJlbnRQb2ludFggPSBwb2ludHNbaSAqIDJdO1xuICAgIGN1cnJlbnRQb2ludFkgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1swXTtcbiAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbMV07XG4gICAgfVxuXG4gICAgLy8gQ3VycmVudCBsaW5lOiBbY3VycmVudFBvaW50WCwgY3VycmVudFBvaW50WV0gdG8gW25leHRQb2ludFgsIG5leHRQb2ludFldXG5cbiAgICAvLyBBc3N1bWUgQ0NXIHBvbHlnb24gd2luZGluZ1xuXG4gICAgdmFyIG9mZnNldFggPSAobmV4dFBvaW50WSAtIGN1cnJlbnRQb2ludFkpO1xuICAgIHZhciBvZmZzZXRZID0gLShuZXh0UG9pbnRYIC0gY3VycmVudFBvaW50WCk7XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgb2Zmc2V0TGVuZ3RoID0gTWF0aC5zcXJ0KG9mZnNldFggKiBvZmZzZXRYICsgb2Zmc2V0WSAqIG9mZnNldFkpO1xuICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WCA9IG9mZnNldFggLyBvZmZzZXRMZW5ndGg7XG4gICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRZID0gb2Zmc2V0WSAvIG9mZnNldExlbmd0aDtcblxuICAgIGV4cGFuZGVkTGluZVNldFtpICogNF0gPSBjdXJyZW50UG9pbnRYICsgbm9ybWFsaXplZE9mZnNldFggKiBwYWQ7XG4gICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgMV0gPSBjdXJyZW50UG9pbnRZICsgbm9ybWFsaXplZE9mZnNldFkgKiBwYWQ7XG4gICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgMl0gPSBuZXh0UG9pbnRYICsgbm9ybWFsaXplZE9mZnNldFggKiBwYWQ7XG4gICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgM10gPSBuZXh0UG9pbnRZICsgbm9ybWFsaXplZE9mZnNldFkgKiBwYWQ7XG4gIH1cblxuICByZXR1cm4gZXhwYW5kZWRMaW5lU2V0O1xufTtcblxubWF0aC5pbnRlcnNlY3RMaW5lRWxsaXBzZSA9IGZ1bmN0aW9uKFxuICB4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBlbGxpcHNlV3JhZGl1cywgZWxsaXBzZUhyYWRpdXMpIHtcblxuICB2YXIgZGlzcFggPSBjZW50ZXJYIC0geDtcbiAgdmFyIGRpc3BZID0gY2VudGVyWSAtIHk7XG5cbiAgZGlzcFggLz0gZWxsaXBzZVdyYWRpdXM7XG4gIGRpc3BZIC89IGVsbGlwc2VIcmFkaXVzO1xuXG4gIHZhciBsZW4gPSBNYXRoLnNxcnQoZGlzcFggKiBkaXNwWCArIGRpc3BZICogZGlzcFkpO1xuXG4gIHZhciBuZXdMZW5ndGggPSBsZW4gLSAxO1xuXG4gIGlmIChuZXdMZW5ndGggPCAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGxlblByb3BvcnRpb24gPSBuZXdMZW5ndGggLyBsZW47XG5cbiAgcmV0dXJuIFsoY2VudGVyWCAtIHgpICogbGVuUHJvcG9ydGlvbiArIHgsIChjZW50ZXJZIC0geSkgKiBsZW5Qcm9wb3J0aW9uICsgeV07XG59O1xuXG4vLyBSZXR1cm5zIGludGVyc2VjdGlvbnMgb2YgaW5jcmVhc2luZyBkaXN0YW5jZSBmcm9tIGxpbmUncyBzdGFydCBwb2ludFxubWF0aC5pbnRlcnNlY3RMaW5lQ2lyY2xlID0gZnVuY3Rpb24oXG4gIHgxLCB5MSwgeDIsIHkyLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMpIHtcblxuICAvLyBDYWxjdWxhdGUgZCwgZGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gIHZhciBkID0gW3gyIC0geDEsIHkyIC0geTFdOyAvLyBEaXJlY3Rpb24gdmVjdG9yIG9mIGxpbmVcbiAgdmFyIGMgPSBbY2VudGVyWCwgY2VudGVyWV07IC8vIENlbnRlciBvZiBjaXJjbGVcbiAgdmFyIGYgPSBbeDEgLSBjZW50ZXJYLCB5MSAtIGNlbnRlclldO1xuXG4gIHZhciBhID0gZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXTtcbiAgdmFyIGIgPSAyICogKGZbMF0gKiBkWzBdICsgZlsxXSAqIGRbMV0pO1xuICB2YXIgYyA9IChmWzBdICogZlswXSArIGZbMV0gKiBmWzFdKSAtIHJhZGl1cyAqIHJhZGl1cyA7XG5cbiAgdmFyIGRpc2NyaW1pbmFudCA9IGIqYi00KmEqYztcblxuICBpZiAoZGlzY3JpbWluYW50IDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG4gIHZhciB0MiA9ICgtYiAtIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG5cbiAgdmFyIHRNaW4gPSBNYXRoLm1pbih0MSwgdDIpO1xuICB2YXIgdE1heCA9IE1hdGgubWF4KHQxLCB0Mik7XG4gIHZhciBpblJhbmdlUGFyYW1zID0gW107XG5cbiAgaWYgKHRNaW4gPj0gMCAmJiB0TWluIDw9IDEpIHtcbiAgICBpblJhbmdlUGFyYW1zLnB1c2godE1pbik7XG4gIH1cblxuICBpZiAodE1heCA+PSAwICYmIHRNYXggPD0gMSkge1xuICAgIGluUmFuZ2VQYXJhbXMucHVzaCh0TWF4KTtcbiAgfVxuXG4gIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBuZWFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMF0gKiBkWzBdICsgeDE7XG4gIHZhciBuZWFySW50ZXJzZWN0aW9uWSA9IGluUmFuZ2VQYXJhbXNbMF0gKiBkWzFdICsgeTE7XG5cbiAgaWYgKGluUmFuZ2VQYXJhbXMubGVuZ3RoID4gMSkge1xuXG4gICAgaWYgKGluUmFuZ2VQYXJhbXNbMF0gPT0gaW5SYW5nZVBhcmFtc1sxXSkge1xuICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMF0gKyB4MTtcbiAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMV0gKyB5MTtcblxuICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblksIGZhckludGVyc2VjdGlvblgsIGZhckludGVyc2VjdGlvblldO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZXTtcbiAgfVxuXG59O1xuXG5tYXRoLmZpbmRDaXJjbGVOZWFyUG9pbnQgPSBmdW5jdGlvbihjZW50ZXJYLCBjZW50ZXJZLFxuICByYWRpdXMsIGZhclgsIGZhclkpIHtcblxuICB2YXIgZGlzcGxhY2VtZW50WCA9IGZhclggLSBjZW50ZXJYO1xuICB2YXIgZGlzcGxhY2VtZW50WSA9IGZhclkgLSBjZW50ZXJZO1xuICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzcGxhY2VtZW50WCAqIGRpc3BsYWNlbWVudFhcbiAgICArIGRpc3BsYWNlbWVudFkgKiBkaXNwbGFjZW1lbnRZKTtcblxuICB2YXIgdW5pdERpc3BsYWNlbWVudFggPSBkaXNwbGFjZW1lbnRYIC8gZGlzdGFuY2U7XG4gIHZhciB1bml0RGlzcGxhY2VtZW50WSA9IGRpc3BsYWNlbWVudFkgLyBkaXN0YW5jZTtcblxuICByZXR1cm4gW2NlbnRlclggKyB1bml0RGlzcGxhY2VtZW50WCAqIHJhZGl1cyxcbiAgICBjZW50ZXJZICsgdW5pdERpc3BsYWNlbWVudFkgKiByYWRpdXNdO1xufTtcblxubWF0aC5maW5kTWF4U3FEaXN0YW5jZVRvT3JpZ2luID0gZnVuY3Rpb24ocG9pbnRzKSB7XG4gIHZhciBtYXhTcURpc3RhbmNlID0gMC4wMDAwMDE7XG4gIHZhciBzcURpc3RhbmNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuXG4gICAgc3FEaXN0YW5jZSA9IHBvaW50c1tpICogMl0gKiBwb2ludHNbaSAqIDJdXG4gICAgICArIHBvaW50c1tpICogMiArIDFdICogcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICBpZiAoc3FEaXN0YW5jZSA+IG1heFNxRGlzdGFuY2UpIHtcbiAgICAgIG1heFNxRGlzdGFuY2UgPSBzcURpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXhTcURpc3RhbmNlO1xufTtcblxubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdCA9IGZ1bmN0aW9uKFxuICB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGluZmluaXRlTGluZXMpIHtcblxuICB2YXIgdWFfdCA9ICh4NCAtIHgzKSAqICh5MSAtIHkzKSAtICh5NCAtIHkzKSAqICh4MSAtIHgzKTtcbiAgdmFyIHViX3QgPSAoeDIgLSB4MSkgKiAoeTEgLSB5MykgLSAoeTIgLSB5MSkgKiAoeDEgLSB4Myk7XG4gIHZhciB1X2IgPSAoeTQgLSB5MykgKiAoeDIgLSB4MSkgLSAoeDQgLSB4MykgKiAoeTIgLSB5MSk7XG5cbiAgaWYgKHVfYiAhPT0gMCkge1xuICAgIHZhciB1YSA9IHVhX3QgLyB1X2I7XG4gICAgdmFyIHViID0gdWJfdCAvIHVfYjtcblxuICAgIGlmICgwIDw9IHVhICYmIHVhIDw9IDEgJiYgMCA8PSB1YiAmJiB1YiA8PSAxKSB7XG4gICAgICByZXR1cm4gW3gxICsgdWEgKiAoeDIgLSB4MSksIHkxICsgdWEgKiAoeTIgLSB5MSldO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaW5maW5pdGVMaW5lcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3gxICsgdWEgKiAoeDIgLSB4MSksIHkxICsgdWEgKiAoeTIgLSB5MSldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodWFfdCA9PT0gMCB8fCB1Yl90ID09PSAwKSB7XG5cbiAgICAgIC8vIFBhcmFsbGVsLCBjb2luY2lkZW50IGxpbmVzLiBDaGVjayBpZiBvdmVybGFwXG5cbiAgICAgIC8vIENoZWNrIGVuZHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICBpZiAoW3gxLCB4MiwgeDRdLnNvcnQoKVsxXSA9PT0geDQpIHtcbiAgICAgICAgcmV0dXJuIFt4NCwgeTRdO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBzdGFydCBwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgaWYgKFt4MSwgeDIsIHgzXS5zb3J0KClbMV0gPT09IHgzKSB7XG4gICAgICAgIHJldHVybiBbeDMsIHkzXTtcbiAgICAgIH1cblxuICAgICAgLy8gRW5kcG9pbnQgb2YgZmlyc3QgbGluZVxuICAgICAgaWYgKFt4MywgeDQsIHgyXS5zb3J0KClbMV0gPT09IHgyKSB7XG4gICAgICAgIHJldHVybiBbeDIsIHkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIFBhcmFsbGVsLCBub24tY29pbmNpZGVudFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufTtcblxubWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uKFxuICB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG5cbiAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgdmFyIGludGVyc2VjdGlvbjtcblxuICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gYmFzZVBvaW50c1tpICogMl0gKiB3aWR0aCArIGNlbnRlclg7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGhlaWdodCArIGNlbnRlclk7XG4gIH1cblxuICB2YXIgcG9pbnRzO1xuXG4gIGlmIChwYWRkaW5nID4gMCkge1xuICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBtYXRoLmV4cGFuZFBvbHlnb24oXG4gICAgICB0cmFuc2Zvcm1lZFBvaW50cyxcbiAgICAgIC1wYWRkaW5nKTtcblxuICAgIHBvaW50cyA9IG1hdGguam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gIH1cbiAgLy8gdmFyIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuXG4gIHZhciBjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcblxuICAgIGN1cnJlbnRYID0gcG9pbnRzW2kgKiAyXTtcbiAgICBjdXJyZW50WSA9IHBvaW50c1tpICogMiArIDFdO1xuXG4gICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgIG5leHRYID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgIG5leHRZID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRYID0gcG9pbnRzWzBdO1xuICAgICAgbmV4dFkgPSBwb2ludHNbMV07XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0aW9uID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgIHgsIHksIGNlbnRlclgsIGNlbnRlclksXG4gICAgICBjdXJyZW50WCwgY3VycmVudFksXG4gICAgICBuZXh0WCwgbmV4dFkpO1xuXG4gICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgIGludGVyc2VjdGlvbnMucHVzaChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG59O1xuXG5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihcbiAgaW50ZXJzZWN0aW9uLCBvZmZzZXQsIGFtb3VudCkge1xuXG4gIHZhciBkaXNwID0gW2ludGVyc2VjdGlvblswXSAtIG9mZnNldFswXSwgaW50ZXJzZWN0aW9uWzFdIC0gb2Zmc2V0WzFdXTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KGRpc3BbMF0gKiBkaXNwWzBdICsgZGlzcFsxXSAqIGRpc3BbMV0pO1xuXG4gIHZhciBsZW5SYXRpbyA9IChsZW5ndGggLSBhbW91bnQpIC8gbGVuZ3RoO1xuXG4gIGlmIChsZW5SYXRpbyA8IDApIHtcbiAgICBsZW5SYXRpbyA9IDAuMDAwMDE7XG4gIH1cblxuICByZXR1cm4gW29mZnNldFswXSArIGxlblJhdGlvICogZGlzcFswXSwgb2Zmc2V0WzFdICsgbGVuUmF0aW8gKiBkaXNwWzFdXTtcbn07XG5cbm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlID0gZnVuY3Rpb24oc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICB2YXIgcG9pbnRzID0gbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpO1xuICBwb2ludHMgPSBtYXRoLmZpdFBvbHlnb25Ub1NxdWFyZShwb2ludHMpO1xuXG4gIHJldHVybiBwb2ludHM7XG59O1xuXG5tYXRoLmZpdFBvbHlnb25Ub1NxdWFyZSA9IGZ1bmN0aW9uKHBvaW50cyl7XG4gIHZhciB4LCB5O1xuICB2YXIgc2lkZXMgPSBwb2ludHMubGVuZ3RoLzI7XG4gIHZhciBtaW5YID0gSW5maW5pdHksIG1pblkgPSBJbmZpbml0eSwgbWF4WCA9IC1JbmZpbml0eSwgbWF4WSA9IC1JbmZpbml0eTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICB4ID0gcG9pbnRzWzIgKiBpXTtcbiAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV07XG5cbiAgICBtaW5YID0gTWF0aC5taW4oIG1pblgsIHggKTtcbiAgICBtYXhYID0gTWF0aC5tYXgoIG1heFgsIHggKTtcbiAgICBtaW5ZID0gTWF0aC5taW4oIG1pblksIHkgKTtcbiAgICBtYXhZID0gTWF0aC5tYXgoIG1heFksIHkgKTtcbiAgfVxuXG4gIC8vIHN0cmV0Y2ggZmFjdG9yc1xuICB2YXIgc3ggPSAyIC8gKG1heFggLSBtaW5YKTtcbiAgdmFyIHN5ID0gMiAvIChtYXhZIC0gbWluWSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKXtcbiAgICB4ID0gcG9pbnRzWzIgKiBpXSA9IHBvaW50c1syICogaV0gKiBzeDtcbiAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBwb2ludHNbMiAqIGkgKyAxXSAqIHN5O1xuXG4gICAgbWluWCA9IE1hdGgubWluKCBtaW5YLCB4ICk7XG4gICAgbWF4WCA9IE1hdGgubWF4KCBtYXhYLCB4ICk7XG4gICAgbWluWSA9IE1hdGgubWluKCBtaW5ZLCB5ICk7XG4gICAgbWF4WSA9IE1hdGgubWF4KCBtYXhZLCB5ICk7XG4gIH1cblxuICBpZiggbWluWSA8IC0xICl7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKXtcbiAgICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXSA9IHBvaW50c1syICogaSArIDFdICsgKC0xIC1taW5ZKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufTtcblxubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzID0gZnVuY3Rpb24oc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuXG4gIHZhciBpbmNyZW1lbnQgPSAxLjAgLyBzaWRlcyAqIDIgKiBNYXRoLlBJO1xuICB2YXIgc3RhcnRBbmdsZSA9IHNpZGVzICUgMiA9PT0gMCA/XG4gICAgTWF0aC5QSSAvIDIuMCArIGluY3JlbWVudCAvIDIuMCA6IE1hdGguUEkgLyAyLjA7XG4gICAgLy8gICAgY29uc29sZS5sb2cobm9kZVNoYXBlc1snc3F1YXJlJ10pO1xuICBzdGFydEFuZ2xlICs9IHJvdGF0aW9uUmFkaWFucztcblxuICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KHNpZGVzICogMik7XG5cbiAgdmFyIGN1cnJlbnRBbmdsZSwgeCwgeTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgY3VycmVudEFuZ2xlID0gaSAqIGluY3JlbWVudCArIHN0YXJ0QW5nbGU7XG5cbiAgICB4ID0gcG9pbnRzWzIgKiBpXSA9IE1hdGguY29zKGN1cnJlbnRBbmdsZSk7Ly8gKiAoMSArIGkvMik7XG4gICAgeSA9IHBvaW50c1syICogaSArIDFdID0gTWF0aC5zaW4oLWN1cnJlbnRBbmdsZSk7Ly8gICogKDEgKyBpLzIpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbm1hdGguZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgLy8gU2V0IHRoZSBkZWZhdWx0IHJhZGl1cywgdW5sZXNzIGhhbGYgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHNtYWxsZXIgdGhhbiBkZWZhdWx0XG4gIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDQsIGhlaWdodCAvIDQsIDgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYXRoO1xuXG59LHt9XSw4MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKiFcbkVtYmVkZGFibGUgTWluaW11bSBTdHJpY3RseS1Db21wbGlhbnQgUHJvbWlzZXMvQSsgMS4xLjEgVGhlbmFibGVcbkNvcHlyaWdodCAoYykgMjAxMy0yMDE0IFJhbGYgUy4gRW5nZWxzY2hhbGwgKGh0dHA6Ly9lbmdlbHNjaGFsbC5jb20pXG5MaWNlbnNlZCB1bmRlciBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qICBwcm9taXNlIHN0YXRlcyBbUHJvbWlzZXMvQSsgMi4xXSAgKi9cbnZhciBTVEFURV9QRU5ESU5HICAgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMV0gICovXG52YXIgU1RBVEVfRlVMRklMTEVEID0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjJdICAqL1xudmFyIFNUQVRFX1JFSkVDVEVEICA9IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4zXSAgKi9cblxuLyogIHByb21pc2Ugb2JqZWN0IGNvbnN0cnVjdG9yICAqL1xudmFyIGFwaSA9IGZ1bmN0aW9uIChleGVjdXRvcikge1xuICAvKiAgb3B0aW9uYWxseSBzdXBwb3J0IG5vbi1jb25zdHJ1Y3Rvci9wbGFpbi1mdW5jdGlvbiBjYWxsICAqL1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYXBpKSlcbiAgICByZXR1cm4gbmV3IGFwaShleGVjdXRvcik7XG5cbiAgLyogIGluaXRpYWxpemUgb2JqZWN0ICAqL1xuICB0aGlzLmlkICAgICAgICAgICA9IFwiVGhlbmFibGUvMS4wLjdcIjtcbiAgdGhpcy5zdGF0ZSAgICAgICAgPSBTVEFURV9QRU5ESU5HOyAvKiAgaW5pdGlhbCBzdGF0ZSAgKi9cbiAgdGhpcy5mdWxmaWxsVmFsdWUgPSB1bmRlZmluZWQ7ICAgICAvKiAgaW5pdGlhbCB2YWx1ZSAgKi8gICAgIC8qICBbUHJvbWlzZXMvQSsgMS4zLCAyLjEuMi4yXSAgKi9cbiAgdGhpcy5yZWplY3RSZWFzb24gPSB1bmRlZmluZWQ7ICAgICAvKiAgaW5pdGlhbCByZWFzb24gKi8gICAgIC8qICBbUHJvbWlzZXMvQSsgMS41LCAyLjEuMy4yXSAgKi9cbiAgdGhpcy5vbkZ1bGZpbGxlZCAgPSBbXTsgICAgICAgICAgICAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cbiAgdGhpcy5vblJlamVjdGVkICAgPSBbXTsgICAgICAgICAgICAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cblxuICAvKiAgcHJvdmlkZSBvcHRpb25hbCBpbmZvcm1hdGlvbi1oaWRpbmcgcHJveHkgICovXG4gIHRoaXMucHJveHkgPSB7XG4gICAgdGhlbjogdGhpcy50aGVuLmJpbmQodGhpcylcbiAgfTtcblxuICAvKiAgc3VwcG9ydCBvcHRpb25hbCBleGVjdXRvciBmdW5jdGlvbiAgKi9cbiAgaWYgKHR5cGVvZiBleGVjdXRvciA9PT0gXCJmdW5jdGlvblwiKVxuICAgIGV4ZWN1dG9yLmNhbGwodGhpcywgdGhpcy5mdWxmaWxsLmJpbmQodGhpcyksIHRoaXMucmVqZWN0LmJpbmQodGhpcykpO1xufTtcblxuLyogIHByb21pc2UgQVBJIG1ldGhvZHMgICovXG5hcGkucHJvdG90eXBlID0ge1xuICAvKiAgcHJvbWlzZSByZXNvbHZpbmcgbWV0aG9kcyAgKi9cbiAgZnVsZmlsbDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX0ZVTEZJTExFRCwgXCJmdWxmaWxsVmFsdWVcIiwgdmFsdWUpOyB9LFxuICByZWplY3Q6ICBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGRlbGl2ZXIodGhpcywgU1RBVEVfUkVKRUNURUQsICBcInJlamVjdFJlYXNvblwiLCB2YWx1ZSk7IH0sXG5cbiAgLyogIFwiVGhlIHRoZW4gTWV0aG9kXCIgW1Byb21pc2VzL0ErIDEuMSwgMS4yLCAyLjJdICAqL1xuICB0aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgY3VyciA9IHRoaXM7XG4gICAgdmFyIG5leHQgPSBuZXcgYXBpKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuN10gICovXG4gICAgY3Vyci5vbkZ1bGZpbGxlZC5wdXNoKFxuICAgICAgcmVzb2x2ZXIob25GdWxmaWxsZWQsIG5leHQsIFwiZnVsZmlsbFwiKSk7ICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIvMi4yLjZdICAqL1xuICAgIGN1cnIub25SZWplY3RlZC5wdXNoKFxuICAgICAgcmVzb2x2ZXIob25SZWplY3RlZCwgIG5leHQsIFwicmVqZWN0XCIgKSk7ICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjMvMi4yLjZdICAqL1xuICAgIGV4ZWN1dGUoY3Vycik7XG4gICAgcmV0dXJuIG5leHQucHJveHk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNywgMy4zXSAgKi9cbiAgfVxufTtcblxuLyogIGRlbGl2ZXIgYW4gYWN0aW9uICAqL1xudmFyIGRlbGl2ZXIgPSBmdW5jdGlvbiAoY3Vyciwgc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9QRU5ESU5HKSB7XG4gICAgY3Vyci5zdGF0ZSA9IHN0YXRlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4xLCAyLjEuMy4xXSAgKi9cbiAgICBjdXJyW25hbWVdID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjIsIDIuMS4zLjJdICAqL1xuICAgIGV4ZWN1dGUoY3Vycik7XG4gIH1cbiAgcmV0dXJuIGN1cnI7XG59O1xuXG4vKiAgZXhlY3V0ZSBhbGwgaGFuZGxlcnMgICovXG52YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uIChjdXJyKSB7XG4gIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9GVUxGSUxMRUQpXG4gICAgZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCBcIm9uRnVsZmlsbGVkXCIsIGN1cnIuZnVsZmlsbFZhbHVlKTtcbiAgZWxzZSBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUkVKRUNURUQpXG4gICAgZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCBcIm9uUmVqZWN0ZWRcIiwgIGN1cnIucmVqZWN0UmVhc29uKTtcbn07XG5cbi8qICBleGVjdXRlIHBhcnRpY3VsYXIgc2V0IG9mIGhhbmRsZXJzICAqL1xudmFyIGV4ZWN1dGVfaGFuZGxlcnMgPSBmdW5jdGlvbiAoY3VyciwgbmFtZSwgdmFsdWUpIHtcbiAgLyogZ2xvYmFsIHNldEltbWVkaWF0ZTogdHJ1ZSAqL1xuICAvKiBnbG9iYWwgc2V0VGltZW91dDogdHJ1ZSAqL1xuXG4gIC8qICBzaG9ydC1jaXJjdWl0IHByb2Nlc3NpbmcgICovXG4gIGlmIChjdXJyW25hbWVdLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG5cbiAgLyogIGl0ZXJhdGUgb3ZlciBhbGwgaGFuZGxlcnMsIGV4YWN0bHkgb25jZSAgKi9cbiAgdmFyIGhhbmRsZXJzID0gY3VycltuYW1lXTtcbiAgY3VycltuYW1lXSA9IFtdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMywgMi4yLjMuM10gICovXG4gIHZhciBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspXG4gICAgICBoYW5kbGVyc1tpXSh2YWx1ZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjVdICAqL1xuICB9O1xuXG4gIC8qICBleGVjdXRlIHByb2NlZHVyZSBhc3luY2hyb25vdXNseSAgKi8gICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi40LCAzLjFdICAqL1xuICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgIHNldEltbWVkaWF0ZShmdW5jKTtcbiAgZWxzZVxuICAgIHNldFRpbWVvdXQoZnVuYywgMCk7XG59O1xuXG4vKiAgZ2VuZXJhdGUgYSByZXNvbHZlciBmdW5jdGlvbiAgKi9cbnZhciByZXNvbHZlciA9IGZ1bmN0aW9uIChjYiwgbmV4dCwgbWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjEsIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgICAgbmV4dFttZXRob2RdLmNhbGwobmV4dCwgdmFsdWUpOyAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgIGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHRyeSB7IHJlc3VsdCA9IGNiKHZhbHVlKTsgfSAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi4xLCAyLjIuMy4xLCAyLjIuNSwgMy4yXSAgKi9cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIG5leHQucmVqZWN0KGUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjJdICAqL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKG5leHQsIHJlc3VsdCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMV0gICovXG4gICAgfVxuICB9O1xufTtcblxuLyogIFwiUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVwiICAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zXSAgKi9cbnZhciByZXNvbHZlID0gZnVuY3Rpb24gKHByb21pc2UsIHgpIHtcbiAgLyogIHNhbml0eSBjaGVjayBhcmd1bWVudHMgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjFdICAqL1xuICBpZiAocHJvbWlzZSA9PT0geCB8fCBwcm9taXNlLnByb3h5ID09PSB4KSB7XG4gICAgcHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihcImNhbm5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGZcIikpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qICBzdXJnaWNhbGx5IGNoZWNrIGZvciBhIFwidGhlblwiIG1ldGhvZFxuICAgIChtYWlubHkgdG8ganVzdCBjYWxsIHRoZSBcImdldHRlclwiIG9mIFwidGhlblwiIG9ubHkgb25jZSkgICovXG4gIHZhciB0aGVuO1xuICBpZiAoKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIHggIT09IG51bGwpIHx8IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0cnkgeyB0aGVuID0geC50aGVuOyB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjEsIDMuNV0gICovXG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHByb21pc2UucmVqZWN0KGUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4yXSAgKi9cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvKiAgaGFuZGxlIG93biBUaGVuYWJsZXMgICAgW1Byb21pc2VzL0ErIDIuMy4yXVxuICAgIGFuZCBzaW1pbGFyIFwidGhlbmFibGVzXCIgW1Byb21pc2VzL0ErIDIuMy4zXSAgKi9cbiAgaWYgKHR5cGVvZiB0aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgLyogIGNhbGwgcmV0cmlldmVkIFwidGhlblwiIG1ldGhvZCAqLyAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuM10gICovXG4gICAgICB0aGVuLmNhbGwoeCxcbiAgICAgICAgLyogIHJlc29sdmVQcm9taXNlICAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4xXSAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjsgcmVzb2x2ZWQgPSB0cnVlOyAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgICAgaWYgKHkgPT09IHgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAzLjZdICAqL1xuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihcImNpcmN1bGFyIHRoZW5hYmxlIGNoYWluXCIpKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXNvbHZlKHByb21pc2UsIHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qICByZWplY3RQcm9taXNlICAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMl0gICovXG4gICAgICAgIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm47IHJlc29sdmVkID0gdHJ1ZTsgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KHIpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFyZXNvbHZlZCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgIHByb21pc2UucmVqZWN0KGUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuNF0gICovXG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qICBoYW5kbGUgb3RoZXIgdmFsdWVzICAqL1xuICBwcm9taXNlLmZ1bGZpbGwoeCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuNCwgMi4zLjMuNF0gICovXG59O1xuXG4vLyB1c2UgbmF0aXZlIHByb21pc2VzIHdoZXJlIHBvc3NpYmxlXG52YXIgUHJvbWlzZSA9IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IGFwaSA6IFByb21pc2U7XG5cbi8vIHNvIHdlIGFsd2F5cyBoYXZlIFByb21pc2UuYWxsKClcblByb21pc2UuYWxsID0gUHJvbWlzZS5hbGwgfHwgZnVuY3Rpb24oIHBzICl7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiggcmVzb2x2ZUFsbCwgcmVqZWN0QWxsICl7XG4gICAgdmFyIHZhbHMgPSBuZXcgQXJyYXkoIHBzLmxlbmd0aCApO1xuICAgIHZhciBkb25lQ291bnQgPSAwO1xuXG4gICAgdmFyIGZ1bGZpbGwgPSBmdW5jdGlvbiggaSwgdmFsICl7XG4gICAgICB2YWxzW2ldID0gdmFsO1xuICAgICAgZG9uZUNvdW50Kys7XG5cbiAgICAgIGlmKCBkb25lQ291bnQgPT09IHBzLmxlbmd0aCApe1xuICAgICAgICByZXNvbHZlQWxsKCB2YWxzICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIChmdW5jdGlvbiggaSApe1xuICAgICAgICB2YXIgcCA9IHBzW2ldO1xuICAgICAgICB2YXIgaXNQcm9taXNlID0gcC50aGVuICE9IG51bGw7XG5cbiAgICAgICAgaWYoIGlzUHJvbWlzZSApe1xuICAgICAgICAgIHAudGhlbihmdW5jdGlvbiggdmFsICl7XG4gICAgICAgICAgICBmdWxmaWxsKCBpLCB2YWwgKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiggZXJyICl7XG4gICAgICAgICAgICByZWplY3RBbGwoIGVyciApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2YWwgPSBwO1xuICAgICAgICAgIGZ1bGZpbGwoIGksIHZhbCApO1xuICAgICAgICB9XG4gICAgICB9KSggaSApO1xuICAgIH1cblxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxufSx7fV0sODE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuL2lzJyk7XG52YXIgdXRpbCA9IF9kZXJlcV8oJy4vdXRpbCcpO1xuXG52YXIgU2VsZWN0b3IgPSBmdW5jdGlvbiggb25seVRoaXNHcm91cCwgc2VsZWN0b3IgKXtcblxuICBpZiggISh0aGlzIGluc3RhbmNlb2YgU2VsZWN0b3IpICl7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rvcihvbmx5VGhpc0dyb3VwLCBzZWxlY3Rvcik7XG4gIH1cblxuICBpZiggc2VsZWN0b3IgPT09IHVuZGVmaW5lZCAmJiBvbmx5VGhpc0dyb3VwICE9PSB1bmRlZmluZWQgKXtcbiAgICBzZWxlY3RvciA9IG9ubHlUaGlzR3JvdXA7XG4gICAgb25seVRoaXNHcm91cCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBzZWxmLl9wcml2YXRlID0ge1xuICAgIHNlbGVjdG9yVGV4dDogbnVsbCxcbiAgICBpbnZhbGlkOiB0cnVlXG4gIH07XG5cbiAgaWYoICFzZWxlY3RvciB8fCAoIGlzLnN0cmluZyhzZWxlY3RvcikgJiYgc2VsZWN0b3IubWF0Y2goL15cXHMqJC8pICkgKXtcblxuICAgIGlmKCBvbmx5VGhpc0dyb3VwID09IG51bGwgKXtcbiAgICAgIC8vIGlnbm9yZVxuICAgICAgc2VsZi5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICAgIHNlbGZbMF0uZ3JvdXAgPSBvbmx5VGhpc0dyb3VwO1xuICAgICAgc2VsZi5sZW5ndGggPSAxO1xuICAgIH1cblxuICB9IGVsc2UgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIHNlbGVjdG9yICkgKXtcbiAgICB2YXIgY29sbGVjdGlvbiA9IHNlbGVjdG9yLmNvbGxlY3Rpb24oKTtcblxuICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgIHNlbGZbMF0uY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgc2VsZi5sZW5ndGggPSAxO1xuXG4gIH0gZWxzZSBpZiggaXMuZm4oIHNlbGVjdG9yICkgKSB7XG4gICAgc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gICAgc2VsZlswXS5maWx0ZXIgPSBzZWxlY3RvcjtcbiAgICBzZWxmLmxlbmd0aCA9IDE7XG5cbiAgfSBlbHNlIGlmKCBpcy5zdHJpbmcoIHNlbGVjdG9yICkgKXtcblxuICAgIC8vIHRoZSBjdXJyZW50IHN1YmplY3QgaW4gdGhlIHF1ZXJ5XG4gICAgdmFyIGN1cnJlbnRTdWJqZWN0ID0gbnVsbDtcblxuICAgIC8vIHN0b3JhZ2UgZm9yIHBhcnNlZCBxdWVyaWVzXG4gICAgdmFyIG5ld1F1ZXJ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsYXNzZXM6IFtdLFxuICAgICAgICBjb2xvblNlbGVjdG9yczogW10sXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBncm91cDogbnVsbCxcbiAgICAgICAgaWRzOiBbXSxcbiAgICAgICAgbWV0YTogW10sXG5cbiAgICAgICAgLy8gZmFrZSBzZWxlY3RvcnNcbiAgICAgICAgY29sbGVjdGlvbjogbnVsbCwgLy8gYSBjb2xsZWN0aW9uIHRvIG1hdGNoIGFnYWluc3RcbiAgICAgICAgZmlsdGVyOiBudWxsLCAvLyBmaWx0ZXIgZnVuY3Rpb25cblxuICAgICAgICAvLyB0aGVzZSBhcmUgZGVmaW5lZCBpbiB0aGUgdXB3YXJkIGRpcmVjdGlvbiByYXRoZXIgdGhhbiBkb3duIChlLmcuIGNoaWxkKVxuICAgICAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gZ28gdXAgaW4gU2VsZWN0b3IuZmlsdGVyKClcbiAgICAgICAgcGFyZW50OiBudWxsLCAvLyBwYXJlbnQgcXVlcnkgb2JqXG4gICAgICAgIGFuY2VzdG9yOiBudWxsLCAvLyBhbmNlc3RvciBxdWVyeSBvYmpcbiAgICAgICAgc3ViamVjdDogbnVsbCwgLy8gZGVmaW5lcyBzdWJqZWN0IGluIGNvbXBvdW5kIHF1ZXJ5IChzdWJqZWN0IHF1ZXJ5IG9iajsgcG9pbnRzIHRvIHNlbGYgaWYgc3ViamVjdClcblxuICAgICAgICAvLyB1c2UgdGhlc2Ugb25seSB3aGVuIHN1YmplY3QgaGFzIGJlZW4gZGVmaW5lZFxuICAgICAgICBjaGlsZDogbnVsbCxcbiAgICAgICAgZGVzY2VuZGFudDogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gdG9rZW5zIGluIHRoZSBxdWVyeSBsYW5ndWFnZVxuICAgIHZhciB0b2tlbnMgPSB7XG4gICAgICBtZXRhQ2hhcjogJ1tcXFxcIVxcXFxcIlxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLlxcXFwvXFxcXDpcXFxcO1xcXFw8XFxcXD1cXFxcPlxcXFw/XFxcXEBcXFxcW1xcXFxdXFxcXF5cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XScsIC8vIGNoYXJzIHdlIG5lZWQgdG8gZXNjYXBlIGluIHZhciBuYW1lcywgZXRjXG4gICAgICBjb21wYXJhdG9yT3A6ICc9fFxcXFwhPXw+fD49fDx8PD18XFxcXCQ9fFxcXFxePXxcXFxcKj0nLCAvLyBiaW5hcnkgY29tcGFyaXNvbiBvcCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgICAgIGJvb2xPcDogJ1xcXFw/fFxcXFwhfFxcXFxeJywgLy8gYm9vbGVhbiAodW5hcnkpIG9wZXJhdG9ycyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgICAgIHN0cmluZzogJ1wiKD86XFxcXFxcXFxcInxbXlwiXSkrXCInICsgJ3wnICsgXCInKD86XFxcXFxcXFwnfFteJ10pKydcIiwgLy8gc3RyaW5nIGxpdGVyYWxzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLSBkb3VibGVxdW90ZXMgfCBzaW5nbGVxdW90ZXNcbiAgICAgIG51bWJlcjogdXRpbC5yZWdleC5udW1iZXIsIC8vIG51bWJlciBsaXRlcmFsICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLS0gZS5nLiAwLjEyMzQsIDEyMzQsIDEyZTEyM1xuICAgICAgbWV0YTogJ2RlZ3JlZXxpbmRlZ3JlZXxvdXRkZWdyZWUnLCAvLyBhbGxvd2VkIG1ldGFkYXRhIGZpZWxkcyAoaS5lLiBhbGxvd2VkIGZ1bmN0aW9ucyB0byB1c2UgZnJvbSBDb2xsZWN0aW9uKVxuICAgICAgc2VwYXJhdG9yOiAnXFxcXHMqLFxcXFxzKicsIC8vIHF1ZXJpZXMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMsIGUuZy4gZWRnZVtmb28gPSAnYmFyJ10sIG5vZGUuc29tZUNsYXNzXG4gICAgICBkZXNjZW5kYW50OiAnXFxcXHMrJyxcbiAgICAgIGNoaWxkOiAnXFxcXHMrPlxcXFxzKycsXG4gICAgICBzdWJqZWN0OiAnXFxcXCQnXG4gICAgfTtcbiAgICB0b2tlbnMudmFyaWFibGUgPSAnKD86W1xcXFx3LV18KD86XFxcXFxcXFwnKyB0b2tlbnMubWV0YUNoYXIgKycpKSsnOyAvLyBhIHZhcmlhYmxlIG5hbWVcbiAgICB0b2tlbnMudmFsdWUgPSB0b2tlbnMuc3RyaW5nICsgJ3wnICsgdG9rZW5zLm51bWJlcjsgLy8gYSB2YWx1ZSBsaXRlcmFsLCBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgdG9rZW5zLmNsYXNzTmFtZSA9IHRva2Vucy52YXJpYWJsZTsgLy8gYSBjbGFzcyBuYW1lIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuICAgIHRva2Vucy5pZCA9IHRva2Vucy52YXJpYWJsZTsgLy8gYW4gZWxlbWVudCBpZCAoZm9sbG93cyB2YXJpYWJsZSBjb252ZW50aW9ucylcblxuICAgIC8vIHdoZW4gYSB0b2tlbiBsaWtlIGEgdmFyaWFibGUgaGFzIGVzY2FwZWQgbWV0YSBjaGFyYWN0ZXJzLCB3ZSBuZWVkIHRvIGNsZWFuIHRoZSBiYWNrc2xhc2hlcyBvdXRcbiAgICAvLyBzbyB0aGF0IHZhbHVlcyBnZXQgY29tcGFyZWQgcHJvcGVybHkgaW4gU2VsZWN0b3IuZmlsdGVyKClcbiAgICB2YXIgY2xlYW5NZXRhQ2hhcnMgPSBmdW5jdGlvbihzdHIpe1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxcXFxcKCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKScsICdnJyksIGZ1bmN0aW9uKG1hdGNoLCAkMSwgb2Zmc2V0LCBvcmlnaW5hbCl7XG4gICAgICAgIHJldHVybiAkMTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBhZGQgQCB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcbiAgICB2YXIgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCgnfCcpO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgb3AgPSBvcHNbaV07XG4gICAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8QCcgKyBvcDtcbiAgICB9XG5cbiAgICAvLyBhZGQgISB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcbiAgICB2YXIgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCgnfCcpO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgb3AgPSBvcHNbaV07XG5cbiAgICAgIGlmKCBvcC5pbmRleE9mKCchJykgPj0gMCApeyBjb250aW51ZTsgfSAvLyBza2lwIG9wcyB0aGF0IGV4cGxpY2l0bHkgY29udGFpbiAhXG4gICAgICBpZiggb3AgPT09ICc9JyApeyBjb250aW51ZTsgfSAvLyBza2lwID0gYi9jICE9IGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuXG4gICAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8XFxcXCEnICsgb3A7XG4gICAgfVxuXG4gICAgLy8gTk9URTogYWRkIG5ldyBleHByZXNzaW9uIHN5bnRheCBoZXJlIHRvIGhhdmUgaXQgcmVjb2duaXNlZCBieSB0aGUgcGFyc2VyO1xuICAgIC8vIC0gYSBxdWVyeSBjb250YWlucyBhbGwgYWRqYWNlbnQgKGkuZS4gbm8gc2VwYXJhdG9yIGluIGJldHdlZW4pIGV4cHJlc3Npb25zO1xuICAgIC8vIC0gdGhlIGN1cnJlbnQgcXVlcnkgaXMgc3RvcmVkIGluIHNlbGZbaV0gLS0tIHlvdSBjYW4gdXNlIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgIGluIHRoZSBwb3B1bGF0ZSBmdW5jdGlvbjtcbiAgICAvLyAtIHlvdSBuZWVkIHRvIGNoZWNrIHRoZSBxdWVyeSBvYmplY3RzIGluIFNlbGVjdG9yLmZpbHRlcigpIGZvciBpdCBhY3R1YWxseSBmaWx0ZXIgcHJvcGVybHksIGJ1dCB0aGF0J3MgcHJldHR5IHN0cmFpZ2h0IGZvcndhcmRcbiAgICAvLyAtIHdoZW4geW91IGFkZCBzb21ldGhpbmcgaGVyZSwgYWxzbyBhZGQgdG8gU2VsZWN0b3IudG9TdHJpbmcoKVxuICAgIHZhciBleHBycyA9IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2dyb3VwJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiAnKG5vZGV8ZWRnZXxcXFxcKiknLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIGdyb3VwICl7XG4gICAgICAgICAgdGhpcy5ncm91cCA9IGdyb3VwID09IFwiKlwiID8gZ3JvdXAgOiBncm91cCArICdzJztcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc3RhdGUnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgLy8gTkI6IGlmIG9uZSBjb2xvbiBzZWxlY3RvciBpcyBhIHN1YnN0cmluZyBvZiBhbm90aGVyIGZyb20gaXRzIHN0YXJ0LCBwbGFjZSB0aGUgbG9uZ2VyIG9uZSBmaXJzdFxuICAgICAgICAvLyBlLmcuIDpmb29iYXJ8OmZvb1xuICAgICAgICByZWdleDogJyg6c2VsZWN0ZWR8OnVuc2VsZWN0ZWR8OmxvY2tlZHw6dW5sb2NrZWR8OnZpc2libGV8OmhpZGRlbnw6dHJhbnNwYXJlbnR8OmdyYWJiZWR8OmZyZWV8OnJlbW92ZWR8Omluc2lkZXw6Z3JhYmJhYmxlfDp1bmdyYWJiYWJsZXw6YW5pbWF0ZWR8OnVuYW5pbWF0ZWR8OnNlbGVjdGFibGV8OnVuc2VsZWN0YWJsZXw6b3JwaGFufDpub25vcnBoYW58OnBhcmVudHw6Y2hpbGR8Omxvb3B8OnNpbXBsZXw6YWN0aXZlfDppbmFjdGl2ZXw6dG91Y2h8OmJhY2tncm91bmRpbmd8Om5vbmJhY2tncm91bmRpbmcpJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBzdGF0ZSApe1xuICAgICAgICAgIHRoaXMuY29sb25TZWxlY3RvcnMucHVzaCggc3RhdGUgKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaWQnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgcmVnZXg6ICdcXFxcIygnKyB0b2tlbnMuaWQgKycpJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBpZCApe1xuICAgICAgICAgIHRoaXMuaWRzLnB1c2goIGNsZWFuTWV0YUNoYXJzKGlkKSApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGFzc05hbWUnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgcmVnZXg6ICdcXFxcLignKyB0b2tlbnMuY2xhc3NOYW1lICsnKScsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggY2xhc3NOYW1lICl7XG4gICAgICAgICAgdGhpcy5jbGFzc2VzLnB1c2goIGNsZWFuTWV0YUNoYXJzKGNsYXNzTmFtZSkgKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnZGF0YUV4aXN0cycsXG4gICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcrIHRva2Vucy52YXJpYWJsZSArJylcXFxccypcXFxcXScsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggdmFyaWFibGUgKXtcbiAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XG4gICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2RhdGFDb21wYXJlJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJysgdG9rZW5zLnZhcmlhYmxlICsnKVxcXFxzKignKyB0b2tlbnMuY29tcGFyYXRvck9wICsnKVxcXFxzKignKyB0b2tlbnMudmFsdWUgKycpXFxcXHMqXFxcXF0nLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIHZhcmlhYmxlLCBjb21wYXJhdG9yT3AsIHZhbHVlICl7XG4gICAgICAgICAgdmFyIHZhbHVlSXNTdHJpbmcgPSBuZXcgUmVnRXhwKCdeJyArIHRva2Vucy5zdHJpbmcgKyAnJCcpLmV4ZWModmFsdWUpICE9IG51bGw7XG5cbiAgICAgICAgICBpZiggdmFsdWVJc1N0cmluZyApe1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kYXRhLnB1c2goe1xuICAgICAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnZGF0YUJvb2wnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgcmVnZXg6ICdcXFxcW1xcXFxzKignKyB0b2tlbnMuYm9vbE9wICsnKVxcXFxzKignKyB0b2tlbnMudmFyaWFibGUgKycpXFxcXHMqXFxcXF0nLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIGJvb2xPcCwgdmFyaWFibGUgKXtcbiAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XG4gICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgICAgICAgb3BlcmF0b3I6IGJvb2xPcFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdtZXRhQ29tcGFyZScsXG4gICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICByZWdleDogJ1xcXFxbXFxcXFtcXFxccyooJysgdG9rZW5zLm1ldGEgKycpXFxcXHMqKCcrIHRva2Vucy5jb21wYXJhdG9yT3AgKycpXFxcXHMqKCcrIHRva2Vucy5udW1iZXIgKycpXFxcXHMqXFxcXF1cXFxcXScsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggbWV0YSwgY29tcGFyYXRvck9wLCBudW1iZXIgKXtcbiAgICAgICAgICB0aGlzLm1ldGEucHVzaCh7XG4gICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnMobWV0YSksXG4gICAgICAgICAgICBvcGVyYXRvcjogY29tcGFyYXRvck9wLFxuICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICduZXh0UXVlcnknLFxuICAgICAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgICAgIHJlZ2V4OiB0b2tlbnMuc2VwYXJhdG9yLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAvLyBnbyBvbiB0byBuZXh0IHF1ZXJ5XG4gICAgICAgICAgc2VsZlsrK2ldID0gbmV3UXVlcnkoKTtcbiAgICAgICAgICBjdXJyZW50U3ViamVjdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NoaWxkJyxcbiAgICAgICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgICAgICByZWdleDogdG9rZW5zLmNoaWxkLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAvLyB0aGlzIHF1ZXJ5IGlzIHRoZSBwYXJlbnQgb2YgdGhlIGZvbGxvd2luZyBxdWVyeVxuICAgICAgICAgIHZhciBjaGlsZFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgICBjaGlsZFF1ZXJ5LnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgY2hpbGRRdWVyeS5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG5cbiAgICAgICAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgICAgICAgIHNlbGZbaV0gPSBjaGlsZFF1ZXJ5O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdkZXNjZW5kYW50JyxcbiAgICAgICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgICAgICByZWdleDogdG9rZW5zLmRlc2NlbmRhbnQsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgIC8vIHRoaXMgcXVlcnkgaXMgdGhlIGFuY2VzdG9yIG9mIHRoZSBmb2xsb3dpbmcgcXVlcnlcbiAgICAgICAgICB2YXIgZGVzY2VuZGFudFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgICBkZXNjZW5kYW50UXVlcnkuYW5jZXN0b3IgPSB0aGlzO1xuICAgICAgICAgIGRlc2NlbmRhbnRRdWVyeS5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG5cbiAgICAgICAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgZGVzY2VuZGFudCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgICAgICAgc2VsZltpXSA9IGRlc2NlbmRhbnRRdWVyeTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc3ViamVjdCcsXG4gICAgICAgIG1vZGlmaWVyOiB0cnVlLFxuICAgICAgICByZWdleDogdG9rZW5zLnN1YmplY3QsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgIGlmKCBjdXJyZW50U3ViamVjdCAhPSBudWxsICYmIHRoaXMuc3ViamVjdCAhPSB0aGlzICl7XG4gICAgICAgICAgICB1dGlsLmVycm9yKCdSZWRlZmluaXRpb24gb2Ygc3ViamVjdCBpbiBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50U3ViamVjdCA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5zdWJqZWN0ID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgXTtcblxuICAgIHNlbGYuX3ByaXZhdGUuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgdmFyIHJlbWFpbmluZyA9IHNlbGVjdG9yO1xuICAgIHZhciBpID0gMDtcblxuICAgIC8vIG9mIGFsbCB0aGUgZXhwcmVzc2lvbnMsIGZpbmQgdGhlIGZpcnN0IG1hdGNoIGluIHRoZSByZW1haW5pbmcgdGV4dFxuICAgIHZhciBjb25zdW1lRXhwciA9IGZ1bmN0aW9uKCBleHBlY3RhdGlvbiApe1xuICAgICAgdmFyIGV4cHI7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB2YXIgbmFtZTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBleHBycy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgZSA9IGV4cHJzW2pdO1xuICAgICAgICB2YXIgbiA9IGUubmFtZTtcblxuICAgICAgICAvLyBpZ25vcmUgdGhpcyBleHByZXNzaW9uIGlmIGl0IGRvZXNuJ3QgbWVldCB0aGUgZXhwZWN0YXRpb24gZnVuY3Rpb25cbiAgICAgICAgaWYoIGlzLmZuKCBleHBlY3RhdGlvbiApICYmICFleHBlY3RhdGlvbihuLCBlKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBtID0gcmVtYWluaW5nLm1hdGNoKG5ldyBSZWdFeHAoICdeJyArIGUucmVnZXggKSk7XG5cbiAgICAgICAgaWYoIG0gIT0gbnVsbCApe1xuICAgICAgICAgIG1hdGNoID0gbTtcbiAgICAgICAgICBleHByID0gZTtcbiAgICAgICAgICBuYW1lID0gbjtcblxuICAgICAgICAgIHZhciBjb25zdW1lZCA9IG1bMF07XG4gICAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggY29uc3VtZWQubGVuZ3RoICk7XG5cbiAgICAgICAgICBicmVhazsgLy8gd2UndmUgY29uc3VtZWQgb25lIGV4cHIsIHNvIHdlIGNhbiByZXR1cm4gbm93XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwcjogZXhwcixcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBjb25zdW1lIGFsbCBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICB2YXIgY29uc3VtZVdoaXRlc3BhY2UgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIG1hdGNoID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKy8pO1xuXG4gICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgdmFyIGNvbnN1bWVkID0gbWF0Y2hbMF07XG4gICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGNvbnN1bWVkLmxlbmd0aCApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTsgLy8gZ2V0IHN0YXJ0ZWRcblxuICAgIGNvbnN1bWVXaGl0ZXNwYWNlKCk7IC8vIGdldCByaWQgb2YgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgZm9yKDs7KXtcbiAgICAgIHZhciBjaGVjayA9IGNvbnN1bWVFeHByKCk7XG5cbiAgICAgIGlmKCBjaGVjay5leHByID09IG51bGwgKXtcbiAgICAgICAgdXRpbC5lcnJvcignVGhlIHNlbGVjdG9yIGAnKyBzZWxlY3RvciArJ2BpcyBpbnZhbGlkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvcih2YXIgaiA9IDE7IGogPCBjaGVjay5tYXRjaC5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgYXJncy5wdXNoKCBjaGVjay5tYXRjaFtqXSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0IHRoZSB0b2tlbiBwb3B1bGF0ZSB0aGUgc2VsZWN0b3Igb2JqZWN0IChpLmUuIGluIHNlbGZbaV0pXG4gICAgICAgIHZhciByZXQgPSBjaGVjay5leHByLnBvcHVsYXRlLmFwcGx5KCBzZWxmW2ldLCBhcmdzICk7XG5cbiAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXsgcmV0dXJuOyB9IC8vIGV4aXQgaWYgcG9wdWxhdGlvbiBmYWlsZWRcbiAgICAgIH1cblxuICAgICAgLy8gd2UncmUgZG9uZSB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHBhcnNlXG4gICAgICBpZiggcmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKSApe1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLmxlbmd0aCA9IGkgKyAxO1xuXG4gICAgLy8gYWRqdXN0IHJlZmVyZW5jZXMgZm9yIHN1YmplY3RcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyl7XG4gICAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuXG4gICAgICBpZiggcXVlcnkuc3ViamVjdCAhPSBudWxsICl7XG4gICAgICAgIC8vIGdvIHVwIHRoZSB0cmVlIHVudGlsIHdlIHJlYWNoIHRoZSBzdWJqZWN0XG4gICAgICAgIGZvcig7Oyl7XG4gICAgICAgICAgaWYoIHF1ZXJ5LnN1YmplY3QgPT0gcXVlcnkgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiBzdWJqZWN0IGlzIHNlbGZcblxuICAgICAgICAgIGlmKCBxdWVyeS5wYXJlbnQgIT0gbnVsbCApeyAvLyBzd2FwIHBhcmVudC9jaGlsZCByZWZlcmVuY2VcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBxdWVyeS5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBxdWVyeTtcblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZCA9IGNoaWxkO1xuXG4gICAgICAgICAgICBxdWVyeSA9IHBhcmVudDsgLy8gZ28gdXAgdGhlIHRyZWVcbiAgICAgICAgICB9IGVsc2UgaWYoIHF1ZXJ5LmFuY2VzdG9yICE9IG51bGwgKXsgLy8gc3dhcCBhbmNlc3Rvci9kZXNjZW5kYW50XG4gICAgICAgICAgICB2YXIgYW5jZXN0b3IgPSBxdWVyeS5hbmNlc3RvcjtcbiAgICAgICAgICAgIHZhciBkZXNjZW5kYW50ID0gcXVlcnk7XG5cbiAgICAgICAgICAgIGRlc2NlbmRhbnQuYW5jZXN0b3IgPSBudWxsO1xuICAgICAgICAgICAgYW5jZXN0b3IuZGVzY2VuZGFudCA9IGRlc2NlbmRhbnQ7XG5cbiAgICAgICAgICAgIHF1ZXJ5ID0gYW5jZXN0b3I7IC8vIGdvIHVwIHRoZSB0cmVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0aWwuZXJyb3IoJ1doZW4gYWRqdXN0aW5nIHJlZmVyZW5jZXMgZm9yIHRoZSBzZWxlY3RvciBgJysgcXVlcnkgKydgLCBuZWl0aGVyIHBhcmVudCBub3IgYW5jZXN0b3Igd2FzIGZvdW5kJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZm9yXG5cbiAgICAgICAgc2VsZltqXSA9IHF1ZXJ5LnN1YmplY3Q7IC8vIHN1YmplY3Qgc2hvdWxkIGJlIHRoZSByb290IHF1ZXJ5XG4gICAgICB9IC8vIGlmXG4gICAgfSAvLyBmb3JcblxuICAgIC8vIG1ha2Ugc3VyZSBmb3IgZWFjaCBxdWVyeSB0aGF0IHRoZSBzdWJqZWN0IGdyb3VwIG1hdGNoZXMgdGhlIGltcGxpY2l0IGdyb3VwIGlmIGFueVxuICAgIGlmKCBvbmx5VGhpc0dyb3VwICE9IG51bGwgKXtcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKXtcbiAgICAgICAgaWYoIHNlbGZbal0uZ3JvdXAgIT0gbnVsbCAmJiBzZWxmW2pdLmdyb3VwICE9IG9ubHlUaGlzR3JvdXAgKXtcbiAgICAgICAgICB1dGlsLmVycm9yKCdHcm91cCBgJysgc2VsZltqXS5ncm91cCArJ2AgY29uZmxpY3RzIHdpdGggaW1wbGljaXQgZ3JvdXAgYCcrIG9ubHlUaGlzR3JvdXAgKydgIGluIHNlbGVjdG9yIGAnKyBzZWxlY3RvciArJ2AnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmW2pdLmdyb3VwID0gb25seVRoaXNHcm91cDsgLy8gc2V0IHRvIGltcGxpY2l0IGdyb3VwXG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdXRpbC5lcnJvcignQSBzZWxlY3RvciBtdXN0IGJlIGNyZWF0ZWQgZnJvbSBhIHN0cmluZzsgZm91bmQgJyArIHNlbGVjdG9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZWxmLl9wcml2YXRlLmludmFsaWQgPSBmYWxzZTtcblxufTtcblxudmFyIHNlbGZuID0gU2VsZWN0b3IucHJvdG90eXBlO1xuXG5zZWxmbi5zaXplID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuc2VsZm4uZXEgPSBmdW5jdGlvbihpKXtcbiAgcmV0dXJuIHRoaXNbaV07XG59O1xuXG52YXIgcXVlcnlNYXRjaGVzID0gZnVuY3Rpb24ocXVlcnksIGVsZW1lbnQpe1xuICAvLyBjaGVjayBncm91cFxuICBpZiggcXVlcnkuZ3JvdXAgIT0gbnVsbCAmJiBxdWVyeS5ncm91cCAhPSAnKicgJiYgcXVlcnkuZ3JvdXAgIT0gZWxlbWVudC5fcHJpdmF0ZS5ncm91cCApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjeSA9IGVsZW1lbnQuY3koKTtcblxuICAvLyBjaGVjayBjb2xvbiBzZWxlY3RvcnNcbiAgdmFyIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSB0cnVlO1xuICBmb3IodmFyIGsgPSAwOyBrIDwgcXVlcnkuY29sb25TZWxlY3RvcnMubGVuZ3RoOyBrKyspe1xuICAgIHZhciBzZWwgPSBxdWVyeS5jb2xvblNlbGVjdG9yc1trXTtcblxuICAgIHN3aXRjaChzZWwpe1xuICAgIGNhc2UgJzpzZWxlY3RlZCc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5zZWxlY3RlZCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOnVuc2VsZWN0ZWQnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LnNlbGVjdGVkKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6c2VsZWN0YWJsZSc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5zZWxlY3RhYmxlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6dW5zZWxlY3RhYmxlJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5zZWxlY3RhYmxlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6bG9ja2VkJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmxvY2tlZCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOnVubG9ja2VkJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5sb2NrZWQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzp2aXNpYmxlJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnZpc2libGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzpoaWRkZW4nOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LnZpc2libGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzp0cmFuc3BhcmVudCc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC50cmFuc3BhcmVudCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOmdyYWJiZWQnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuZ3JhYmJlZCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOmZyZWUnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LmdyYWJiZWQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzpyZW1vdmVkJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnJlbW92ZWQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzppbnNpZGUnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LnJlbW92ZWQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzpncmFiYmFibGUnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuZ3JhYmJhYmxlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6dW5ncmFiYmFibGUnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LmdyYWJiYWJsZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOmFuaW1hdGVkJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmFuaW1hdGVkKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6dW5hbmltYXRlZCc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuYW5pbWF0ZWQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzpwYXJlbnQnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuaXNOb2RlKCkgJiYgZWxlbWVudC5jaGlsZHJlbigpLm5vbmVtcHR5KCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6Y2hpbGQnOlxuICAgIGNhc2UgJzpub25vcnBoYW4nOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuaXNOb2RlKCkgJiYgZWxlbWVudC5wYXJlbnQoKS5ub25lbXB0eSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOm9ycGhhbic6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc05vZGUoKSAmJiBlbGVtZW50LnBhcmVudCgpLmVtcHR5KCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6bG9vcCc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc0VkZ2UoKSAmJiBlbGVtZW50LmRhdGEoJ3NvdXJjZScpID09PSBlbGVtZW50LmRhdGEoJ3RhcmdldCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOnNpbXBsZSc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc0VkZ2UoKSAmJiBlbGVtZW50LmRhdGEoJ3NvdXJjZScpICE9PSBlbGVtZW50LmRhdGEoJ3RhcmdldCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOmFjdGl2ZSc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5hY3RpdmUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzppbmFjdGl2ZSc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuYWN0aXZlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6dG91Y2gnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGlzLnRvdWNoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6YmFja2dyb3VuZGluZyc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5iYWNrZ3JvdW5kaW5nKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6bm9uYmFja2dyb3VuZGluZyc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuYmFja2dyb3VuZGluZygpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYoICFhbGxDb2xvblNlbGVjdG9yc01hdGNoICkgYnJlYWs7XG4gIH1cbiAgaWYoICFhbGxDb2xvblNlbGVjdG9yc01hdGNoICkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGNoZWNrIGlkXG4gIHZhciBhbGxJZHNNYXRjaCA9IHRydWU7XG4gIGZvcih2YXIgayA9IDA7IGsgPCBxdWVyeS5pZHMubGVuZ3RoOyBrKyspe1xuICAgIHZhciBpZCA9IHF1ZXJ5Lmlkc1trXTtcbiAgICB2YXIgYWN0dWFsSWQgPSBlbGVtZW50Ll9wcml2YXRlLmRhdGEuaWQ7XG5cbiAgICBhbGxJZHNNYXRjaCA9IGFsbElkc01hdGNoICYmIChpZCA9PSBhY3R1YWxJZCk7XG5cbiAgICBpZiggIWFsbElkc01hdGNoICkgYnJlYWs7XG4gIH1cbiAgaWYoICFhbGxJZHNNYXRjaCApIHJldHVybiBmYWxzZTtcblxuICAvLyBjaGVjayBjbGFzc2VzXG4gIHZhciBhbGxDbGFzc2VzTWF0Y2ggPSB0cnVlO1xuICBmb3IodmFyIGsgPSAwOyBrIDwgcXVlcnkuY2xhc3Nlcy5sZW5ndGg7IGsrKyl7XG4gICAgdmFyIGNscyA9IHF1ZXJ5LmNsYXNzZXNba107XG5cbiAgICBhbGxDbGFzc2VzTWF0Y2ggPSBhbGxDbGFzc2VzTWF0Y2ggJiYgZWxlbWVudC5oYXNDbGFzcyhjbHMpO1xuXG4gICAgaWYoICFhbGxDbGFzc2VzTWF0Y2ggKSBicmVhaztcbiAgfVxuICBpZiggIWFsbENsYXNzZXNNYXRjaCApIHJldHVybiBmYWxzZTtcblxuICAvLyBnZW5lcmljIGNoZWNraW5nIGZvciBkYXRhL21ldGFkYXRhXG4gIHZhciBvcGVyYW5kc01hdGNoID0gZnVuY3Rpb24ocGFyYW1zKXtcbiAgICB2YXIgYWxsRGF0YU1hdGNoZXMgPSB0cnVlO1xuICAgIGZvcih2YXIgayA9IDA7IGsgPCBxdWVyeVtwYXJhbXMubmFtZV0ubGVuZ3RoOyBrKyspe1xuICAgICAgdmFyIGRhdGEgPSBxdWVyeVtwYXJhbXMubmFtZV1ba107XG4gICAgICB2YXIgb3BlcmF0b3IgPSBkYXRhLm9wZXJhdG9yO1xuICAgICAgdmFyIHZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgIHZhciBmaWVsZCA9IGRhdGEuZmllbGQ7XG4gICAgICB2YXIgbWF0Y2hlcztcblxuICAgICAgaWYoIG9wZXJhdG9yICE9IG51bGwgJiYgdmFsdWUgIT0gbnVsbCApe1xuXG4gICAgICAgIHZhciBmaWVsZFZhbCA9IHBhcmFtcy5maWVsZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgdmFyIGZpZWxkU3RyID0gIWlzLnN0cmluZyhmaWVsZFZhbCkgJiYgIWlzLm51bWJlcihmaWVsZFZhbCkgPyAnJyA6ICcnICsgZmllbGRWYWw7XG4gICAgICAgIHZhciB2YWxTdHIgPSAnJyArIHZhbHVlO1xuXG4gICAgICAgIHZhciBjYXNlSW5zZW5zaXRpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYoIG9wZXJhdG9yLmluZGV4T2YoJ0AnKSA+PSAwICl7XG4gICAgICAgICAgZmllbGRTdHIgPSBmaWVsZFN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHZhbFN0ciA9IHZhbFN0ci50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCdAJywgJycpO1xuICAgICAgICAgIGNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm90RXhwciA9IGZhbHNlO1xuICAgICAgICB2YXIgaGFuZGxlZE5vdEV4cHIgPSBmYWxzZTtcbiAgICAgICAgaWYoIG9wZXJhdG9yLmluZGV4T2YoJyEnKSA+PSAwICl7XG4gICAgICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCchJywgJycpO1xuICAgICAgICAgIG5vdEV4cHIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UncmUgZG9pbmcgYSBjYXNlIGluc2Vuc2l0aXZlIGNvbXBhcmlzb24sIHRoZW4gd2UncmUgdXNpbmcgYSBTVFJJTkcgY29tcGFyaXNvblxuICAgICAgICAvLyBldmVuIGlmIHdlJ3JlIGNvbXBhcmluZyBudW1iZXJzXG4gICAgICAgIGlmKCBjYXNlSW5zZW5zaXRpdmUgKXtcbiAgICAgICAgICB2YWx1ZSA9IHZhbFN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGZpZWxkVmFsID0gZmllbGRTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaChvcGVyYXRvcil7XG4gICAgICAgIGNhc2UgJyo9JzpcbiAgICAgICAgICBtYXRjaGVzID0gZmllbGRTdHIuc2VhcmNoKHZhbFN0cikgPj0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnJD0nOlxuICAgICAgICAgIG1hdGNoZXMgPSBuZXcgUmVnRXhwKHZhbFN0ciArICckJykuZXhlYyhmaWVsZFN0cikgIT0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXj0nOlxuICAgICAgICAgIG1hdGNoZXMgPSBuZXcgUmVnRXhwKCdeJyArIHZhbFN0cikuZXhlYyhmaWVsZFN0cikgIT0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID09PSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCAhPT0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIG1hdGNoZXMgPSAhbm90RXhwciA/IGZpZWxkVmFsID4gdmFsdWUgOiBmaWVsZFZhbCA8PSB2YWx1ZTtcbiAgICAgICAgICBoYW5kbGVkTm90RXhwciA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICBtYXRjaGVzID0gIW5vdEV4cHIgPyBmaWVsZFZhbCA+PSB2YWx1ZSA6IGZpZWxkVmFsIDwgdmFsdWU7XG4gICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBtYXRjaGVzID0gIW5vdEV4cHIgPyBmaWVsZFZhbCA8IHZhbHVlIDogZmllbGRWYWwgPj0gdmFsdWU7XG4gICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgbWF0Y2hlcyA9ICFub3RFeHByID8gZmllbGRWYWwgPD0gdmFsdWUgOiBmaWVsZFZhbCA+IHZhbHVlO1xuICAgICAgICAgIGhhbmRsZWROb3RFeHByID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBtYXRjaGVzID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKCBvcGVyYXRvciAhPSBudWxsICl7XG4gICAgICAgIHN3aXRjaChvcGVyYXRvcil7XG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgIG1hdGNoZXMgPSBwYXJhbXMuZmllbGRUcnV0aHkoZmllbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICBtYXRjaGVzID0gIXBhcmFtcy5maWVsZFRydXRoeShmaWVsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIG1hdGNoZXMgPSBwYXJhbXMuZmllbGRVbmRlZmluZWQoZmllbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaGVzID0gIXBhcmFtcy5maWVsZFVuZGVmaW5lZChmaWVsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBub3RFeHByICYmICFoYW5kbGVkTm90RXhwciApe1xuICAgICAgICBtYXRjaGVzID0gIW1hdGNoZXM7XG4gICAgICAgIGhhbmRsZWROb3RFeHByID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYoICFtYXRjaGVzICl7XG4gICAgICAgIGFsbERhdGFNYXRjaGVzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gZm9yXG5cbiAgICByZXR1cm4gYWxsRGF0YU1hdGNoZXM7XG4gIH07IC8vIG9wZXJhbmRzTWF0Y2hcblxuICAvLyBjaGVjayBkYXRhIG1hdGNoZXNcbiAgdmFyIGFsbERhdGFNYXRjaGVzID0gb3BlcmFuZHNNYXRjaCh7XG4gICAgbmFtZTogJ2RhdGEnLFxuICAgIGZpZWxkVmFsdWU6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgIHJldHVybiBlbGVtZW50Ll9wcml2YXRlLmRhdGFbZmllbGRdO1xuICAgIH0sXG4gICAgZmllbGRSZWY6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgIHJldHVybiAnZWxlbWVudC5fcHJpdmF0ZS5kYXRhLicgKyBmaWVsZDtcbiAgICB9LFxuICAgIGZpZWxkVW5kZWZpbmVkOiBmdW5jdGlvbihmaWVsZCl7XG4gICAgICByZXR1cm4gZWxlbWVudC5fcHJpdmF0ZS5kYXRhW2ZpZWxkXSA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZmllbGRUcnV0aHk6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgIGlmKCBlbGVtZW50Ll9wcml2YXRlLmRhdGFbZmllbGRdICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYoICFhbGxEYXRhTWF0Y2hlcyApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNoZWNrIG1ldGFkYXRhIG1hdGNoZXNcbiAgdmFyIGFsbE1ldGFNYXRjaGVzID0gb3BlcmFuZHNNYXRjaCh7XG4gICAgbmFtZTogJ21ldGEnLFxuICAgIGZpZWxkVmFsdWU6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgIHJldHVybiBlbGVtZW50W2ZpZWxkXSgpO1xuICAgIH0sXG4gICAgZmllbGRSZWY6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgIHJldHVybiAnZWxlbWVudC4nICsgZmllbGQgKyAnKCknO1xuICAgIH0sXG4gICAgZmllbGRVbmRlZmluZWQ6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgIHJldHVybiBlbGVtZW50W2ZpZWxkXSgpID09IG51bGw7XG4gICAgfSxcbiAgICBmaWVsZFRydXRoeTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgaWYoIGVsZW1lbnRbZmllbGRdKCkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICBpZiggIWFsbE1ldGFNYXRjaGVzICl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2hlY2sgY29sbGVjdGlvblxuICBpZiggcXVlcnkuY29sbGVjdGlvbiAhPSBudWxsICl7XG4gICAgdmFyIG1hdGNoZXNBbnkgPSBxdWVyeS5jb2xsZWN0aW9uLl9wcml2YXRlLmlkc1sgZWxlbWVudC5pZCgpIF0gIT0gbnVsbDtcblxuICAgIGlmKCAhbWF0Y2hlc0FueSApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGZpbHRlciBmdW5jdGlvblxuICBpZiggcXVlcnkuZmlsdGVyICE9IG51bGwgJiYgZWxlbWVudC5jb2xsZWN0aW9uKCkuZmlsdGVyKCBxdWVyeS5maWx0ZXIgKS5zaXplKCkgPT09IDAgKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXG4gIC8vIGNoZWNrIHBhcmVudC9jaGlsZCByZWxhdGlvbnNcbiAgdmFyIGNvbmZpcm1SZWxhdGlvbnMgPSBmdW5jdGlvbiggcXVlcnksIGVsZW1lbnRzICl7XG4gICAgaWYoIHF1ZXJ5ICE9IG51bGwgKXtcbiAgICAgIHZhciBtYXRjaGVzID0gZmFsc2U7XG5cbiAgICAgIGlmKCAhY3kuaGFzQ29tcG91bmROb2RlcygpICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudHMgPSBlbGVtZW50cygpOyAvLyBtYWtlIGVsZW1lbnRzIGZ1bmN0aW9uYWwgc28gd2Ugc2F2ZSBjeWNsZXMgaWYgcXVlcnkgPT0gbnVsbFxuXG4gICAgICAvLyBxdWVyeSBtdXN0IG1hdGNoIGZvciBhdCBsZWFzdCBvbmUgZWxlbWVudCAobWF5IGJlIHJlY3Vyc2l2ZSlcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmKCBxdWVyeU1hdGNoZXMoIHF1ZXJ5LCBlbGVtZW50c1tpXSApICl7XG4gICAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBpZiAoISBjb25maXJtUmVsYXRpb25zKHF1ZXJ5LnBhcmVudCwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZWxlbWVudC5wYXJlbnQoKTtcbiAgfSkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCEgY29uZmlybVJlbGF0aW9ucyhxdWVyeS5hbmNlc3RvciwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZWxlbWVudC5wYXJlbnRzKCk7XG4gIH0pICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghIGNvbmZpcm1SZWxhdGlvbnMocXVlcnkuY2hpbGQsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4oKTtcbiAgfSkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCEgY29uZmlybVJlbGF0aW9ucyhxdWVyeS5kZXNjZW5kYW50LCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBlbGVtZW50LmRlc2NlbmRhbnRzKCk7XG4gIH0pICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCwgc28gd2UndmUgbWF0Y2hlZCBldmVyeXRoaW5nIGZvciB0aGlzIHF1ZXJ5XG4gIHJldHVybiB0cnVlO1xufTsgLy8gcXVlcnlNYXRjaGVzXG5cbi8vIGZpbHRlciBhbiBleGlzdGluZyBjb2xsZWN0aW9uXG5zZWxmbi5maWx0ZXIgPSBmdW5jdGlvbihjb2xsZWN0aW9uKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3kgPSBjb2xsZWN0aW9uLmN5KCk7XG5cbiAgLy8gZG9uJ3QgYm90aGVyIHRyeWluZyBpZiBpdCdzIGludmFsaWRcbiAgaWYoIHNlbGYuX3ByaXZhdGUuaW52YWxpZCApe1xuICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCk7XG4gIH1cblxuICB2YXIgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGksIGVsZW1lbnQpe1xuICAgIGZvcih2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKXtcbiAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG5cbiAgICAgIGlmKCBxdWVyeU1hdGNoZXMocXVlcnksIGVsZW1lbnQpICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBpZiggc2VsZi5fcHJpdmF0ZS5zZWxlY3RvclRleHQgPT0gbnVsbCApe1xuICAgIHNlbGVjdG9yRnVuY3Rpb24gPSBmdW5jdGlvbigpeyByZXR1cm4gdHJ1ZTsgfTtcbiAgfVxuXG4gIHZhciBmaWx0ZXJlZENvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmZpbHRlciggc2VsZWN0b3JGdW5jdGlvbiApO1xuXG4gIHJldHVybiBmaWx0ZXJlZENvbGxlY3Rpb247XG59OyAvLyBmaWx0ZXJcblxuLy8gZG9lcyBzZWxlY3RvciBtYXRjaCBhIHNpbmdsZSBlbGVtZW50P1xuc2VsZm4ubWF0Y2hlcyA9IGZ1bmN0aW9uKGVsZSl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBkb24ndCBib3RoZXIgdHJ5aW5nIGlmIGl0J3MgaW52YWxpZFxuICBpZiggc2VsZi5fcHJpdmF0ZS5pbnZhbGlkICl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspe1xuICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG5cbiAgICBpZiggcXVlcnlNYXRjaGVzKHF1ZXJ5LCBlbGUpICl7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59OyAvLyBmaWx0ZXJcblxuLy8gaXRoIHF1ZXJ5IHRvIHN0cmluZ1xuc2VsZm4udG9TdHJpbmcgPSBzZWxmbi5zZWxlY3RvciA9IGZ1bmN0aW9uKCl7XG5cbiAgdmFyIHN0ciA9ICcnO1xuXG4gIHZhciBjbGVhbiA9IGZ1bmN0aW9uKG9iaiwgaXNWYWx1ZSl7XG4gICAgaWYoIGlzLnN0cmluZyhvYmopICl7XG4gICAgICByZXR1cm4gaXNWYWx1ZSA/ICdcIicgKyBvYmogKyAnXCInIDogb2JqO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgdmFyIHF1ZXJ5VG9TdHJpbmcgPSBmdW5jdGlvbihxdWVyeSl7XG4gICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgaWYoIHF1ZXJ5LnN1YmplY3QgPT09IHF1ZXJ5ICl7XG4gICAgICBzdHIgKz0gJyQnO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IGNsZWFuKHF1ZXJ5Lmdyb3VwKTtcbiAgICBzdHIgKz0gZ3JvdXAuc3Vic3RyaW5nKDAsIGdyb3VwLmxlbmd0aCAtIDEpO1xuXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHF1ZXJ5LmRhdGEubGVuZ3RoOyBqKyspe1xuICAgICAgdmFyIGRhdGEgPSBxdWVyeS5kYXRhW2pdO1xuXG4gICAgICBpZiggZGF0YS52YWx1ZSApe1xuICAgICAgICBzdHIgKz0gJ1snICsgZGF0YS5maWVsZCArIGNsZWFuKGRhdGEub3BlcmF0b3IpICsgY2xlYW4oZGF0YS52YWx1ZSwgdHJ1ZSkgKyAnXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gJ1snICsgY2xlYW4oZGF0YS5vcGVyYXRvcikgKyBkYXRhLmZpZWxkICsgJ10nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5tZXRhLmxlbmd0aDsgaisrKXtcbiAgICAgIHZhciBtZXRhID0gcXVlcnkubWV0YVtqXTtcbiAgICAgIHN0ciArPSAnW1snICsgbWV0YS5maWVsZCArIGNsZWFuKG1ldGEub3BlcmF0b3IpICsgY2xlYW4obWV0YS52YWx1ZSwgdHJ1ZSkgKyAnXV0nO1xuICAgIH1cblxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5jb2xvblNlbGVjdG9ycy5sZW5ndGg7IGorKyl7XG4gICAgICB2YXIgc2VsID0gcXVlcnkuY29sb25TZWxlY3RvcnNbaV07XG4gICAgICBzdHIgKz0gc2VsO1xuICAgIH1cblxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5pZHMubGVuZ3RoOyBqKyspe1xuICAgICAgdmFyIHNlbCA9ICcjJyArIHF1ZXJ5Lmlkc1tpXTtcbiAgICAgIHN0ciArPSBzZWw7XG4gICAgfVxuXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHF1ZXJ5LmNsYXNzZXMubGVuZ3RoOyBqKyspe1xuICAgICAgdmFyIHNlbCA9ICcuJyArIHF1ZXJ5LmNsYXNzZXNbal07XG4gICAgICBzdHIgKz0gc2VsO1xuICAgIH1cblxuICAgIGlmKCBxdWVyeS5wYXJlbnQgIT0gbnVsbCApe1xuICAgICAgc3RyID0gcXVlcnlUb1N0cmluZyggcXVlcnkucGFyZW50ICkgKyAnID4gJyArIHN0cjtcbiAgICB9XG5cbiAgICBpZiggcXVlcnkuYW5jZXN0b3IgIT0gbnVsbCApe1xuICAgICAgc3RyID0gcXVlcnlUb1N0cmluZyggcXVlcnkuYW5jZXN0b3IgKSArICcgJyArIHN0cjtcbiAgICB9XG5cbiAgICBpZiggcXVlcnkuY2hpbGQgIT0gbnVsbCApe1xuICAgICAgc3RyICs9ICcgPiAnICsgcXVlcnlUb1N0cmluZyggcXVlcnkuY2hpbGQgKTtcbiAgICB9XG5cbiAgICBpZiggcXVlcnkuZGVzY2VuZGFudCAhPSBudWxsICl7XG4gICAgICBzdHIgKz0gJyAnICsgcXVlcnlUb1N0cmluZyggcXVlcnkuZGVzY2VuZGFudCApO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspe1xuICAgIHZhciBxdWVyeSA9IHRoaXNbaV07XG5cbiAgICBzdHIgKz0gcXVlcnlUb1N0cmluZyggcXVlcnkgKTtcblxuICAgIGlmKCB0aGlzLmxlbmd0aCA+IDEgJiYgaSA8IHRoaXMubGVuZ3RoIC0gMSApe1xuICAgICAgc3RyICs9ICcsICc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0b3I7XG5cbn0se1wiLi9pc1wiOjc3LFwiLi91dGlsXCI6OTR9XSw4MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gX2RlcmVxXygnLi4vdXRpbCcpO1xudmFyIGlzID0gX2RlcmVxXygnLi4vaXMnKTtcblxudmFyIHN0eWZuID0ge307XG5cbi8vIChwb3RlbnRpYWxseSBleHBlbnNpdmUgY2FsY3VsYXRpb24pXG4vLyBhcHBseSB0aGUgc3R5bGUgdG8gdGhlIGVsZW1lbnQgYmFzZWQgb25cbi8vIC0gaXRzIGJ5cGFzc1xuLy8gLSB3aGF0IHNlbGVjdG9ycyBtYXRjaCBpdFxuc3R5Zm4uYXBwbHkgPSBmdW5jdGlvbiggZWxlcyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYoIHNlbGYuX3ByaXZhdGUubmV3U3R5bGUgKXsgLy8gY2xlYXIgc3R5bGUgY2FjaGVzXG4gICAgdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzID0ge307XG4gICAgdGhpcy5fcHJpdmF0ZS5wcm9wRGlmZnMgPSB7fTtcbiAgfVxuXG4gIGZvciggdmFyIGllID0gMDsgaWUgPCBlbGVzLmxlbmd0aDsgaWUrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzW2llXTtcbiAgICB2YXIgY3h0TWV0YSA9IHNlbGYuZ2V0Q29udGV4dE1ldGEoIGVsZSApO1xuICAgIHZhciBjeHRTdHlsZSA9IHNlbGYuZ2V0Q29udGV4dFN0eWxlKCBjeHRNZXRhICk7XG4gICAgdmFyIGFwcCA9IHNlbGYuYXBwbHlDb250ZXh0U3R5bGUoIGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUgKTtcblxuICAgIHNlbGYudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgYXBwLmRpZmZQcm9wcyApO1xuICAgIHNlbGYudXBkYXRlU3R5bGVIaW50cyggZWxlICk7XG5cbiAgfSAvLyBmb3IgZWxlbWVudHNcblxuICBzZWxmLl9wcml2YXRlLm5ld1N0eWxlID0gZmFsc2U7XG59O1xuXG5zdHlmbi5nZXRQcm9wZXJ0aWVzRGlmZiA9IGZ1bmN0aW9uKCBvbGRDeHRLZXksIG5ld0N4dEtleSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjYWNoZSA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgfHwge307XG4gIHZhciBkdWFsQ3h0S2V5ID0gb2xkQ3h0S2V5ICsgJy0nICsgbmV3Q3h0S2V5O1xuICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbZHVhbEN4dEtleV07XG5cbiAgaWYoIGNhY2hlZFZhbCApe1xuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH1cblxuICB2YXIgZGlmZlByb3BzID0gW107XG4gIHZhciBhZGRlZFByb3AgPSB7fTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgY3h0ID0gc2VsZltpXTtcbiAgICB2YXIgb2xkSGFzQ3h0ID0gb2xkQ3h0S2V5W2ldID09PSAndCc7XG4gICAgdmFyIG5ld0hhc0N4dCA9IG5ld0N4dEtleVtpXSA9PT0gJ3QnO1xuICAgIHZhciBjeHRIYXNEaWZmZWQgPSBvbGRIYXNDeHQgIT09IG5ld0hhc0N4dDtcbiAgICB2YXIgY3h0SGFzTWFwcGVkUHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllcy5sZW5ndGggPiAwO1xuXG4gICAgaWYoIGN4dEhhc0RpZmZlZCB8fCBjeHRIYXNNYXBwZWRQcm9wcyApe1xuICAgICAgdmFyIHByb3BzO1xuXG4gICAgICBpZiggY3h0SGFzRGlmZmVkICYmIGN4dEhhc01hcHBlZFByb3BzICl7XG4gICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIHN1ZmZpY2VzIGIvYyBtYXBwZWRQcm9wZXJ0aWVzIGlzIGEgc3Vic2V0IG9mIHByb3BlcnRpZXNcbiAgICAgIH0gZWxzZSBpZiggY3h0SGFzRGlmZmVkICl7XG4gICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIG5lZWQgdG8gY2hlY2sgdGhlbSBhbGxcbiAgICAgIH0gZWxzZSBpZiggY3h0SGFzTWFwcGVkUHJvcHMgKXtcbiAgICAgICAgcHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllczsgLy8gb25seSBuZWVkIHRvIGNoZWNrIG1hcHBlZFxuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuXG4gICAgICAgIC8vIGlmIGEgbGF0ZXIgY29udGV4dCBvdmVycmlkZXMgdGhpcyBwcm9wZXJ0eSwgdGhlbiB0aGUgZmFjdCB0aGF0IHRoaXMgY29udGV4dCBoYXMgc3dpdGNoZWQvZGlmZmVkIGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgIC8vIChzZW1pIGV4cGVuc2l2ZSBjaGVjayBzaW5jZSBpdCBtYWtlcyB0aGlzIGZ1bmN0aW9uIE8obl4yKSBvbiBjb250ZXh0IGxlbmd0aCwgYnV0IHdvcnRoIGl0IHNpbmNlIG92ZXJhbGwgcmVzdWx0XG4gICAgICAgIC8vIGlzIGNhY2hlZClcbiAgICAgICAgdmFyIGxhdGVyQ3h0T3ZlcnJpZGVzID0gZmFsc2U7XG4gICAgICAgIGZvciggdmFyIGsgPSBpICsgMTsgayA8IHNlbGYubGVuZ3RoOyBrKysgKXtcbiAgICAgICAgICB2YXIgbGF0ZXJDeHQgPSBzZWxmW2tdO1xuICAgICAgICAgIHZhciBoYXNMYXRlckN4dCA9IG5ld0N4dEtleVtrXSA9PT0gJ3QnO1xuXG4gICAgICAgICAgaWYoICFoYXNMYXRlckN4dCApeyBjb250aW51ZTsgfSAvLyBjYW4ndCBvdmVycmlkZSB1bmxlc3MgdGhlIGNvbnRleHQgaXMgYWN0aXZlXG5cbiAgICAgICAgICBsYXRlckN4dE92ZXJyaWRlcyA9IGxhdGVyQ3h0LnByb3BlcnRpZXNbIHByb3AubmFtZSBdICE9IG51bGw7XG5cbiAgICAgICAgICBpZiggbGF0ZXJDeHRPdmVycmlkZXMgKXsgYnJlYWs7IH0gLy8gZXhpdCBlYXJseSBhcyBsb25nIGFzIG9uZSBsYXRlciBjb250ZXh0IG92ZXJyaWRlc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFhZGRlZFByb3BbbmFtZV0gJiYgIWxhdGVyQ3h0T3ZlcnJpZGVzICl7XG4gICAgICAgICAgYWRkZWRQcm9wW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBkaWZmUHJvcHMucHVzaCggbmFtZSApO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBwcm9wc1xuICAgIH0gLy8gaWZcblxuICB9IC8vIGZvciBjb250ZXh0c1xuXG4gIGNhY2hlWyBkdWFsQ3h0S2V5IF0gPSBkaWZmUHJvcHM7XG4gIHJldHVybiBkaWZmUHJvcHM7XG59O1xuXG5zdHlmbi5nZXRDb250ZXh0TWV0YSA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3h0S2V5ID0gJyc7XG4gIHZhciBkaWZmUHJvcHM7XG4gIHZhciBwcmV2S2V5ID0gZWxlLl9wcml2YXRlLnN0eWxlQ3h0S2V5IHx8ICcnO1xuXG4gIGlmKCBzZWxmLl9wcml2YXRlLm5ld1N0eWxlICl7XG4gICAgcHJldktleSA9ICcnOyAvLyBzaW5jZSB3ZSBuZWVkIHRvIGFwcGx5IGFsbCBzdHlsZSBpZiBhIGZyZXNoIHN0eWxlc2hlZXRcbiAgfVxuXG4gIC8vIGdldCB0aGUgY3h0IGtleVxuICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgY29udGV4dCA9IHNlbGZbaV07XG4gICAgdmFyIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgPSBjb250ZXh0LnNlbGVjdG9yICYmIGNvbnRleHQuc2VsZWN0b3IubWF0Y2hlcyggZWxlICk7IC8vIE5COiBjb250ZXh0LnNlbGVjdG9yIG1heSBiZSBudWxsIGZvciAnY29yZSdcblxuICAgIGlmKCBjb250ZXh0U2VsZWN0b3JNYXRjaGVzICl7XG4gICAgICBjeHRLZXkgKz0gJ3QnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjeHRLZXkgKz0gJ2YnO1xuICAgIH1cbiAgfSAvLyBmb3IgY29udGV4dFxuXG4gIGRpZmZQcm9wcyA9IHNlbGYuZ2V0UHJvcGVydGllc0RpZmYoIHByZXZLZXksIGN4dEtleSApO1xuXG4gIGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSA9IGN4dEtleTtcblxuICByZXR1cm4ge1xuICAgIGtleTogY3h0S2V5LFxuICAgIGRpZmZQcm9wTmFtZXM6IGRpZmZQcm9wc1xuICB9O1xufTtcblxuLy8gZ2V0cyBhIGNvbXB1dGVkIGVsZSBzdHlsZSBvYmplY3QgYmFzZWQgb24gbWF0Y2hlZCBjb250ZXh0c1xuc3R5Zm4uZ2V0Q29udGV4dFN0eWxlID0gZnVuY3Rpb24oIGN4dE1ldGEgKXtcbiAgdmFyIGN4dEtleSA9IGN4dE1ldGEua2V5O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgfHwge307XG5cbiAgLy8gaWYgYWxyZWFkeSBjb21wdXRlZCBzdHlsZSwgcmV0dXJuZWQgY2FjaGVkIGNvcHlcbiAgaWYoIGN4dFN0eWxlc1tjeHRLZXldICl7IHJldHVybiBjeHRTdHlsZXNbY3h0S2V5XTsgfVxuXG4gIHZhciBzdHlsZSA9IHtcbiAgICBfcHJpdmF0ZToge1xuICAgICAga2V5OiBjeHRLZXlcbiAgICB9XG4gIH07XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgdmFyIGhhc0N4dCA9IGN4dEtleVtpXSA9PT0gJ3QnO1xuXG4gICAgaWYoICFoYXNDeHQgKXsgY29udGludWU7IH1cblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgY3h0LnByb3BlcnRpZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBwcm9wID0gY3h0LnByb3BlcnRpZXNbal07XG4gICAgICB2YXIgc3R5UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXSA9IHByb3A7XG5cbiAgICAgIHN0eVByb3AuY29udGV4dCA9IGN4dDtcbiAgICB9XG4gIH1cblxuICBjeHRTdHlsZXNbY3h0S2V5XSA9IHN0eWxlO1xuICByZXR1cm4gc3R5bGU7XG59O1xuXG5zdHlmbi5hcHBseUNvbnRleHRTdHlsZSA9IGZ1bmN0aW9uKCBjeHRNZXRhLCBjeHRTdHlsZSwgZWxlICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGRpZmZQcm9wcyA9IGN4dE1ldGEuZGlmZlByb3BOYW1lcztcbiAgdmFyIHJldERpZmZQcm9wcyA9IHt9O1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZGlmZlByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGRpZmZQcm9wTmFtZSA9IGRpZmZQcm9wc1tpXTtcbiAgICB2YXIgY3h0UHJvcCA9IGN4dFN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcbiAgICB2YXIgZWxlUHJvcCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsgZGlmZlByb3BOYW1lIF07XG5cbiAgICAvLyBzYXZlIGN5Y2xlcyB3aGVuIHRoZSBjb250ZXh0IHByb3AgZG9lc24ndCBuZWVkIHRvIGJlIGFwcGxpZWRcbiAgICBpZiggIWN4dFByb3AgfHwgZWxlUHJvcCA9PT0gY3h0UHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgdmFyIHJldERpZmZQcm9wID0gcmV0RGlmZlByb3BzWyBkaWZmUHJvcE5hbWUgXSA9IHtcbiAgICAgIHByZXY6IGVsZVByb3BcbiAgICB9O1xuXG4gICAgc2VsZi5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIGN4dFByb3AgKTtcblxuICAgIHJldERpZmZQcm9wLm5leHQgPSBlbGUuX3ByaXZhdGUuc3R5bGVbIGRpZmZQcm9wTmFtZSBdO1xuXG4gICAgaWYoIHJldERpZmZQcm9wLm5leHQgJiYgcmV0RGlmZlByb3AubmV4dC5ieXBhc3MgKXtcbiAgICAgIHJldERpZmZQcm9wLm5leHQgPSByZXREaWZmUHJvcC5uZXh0LmJ5cGFzc2VkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGlmZlByb3BzOiByZXREaWZmUHJvcHNcbiAgfTtcbn07XG5cbnN0eWZuLnVwZGF0ZVN0eWxlSGludHMgPSBmdW5jdGlvbihlbGUpe1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0eWxlID0gX3Auc3R5bGU7XG5cbiAgaWYoIGVsZS5yZW1vdmVkKCkgKXsgcmV0dXJuOyB9XG5cbiAgLy8gc2V0IHdoZXRoZXIgaGFzIHBpZSBvciBub3Q7IGZvciBncmVhdGVyIGVmZmljaWVuY3lcbiAgdmFyIGhhc1BpZSA9IGZhbHNlO1xuICBpZiggX3AuZ3JvdXAgPT09ICdub2RlcycgJiYgc2VsZi5fcHJpdmF0ZS5oYXNQaWUgKXtcbiAgICBmb3IoIHZhciBpID0gMTsgaSA8PSBzZWxmLnBpZUJhY2tncm91bmROOyBpKysgKXsgLy8gMS4uTlxuICAgICAgdmFyIHNpemUgPSBfcC5zdHlsZVsncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnXS52YWx1ZTtcblxuICAgICAgaWYoIHNpemUgPiAwICl7XG4gICAgICAgIGhhc1BpZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9wLmhhc1BpZSA9IGhhc1BpZTtcblxuICB2YXIgdHJhbnNmb3JtID0gc3R5bGVbJ3RleHQtdHJhbnNmb3JtJ10uc3RyVmFsdWU7XG4gIHZhciBjb250ZW50ID0gc3R5bGVbJ2xhYmVsJ10uc3RyVmFsdWU7XG4gIHZhciBmU3R5bGUgPSBzdHlsZVsnZm9udC1zdHlsZSddLnN0clZhbHVlO1xuICB2YXIgc2l6ZSA9IHN0eWxlWydmb250LXNpemUnXS5wZlZhbHVlICsgJ3B4JztcbiAgdmFyIGZhbWlseSA9IHN0eWxlWydmb250LWZhbWlseSddLnN0clZhbHVlO1xuICAvLyB2YXIgdmFyaWFudCA9IHN0eWxlWydmb250LXZhcmlhbnQnXS5zdHJWYWx1ZTtcbiAgdmFyIHdlaWdodCA9IHN0eWxlWydmb250LXdlaWdodCddLnN0clZhbHVlO1xuICB2YXIgdmFsaWduID0gc3R5bGVbJ3RleHQtdmFsaWduJ10uc3RyVmFsdWU7XG4gIHZhciBoYWxpZ24gPSBzdHlsZVsndGV4dC12YWxpZ24nXS5zdHJWYWx1ZTtcbiAgdmFyIG9XaWR0aCA9IHN0eWxlWyd0ZXh0LW91dGxpbmUtd2lkdGgnXS5wZlZhbHVlO1xuICB2YXIgd3JhcCA9IHN0eWxlWyd0ZXh0LXdyYXAnXS5zdHJWYWx1ZTtcbiAgdmFyIHdyYXBXID0gc3R5bGVbJ3RleHQtbWF4LXdpZHRoJ10ucGZWYWx1ZTtcbiAgX3AubGFiZWxLZXkgPSBmU3R5bGUgKyckJysgc2l6ZSArJyQnKyBmYW1pbHkgKyckJysgd2VpZ2h0ICsnJCcrIGNvbnRlbnQgKyckJysgdHJhbnNmb3JtICsnJCcrIHZhbGlnbiArJyQnKyBoYWxpZ24gKyckJysgb1dpZHRoICsgJyQnICsgd3JhcCArICckJyArIHdyYXBXO1xuICBfcC5mb250S2V5ID0gZlN0eWxlICsnJCcrIHdlaWdodCArJyQnKyBzaXplICsnJCcrIGZhbWlseTtcblxuICB2YXIgd2lkdGggPSBzdHlsZVsnd2lkdGgnXS5wZlZhbHVlO1xuICB2YXIgaGVpZ2h0ID0gc3R5bGVbJ2hlaWdodCddLnBmVmFsdWU7XG4gIHZhciBib3JkZXJXID0gc3R5bGVbJ2JvcmRlci13aWR0aCddLnBmVmFsdWU7XG4gIF9wLmJvdW5kaW5nQm94S2V5ID0gd2lkdGggKyckJysgaGVpZ2h0ICsnJCcrIGJvcmRlclc7XG5cbiAgaWYoIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ2VkZ2VzJyApe1xuICAgIHZhciBjcHNzID0gc3R5bGVbJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJ10ucGZWYWx1ZTtcbiAgICB2YXIgY3BkID0gc3R5bGVbJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJ10gPyBzdHlsZVsnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnXS5wZlZhbHVlLmpvaW4oJ18nKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgY3B3ID0gc3R5bGVbJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cyddLnZhbHVlLmpvaW4oJ18nKTtcbiAgICB2YXIgY3VydmUgPSBzdHlsZVsnY3VydmUtc3R5bGUnXS5zdHJWYWx1ZTtcbiAgICB2YXIgc2QgPSBzdHlsZVsnc2VnbWVudC1kaXN0YW5jZXMnXSA/IHN0eWxlWydzZWdtZW50LWRpc3RhbmNlcyddLnBmVmFsdWUuam9pbignXycpIDogdW5kZWZpbmVkO1xuICAgIHZhciBzdyA9IHN0eWxlWydzZWdtZW50LXdlaWdodHMnXS52YWx1ZS5qb2luKCdfJyk7XG5cbiAgICBfcC5ib3VuZGluZ0JveEtleSArPSAnJCcrIGNwc3MgKyckJysgY3BkICsnJCcrIGNwdyArJyQnKyBzZCArJyQnKyBzdyArJyQnKyBjdXJ2ZTtcbiAgfVxuXG4gIF9wLnN0eWxlS2V5ID0gRGF0ZS5ub3coKTtcbn07XG5cbi8vIGFwcGx5IGEgcHJvcGVydHkgdG8gdGhlIHN0eWxlIChmb3IgaW50ZXJuYWwgdXNlKVxuLy8gcmV0dXJucyB3aGV0aGVyIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsXG4vL1xuLy8gbm93LCB0aGlzIGZ1bmN0aW9uIGZsYXR0ZW5zIHRoZSBwcm9wZXJ0eSwgYW5kIGhlcmUncyBob3c6XG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUsIGRlbGV0ZUJ5cGFzczogdHJ1ZSB9XG4vLyBubyBwcm9wZXJ0eSBpcyBnZW5lcmF0ZWQsIGluc3RlYWQgdGhlIGJ5cGFzcyBwcm9wZXJ0eSBpbiB0aGVcbi8vIGVsZW1lbnQncyBzdHlsZSBpcyByZXBsYWNlZCBieSB3aGF0J3MgcG9pbnRlZCB0byBieSB0aGUgYGJ5cGFzc2VkYFxuLy8gZmllbGQgaW4gdGhlIGJ5cGFzcyBwcm9wZXJ0eSAoaS5lLiByZXN0b3JpbmcgdGhlIHByb3BlcnR5IHRoZVxuLy8gYnlwYXNzIHdhcyBvdmVycmlkaW5nKVxuLy9cbi8vIGZvciBwYXJzZWRQcm9wOnsgbWFwcGVkOiB0cnV0aHkgfVxuLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgbWFwcGluZzogcHJvcCB9XG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUgfVxuLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgYnlwYXNzZWQ6IHBhcnNlZFByb3AgfVxuc3R5Zm4uYXBwbHlQYXJzZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBlbGUsIHBhcnNlZFByb3AgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcCA9IHBhcnNlZFByb3A7XG4gIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgdmFyIGZpZWxkVmFsLCBmbGF0UHJvcDtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcbiAgdmFyIHR5cGUgPSBzZWxmLnByb3BlcnRpZXNbIHByb3AubmFtZSBdLnR5cGU7XG4gIHZhciBwcm9wSXNCeXBhc3MgPSBwcm9wLmJ5cGFzcztcbiAgdmFyIG9yaWdQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICB2YXIgb3JpZ1Byb3BJc0J5cGFzcyA9IG9yaWdQcm9wICYmIG9yaWdQcm9wLmJ5cGFzcztcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gIC8vIGNhbid0IGFwcGx5IGF1dG8gdG8gd2lkdGggb3IgaGVpZ2h0IHVubGVzcyBpdCdzIGEgcGFyZW50IG5vZGVcbiAgaWYoIChwYXJzZWRQcm9wLm5hbWUgPT09ICdoZWlnaHQnIHx8IHBhcnNlZFByb3AubmFtZSA9PT0gJ3dpZHRoJykgJiYgZWxlLmlzTm9kZSgpICl7XG4gICAgaWYoIHBhcnNlZFByb3AudmFsdWUgPT09ICdhdXRvJyAmJiAhZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYoIHBhcnNlZFByb3AudmFsdWUgIT09ICdhdXRvJyAmJiBlbGUuaXNQYXJlbnQoKSApe1xuICAgICAgcHJvcCA9IHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKCBwYXJzZWRQcm9wLm5hbWUsICdhdXRvJywgcHJvcElzQnlwYXNzICk7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBkZWxldGUgdGhlIGN1cnJlbnQgYnlwYXNzXG4gIGlmKCBwcm9wSXNCeXBhc3MgJiYgcHJvcC5kZWxldGVCeXBhc3MgKXsgLy8gdGhlbiB0aGlzIHByb3BlcnR5IGlzIGp1c3QgaGVyZSB0byBpbmRpY2F0ZSB3ZSBuZWVkIHRvIGRlbGV0ZVxuICAgIHZhciBjdXJyZW50UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcblxuICAgIC8vIGNhbiBvbmx5IGRlbGV0ZSBpZiB0aGUgY3VycmVudCBwcm9wIGlzIGEgYnlwYXNzIGFuZCBpdCBwb2ludHMgdG8gdGhlIHByb3BlcnR5IGl0IHdhcyBvdmVycmlkaW5nXG4gICAgaWYoICFjdXJyZW50UHJvcCApe1xuICAgICAgcmV0dXJuIHRydWU7IC8vIHByb3BlcnR5IGlzIGFscmVhZHkgbm90IGRlZmluZWRcbiAgICB9IGVsc2UgaWYoIGN1cnJlbnRQcm9wLmJ5cGFzcyAmJiBjdXJyZW50UHJvcC5ieXBhc3NlZCApeyAvLyB0aGVuIHJlcGxhY2UgdGhlIGJ5cGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBvcmlnaW5hbFxuXG4gICAgICAvLyBiZWNhdXNlIHRoZSBieXBhc3NlZCBwcm9wZXJ0eSB3YXMgYWxyZWFkeSBhcHBsaWVkIChhbmQgdGhlcmVmb3JlIHBhcnNlZCksIHdlIGNhbiBqdXN0IHJlcGxhY2UgaXQgKG5vIHJlYXBwbHlpbmcgbmVjZXNzYXJ5KVxuICAgICAgc3R5bGVbIHByb3AubmFtZSBdID0gY3VycmVudFByb3AuYnlwYXNzZWQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIHVuc3VjY2Vzc2Z1bCBkZWxldGluZyB0aGUgYnlwYXNzXG4gICAgfVxuICB9XG5cbiAgdmFyIHByaW50TWFwcGluZ0VyciA9IGZ1bmN0aW9uKCl7XG4gICAgdXRpbC5lcnJvcignRG8gbm90IGFzc2lnbiBtYXBwaW5ncyB0byBlbGVtZW50cyB3aXRob3V0IGNvcnJlc3BvbmRpbmcgZGF0YSAoZS5nLiBlbGUgYCcrIGVsZS5pZCgpICsnYCBmb3IgcHJvcGVydHkgYCcrIHByb3AubmFtZSArJ2Agd2l0aCBkYXRhIGZpZWxkIGAnKyBwcm9wLmZpZWxkICsnYCk7IHRyeSBhIGBbJysgcHJvcC5maWVsZCArJ11gIHNlbGVjdG9yIHRvIGxpbWl0IHNjb3BlIHRvIGVsZW1lbnRzIHdpdGggYCcrIHByb3AuZmllbGQgKydgIGRlZmluZWQnKTtcbiAgfTtcblxuICAvLyBwdXQgdGhlIHByb3BlcnR5IGluIHRoZSBzdHlsZSBvYmplY3RzXG4gIHN3aXRjaCggcHJvcC5tYXBwZWQgKXsgLy8gZmxhdHRlbiB0aGUgcHJvcGVydHkgaWYgbWFwcGVkXG4gIGNhc2UgdHlwZXMubWFwRGF0YTpcbiAgY2FzZSB0eXBlcy5tYXBMYXlvdXREYXRhOlxuICBjYXNlIHR5cGVzLm1hcFNjcmF0Y2g6XG5cbiAgICB2YXIgaXNMYXlvdXQgPSBwcm9wLm1hcHBlZCA9PT0gdHlwZXMubWFwTGF5b3V0RGF0YTtcbiAgICB2YXIgaXNTY3JhdGNoID0gcHJvcC5tYXBwZWQgPT09IHR5cGVzLm1hcFNjcmF0Y2g7XG5cbiAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgdmFyIGZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoXCIuXCIpO1xuICAgIHZhciBmaWVsZFZhbDtcblxuICAgIGlmKCBpc1NjcmF0Y2ggfHwgaXNMYXlvdXQgKXtcbiAgICAgIGZpZWxkVmFsID0gX3Auc2NyYXRjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmllbGRWYWwgPSBfcC5kYXRhO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aCAmJiBmaWVsZFZhbDsgaSsrICl7XG4gICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICBmaWVsZFZhbCA9IGZpZWxkVmFsWyBmaWVsZCBdO1xuICAgIH1cblxuICAgIHZhciBwZXJjZW50O1xuICAgIGlmKCAhaXMubnVtYmVyKGZpZWxkVmFsKSApeyAvLyB0aGVuIGtlZXAgdGhlIG1hcHBpbmcgYnV0IGFzc3VtZSAwJSBmb3Igbm93XG4gICAgICBwZXJjZW50ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVyY2VudCA9IChmaWVsZFZhbCAtIHByb3AuZmllbGRNaW4pIC8gKHByb3AuZmllbGRNYXggLSBwcm9wLmZpZWxkTWluKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdG8gYm91bmQgcGVyY2VudCB2YWx1ZVxuICAgIGlmKCBwZXJjZW50IDwgMCApe1xuICAgICAgcGVyY2VudCA9IDA7XG4gICAgfSBlbHNlIGlmKCBwZXJjZW50ID4gMSApe1xuICAgICAgcGVyY2VudCA9IDE7XG4gICAgfVxuXG4gICAgaWYoIHR5cGUuY29sb3IgKXtcbiAgICAgIHZhciByMSA9IHByb3AudmFsdWVNaW5bMF07XG4gICAgICB2YXIgcjIgPSBwcm9wLnZhbHVlTWF4WzBdO1xuICAgICAgdmFyIGcxID0gcHJvcC52YWx1ZU1pblsxXTtcbiAgICAgIHZhciBnMiA9IHByb3AudmFsdWVNYXhbMV07XG4gICAgICB2YXIgYjEgPSBwcm9wLnZhbHVlTWluWzJdO1xuICAgICAgdmFyIGIyID0gcHJvcC52YWx1ZU1heFsyXTtcbiAgICAgIHZhciBhMSA9IHByb3AudmFsdWVNaW5bM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWluWzNdO1xuICAgICAgdmFyIGEyID0gcHJvcC52YWx1ZU1heFszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNYXhbM107XG5cbiAgICAgIHZhciBjbHIgPSBbXG4gICAgICAgIE1hdGgucm91bmQoIHIxICsgKHIyIC0gcjEpKnBlcmNlbnQgKSxcbiAgICAgICAgTWF0aC5yb3VuZCggZzEgKyAoZzIgLSBnMSkqcGVyY2VudCApLFxuICAgICAgICBNYXRoLnJvdW5kKCBiMSArIChiMiAtIGIxKSpwZXJjZW50ICksXG4gICAgICAgIE1hdGgucm91bmQoIGExICsgKGEyIC0gYTEpKnBlcmNlbnQgKVxuICAgICAgXTtcblxuICAgICAgZmxhdFByb3AgPSB7IC8vIGNvbG91cnMgYXJlIHNpbXBsZSwgc28ganVzdCBjcmVhdGUgdGhlIGZsYXQgcHJvcGVydHkgaW5zdGVhZCBvZiBleHBlbnNpdmUgc3RyaW5nIHBhcnNpbmdcbiAgICAgICAgYnlwYXNzOiBwcm9wLmJ5cGFzcywgLy8gd2UncmUgYSBieXBhc3MgaWYgdGhlIG1hcHBpbmcgcHJvcGVydHkgaXMgYSBieXBhc3NcbiAgICAgICAgbmFtZTogcHJvcC5uYW1lLFxuICAgICAgICB2YWx1ZTogY2xyLFxuICAgICAgICBzdHJWYWx1ZTogJ3JnYignICsgY2xyWzBdICsgJywgJyArIGNsclsxXSArICcsICcgKyBjbHJbMl0gKyAnKSdcbiAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYoIHR5cGUubnVtYmVyICl7XG4gICAgICB2YXIgY2FsY1ZhbHVlID0gcHJvcC52YWx1ZU1pbiArIChwcm9wLnZhbHVlTWF4IC0gcHJvcC52YWx1ZU1pbikgKiBwZXJjZW50O1xuICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKCBwcm9wLm5hbWUsIGNhbGNWYWx1ZSwgcHJvcC5ieXBhc3MsIHRydWUgKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbiBvbmx5IG1hcCB0byBjb2xvdXJzIGFuZCBudW1iZXJzXG4gICAgfVxuXG4gICAgaWYoICFmbGF0UHJvcCApeyAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiB1c2UgdGhlIG9yaWdQcm9wIHNvIHdlIHN0aWxsIGtlZXAgdGhlIG1hcHBpbmcgaXRzZWxmXG4gICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgb3JpZ1Byb3Auc3RyVmFsdWUsIHByb3AuYnlwYXNzLCB0cnVlICk7XG4gICAgfVxuXG4gICAgaWYoICFmbGF0UHJvcCApeyBwcmludE1hcHBpbmdFcnIoKTsgfVxuICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgYnJlYWs7XG5cbiAgLy8gZGlyZWN0IG1hcHBpbmdcbiAgY2FzZSB0eXBlcy5kYXRhOlxuICBjYXNlIHR5cGVzLmxheW91dERhdGE6XG4gIGNhc2UgdHlwZXMuc2NyYXRjaDpcbiAgICB2YXIgaXNMYXlvdXQgPSBwcm9wLm1hcHBlZCA9PT0gdHlwZXMubGF5b3V0RGF0YTtcbiAgICB2YXIgaXNTY3JhdGNoID0gcHJvcC5tYXBwZWQgPT09IHR5cGVzLnNjcmF0Y2g7XG5cbiAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgdmFyIGZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoXCIuXCIpO1xuICAgIHZhciBmaWVsZFZhbDtcblxuICAgIGlmKCBpc1NjcmF0Y2ggfHwgaXNMYXlvdXQgKXtcbiAgICAgIGZpZWxkVmFsID0gX3Auc2NyYXRjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmllbGRWYWwgPSBfcC5kYXRhO1xuICAgIH1cblxuICAgIGlmKCBmaWVsZFZhbCApeyBmb3IoIHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgZmllbGRWYWwgPSBmaWVsZFZhbFsgZmllbGQgXTtcbiAgICB9IH1cblxuICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBmaWVsZFZhbCwgcHJvcC5ieXBhc3MsIHRydWUgKTtcblxuICAgIGlmKCAhZmxhdFByb3AgKXsgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gdXNlIHRoZSBvcmlnUHJvcCBzbyB3ZSBzdGlsbCBrZWVwIHRoZSBtYXBwaW5nIGl0c2VsZlxuICAgICAgdmFyIGZsYXRQcm9wVmFsID0gb3JpZ1Byb3AgPyBvcmlnUHJvcC5zdHJWYWx1ZSA6ICcnO1xuXG4gICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgZmxhdFByb3BWYWwsIHByb3AuYnlwYXNzLCB0cnVlICk7XG4gICAgfVxuXG4gICAgaWYoICFmbGF0UHJvcCApeyBwcmludE1hcHBpbmdFcnIoKTsgfVxuICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgYnJlYWs7XG5cbiAgY2FzZSB0eXBlcy5mbjpcbiAgICB2YXIgZm4gPSBwcm9wLnZhbHVlO1xuICAgIHZhciBmblJldFZhbCA9IGZuKCBlbGUgKTtcblxuICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBmblJldFZhbCwgcHJvcC5ieXBhc3MsIHRydWUgKTtcbiAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgIGJyZWFrO1xuXG4gIGNhc2UgdW5kZWZpbmVkOlxuICAgIGJyZWFrOyAvLyBqdXN0IHNldCB0aGUgcHJvcGVydHlcblxuICBkZWZhdWx0OlxuICAgIHJldHVybiBmYWxzZTsgLy8gbm90IGEgdmFsaWQgbWFwcGluZ1xuICB9XG5cbiAgLy8gaWYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5LCB0aGVuIGxpbmsgdGhlIHJlc3VsdGFudCBwcm9wZXJ0eSB0byB0aGUgb3JpZ2luYWwgb25lXG4gIGlmKCBwcm9wSXNCeXBhc3MgKXtcbiAgICBpZiggb3JpZ1Byb3BJc0J5cGFzcyApeyAvLyB0aGVuIHRoaXMgYnlwYXNzIG92ZXJyaWRlcyB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICBwcm9wLmJ5cGFzc2VkID0gb3JpZ1Byb3AuYnlwYXNzZWQ7IC8vIHN0ZWFsIGJ5cGFzc2VkIHByb3AgZnJvbSBvbGQgYnlwYXNzXG4gICAgfSBlbHNlIHsgLy8gdGhlbiBsaW5rIHRoZSBvcmlnIHByb3AgdG8gdGhlIG5ldyBieXBhc3NcbiAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcDtcbiAgICB9XG5cbiAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wOyAvLyBhbmQgc2V0XG5cbiAgfSBlbHNlIHsgLy8gcHJvcCBpcyBub3QgYnlwYXNzXG4gICAgaWYoIG9yaWdQcm9wSXNCeXBhc3MgKXsgLy8gdGhlbiBrZWVwIHRoZSBvcmlnIHByb3AgKHNpbmNlIGl0J3MgYSBieXBhc3MpIGFuZCBsaW5rIHRvIHRoZSBuZXcgcHJvcFxuICAgICAgb3JpZ1Byb3AuYnlwYXNzZWQgPSBwcm9wO1xuICAgIH0gZWxzZSB7IC8vIHRoZW4ganVzdCByZXBsYWNlIHRoZSBvbGQgcHJvcCB3aXRoIHRoZSBuZXcgb25lXG4gICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gdXBkYXRlcyB0aGUgdmlzdWFsIHN0eWxlIGZvciBhbGwgZWxlbWVudHMgKHVzZWZ1bCBmb3IgbWFudWFsIHN0eWxlIG1vZGlmaWNhdGlvbiBhZnRlciBpbml0KVxuc3R5Zm4udXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVsZXMgPSBjeS5lbGVtZW50cygpO1xuXG4gIGVsZXMudXBkYXRlU3R5bGUoKTtcbn07XG5cbi8vIGp1c3QgdXBkYXRlIHRoZSBmdW5jdGlvbmFsIHByb3BlcnRpZXMgKGkuZS4gbWFwcGluZ3MpIGluIHRoZSBlbGVtZW50cydcbi8vIHN0eWxlcyAobGVzcyBleHBlbnNpdmUgdGhhbiByZWNhbGN1bGF0aW9uKVxuc3R5Zm4udXBkYXRlTWFwcGVycyA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXsgLy8gZm9yIGVhY2ggZWxlXG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBqKysgKXsgLy8gZm9yIGVhY2ggcHJvcFxuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbal07XG4gICAgICB2YXIgcHJvcEluU3R5bGUgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG5cbiAgICAgIGlmKCBwcm9wSW5TdHlsZSAmJiBwcm9wSW5TdHlsZS5tYXBwaW5nICl7XG4gICAgICAgIHZhciBtYXBwaW5nID0gcHJvcEluU3R5bGUubWFwcGluZztcbiAgICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIG1hcHBpbmcgKTsgLy8gcmVhcHBseSB0aGUgbWFwcGluZyBwcm9wZXJ0eVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyggZWxlICk7XG4gIH1cbn07XG5cbi8vIGRpZmZQcm9wcyA6IHsgbmFtZSA9PiB7IHByZXYsIG5leHQgfSB9XG5zdHlmbi51cGRhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uKCBlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuICB2YXIgcHJvcHMgPSBzdHlsZVsndHJhbnNpdGlvbi1wcm9wZXJ0eSddLnZhbHVlO1xuICB2YXIgZHVyYXRpb24gPSBzdHlsZVsndHJhbnNpdGlvbi1kdXJhdGlvbiddLnBmVmFsdWU7XG4gIHZhciBkZWxheSA9IHN0eWxlWyd0cmFuc2l0aW9uLWRlbGF5J10ucGZWYWx1ZTtcbiAgdmFyIGNzcyA9IHt9O1xuXG4gIGlmKCBwcm9wcy5sZW5ndGggPiAwICYmIGR1cmF0aW9uID4gMCApe1xuXG4gICAgLy8gYnVpbGQgdXAgdGhlIHN0eWxlIHRvIGFuaW1hdGUgdG93YXJkc1xuICAgIHZhciBhbnlQcmV2ID0gZmFsc2U7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIHZhciBzdHlQcm9wID0gc3R5bGVbIHByb3AgXTtcbiAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1sgcHJvcCBdO1xuXG4gICAgICBpZiggIWRpZmZQcm9wICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIHZhciBwcmV2UHJvcCA9IGRpZmZQcm9wLnByZXY7XG4gICAgICB2YXIgZnJvbVByb3AgPSBwcmV2UHJvcDtcbiAgICAgIHZhciB0b1Byb3AgPSBkaWZmUHJvcC5uZXh0ICE9IG51bGwgPyBkaWZmUHJvcC5uZXh0IDogc3R5UHJvcDtcbiAgICAgIHZhciBkaWZmID0gZmFsc2U7XG4gICAgICB2YXIgaW5pdFZhbDtcbiAgICAgIHZhciBpbml0RHQgPSAwLjAwMDAwMTsgLy8gZGVsdGEgdGltZSAlIHZhbHVlIGZvciBpbml0VmFsIChhbGxvd3MgYW5pbWF0aW5nIG91dCBvZiBpbml0IHplcm8gb3BhY2l0eSlcblxuICAgICAgaWYoICFmcm9tUHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgICAvLyBjb25zaWRlciBweCB2YWx1ZXNcbiAgICAgIGlmKCBpcy5udW1iZXIoIGZyb21Qcm9wLnBmVmFsdWUgKSAmJiBpcy5udW1iZXIoIHRvUHJvcC5wZlZhbHVlICkgKXtcbiAgICAgICAgZGlmZiA9IHRvUHJvcC5wZlZhbHVlIC0gZnJvbVByb3AucGZWYWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnBmVmFsdWUgKyBpbml0RHQgKiBkaWZmO1xuXG4gICAgICAvLyBjb25zaWRlciBudW1lcmljYWwgdmFsdWVzXG4gICAgICB9IGVsc2UgaWYoIGlzLm51bWJlciggZnJvbVByb3AudmFsdWUgKSAmJiBpcy5udW1iZXIoIHRvUHJvcC52YWx1ZSApICl7XG4gICAgICAgIGRpZmYgPSB0b1Byb3AudmFsdWUgLSBmcm9tUHJvcC52YWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnZhbHVlICsgaW5pdER0ICogZGlmZjtcblxuICAgICAgLy8gY29uc2lkZXIgY29sb3VyIHZhbHVlc1xuICAgICAgfSBlbHNlIGlmKCBpcy5hcnJheSggZnJvbVByb3AudmFsdWUgKSAmJiBpcy5hcnJheSggdG9Qcm9wLnZhbHVlICkgKXtcbiAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnZhbHVlWzBdICE9PSB0b1Byb3AudmFsdWVbMF1cbiAgICAgICAgICB8fCBmcm9tUHJvcC52YWx1ZVsxXSAhPT0gdG9Qcm9wLnZhbHVlWzFdXG4gICAgICAgICAgfHwgZnJvbVByb3AudmFsdWVbMl0gIT09IHRvUHJvcC52YWx1ZVsyXVxuICAgICAgICA7XG5cbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnN0clZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGUgcHJldmlvdXMgdmFsdWUgaXMgZ29vZCBmb3IgYW4gYW5pbWF0aW9uIG9ubHkgaWYgaXQncyBkaWZmZXJlbnRcbiAgICAgIGlmKCBkaWZmICl7XG4gICAgICAgIGNzc1sgcHJvcCBdID0gdG9Qcm9wLnN0clZhbHVlOyAvLyB0byB2YWxcbiAgICAgICAgdGhpcy5hcHBseUJ5cGFzcyggZWxlLCBwcm9wLCBpbml0VmFsICk7IC8vIGZyb20gdmFsXG4gICAgICAgIGFueVByZXYgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgfSAvLyBlbmQgaWYgcHJvcHMgYWxsb3cgYW5pXG5cbiAgICAvLyBjYW4ndCB0cmFuc2l0aW9uIGlmIHRoZXJlJ3Mgbm90aGluZyBwcmV2aW91cyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICBpZiggIWFueVByZXYgKXsgcmV0dXJuOyB9XG5cbiAgICBfcC50cmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgIGVsZS5zdG9wKCk7XG5cbiAgICBpZiggZGVsYXkgPiAwICl7XG4gICAgICBlbGUuZGVsYXkoIGRlbGF5ICk7XG4gICAgfVxuXG4gICAgZWxlLmFuaW1hdGUoe1xuICAgICAgY3NzOiBjc3NcbiAgICB9LCB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBlYXNpbmc6IHN0eWxlWyd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbiddLnZhbHVlLFxuICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCAhaXNCeXBhc3MgKXtcbiAgICAgICAgICBzZWxmLnJlbW92ZUJ5cGFzc2VzKCBlbGUsIHByb3BzICk7XG4gICAgICAgIH1cblxuICAgICAgICBfcC50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSBlbHNlIGlmKCBfcC50cmFuc2l0aW9uaW5nICl7XG4gICAgZWxlLnN0b3AoKTtcblxuICAgIHRoaXMucmVtb3ZlQnlwYXNzZXMoIGVsZSwgcHJvcHMgKTtcblxuICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcblxufSx7XCIuLi9pc1wiOjc3LFwiLi4vdXRpbFwiOjk0fV0sODM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi9pcycpO1xudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi91dGlsJyk7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG4vLyBieXBhc3NlcyBhcmUgYXBwbGllZCB0byBhbiBleGlzdGluZyBzdHlsZSBvbiBhbiBlbGVtZW50LCBhbmQganVzdCB0YWNrZWQgb24gdGVtcG9yYXJpbHlcbi8vIHJldHVybnMgdHJ1ZSBpZmYgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWwgZm9yIGF0IGxlYXN0IDEgc3BlY2lmaWVkIHByb3BlcnR5XG5zdHlmbi5hcHBseUJ5cGFzcyA9IGZ1bmN0aW9uKCBlbGVzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcHMgPSBbXTtcbiAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICAvLyBwdXQgYWxsIHRoZSBwcm9wZXJ0aWVzIChjYW4gc3BlY2lmeSBvbmUgb3IgbWFueSkgaW4gYW4gYXJyYXkgYWZ0ZXIgcGFyc2luZyB0aGVtXG4gIGlmKCBuYW1lID09PSBcIipcIiB8fCBuYW1lID09PSBcIioqXCIgKXsgLy8gYXBwbHkgdG8gYWxsIHByb3BlcnR5IG5hbWVzXG5cbiAgICBpZiggdmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuXG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYoIHBhcnNlZFByb3AgKXtcbiAgICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIGlmKCBpcy5zdHJpbmcobmFtZSkgKXsgLy8gdGhlbiBwYXJzZSB0aGUgc2luZ2xlIHByb3BlcnR5XG4gICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcblxuICAgIGlmKCBwYXJzZWRQcm9wICl7XG4gICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgfVxuICB9IGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KG5hbWUpICl7IC8vIHRoZW4gcGFyc2UgZWFjaCBwcm9wZXJ0eVxuICAgIHZhciBzcGVjaWZpZWRQcm9wcyA9IG5hbWU7XG4gICAgdXBkYXRlVHJhbnNpdGlvbnMgPSB2YWx1ZTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgdmFyIHZhbHVlID0gc3BlY2lmaWVkUHJvcHNbIG5hbWUgXTtcblxuICAgICAgaWYoIHZhbHVlID09PSB1bmRlZmluZWQgKXsgLy8gdHJ5IGNhbWVsIGNhc2UgbmFtZSB0b29cbiAgICAgICAgdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1sgdXRpbC5kYXNoMmNhbWVsKG5hbWUpIF07XG4gICAgICB9XG5cbiAgICAgIGlmKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYoIHBhcnNlZFByb3AgKXtcbiAgICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7IC8vIGNhbid0IGRvIGFueXRoaW5nIHdpdGhvdXQgd2VsbCBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB3ZSd2ZSBmYWlsZWQgaWYgdGhlcmUgYXJlIG5vIHZhbGlkIHByb3BlcnRpZXNcbiAgaWYoIHByb3BzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBub3csIGFwcGx5IHRoZSBieXBhc3MgcHJvcGVydGllcyBvbiB0aGUgZWxlbWVudHNcbiAgdmFyIHJldCA9IGZhbHNlOyAvLyByZXR1cm4gdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgc3VjY2VzZnVsIGJ5cGFzcyBhcHBsaWVkXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApeyAvLyBmb3IgZWFjaCBlbGVcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuICAgIHZhciBkaWZmUHJvcDtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXsgLy8gZm9yIGVhY2ggcHJvcFxuICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcblxuICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgIHZhciBwcmV2UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgICAgZGlmZlByb3AgPSBkaWZmUHJvcHNbIHByb3AubmFtZSBdID0geyBwcmV2OiBwcmV2UHJvcCB9O1xuICAgICAgfVxuXG4gICAgICByZXQgPSB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoIGVsZSwgcHJvcCApIHx8IHJldDtcblxuICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgIGRpZmZQcm9wLm5leHQgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgICB9XG5cbiAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgaWYoIHJldCApe1xuICAgICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKCBlbGUgKTtcbiAgICB9XG5cbiAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlc1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWZpYyBjYXNlcyBsaWtlIGFuaW1hdGlvblxuc3R5Zm4ub3ZlcnJpZGVCeXBhc3MgPSBmdW5jdGlvbiggZWxlcywgbmFtZSwgdmFsdWUgKXtcbiAgbmFtZSA9IHV0aWwuY2FtZWwyZGFzaChuYW1lKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcHJvcCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsgbmFtZSBdO1xuICAgIHZhciB0eXBlID0gdGhpcy5wcm9wZXJ0aWVzWyBuYW1lIF0udHlwZTtcbiAgICB2YXIgaXNDb2xvciA9IHR5cGUuY29sb3I7XG4gICAgdmFyIGlzTXVsdGkgPSB0eXBlLm11dGlwbGU7XG5cbiAgICBpZiggIXByb3AuYnlwYXNzICl7IC8vIG5lZWQgYSBieXBhc3MgaWYgb25lIGRvZXNuJ3QgZXhpc3RcbiAgICAgIHRoaXMuYXBwbHlCeXBhc3MoIGVsZSwgbmFtZSwgdmFsdWUgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHByb3AudmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmKCBwcm9wLnBmVmFsdWUgIT0gbnVsbCApe1xuICAgICAgcHJvcC5wZlZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYoIGlzQ29sb3IgKXtcbiAgICAgIHByb3Auc3RyVmFsdWUgPSAncmdiKCcgKyB2YWx1ZS5qb2luKCcsJykgKyAnKSc7XG4gICAgfSBlbHNlIGlmKCBpc011bHRpICl7XG4gICAgICBwcm9wLnN0clZhbHVlID0gdmFsdWUuam9pbignICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnN0clZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbnN0eWZuLnJlbW92ZUFsbEJ5cGFzc2VzID0gZnVuY3Rpb24oIGVsZXMsIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gIHJldHVybiB0aGlzLnJlbW92ZUJ5cGFzc2VzKCBlbGVzLCB0aGlzLnByb3BlcnR5TmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG59O1xuXG5zdHlmbi5yZW1vdmVCeXBhc3NlcyA9IGZ1bmN0aW9uKCBlbGVzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICBmb3IoIHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tqXTtcbiAgICB2YXIgZGlmZlByb3BzID0ge307XG4gICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5hbWUgPSBwcm9wc1tpXTtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzWyBuYW1lIF07XG4gICAgICB2YXIgdmFsdWUgPSAnJzsgLy8gZW1wdHkgPT4gcmVtb3ZlIGJ5cGFzc1xuICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgIHZhciBwcmV2UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1sgcHJvcC5uYW1lIF0gPSB7IHByZXY6IHByZXZQcm9wIH07XG5cbiAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIHBhcnNlZFByb3ApO1xuXG4gICAgICBkaWZmUHJvcC5uZXh0ID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoIGVsZSApO1xuXG4gICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKCBlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MgKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVsZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG5cbn0se1wiLi4vaXNcIjo3NyxcIi4uL3V0aWxcIjo5NH1dLDg0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHdpbmRvdyA9IF9kZXJlcV8oJy4uL3dpbmRvdycpO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuLy8gZ2V0cyB3aGF0IGFuIGVtIHNpemUgY29ycmVzcG9uZHMgdG8gaW4gcGl4ZWxzIHJlbGF0aXZlIHRvIGEgZG9tIGVsZW1lbnRcbnN0eWZuLmdldEVtU2l6ZUluUGl4ZWxzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHB4ID0gdGhpcy5jb250YWluZXJDc3MoJ2ZvbnQtc2l6ZScpO1xuXG4gIGlmKCBweCAhPSBudWxsICl7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoIHB4ICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7IC8vIGZvciBoZWFkbGVzc1xuICB9XG59O1xuXG4vLyBnZXRzIGNzcyBwcm9wZXJ0eSBmcm9tIHRoZSBjb3JlIGNvbnRhaW5lclxuc3R5Zm4uY29udGFpbmVyQ3NzID0gZnVuY3Rpb24oIHByb3BOYW1lICl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBkb21FbGVtZW50ID0gY3kuY29udGFpbmVyKCk7XG5cbiAgaWYoIHdpbmRvdyAmJiBkb21FbGVtZW50ICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICl7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbUVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoIHByb3BOYW1lICk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG5cbn0se1wiLi4vd2luZG93XCI6MTAwfV0sODU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uL3V0aWwnKTtcbnZhciBpcyA9IF9kZXJlcV8oJy4uL2lzJyk7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG4vLyBnZXRzIHRoZSByZW5kZXJlZCBzdHlsZSBmb3IgYW4gZWxlbWVudFxuc3R5Zm4uZ2V0UmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgcmV0dXJuIHRoaXMuZ2V0UmF3U3R5bGUoIGVsZSwgdHJ1ZSApO1xufTtcblxuLy8gZ2V0cyB0aGUgcmF3IHN0eWxlIGZvciBhbiBlbGVtZW50XG5zdHlmbi5nZXRSYXdTdHlsZSA9IGZ1bmN0aW9uKCBlbGUsIGlzUmVuZGVyZWRWYWwgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgaWYoIGVsZSApe1xuICAgIHZhciByc3R5bGUgPSB7fTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgIHZhciB2YWwgPSBzZWxmLmdldFN0eWxlUHJvcGVydHlWYWx1ZSggZWxlLCBwcm9wLm5hbWUsIGlzUmVuZGVyZWRWYWwgKTtcblxuICAgICAgaWYoIHZhbCApe1xuICAgICAgICByc3R5bGVbIHByb3AubmFtZSBdID0gdmFsO1xuICAgICAgICByc3R5bGVbIHV0aWwuZGFzaDJjYW1lbChwcm9wLm5hbWUpIF0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdHlsZTtcbiAgfVxufTtcblxuc3R5Zm4uZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24oIGVsZSwgcHJvcE5hbWUsIGlzUmVuZGVyZWRWYWwgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgaWYoIGVsZSApe1xuICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1sgcHJvcE5hbWUgXTtcbiAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgICB2YXIgc3R5bGVQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgIHZhciB6b29tID0gZWxlLmN5KCkuem9vbSgpO1xuXG4gICAgaWYoIHN0eWxlUHJvcCApe1xuICAgICAgdmFyIHVuaXRzID0gc3R5bGVQcm9wLnVuaXRzID8gdHlwZS5pbXBsaWNpdFVuaXRzIHx8ICdweCcgOiBudWxsO1xuICAgICAgdmFyIHZhbCA9IHVuaXRzID8gW10uY29uY2F0KCBzdHlsZVByb3AucGZWYWx1ZSApLm1hcChmdW5jdGlvbiggcGZWYWx1ZSApe1xuICAgICAgICByZXR1cm4gKCBwZlZhbHVlICogKGlzUmVuZGVyZWRWYWwgPyB6b29tIDogMSkgKSArIHVuaXRzO1xuICAgICAgfSkuam9pbignICcpIDogc3R5bGVQcm9wLnN0clZhbHVlO1xuXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxufTtcblxuLy8gZ2V0cyB0aGUgdmFsdWUgc3R5bGUgZm9yIGFuIGVsZW1lbnQgKHVzZWZ1bCBmb3IgdGhpbmdzIGxpa2UgYW5pbWF0aW9ucylcbnN0eWZuLmdldFZhbHVlU3R5bGUgPSBmdW5jdGlvbiggZWxlICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJzdHlsZSA9IHt9O1xuICB2YXIgc3R5bGU7XG4gIHZhciBpc0VsZSA9IGlzLmVsZW1lbnQoZWxlKTtcblxuICBpZiggaXNFbGUgKXtcbiAgICBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGVsZTsgLy8ganVzdCBwYXNzZWQgdGhlIHN0eWxlIGl0c2VsZlxuICB9XG5cbiAgaWYoIHN0eWxlICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgdmFyIHN0eWxlUHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXSB8fCBzdHlsZVsgdXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXTtcblxuICAgICAgaWYoIHN0eWxlUHJvcCAhPT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gbWFrZSBhIHByb3Agb2YgaXRcbiAgICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBzdHlsZVByb3AgKSApe1xuICAgICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgc3R5bGVQcm9wLnN0clZhbHVlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBzdHlsZVByb3AgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggc3R5bGVQcm9wICl7XG4gICAgICAgIHJzdHlsZVsgcHJvcC5uYW1lIF0gPSBzdHlsZVByb3A7XG4gICAgICAgIHJzdHlsZVsgdXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXSA9IHN0eWxlUHJvcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnN0eWxlO1xufTtcblxuc3R5Zm4uZ2V0UHJvcHNMaXN0ID0gZnVuY3Rpb24oIHByb3BzT2JqICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJzdHlsZSA9IFtdO1xuICB2YXIgc3R5bGUgPSBwcm9wc09iajtcbiAgdmFyIHByb3BzID0gc2VsZi5wcm9wZXJ0aWVzO1xuXG4gIGlmKCBzdHlsZSApe1xuICAgIGZvciggdmFyIG5hbWUgaW4gc3R5bGUgKXtcbiAgICAgIHZhciB2YWwgPSBzdHlsZVtuYW1lXTtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbbmFtZV0gfHwgcHJvcHNbIHV0aWwuY2FtZWwyZGFzaChuYW1lKSBdO1xuICAgICAgdmFyIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgdmFsICk7XG5cbiAgICAgIHJzdHlsZS5wdXNoKCBzdHlsZVByb3AgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnN0eWxlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcblxufSx7XCIuLi9pc1wiOjc3LFwiLi4vdXRpbFwiOjk0fV0sODY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi9pcycpO1xudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi91dGlsJyk7XG52YXIgU2VsZWN0b3IgPSBfZGVyZXFfKCcuLi9zZWxlY3RvcicpO1xuXG52YXIgU3R5bGUgPSBmdW5jdGlvbiggY3kgKXtcblxuICBpZiggISh0aGlzIGluc3RhbmNlb2YgU3R5bGUpICl7XG4gICAgcmV0dXJuIG5ldyBTdHlsZShjeSk7XG4gIH1cblxuICBpZiggIWlzLmNvcmUoY3kpICl7XG4gICAgdXRpbC5lcnJvcignQSBzdHlsZSBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIGNvcmVTdHlsZToge30sXG4gICAgbmV3U3R5bGU6IHRydWVcbiAgfTtcblxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xufTtcblxudmFyIHN0eWZuID0gU3R5bGUucHJvdG90eXBlO1xuXG5zdHlmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAnc3R5bGUnO1xufTtcblxuLy8gcmVtb3ZlIGFsbCBjb250ZXh0c1xuc3R5Zm4uY2xlYXIgPSBmdW5jdGlvbigpe1xuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICB9XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5fcHJpdmF0ZS5uZXdTdHlsZSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5zdHlmbi5yZXNldFRvRGVmYXVsdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY2xlYXIoKTtcbiAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gYnVpbGRzIGEgc3R5bGUgb2JqZWN0IGZvciB0aGUgJ2NvcmUnIHNlbGVjdG9yXG5zdHlmbi5jb3JlID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlO1xufTtcblxuLy8gY3JlYXRlIGEgbmV3IGNvbnRleHQgZnJvbSB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yIHN0cmluZyBhbmQgc3dpdGNoIHRvIHRoYXQgY29udGV4dFxuc3R5Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiggc2VsZWN0b3JTdHIgKXtcbiAgLy8gJ2NvcmUnIGlzIGEgc3BlY2lhbCBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkIGEgc2VsZWN0b3JcbiAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JTdHIgPT09ICdjb3JlJyA/IG51bGwgOiBuZXcgU2VsZWN0b3IoIHNlbGVjdG9yU3RyICk7XG5cbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrOyAvLyBuZXcgY29udGV4dCBtZWFucyBuZXcgaW5kZXhcbiAgdGhpc1tpXSA9IHtcbiAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgcHJvcGVydGllczogW10sXG4gICAgbWFwcGVkUHJvcGVydGllczogW10sXG4gICAgaW5kZXg6IGlcbiAgfTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8vIGFkZCBvbmUgb3IgbWFueSBjc3MgcnVsZXMgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuc3R5Zm4uY3NzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICBzd2l0Y2goIGFyZ3MubGVuZ3RoICl7XG4gIGNhc2UgMTpcbiAgICB2YXIgbWFwID0gYXJnc1swXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgIHZhciBtYXBWYWwgPSBtYXBbIHByb3AubmFtZSBdO1xuXG4gICAgICBpZiggbWFwVmFsID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgbWFwVmFsID0gbWFwWyB1dGlsLmRhc2gyY2FtZWwocHJvcC5uYW1lKSBdO1xuICAgICAgfVxuXG4gICAgICBpZiggbWFwVmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5jc3NSdWxlKCBwcm9wLm5hbWUsIG1hcFZhbCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJyZWFrO1xuXG4gIGNhc2UgMjpcbiAgICB0aGlzLmNzc1J1bGUoIGFyZ3NbMF0sIGFyZ3NbMV0gKTtcbiAgICBicmVhaztcblxuICBkZWZhdWx0OlxuICAgIGJyZWFrOyAvLyBkbyBub3RoaW5nIGlmIGFyZ3MgYXJlIGludmFsaWRcbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcbnN0eWZuLnN0eWxlID0gc3R5Zm4uY3NzO1xuXG4vLyBhZGQgYSBzaW5nbGUgY3NzIHJ1bGUgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuc3R5Zm4uY3NzUnVsZSA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICAvLyBuYW1lLXZhbHVlIHBhaXJcbiAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUgKTtcblxuICAvLyBhZGQgcHJvcGVydHkgdG8gY3VycmVudCBjb250ZXh0IGlmIHZhbGlkXG4gIGlmKCBwcm9wZXJ0eSApe1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKCBwcm9wZXJ0eSApO1xuICAgIHRoaXNbaV0ucHJvcGVydGllc1sgcHJvcGVydHkubmFtZSBdID0gcHJvcGVydHk7IC8vIGFsbG93IGFjY2VzcyBieSBuYW1lIGFzIHdlbGxcblxuICAgIGlmKCBwcm9wZXJ0eS5uYW1lLm1hdGNoKC9waWUtKFxcZCspLWJhY2tncm91bmQtc2l6ZS8pICYmIHByb3BlcnR5LnZhbHVlICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmhhc1BpZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoIHByb3BlcnR5Lm1hcHBlZCApe1xuICAgICAgdGhpc1tpXS5tYXBwZWRQcm9wZXJ0aWVzLnB1c2goIHByb3BlcnR5ICk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHRvIGNvcmUgc3R5bGUgaWYgbmVjZXNzYXJ5XG4gICAgdmFyIGN1cnJlbnRTZWxlY3RvcklzQ29yZSA9ICF0aGlzW2ldLnNlbGVjdG9yO1xuICAgIGlmKCBjdXJyZW50U2VsZWN0b3JJc0NvcmUgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlWyBwcm9wZXJ0eS5uYW1lIF0gPSBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8vIHN0YXRpYyBmdW5jdGlvblxuU3R5bGUuZnJvbUpzb24gPSBmdW5jdGlvbiggY3ksIGpzb24gKXtcbiAgdmFyIHN0eWxlID0gbmV3IFN0eWxlKCBjeSApO1xuXG4gIHN0eWxlLmZyb21Kc29uKCBqc29uICk7XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuU3R5bGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKCBjeSwgc3RyaW5nICl7XG4gIHJldHVybiBuZXcgU3R5bGUoIGN5ICkuZnJvbVN0cmluZyggc3RyaW5nICk7XG59O1xuXG5bXG4gIF9kZXJlcV8oJy4vYXBwbHknKSxcbiAgX2RlcmVxXygnLi9ieXBhc3MnKSxcbiAgX2RlcmVxXygnLi9jb250YWluZXInKSxcbiAgX2RlcmVxXygnLi9nZXQtZm9yLWVsZScpLFxuICBfZGVyZXFfKCcuL2pzb24nKSxcbiAgX2RlcmVxXygnLi9zdHJpbmctc2hlZXQnKSxcbiAgX2RlcmVxXygnLi9wcm9wZXJ0aWVzJyksXG4gIF9kZXJlcV8oJy4vcGFyc2UnKVxuXS5mb3JFYWNoKGZ1bmN0aW9uKCBwcm9wcyApe1xuICB1dGlsLmV4dGVuZCggc3R5Zm4sIHByb3BzICk7XG59KTtcblxuXG5TdHlsZS50eXBlcyA9IHN0eWZuLnR5cGVzO1xuU3R5bGUucHJvcGVydGllcyA9IHN0eWZuLnByb3BlcnRpZXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGU7XG5cbn0se1wiLi4vaXNcIjo3NyxcIi4uL3NlbGVjdG9yXCI6ODEsXCIuLi91dGlsXCI6OTQsXCIuL2FwcGx5XCI6ODIsXCIuL2J5cGFzc1wiOjgzLFwiLi9jb250YWluZXJcIjo4NCxcIi4vZ2V0LWZvci1lbGVcIjo4NSxcIi4vanNvblwiOjg3LFwiLi9wYXJzZVwiOjg4LFwiLi9wcm9wZXJ0aWVzXCI6ODksXCIuL3N0cmluZy1zaGVldFwiOjkwfV0sODc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuc3R5Zm4uYXBwbHlGcm9tSnNvbiA9IGZ1bmN0aW9uKCBqc29uICl7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGNvbnRleHQgPSBqc29uW2ldO1xuICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgdmFyIHByb3BzID0gY29udGV4dC5zdHlsZSB8fCBjb250ZXh0LmNzcztcblxuICAgIHN0eWxlLnNlbGVjdG9yKCBzZWxlY3RvciApOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgZm9yKCB2YXIgbmFtZSBpbiBwcm9wcyApe1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbbmFtZV07XG5cbiAgICAgIHN0eWxlLmNzcyggbmFtZSwgdmFsdWUgKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBhY2Nlc3NpYmxlIGN5LnN0eWxlKCkgZnVuY3Rpb25cbnN0eWZuLmZyb21Kc29uID0gZnVuY3Rpb24oIGpzb24gKXtcbiAgdmFyIHN0eWxlID0gdGhpcztcblxuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBseUZyb21Kc29uKCBqc29uICk7XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuLy8gZ2V0IGpzb24gZnJvbSBjeS5zdHlsZSgpIGFwaVxuc3R5Zm4uanNvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBqc29uID0gW107XG5cbiAgZm9yKCB2YXIgaSA9IHRoaXMuZGVmYXVsdExlbmd0aDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgY3h0ID0gdGhpc1tpXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBjeHQuc2VsZWN0b3I7XG4gICAgdmFyIHByb3BzID0gY3h0LnByb3BlcnRpZXM7XG4gICAgdmFyIGNzcyA9IHt9O1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgIGNzc1sgcHJvcC5uYW1lIF0gPSBwcm9wLnN0clZhbHVlO1xuICAgIH1cblxuICAgIGpzb24ucHVzaCh7XG4gICAgICBzZWxlY3RvcjogIXNlbGVjdG9yID8gJ2NvcmUnIDogc2VsZWN0b3IudG9TdHJpbmcoKSxcbiAgICAgIHN0eWxlOiBjc3NcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBqc29uO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcblxufSx7fV0sODg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uL3V0aWwnKTtcbnZhciBpcyA9IF9kZXJlcV8oJy4uL2lzJyk7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG4vLyBhIGNhY2hpbmcgbGF5ZXIgZm9yIHByb3BlcnR5IHBhcnNpbmdcbnN0eWZuLnBhcnNlID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKXtcbiAgdmFyIGFyZ0hhc2ggPSBbIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgXS5qb2luKCckJyk7XG4gIHZhciBwcm9wQ2FjaGUgPSB0aGlzLnByb3BDYWNoZSA9IHRoaXMucHJvcENhY2hlIHx8IHt9O1xuICB2YXIgcmV0O1xuICB2YXIgaW1wbCA9IHBhcnNlSW1wbC5iaW5kKCB0aGlzICk7XG5cbiAgaWYoICEocmV0ID0gcHJvcENhY2hlW2FyZ0hhc2hdKSApe1xuICAgIHJldCA9IHByb3BDYWNoZVthcmdIYXNoXSA9IGltcGwoIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKTtcbiAgfVxuXG4gIC8vIGFsd2F5cyBuZWVkIGEgY29weSBzaW5jZSBwcm9wcyBhcmUgbXV0YXRlZCBsYXRlciBpbiB0aGVpciBsaWZlY3ljbGVzXG4gIHJldCA9IHV0aWwuY29weSggcmV0ICk7XG5cbiAgaWYoIHJldCApe1xuICAgIHJldC52YWx1ZSA9IHV0aWwuY29weSggcmV0LnZhbHVlICk7IC8vIGJlY2F1c2UgaXQgY291bGQgYmUgYW4gYXJyYXksIGUuZy4gY29sb3VyXG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLy8gcGFyc2UgYSBwcm9wZXJ0eTsgcmV0dXJuIG51bGwgb24gaW52YWxpZDsgcmV0dXJuIHBhcnNlZCBwcm9wZXJ0eSBvdGhlcndpc2Vcbi8vIGZpZWxkcyA6XG4vLyAtIG5hbWUgOiB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbi8vIC0gdmFsdWUgOiB0aGUgcGFyc2VkLCBuYXRpdmUtdHlwZWQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4vLyAtIHN0clZhbHVlIDogYSBzdHJpbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpbiB2YWxpZCBjc3Ncbi8vIC0gYnlwYXNzIDogdHJ1ZSBpZmYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5XG52YXIgcGFyc2VJbXBsID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIG5hbWUgPSB1dGlsLmNhbWVsMmRhc2goIG5hbWUgKTsgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBuYW1lIGlzIGluIGRhc2ggZm9ybSAoZS5nLiAncHJvcGVydHktbmFtZScgbm90ICdwcm9wZXJ0eU5hbWUnKVxuXG4gIHZhciBwcm9wZXJ0eSA9IHNlbGYucHJvcGVydGllc1sgbmFtZSBdO1xuICB2YXIgcGFzc2VkVmFsdWUgPSB2YWx1ZTtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcblxuICBpZiggIXByb3BlcnR5ICl7IHJldHVybiBudWxsOyB9IC8vIHJldHVybiBudWxsIG9uIHByb3BlcnR5IG9mIHVua25vd24gbmFtZVxuICBpZiggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCApeyByZXR1cm4gbnVsbDsgfSAvLyBjYW4ndCBhc3NpZ24gbnVsbFxuXG4gIC8vIHRoZSBwcm9wZXJ0eSBtYXkgYmUgYW4gYWxpYXNcbiAgaWYoIHByb3BlcnR5LmFsaWFzICl7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5wb2ludHNUbztcbiAgICBuYW1lID0gcHJvcGVydHkubmFtZTtcbiAgfVxuXG4gIHZhciB2YWx1ZUlzU3RyaW5nID0gaXMuc3RyaW5nKHZhbHVlKTtcbiAgaWYoIHZhbHVlSXNTdHJpbmcgKXsgLy8gdHJpbSB0aGUgdmFsdWUgdG8gbWFrZSBwYXJzaW5nIGVhc2llclxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBwcm9wZXJ0eS50eXBlO1xuICBpZiggIXR5cGUgKXsgcmV0dXJuIG51bGw7IH0gLy8gbm8gdHlwZSwgbm8gbHVja1xuXG4gIC8vIGNoZWNrIGlmIGJ5cGFzcyBpcyBudWxsIG9yIGVtcHR5IHN0cmluZyAoaS5lLiBpbmRpY2F0aW9uIHRvIGRlbGV0ZSBieXBhc3MgcHJvcGVydHkpXG4gIGlmKCBwcm9wSXNCeXBhc3MgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gbnVsbCkgKXtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGJ5cGFzczogdHJ1ZSxcbiAgICAgIGRlbGV0ZUJ5cGFzczogdHJ1ZVxuICAgIH07XG4gIH1cblxuICAvLyBjaGVjayBpZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uIHVzZWQgYXMgYSBtYXBwZXJcbiAgaWYoIGlzLmZuKHZhbHVlKSApe1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgc3RyVmFsdWU6ICdmbicsXG4gICAgICBtYXBwZWQ6IHR5cGVzLmZuLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgdmFsdWUgaXMgbWFwcGVkXG4gIHZhciBkYXRhLCBtYXBEYXRhLCBsYXlvdXREYXRhLCBtYXBMYXlvdXREYXRhLCBzY3JhdGNoLCBtYXBTY3JhdGNoO1xuICBpZiggIXZhbHVlSXNTdHJpbmcgfHwgcHJvcElzRmxhdCApe1xuICAgIC8vIHRoZW4gZG9uJ3QgYm90aGVyIHRvIGRvIHRoZSBleHBlbnNpdmUgcmVnZXggY2hlY2tzXG5cbiAgfSBlbHNlIGlmKFxuICAgICggZGF0YSA9IG5ldyBSZWdFeHAoIHR5cGVzLmRhdGEucmVnZXggKS5leGVjKCB2YWx1ZSApICkgfHxcbiAgICAoIGxheW91dERhdGEgPSBuZXcgUmVnRXhwKCB0eXBlcy5sYXlvdXREYXRhLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApIHx8XG4gICAgKCBzY3JhdGNoID0gbmV3IFJlZ0V4cCggdHlwZXMuc2NyYXRjaC5yZWdleCApLmV4ZWMoIHZhbHVlICkgKVxuICApe1xuICAgIGlmKCBwcm9wSXNCeXBhc3MgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG5cbiAgICB2YXIgbWFwcGVkO1xuICAgIGlmKCBkYXRhICl7XG4gICAgICBtYXBwZWQgPSB0eXBlcy5kYXRhO1xuICAgIH0gZWxzZSBpZiggbGF5b3V0RGF0YSApe1xuICAgICAgbWFwcGVkID0gdHlwZXMubGF5b3V0RGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwcGVkID0gdHlwZXMuc2NyYXRjaDtcbiAgICB9XG5cbiAgICBkYXRhID0gZGF0YSB8fCBsYXlvdXREYXRhIHx8IHNjcmF0Y2g7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBtYXBwZWQ6IG1hcHBlZCxcbiAgICAgIGZpZWxkOiBkYXRhWzFdLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuXG4gIH0gZWxzZSBpZihcbiAgICAoIG1hcERhdGEgPSBuZXcgUmVnRXhwKCB0eXBlcy5tYXBEYXRhLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApIHx8XG4gICAgKCBtYXBMYXlvdXREYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMubWFwTGF5b3V0RGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICggbWFwU2NyYXRjaCA9IG5ldyBSZWdFeHAoIHR5cGVzLm1hcFNjcmF0Y2gucmVnZXggKS5leGVjKCB2YWx1ZSApIClcbiAgKXtcbiAgICBpZiggcHJvcElzQnlwYXNzICl7IHJldHVybiBmYWxzZTsgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuICAgIGlmKCB0eXBlLm11bHRpcGxlICl7IHJldHVybiBmYWxzZTsgfSAvLyBpbXBvc3NpYmxlIHRvIG1hcCB0byBudW1cblxuICAgIHZhciBtYXBwZWQ7XG4gICAgaWYoIG1hcERhdGEgKXtcbiAgICAgIG1hcHBlZCA9IHR5cGVzLm1hcERhdGE7XG4gICAgfSBlbHNlIGlmKCBtYXBMYXlvdXREYXRhICl7XG4gICAgICBtYXBwZWQgPSB0eXBlcy5tYXBMYXlvdXREYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXBwZWQgPSB0eXBlcy5tYXBTY3JhdGNoO1xuICAgIH1cblxuICAgIG1hcERhdGEgPSBtYXBEYXRhIHx8IG1hcExheW91dERhdGEgfHwgbWFwU2NyYXRjaDtcblxuICAgIC8vIHdlIGNhbiBtYXAgb25seSBpZiB0aGUgdHlwZSBpcyBhIGNvbG91ciBvciBhIG51bWJlclxuICAgIGlmKCAhKHR5cGUuY29sb3IgfHwgdHlwZS5udW1iZXIpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgdmFyIHZhbHVlTWluID0gdGhpcy5wYXJzZSggbmFtZSwgbWFwRGF0YVs0XSApOyAvLyBwYXJzZSB0byB2YWxpZGF0ZVxuICAgIGlmKCAhdmFsdWVNaW4gfHwgdmFsdWVNaW4ubWFwcGVkICl7IHJldHVybiBmYWxzZTsgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuXG4gICAgdmFyIHZhbHVlTWF4ID0gdGhpcy5wYXJzZSggbmFtZSwgbWFwRGF0YVs1XSApOyAvLyBwYXJzZSB0byB2YWxpZGF0ZVxuICAgIGlmKCAhdmFsdWVNYXggfHwgdmFsdWVNYXgubWFwcGVkICl7IHJldHVybiBmYWxzZTsgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuXG4gICAgLy8gY2hlY2sgaWYgdmFsdWVNaW4gYW5kIHZhbHVlTWF4IGFyZSB0aGUgc2FtZVxuICAgIGlmKCB2YWx1ZU1pbi52YWx1ZSA9PT0gdmFsdWVNYXgudmFsdWUgKXtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gY2FuJ3QgbWFrZSBtdWNoIG9mIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuXG4gICAgfSBlbHNlIGlmKCB0eXBlLmNvbG9yICl7XG4gICAgICB2YXIgYzEgPSB2YWx1ZU1pbi52YWx1ZTtcbiAgICAgIHZhciBjMiA9IHZhbHVlTWF4LnZhbHVlO1xuXG4gICAgICB2YXIgc2FtZSA9IGMxWzBdID09PSBjMlswXSAvLyByZWRcbiAgICAgICAgJiYgYzFbMV0gPT09IGMyWzFdIC8vIGdyZWVuXG4gICAgICAgICYmIGMxWzJdID09PSBjMlsyXSAvLyBibHVlXG4gICAgICAgICYmICggLy8gb3B0aW9uYWwgYWxwaGFcbiAgICAgICAgICBjMVszXSA9PT0gYzJbM10gLy8gc2FtZSBhbHBoYSBvdXRyaWdodFxuICAgICAgICAgIHx8IChcbiAgICAgICAgICAgIChjMVszXSA9PSBudWxsIHx8IGMxWzNdID09PSAxKSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAxP1xuICAgICAgICAgICAgJiZcbiAgICAgICAgICAgIChjMlszXSA9PSBudWxsIHx8IGMyWzNdID09PSAxKSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAyP1xuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgO1xuXG4gICAgICBpZiggc2FtZSApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgbWFrZSBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBtYXBEYXRhLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBtYXBwZWQ6IG1hcHBlZCxcbiAgICAgIGZpZWxkOiBtYXBEYXRhWzFdLFxuICAgICAgZmllbGRNaW46IHBhcnNlRmxvYXQoIG1hcERhdGFbMl0gKSwgLy8gbWluICYgbWF4IGFyZSBudW1lcmljXG4gICAgICBmaWVsZE1heDogcGFyc2VGbG9hdCggbWFwRGF0YVszXSApLFxuICAgICAgdmFsdWVNaW46IHZhbHVlTWluLnZhbHVlLFxuICAgICAgdmFsdWVNYXg6IHZhbHVlTWF4LnZhbHVlLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9XG5cbiAgaWYoIHR5cGUubXVsdGlwbGUgJiYgcHJvcElzRmxhdCAhPT0gJ211bHRpcGxlJyApe1xuICAgIHZhciB2YWxzO1xuXG4gICAgaWYoIHZhbHVlSXNTdHJpbmcgKXtcbiAgICAgIHZhbHMgPSB2YWx1ZS5zcGxpdCgvXFxzKy8pO1xuICAgIH0gZWxzZSBpZiggaXMuYXJyYXkodmFsdWUpICl7XG4gICAgICB2YWxzID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHMgPSBbIHZhbHVlIF07XG4gICAgfVxuXG4gICAgaWYoIHR5cGUuZXZlbk11bHRpcGxlICYmIHZhbHMubGVuZ3RoICUgMiAhPT0gMCApeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgdmFyIHZhbEFyciA9IHZhbHMubWFwKGZ1bmN0aW9uKCB2ICl7XG4gICAgICB2YXIgcCA9IHNlbGYucGFyc2UoIG5hbWUsIHYsIHByb3BJc0J5cGFzcywgJ211bHRpcGxlJyApO1xuXG4gICAgICBpZiggcC5wZlZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIHAucGZWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwLnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsQXJyLFxuICAgICAgcGZWYWx1ZTogdmFsQXJyLFxuICAgICAgc3RyVmFsdWU6IHZhbEFyci5qb2luKCcgJyksXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzcyxcbiAgICAgIHVuaXRzOiB0eXBlLm51bWJlciAmJiAhdHlwZS51bml0bGVzcyA/IHR5cGUuaW1wbGljaXRVbml0cyB8fCAncHgnIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8vIHNldmVyYWwgdHlwZXMgYWxzbyBhbGxvdyBlbnVtc1xuICB2YXIgY2hlY2tFbnVtcyA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0eXBlLmVudW1zLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZW4gPSB0eXBlLmVudW1zW2ldO1xuXG4gICAgICBpZiggZW4gPT09IHZhbHVlICl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvLyBjaGVjayB0aGUgdHlwZSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBvYmplY3RcbiAgaWYoIHR5cGUubnVtYmVyICl7XG4gICAgdmFyIHVuaXRzO1xuICAgIHZhciBpbXBsaWNpdFVuaXRzID0gJ3B4JzsgLy8gbm90IHNldCA9PiBweFxuXG4gICAgaWYoIHR5cGUudW5pdHMgKXsgLy8gdXNlIHNwZWNpZmllZCB1bml0cyBpZiBzZXRcbiAgICAgIHVuaXRzID0gdHlwZS51bml0cztcbiAgICB9XG5cbiAgICBpZiggdHlwZS5pbXBsaWNpdFVuaXRzICl7XG4gICAgICBpbXBsaWNpdFVuaXRzID0gdHlwZS5pbXBsaWNpdFVuaXRzO1xuICAgIH1cblxuICAgIGlmKCAhdHlwZS51bml0bGVzcyApe1xuICAgICAgaWYoIHZhbHVlSXNTdHJpbmcgKXtcbiAgICAgICAgdmFyIHVuaXRzUmVnZXggPSAncHh8ZW0nICsgKHR5cGUuYWxsb3dQZXJjZW50ID8gJ3xcXFxcJScgOiAnJyk7XG4gICAgICAgIGlmKCB1bml0cyApeyB1bml0c1JlZ2V4ID0gdW5pdHM7IH0gLy8gb25seSBhbGxvdyBleHBsaWNpdCB1bml0cyBpZiBzbyBzZXRcbiAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2goICdeKCcgKyB1dGlsLnJlZ2V4Lm51bWJlciArICcpKCcgKyB1bml0c1JlZ2V4ICsgJyk/JyArICckJyApO1xuXG4gICAgICAgIGlmKCBtYXRjaCApe1xuICAgICAgICAgIHZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgICAgdW5pdHMgPSBtYXRjaFsyXSB8fCBpbXBsaWNpdFVuaXRzO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiggIXVuaXRzIHx8IHR5cGUuaW1wbGljaXRVbml0cyApIHtcbiAgICAgICAgdW5pdHMgPSBpbXBsaWNpdFVuaXRzOyAvLyBpbXBsaWNpdGx5IHB4IGlmIHVuc3BlY2lmaWVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsdWUgPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuXG4gICAgLy8gaWYgbm90IGEgbnVtYmVyIGFuZCBlbnVtcyBub3QgYWxsb3dlZCwgdGhlbiB0aGUgdmFsdWUgaXMgaW52YWxpZFxuICAgIGlmKCBpc05hTih2YWx1ZSkgJiYgdHlwZS5lbnVtcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIG51bWJlciB0eXBlIGFsc28gYWNjZXB0cyBzcGVjaWFsIGtleXdvcmRzIGluIHBsYWNlIG9mIG51bWJlcnNcbiAgICAvLyAoaS5lLiBgbGVmdGAsIGBhdXRvYCwgZXRjKVxuICAgIGlmKCBpc05hTih2YWx1ZSkgJiYgdHlwZS5lbnVtcyAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB2YWx1ZSA9IHBhc3NlZFZhbHVlO1xuXG4gICAgICByZXR1cm4gY2hlY2tFbnVtcygpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHZhbHVlIG11c3QgYmUgYW4gaW50ZWdlclxuICAgIGlmKCB0eXBlLmludGVnZXIgJiYgIWlzLmludGVnZXIodmFsdWUpICl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB2YWx1ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICBpZiggKHR5cGUubWluICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCB0eXBlLm1pbilcbiAgICB8fCAodHlwZS5tYXggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+IHR5cGUubWF4KVxuICAgICl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlICsgKHVuaXRzID8gdW5pdHMgOiAnJyksXG4gICAgICB1bml0czogdW5pdHMsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG5cbiAgICAvLyBub3JtYWxpc2UgdmFsdWUgaW4gcGl4ZWxzXG4gICAgaWYoIHR5cGUudW5pdGxlc3MgfHwgKHVuaXRzICE9PSAncHgnICYmIHVuaXRzICE9PSAnZW0nKSApe1xuICAgICAgcmV0LnBmVmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnBmVmFsdWUgPSAoIHVuaXRzID09PSAncHgnIHx8ICF1bml0cyA/ICh2YWx1ZSkgOiAodGhpcy5nZXRFbVNpemVJblBpeGVscygpICogdmFsdWUpICk7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIG1zXG4gICAgaWYoIHVuaXRzID09PSAnbXMnIHx8IHVuaXRzID09PSAncycgKXtcbiAgICAgIHJldC5wZlZhbHVlID0gdW5pdHMgPT09ICdtcycgPyB2YWx1ZSA6IDEwMDAgKiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpc2UgdmFsdWUgaW4gcmFkXG4gICAgaWYoIHVuaXRzID09PSAnZGVnJyB8fCB1bml0cyA9PT0gJ3JhZCcgKXtcbiAgICAgIHJldC5wZlZhbHVlID0gdW5pdHMgPT09ICdyYWQnID8gdmFsdWUgOiB2YWx1ZSAqIE1hdGguUEkvMTgwO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG5cbiAgfSBlbHNlIGlmKCB0eXBlLnByb3BMaXN0ICkge1xuXG4gICAgdmFyIHByb3BzID0gW107XG4gICAgdmFyIHByb3BzU3RyID0gJycgKyB2YWx1ZTtcblxuICAgIGlmKCBwcm9wc1N0ciA9PT0gJ25vbmUnICl7XG4gICAgICAvLyBsZWF2ZSBlbXB0eVxuXG4gICAgfSBlbHNlIHsgLy8gZ28gb3ZlciBlYWNoIHByb3BcblxuICAgICAgdmFyIHByb3BzU3BsaXQgPSBwcm9wc1N0ci5zcGxpdCgnLCcpO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wc1NwbGl0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BzU3BsaXRbaV0udHJpbSgpO1xuXG4gICAgICAgIGlmKCBzZWxmLnByb3BlcnRpZXNbcHJvcE5hbWVdICl7XG4gICAgICAgICAgcHJvcHMucHVzaCggcHJvcE5hbWUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggcHJvcHMubGVuZ3RoID09PSAwICl7IHJldHVybiBudWxsOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogcHJvcHMsXG4gICAgICBzdHJWYWx1ZTogcHJvcHMubGVuZ3RoID09PSAwID8gJ25vbmUnIDogcHJvcHMuam9pbignLCAnKSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcblxuICB9IGVsc2UgaWYoIHR5cGUuY29sb3IgKXtcbiAgICB2YXIgdHVwbGUgPSB1dGlsLmNvbG9yMnR1cGxlKCB2YWx1ZSApO1xuXG4gICAgaWYoICF0dXBsZSApeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdHVwbGUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgcm91bmRWYWx1ZTogdHJ1ZVxuICAgIH07XG5cbiAgfSBlbHNlIGlmKCB0eXBlLnJlZ2V4IHx8IHR5cGUucmVnZXhlcyApe1xuXG4gICAgLy8gZmlyc3QgY2hlY2sgZW51bXNcbiAgICBpZiggdHlwZS5lbnVtcyApe1xuICAgICAgdmFyIGVudW1Qcm9wID0gY2hlY2tFbnVtcygpO1xuXG4gICAgICBpZiggZW51bVByb3AgKXsgcmV0dXJuIGVudW1Qcm9wOyB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2V4ZXMgPSB0eXBlLnJlZ2V4ZXMgPyB0eXBlLnJlZ2V4ZXMgOiBbIHR5cGUucmVnZXggXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcmVnZXhlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCggcmVnZXhlc1tpXSApOyAvLyBtYWtlIGEgcmVnZXggZnJvbSB0aGUgdHlwZSBzdHJpbmdcbiAgICAgIHZhciBtID0gcmVnZXguZXhlYyggdmFsdWUgKTtcblxuICAgICAgaWYoIG0gKXsgLy8gcmVnZXggbWF0Y2hlc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IG0sXG4gICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcblxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsOyAvLyBkaWRuJ3QgbWF0Y2ggYW55XG5cbiAgfSBlbHNlIGlmKCB0eXBlLnN0cmluZyApe1xuICAgIC8vIGp1c3QgcmV0dXJuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcblxuICB9IGVsc2UgaWYoIHR5cGUuZW51bXMgKXsgLy8gY2hlY2sgZW51bXMgbGFzdCBiZWNhdXNlIGl0J3MgYSBjb21ibyB0eXBlIGluIG90aGVyc1xuICAgIHJldHVybiBjaGVja0VudW1zKCk7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm90IGEgdHlwZSB3ZSBjYW4gaGFuZGxlXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcblxufSx7XCIuLi9pc1wiOjc3LFwiLi4vdXRpbFwiOjk0fV0sODk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IF9kZXJlcV8oJy4uL3V0aWwnKTtcblxudmFyIHN0eWZuID0ge307XG5cbihmdW5jdGlvbigpe1xuICB2YXIgbnVtYmVyID0gdXRpbC5yZWdleC5udW1iZXI7XG4gIHZhciByZ2JhID0gdXRpbC5yZWdleC5yZ2JhTm9CYWNrUmVmcztcbiAgdmFyIGhzbGEgPSB1dGlsLnJlZ2V4LmhzbGFOb0JhY2tSZWZzO1xuICB2YXIgaGV4MyA9IHV0aWwucmVnZXguaGV4MztcbiAgdmFyIGhleDYgPSB1dGlsLnJlZ2V4LmhleDY7XG4gIHZhciBkYXRhID0gZnVuY3Rpb24oIHByZWZpeCApeyByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoXFxcXHMqKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCkkJzsgfTtcbiAgdmFyIG1hcERhdGEgPSBmdW5jdGlvbiggcHJlZml4ICl7XG4gICAgdmFyIG1hcEFyZyA9IG51bWJlciArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMgKyAnfCcgKyBoZXg2O1xuICAgIHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXCgoW1xcXFx3XFxcXC5dKylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBtYXBBcmcgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBtYXBBcmcgKyAnKVxcXFwpJCc7XG4gIH07XG5cbiAgLy8gZWFjaCB2aXN1YWwgc3R5bGUgcHJvcGVydHkgaGFzIGEgdHlwZSBhbmQgbmVlZHMgdG8gYmUgdmFsaWRhdGVkIGFjY29yZGluZyB0byBpdFxuICBzdHlmbi50eXBlcyA9IHtcbiAgICB0aW1lOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCB1bml0czogJ3N8bXMnLCBpbXBsaWNpdFVuaXRzOiAnbXMnIH0sXG4gICAgcGVyY2VudDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgbWF4OiAxMDAsIHVuaXRzOiAnJScsIGltcGxpY2l0VW5pdHM6ICclJyB9LFxuICAgIHplcm9PbmVOdW1iZXI6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIG1heDogMSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICBuT25lT25lTnVtYmVyOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAtMSwgbWF4OiAxLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgIG5vbk5lZ2F0aXZlSW50OiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBpbnRlZ2VyOiB0cnVlLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgIHBvc2l0aW9uOiB7IGVudW1zOiBbJ3BhcmVudCcsICdvcmlnaW4nXSB9LFxuICAgIG5vZGVTaXplOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBlbnVtczogWydhdXRvJywgJ2xhYmVsJ10gfSxcbiAgICBudW1iZXI6IHsgbnVtYmVyOiB0cnVlLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgIG51bWJlcnM6IHsgbnVtYmVyOiB0cnVlLCB1bml0bGVzczogdHJ1ZSwgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBzaXplOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwIH0sXG4gICAgYmlkaXJlY3Rpb25hbFNpemU6IHsgbnVtYmVyOiB0cnVlIH0sIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgIGJpZGlyZWN0aW9uYWxTaXplczogeyBudW1iZXI6IHRydWUsIG11bHRpcGxlOiB0cnVlIH0sIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgIGJnU2l6ZTogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgYWxsb3dQZXJjZW50OiB0cnVlIH0sXG4gICAgYmdXSDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgYWxsb3dQZXJjZW50OiB0cnVlLCBlbnVtczogWydhdXRvJ10gfSxcbiAgICBiZ1BvczogeyBudW1iZXI6IHRydWUsIGFsbG93UGVyY2VudDogdHJ1ZSB9LFxuICAgIGJnUmVwZWF0OiB7IGVudW1zOiBbJ3JlcGVhdCcsICdyZXBlYXQteCcsICdyZXBlYXQteScsICduby1yZXBlYXQnXSB9LFxuICAgIGJnRml0OiB7IGVudW1zOiBbJ25vbmUnLCAnY29udGFpbicsICdjb3ZlciddIH0sXG4gICAgYmdDbGlwOiB7IGVudW1zOiBbJ25vbmUnLCAnbm9kZSddIH0sXG4gICAgY29sb3I6IHsgY29sb3I6IHRydWUgfSxcbiAgICBib29sOiB7IGVudW1zOiBbJ3llcycsICdubyddIH0sXG4gICAgbGluZVN0eWxlOiB7IGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnXSB9LFxuICAgIGJvcmRlclN0eWxlOiB7IGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnLCAnZG91YmxlJ10gfSxcbiAgICBjdXJ2ZVN0eWxlOiB7IGVudW1zOiBbJ2JlemllcicsICd1bmJ1bmRsZWQtYmV6aWVyJywgJ2hheXN0YWNrJywgJ3NlZ21lbnRzJ10gfSxcbiAgICBmb250RmFtaWx5OiB7IHJlZ2V4OiAnXihbXFxcXHctIFxcXFxcIl0rKD86XFxcXHMqLFxcXFxzKltcXFxcdy0gXFxcXFwiXSspKikkJyB9LFxuICAgIGZvbnRWYXJpYW50OiB7IGVudW1zOiBbJ3NtYWxsLWNhcHMnLCAnbm9ybWFsJ10gfSxcbiAgICBmb250U3R5bGU6IHsgZW51bXM6IFsnaXRhbGljJywgJ25vcm1hbCcsICdvYmxpcXVlJ10gfSxcbiAgICBmb250V2VpZ2h0OiB7IGVudW1zOiBbJ25vcm1hbCcsICdib2xkJywgJ2JvbGRlcicsICdsaWdodGVyJywgJzEwMCcsICcyMDAnLCAnMzAwJywgJzQwMCcsICc1MDAnLCAnNjAwJywgJzgwMCcsICc5MDAnLCAxMDAsIDIwMCwgMzAwLCA0MDAsIDUwMCwgNjAwLCA3MDAsIDgwMCwgOTAwXSB9LFxuICAgIHRleHREZWNvcmF0aW9uOiB7IGVudW1zOiBbJ25vbmUnLCAndW5kZXJsaW5lJywgJ292ZXJsaW5lJywgJ2xpbmUtdGhyb3VnaCddIH0sXG4gICAgdGV4dFRyYW5zZm9ybTogeyBlbnVtczogWydub25lJywgJ3VwcGVyY2FzZScsICdsb3dlcmNhc2UnXSB9LFxuICAgIHRleHRXcmFwOiB7IGVudW1zOiBbJ25vbmUnLCAnd3JhcCddIH0sXG4gICAgdGV4dEJhY2tncm91bmRTaGFwZTogeyBlbnVtczogWydyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnXX0sXG4gICAgbm9kZVNoYXBlOiB7IGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScsICdlbGxpcHNlJywgJ3RyaWFuZ2xlJywgJ3NxdWFyZScsICdwZW50YWdvbicsICdoZXhhZ29uJywgJ2hlcHRhZ29uJywgJ29jdGFnb24nLCAnc3RhcicsICdkaWFtb25kJywgJ3ZlZScsICdyaG9tYm9pZCcsICdwb2x5Z29uJ10gfSxcbiAgICBjb21wb3VuZEluY2x1ZGVMYWJlbHM6IHsgZW51bXM6IFsnaW5jbHVkZScsICdleGNsdWRlJ10gfSxcbiAgICBhcnJvd1NoYXBlOiB7IGVudW1zOiBbJ3RlZScsICd0cmlhbmdsZScsICd0cmlhbmdsZS10ZWUnLCAndHJpYW5nbGUtYmFja2N1cnZlJywgJ2hhbGYtdHJpYW5nbGUtb3ZlcnNob3QnLCAndmVlJywgJ3NxdWFyZScsICdjaXJjbGUnLCAnZGlhbW9uZCcsICdub25lJ10gfSxcbiAgICBhcnJvd0ZpbGw6IHsgZW51bXM6IFsnZmlsbGVkJywgJ2hvbGxvdyddIH0sXG4gICAgZGlzcGxheTogeyBlbnVtczogWydlbGVtZW50JywgJ25vbmUnXSB9LFxuICAgIHZpc2liaWxpdHk6IHsgZW51bXM6IFsnaGlkZGVuJywgJ3Zpc2libGUnXSB9LFxuICAgIHZhbGlnbjogeyBlbnVtczogWyd0b3AnLCAnY2VudGVyJywgJ2JvdHRvbSddIH0sXG4gICAgaGFsaWduOiB7IGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J10gfSxcbiAgICB0ZXh0OiB7IHN0cmluZzogdHJ1ZSB9LFxuICAgIGRhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoJ2RhdGEnKSB9LFxuICAgIGxheW91dERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoJ2xheW91dERhdGEnKSB9LFxuICAgIHNjcmF0Y2g6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoJ3NjcmF0Y2gnKSB9LFxuICAgIG1hcERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoJ21hcERhdGEnKSB9LFxuICAgIG1hcExheW91dERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoJ21hcExheW91dERhdGEnKSB9LFxuICAgIG1hcFNjcmF0Y2g6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoJ21hcFNjcmF0Y2gnKSB9LFxuICAgIGZuOiB7IG1hcHBpbmc6IHRydWUsIGZuOiB0cnVlIH0sXG4gICAgdXJsOiB7IHJlZ2V4OiAnXnVybFxcXFxzKlxcXFwoXFxcXHMqKFteXFxcXHNdKylcXFxccypcXFxccypcXFxcKXxub25lfCguKykkJyB9LFxuICAgIHByb3BMaXN0OiB7IHByb3BMaXN0OiB0cnVlIH0sXG4gICAgYW5nbGU6IHsgbnVtYmVyOiB0cnVlLCB1bml0czogJ2RlZ3xyYWQnLCBpbXBsaWNpdFVuaXRzOiAncmFkJyB9LFxuICAgIHRleHRSb3RhdGlvbjogeyBlbnVtczogWydub25lJywgJ2F1dG9yb3RhdGUnXSB9LFxuICAgIHBvbHlnb25Qb2ludExpc3Q6IHsgbnVtYmVyOiB0cnVlLCBtdWx0aXBsZTogdHJ1ZSwgZXZlbk11bHRpcGxlOiB0cnVlLCBtaW46IC0xLCBtYXg6IDEsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgZWFzaW5nOiB7XG4gICAgICByZWdleGVzOiBbXG4gICAgICAgICdeKHNwcmluZylcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpJCcsXG4gICAgICAgICdeKGN1YmljLWJlemllcilcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSQnXG4gICAgICBdLFxuICAgICAgZW51bXM6IFtcbiAgICAgICAgJ2xpbmVhcicsXG4gICAgICAgICdlYXNlJywgJ2Vhc2UtaW4nLCAnZWFzZS1vdXQnLCAnZWFzZS1pbi1vdXQnLFxuICAgICAgICAnZWFzZS1pbi1zaW5lJywgJ2Vhc2Utb3V0LXNpbmUnLCAnZWFzZS1pbi1vdXQtc2luZScsXG4gICAgICAgICdlYXNlLWluLXF1YWQnLCAnZWFzZS1vdXQtcXVhZCcsICdlYXNlLWluLW91dC1xdWFkJyxcbiAgICAgICAgJ2Vhc2UtaW4tY3ViaWMnLCAnZWFzZS1vdXQtY3ViaWMnLCAnZWFzZS1pbi1vdXQtY3ViaWMnLFxuICAgICAgICAnZWFzZS1pbi1xdWFydCcsICdlYXNlLW91dC1xdWFydCcsICdlYXNlLWluLW91dC1xdWFydCcsXG4gICAgICAgICdlYXNlLWluLXF1aW50JywgJ2Vhc2Utb3V0LXF1aW50JywgJ2Vhc2UtaW4tb3V0LXF1aW50JyxcbiAgICAgICAgJ2Vhc2UtaW4tZXhwbycsICdlYXNlLW91dC1leHBvJywgJ2Vhc2UtaW4tb3V0LWV4cG8nLFxuICAgICAgICAnZWFzZS1pbi1jaXJjJywgJ2Vhc2Utb3V0LWNpcmMnLCAnZWFzZS1pbi1vdXQtY2lyYydcbiAgICAgIF1cbiAgICB9XG4gIH07XG5cbiAgLy8gZGVmaW5lIHZpc3VhbCBzdHlsZSBwcm9wZXJ0aWVzXG4gIHZhciB0ID0gc3R5Zm4udHlwZXM7XG4gIHZhciBwcm9wcyA9IHN0eWZuLnByb3BlcnRpZXMgPSBbXG4gICAgLy8gbGFiZWxzXG4gICAgeyBuYW1lOiAndGV4dC12YWxpZ24nLCB0eXBlOiB0LnZhbGlnbiB9LFxuICAgIHsgbmFtZTogJ3RleHQtaGFsaWduJywgdHlwZTogdC5oYWxpZ24gfSxcbiAgICB7IG5hbWU6ICdjb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICdsYWJlbCcsIHR5cGU6IHQudGV4dCB9LFxuICAgIHsgbmFtZTogJ3RleHQtb3V0bGluZS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LW91dGxpbmUtd2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LW91dGxpbmUtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3RleHQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3RleHQtYm9yZGVyLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWJvcmRlci1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWJvcmRlci13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ3RleHQtYm9yZGVyLXN0eWxlJywgdHlwZTogdC5ib3JkZXJTdHlsZSB9LFxuICAgIHsgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1zaGFwZScsIHR5cGU6IHQudGV4dEJhY2tncm91bmRTaGFwZX0sXG4gICAgLy8geyBuYW1lOiAndGV4dC1kZWNvcmF0aW9uJywgdHlwZTogdC50ZXh0RGVjb3JhdGlvbiB9LCAvLyBub3Qgc3VwcG9ydGVkIGluIGNhbnZhc1xuICAgIHsgbmFtZTogJ3RleHQtdHJhbnNmb3JtJywgdHlwZTogdC50ZXh0VHJhbnNmb3JtIH0sXG4gICAgeyBuYW1lOiAndGV4dC13cmFwJywgdHlwZTogdC50ZXh0V3JhcCB9LFxuICAgIHsgbmFtZTogJ3RleHQtbWF4LXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAndGV4dC1ldmVudHMnLCB0eXBlOiB0LmJvb2wgfSxcblxuICAgIC8vIHsgbmFtZTogJ3RleHQtcm90YXRpb24nLCB0eXBlOiB0LmFuZ2xlIH0sIC8vIFRPRE8gZGlzYWJsZWQgYi9jIHJvdGF0aW9uIGJyZWFrcyBib3VuZGluZyBib3hlc1xuICAgIHsgbmFtZTogJ2ZvbnQtZmFtaWx5JywgdHlwZTogdC5mb250RmFtaWx5IH0sXG4gICAgeyBuYW1lOiAnZm9udC1zdHlsZScsIHR5cGU6IHQuZm9udFN0eWxlIH0sXG4gICAgLy8geyBuYW1lOiAnZm9udC12YXJpYW50JywgdHlwZTogdC5mb250VmFyaWFudCB9LCAvLyBub3QgdXNlZnVsXG4gICAgeyBuYW1lOiAnZm9udC13ZWlnaHQnLCB0eXBlOiB0LmZvbnRXZWlnaHQgfSxcbiAgICB7IG5hbWU6ICdmb250LXNpemUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdtaW4tem9vbWVkLWZvbnQtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ2VkZ2UtdGV4dC1yb3RhdGlvbicsIHR5cGU6IHQudGV4dFJvdGF0aW9uIH0sXG5cbiAgICAvLyBiZWhhdmlvdXJcbiAgICB7IG5hbWU6ICdldmVudHMnLCB0eXBlOiB0LmJvb2wgfSxcblxuICAgIC8vIHZpc2liaWxpdHlcbiAgICB7IG5hbWU6ICdkaXNwbGF5JywgdHlwZTogdC5kaXNwbGF5IH0sXG4gICAgeyBuYW1lOiAndmlzaWJpbGl0eScsIHR5cGU6IHQudmlzaWJpbGl0eSB9LFxuICAgIHsgbmFtZTogJ29wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICd6LWluZGV4JywgdHlwZTogdC5ub25OZWdhdGl2ZUludCB9LFxuXG4gICAgLy8gb3ZlcmxheXNcbiAgICB7IG5hbWU6ICdvdmVybGF5LXBhZGRpbmcnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdvdmVybGF5LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ292ZXJsYXktb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuXG4gICAgLy8gc2hhZG93c1xuICAgIHsgbmFtZTogJ3NoYWRvdy1ibHVyJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnc2hhZG93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3NoYWRvdy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAnc2hhZG93LW9mZnNldC14JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3NoYWRvdy1vZmZzZXQteScsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUgfSxcblxuICAgIC8vIGxhYmVsIHNoYWRvd3NcbiAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1ibHVyJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAndGV4dC1zaGFkb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAndGV4dC1zaGFkb3ctb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3RleHQtc2hhZG93LW9mZnNldC14JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3RleHQtc2hhZG93LW9mZnNldC15JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuXG4gICAgLy8gdHJhbnNpdGlvbiBhbmlzXG4gICAgeyBuYW1lOiAndHJhbnNpdGlvbi1wcm9wZXJ0eScsIHR5cGU6IHQucHJvcExpc3QgfSxcbiAgICB7IG5hbWU6ICd0cmFuc2l0aW9uLWR1cmF0aW9uJywgdHlwZTogdC50aW1lIH0sXG4gICAgeyBuYW1lOiAndHJhbnNpdGlvbi1kZWxheScsIHR5cGU6IHQudGltZSB9LFxuICAgIHsgbmFtZTogJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJywgdHlwZTogdC5lYXNpbmcgfSxcblxuICAgIC8vIG5vZGUgYm9keVxuICAgIHsgbmFtZTogJ2hlaWdodCcsIHR5cGU6IHQubm9kZVNpemUgfSxcbiAgICB7IG5hbWU6ICd3aWR0aCcsIHR5cGU6IHQubm9kZVNpemUgfSxcbiAgICB7IG5hbWU6ICdzaGFwZScsIHR5cGU6IHQubm9kZVNoYXBlIH0sXG4gICAgeyBuYW1lOiAnc2hhcGUtcG9seWdvbi1wb2ludHMnLCB0eXBlOiB0LnBvbHlnb25Qb2ludExpc3QgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtYmxhY2tlbicsIHR5cGU6IHQubk9uZU9uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3BhZGRpbmctbGVmdCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ3BhZGRpbmctcmlnaHQnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdwYWRkaW5nLXRvcCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ3BhZGRpbmctYm90dG9tJywgdHlwZTogdC5zaXplIH0sXG5cbiAgICAvLyBub2RlIGJvcmRlclxuICAgIHsgbmFtZTogJ2JvcmRlci1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICdib3JkZXItb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ2JvcmRlci13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ2JvcmRlci1zdHlsZScsIHR5cGU6IHQuYm9yZGVyU3R5bGUgfSxcblxuICAgIC8vIG5vZGUgYmFja2dyb3VuZCBpbWFnZXNcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlJywgdHlwZTogdC51cmwgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCB0eXBlOiB0LmJnUG9zIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgdHlwZTogdC5iZ1BvcyB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtcmVwZWF0JywgdHlwZTogdC5iZ1JlcGVhdCB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtZml0JywgdHlwZTogdC5iZ0ZpdCB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtY2xpcCcsIHR5cGU6IHQuYmdDbGlwIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC13aWR0aCcsIHR5cGU6IHQuYmdXSCB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaGVpZ2h0JywgdHlwZTogdC5iZ1dIIH0sXG5cbiAgICAvLyBjb21wb3VuZCBwcm9wc1xuICAgIHsgbmFtZTogJ3Bvc2l0aW9uJywgdHlwZTogdC5wb3NpdGlvbiB9LFxuICAgIHsgbmFtZTogJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJywgdHlwZTogdC5jb21wb3VuZEluY2x1ZGVMYWJlbHMgfSxcblxuICAgIC8vIGVkZ2UgbGluZVxuICAgIHsgbmFtZTogJ2xpbmUtc3R5bGUnLCB0eXBlOiB0LmxpbmVTdHlsZSB9LFxuICAgIHsgbmFtZTogJ2xpbmUtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnY3VydmUtc3R5bGUnLCB0eXBlOiB0LmN1cnZlU3R5bGUgfSxcbiAgICB7IG5hbWU6ICdoYXlzdGFjay1yYWRpdXMnLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZXMgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodHMnLCB0eXBlOiB0Lm51bWJlcnMgfSxcbiAgICB7IG5hbWU6ICdzZWdtZW50LWRpc3RhbmNlcycsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVzIH0sXG4gICAgeyBuYW1lOiAnc2VnbWVudC13ZWlnaHRzJywgdHlwZTogdC5udW1iZXJzIH0sXG5cbiAgICAvLyB0aGVzZSBhcmUganVzdCBmb3IgdGhlIGNvcmVcbiAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnYWN0aXZlLWJnLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ2FjdGl2ZS1iZy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAnYWN0aXZlLWJnLXNpemUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfVxuICBdO1xuXG4gIC8vIGRlZmluZSBhbGlhc2VzXG4gIHZhciBhbGlhc2VzID0gc3R5Zm4uYWxpYXNlcyA9IFtcbiAgICB7IG5hbWU6ICdjb250ZW50JywgcG9pbnRzVG86ICdsYWJlbCcgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LWRpc3RhbmNlJywgcG9pbnRzVG86ICdjb250cm9sLXBvaW50LWRpc3RhbmNlcycgfSxcbiAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodCcsIHBvaW50c1RvOiAnY29udHJvbC1wb2ludC13ZWlnaHRzJyB9XG4gIF07XG5cbiAgLy8gcGllIGJhY2tncm91bmRzIGZvciBub2Rlc1xuICBzdHlmbi5waWVCYWNrZ3JvdW5kTiA9IDE2OyAvLyBiZWNhdXNlIHRoZSBwaWUgcHJvcGVydGllcyBhcmUgbnVtYmVyZWQsIGdpdmUgYWNjZXNzIHRvIGEgY29uc3RhbnQgTiAoZm9yIHJlbmRlcmVyIHVzZSlcbiAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtc2l6ZScsIHR5cGU6IHQuYmdTaXplIH0pO1xuICBmb3IoIHZhciBpID0gMTsgaSA8PSBzdHlmbi5waWVCYWNrZ3JvdW5kTjsgaSsrICl7XG4gICAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtJytpKyctYmFja2dyb3VuZC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSk7XG4gICAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtJytpKyctYmFja2dyb3VuZC1zaXplJywgdHlwZTogdC5wZXJjZW50IH0pO1xuICAgIHByb3BzLnB1c2goeyBuYW1lOiAncGllLScraSsnLWJhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9KTtcbiAgfVxuXG4gIC8vIGVkZ2UgYXJyb3dzXG4gIHZhciBhcnJvd1ByZWZpeGVzID0gc3R5Zm4uYXJyb3dQcmVmaXhlcyA9IFsnc291cmNlJywgJ21pZC1zb3VyY2UnLCAndGFyZ2V0JywgJ21pZC10YXJnZXQnXTtcbiAgW1xuICAgIHsgbmFtZTogJ2Fycm93LXNoYXBlJywgdHlwZTogdC5hcnJvd1NoYXBlIH0sXG4gICAgeyBuYW1lOiAnYXJyb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnYXJyb3ctZmlsbCcsIHR5cGU6IHQuYXJyb3dGaWxsIH1cbiAgXS5mb3JFYWNoKGZ1bmN0aW9uKCBwcm9wICl7XG4gICAgYXJyb3dQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uKCBwcmVmaXggKXtcbiAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgJy0nICsgcHJvcC5uYW1lO1xuICAgICAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG5cbiAgICAgIHByb3BzLnB1c2goeyBuYW1lOiBuYW1lLCB0eXBlOiB0eXBlIH0pO1xuICAgIH0pO1xuICB9LCB7fSk7XG5cbiAgLy8gbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuICBzdHlmbi5wcm9wZXJ0eU5hbWVzID0gcHJvcHMubWFwKGZ1bmN0aW9uKHApeyByZXR1cm4gcC5uYW1lOyB9KTtcblxuICAvLyBhbGxvdyBhY2Nlc3Mgb2YgcHJvcGVydGllcyBieSBuYW1lICggZS5nLiBzdHlsZS5wcm9wZXJ0aWVzLmhlaWdodCApXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgcHJvcHNbIHByb3AubmFtZSBdID0gcHJvcDsgLy8gYWxsb3cgbG9va3VwIGJ5IG5hbWVcbiAgfVxuXG4gIC8vIG1hcCBhbGlhc2VzXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgYWxpYXNlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBhbGlhcyA9IGFsaWFzZXNbaV07XG4gICAgdmFyIHBvaW50c1RvUHJvcCA9IHByb3BzWyBhbGlhcy5wb2ludHNUbyBdO1xuICAgIHZhciBhbGlhc1Byb3AgPSB7XG4gICAgICBuYW1lOiBhbGlhcy5uYW1lLFxuICAgICAgYWxpYXM6IHRydWUsXG4gICAgICBwb2ludHNUbzogcG9pbnRzVG9Qcm9wXG4gICAgfTtcblxuICAgIC8vIGFkZCBhbGlhcyBwcm9wIGZvciBwYXJzaW5nXG4gICAgcHJvcHMucHVzaCggYWxpYXNQcm9wICk7XG5cbiAgICBwcm9wc1sgYWxpYXMubmFtZSBdID0gYWxpYXNQcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICB9XG59KSgpO1xuXG4vLyBhZGRzIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXQgdG8gdGhlIGN1cnJlbnQgc3R5bGVcbnN0eWZuLmFkZERlZmF1bHRTdHlsZXNoZWV0ID0gZnVuY3Rpb24oKXtcbiAgLy8gZmlsbCB0aGUgc3R5bGUgd2l0aCB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0XG4gIHRoaXNcbiAgICAuc2VsZWN0b3IoJ25vZGUsIGVkZ2UnKSAvLyBjb21tb24gcHJvcGVydGllc1xuICAgICAgLmNzcyggdXRpbC5leHRlbmQoIHtcbiAgICAgICAgJ2V2ZW50cyc6ICd5ZXMnLFxuICAgICAgICAndGV4dC1ldmVudHMnOiAnbm8nLFxuICAgICAgICAndGV4dC12YWxpZ24nOiAndG9wJyxcbiAgICAgICAgJ3RleHQtaGFsaWduJzogJ2NlbnRlcicsXG4gICAgICAgICdjb2xvcic6ICcjMDAwJyxcbiAgICAgICAgJ3RleHQtb3V0bGluZS1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgJ3RleHQtb3V0bGluZS13aWR0aCc6IDAsXG4gICAgICAgICd0ZXh0LW91dGxpbmUtb3BhY2l0eSc6IDEsXG4gICAgICAgICd0ZXh0LW9wYWNpdHknOiAxLFxuICAgICAgICAndGV4dC1kZWNvcmF0aW9uJzogJ25vbmUnLFxuICAgICAgICAndGV4dC10cmFuc2Zvcm0nOiAnbm9uZScsXG4gICAgICAgICd0ZXh0LXdyYXAnOiAnbm9uZScsXG4gICAgICAgICd0ZXh0LW1heC13aWR0aCc6IDk5OTksXG4gICAgICAgICd0ZXh0LWJhY2tncm91bmQtY29sb3InOiAnIzAwMCcsXG4gICAgICAgICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSc6IDAsXG4gICAgICAgICd0ZXh0LWJvcmRlci1vcGFjaXR5JzogMCxcbiAgICAgICAgJ3RleHQtYm9yZGVyLXdpZHRoJzogMCxcbiAgICAgICAgJ3RleHQtYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAgICAgJ3RleHQtYm9yZGVyLWNvbG9yJzonIzAwMCcsXG4gICAgICAgICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnOidyZWN0YW5nbGUnLFxuICAgICAgICAnZm9udC1mYW1pbHknOiAnSGVsdmV0aWNhIE5ldWUsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsXG4gICAgICAgICdmb250LXN0eWxlJzogJ25vcm1hbCcsXG4gICAgICAgIC8vICdmb250LXZhcmlhbnQnOiBmb250VmFyaWFudCxcbiAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogJ25vcm1hbCcsXG4gICAgICAgICdmb250LXNpemUnOiAxNixcbiAgICAgICAgJ21pbi16b29tZWQtZm9udC1zaXplJzogMCxcbiAgICAgICAgJ2VkZ2UtdGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAgICAgJ3Zpc2liaWxpdHknOiAndmlzaWJsZScsXG4gICAgICAgICdkaXNwbGF5JzogJ2VsZW1lbnQnLFxuICAgICAgICAnb3BhY2l0eSc6IDEsXG4gICAgICAgICd6LWluZGV4JzogMCxcbiAgICAgICAgJ2xhYmVsJzogJycsXG4gICAgICAgICdvdmVybGF5LW9wYWNpdHknOiAwLFxuICAgICAgICAnb3ZlcmxheS1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICAgICAnc2hhZG93LW9wYWNpdHknOiAwLFxuICAgICAgICAnc2hhZG93LWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAnc2hhZG93LWJsdXInOiAxMCxcbiAgICAgICAgJ3NoYWRvdy1vZmZzZXQteCc6IDAsXG4gICAgICAgICdzaGFkb3ctb2Zmc2V0LXknOiAwLFxuICAgICAgICAndGV4dC1zaGFkb3ctb3BhY2l0eSc6IDAsXG4gICAgICAgICd0ZXh0LXNoYWRvdy1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgJ3RleHQtc2hhZG93LWJsdXInOiA1LFxuICAgICAgICAndGV4dC1zaGFkb3ctb2Zmc2V0LXgnOiAwLFxuICAgICAgICAndGV4dC1zaGFkb3ctb2Zmc2V0LXknOiAwLFxuICAgICAgICAndHJhbnNpdGlvbi1wcm9wZXJ0eSc6ICdub25lJyxcbiAgICAgICAgJ3RyYW5zaXRpb24tZHVyYXRpb24nOiAwLFxuICAgICAgICAndHJhbnNpdGlvbi1kZWxheSc6IDAsXG4gICAgICAgICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbic6ICdsaW5lYXInLFxuXG4gICAgICAgIC8vIG5vZGUgcHJvcHNcbiAgICAgICAgJ2JhY2tncm91bmQtYmxhY2tlbic6IDAsXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyM4ODgnLFxuICAgICAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAnbm9uZScsXG4gICAgICAgICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknOiAxLFxuICAgICAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogJzUwJScsXG4gICAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiAnNTAlJyxcbiAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAgICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub2RlJyxcbiAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnYXV0bycsXG4gICAgICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICdhdXRvJyxcbiAgICAgICAgJ2JvcmRlci1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgJ2JvcmRlci1vcGFjaXR5JzogMSxcbiAgICAgICAgJ2JvcmRlci13aWR0aCc6IDAsXG4gICAgICAgICdib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICAgICAnaGVpZ2h0JzogMzAsXG4gICAgICAgICd3aWR0aCc6IDMwLFxuICAgICAgICAnc2hhcGUnOiAnZWxsaXBzZScsXG4gICAgICAgICdzaGFwZS1wb2x5Z29uLXBvaW50cyc6ICctMSwgLTEsICAgMSwgLTEsICAgMSwgMSwgICAtMSwgMScsXG5cbiAgICAgICAgLy8gY29tcG91bmQgcHJvcHNcbiAgICAgICAgJ3BhZGRpbmctdG9wJzogMCxcbiAgICAgICAgJ3BhZGRpbmctYm90dG9tJzogMCxcbiAgICAgICAgJ3BhZGRpbmctbGVmdCc6IDAsXG4gICAgICAgICdwYWRkaW5nLXJpZ2h0JzogMCxcbiAgICAgICAgJ3Bvc2l0aW9uJzogJ29yaWdpbicsXG4gICAgICAgICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscyc6ICdpbmNsdWRlJ1xuICAgICAgfSwge1xuICAgICAgICAvLyBub2RlIHBpZSBiZ1xuICAgICAgICAncGllLXNpemUnOiAnMTAwJSdcbiAgICAgIH0sIFtcbiAgICAgICAgeyBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtY29sb3InLCB2YWx1ZTogJ2JsYWNrJyB9LFxuICAgICAgICB7IG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1zaXplJywgdmFsdWU6ICcwJScgfSxcbiAgICAgICAgeyBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtb3BhY2l0eScsIHZhbHVlOiAxIH1cbiAgICAgIF0ucmVkdWNlKGZ1bmN0aW9uKCBjc3MsIHByb3AgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDE7IGkgPD0gc3R5Zm4ucGllQmFja2dyb3VuZE47IGkrKyApe1xuICAgICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lLnJlcGxhY2UoJ3t7aX19JywgaSk7XG4gICAgICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG5cbiAgICAgICAgICBjc3NbIG5hbWUgXSA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjc3M7XG4gICAgICB9LCB7fSksIHtcbiAgICAgICAgLy8gZWRnZSBwcm9wc1xuICAgICAgICAnbGluZS1zdHlsZSc6ICdzb2xpZCcsXG4gICAgICAgICdsaW5lLWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnOiA0MCxcbiAgICAgICAgJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cyc6IDAuNSxcbiAgICAgICAgJ3NlZ21lbnQtd2VpZ2h0cyc6IDAuNSxcbiAgICAgICAgJ3NlZ21lbnQtZGlzdGFuY2VzJzogMjAsXG4gICAgICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInLFxuICAgICAgICAnaGF5c3RhY2stcmFkaXVzJzogMC44XG4gICAgICB9LCBbXG4gICAgICAgIHsgbmFtZTogJ2Fycm93LXNoYXBlJywgdmFsdWU6ICdub25lJyB9LFxuICAgICAgICB7IG5hbWU6ICdhcnJvdy1jb2xvcicsIHZhbHVlOiAnI2RkZCcgfSxcbiAgICAgICAgeyBuYW1lOiAnYXJyb3ctZmlsbCcsIHZhbHVlOiAnZmlsbGVkJyB9XG4gICAgICBdLnJlZHVjZShmdW5jdGlvbiggY3NzLCBwcm9wICl7XG4gICAgICAgIHN0eWZuLmFycm93UHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiggcHJlZml4ICl7XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG5cbiAgICAgICAgICBjc3NbIG5hbWUgXSA9IHZhbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNzcztcbiAgICAgIH0sIHt9KSApIClcbiAgICAuc2VsZWN0b3IoJyRub2RlID4gbm9kZScpIC8vIGNvbXBvdW5kIChwYXJlbnQpIG5vZGUgcHJvcGVydGllc1xuICAgICAgLmNzcyh7XG4gICAgICAgICd3aWR0aCc6ICdhdXRvJyxcbiAgICAgICAgJ2hlaWdodCc6ICdhdXRvJyxcbiAgICAgICAgJ3NoYXBlJzogJ3JlY3RhbmdsZScsXG4gICAgICAgICdwYWRkaW5nLXRvcCc6IDEwLFxuICAgICAgICAncGFkZGluZy1yaWdodCc6IDEwLFxuICAgICAgICAncGFkZGluZy1sZWZ0JzogMTAsXG4gICAgICAgICdwYWRkaW5nLWJvdHRvbSc6IDEwXG4gICAgICB9KVxuICAgIC5zZWxlY3RvcignZWRnZScpIC8vIGp1c3QgZWRnZSBwcm9wZXJ0aWVzXG4gICAgICAuY3NzKHtcbiAgICAgICAgJ3dpZHRoJzogMVxuICAgICAgfSlcbiAgICAuc2VsZWN0b3IoJzphY3RpdmUnKVxuICAgICAgLmNzcyh7XG4gICAgICAgICdvdmVybGF5LWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICAgICAnb3ZlcmxheS1vcGFjaXR5JzogMC4yNVxuICAgICAgfSlcbiAgICAuc2VsZWN0b3IoJ2NvcmUnKSAvLyBqdXN0IGNvcmUgcHJvcGVydGllc1xuICAgICAgLmNzcyh7XG4gICAgICAgICdzZWxlY3Rpb24tYm94LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JzogMC42NSxcbiAgICAgICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJzogJyNhYWEnLFxuICAgICAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnOiAxLFxuICAgICAgICAnYWN0aXZlLWJnLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgJ2FjdGl2ZS1iZy1vcGFjaXR5JzogMC4xNSxcbiAgICAgICAgJ2FjdGl2ZS1iZy1zaXplJzogMzAsXG4gICAgICAgICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InOiAnIzAwMCcsXG4gICAgICAgICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eSc6IDAuMTI1XG4gICAgICB9KVxuICA7XG5cbiAgdGhpcy5kZWZhdWx0TGVuZ3RoID0gdGhpcy5sZW5ndGg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuXG59LHtcIi4uL3V0aWxcIjo5NH1dLDkwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBfZGVyZXFfKCcuLi91dGlsJyk7XG52YXIgU2VsZWN0b3IgPSBfZGVyZXFfKCcuLi9zZWxlY3RvcicpO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuc3R5Zm4uYXBwbHlGcm9tU3RyaW5nID0gZnVuY3Rpb24oIHN0cmluZyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG4gIHZhciByZW1haW5pbmcgPSAnJyArIHN0cmluZztcbiAgdmFyIHNlbEFuZEJsb2NrU3RyO1xuICB2YXIgYmxvY2tSZW07XG4gIHZhciBwcm9wQW5kVmFsU3RyO1xuXG4gIC8vIHJlbW92ZSBjb21tZW50cyBmcm9tIHRoZSBzdHlsZSBzdHJpbmdcbiAgcmVtYWluaW5nID0gcmVtYWluaW5nLnJlcGxhY2UoL1svXVsqXShcXHN8LikrP1sqXVsvXS9nLCAnJyk7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCl7XG4gICAgLy8gcmVtb3ZlIHRoZSBwYXJzZWQgc2VsZWN0b3IgYW5kIGJsb2NrIGZyb20gdGhlIHJlbWFpbmluZyB0ZXh0IHRvIHBhcnNlXG4gICAgaWYoIHJlbWFpbmluZy5sZW5ndGggPiBzZWxBbmRCbG9ja1N0ci5sZW5ndGggKXtcbiAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHIoIHNlbEFuZEJsb2NrU3RyLmxlbmd0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1haW5pbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpe1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHByb3BlcnR5IGFuZCB2YWx1ZSBmcm9tIHRoZSByZW1haW5pbmcgYmxvY2sgdGV4dCB0byBwYXJzZVxuICAgIGlmKCBibG9ja1JlbS5sZW5ndGggPiBwcm9wQW5kVmFsU3RyLmxlbmd0aCApe1xuICAgICAgYmxvY2tSZW0gPSBibG9ja1JlbS5zdWJzdHIoIHByb3BBbmRWYWxTdHIubGVuZ3RoICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJsb2NrUmVtID0gJyc7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUodHJ1ZSl7XG4gICAgdmFyIG5vdGhpbmdMZWZ0VG9QYXJzZSA9IHJlbWFpbmluZy5tYXRjaCgvXlxccyokLyk7XG4gICAgaWYoIG5vdGhpbmdMZWZ0VG9QYXJzZSApeyBicmVhazsgfVxuXG4gICAgdmFyIHNlbEFuZEJsb2NrID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKigoPzoufFxccykrPylcXHMqXFx7KCg/Oi58XFxzKSs/KVxcfS8pO1xuXG4gICAgaWYoICFzZWxBbmRCbG9jayApe1xuICAgICAgdXRpbC5lcnJvcignSGFsdGluZyBzdHlsZXNoZWV0IHBhcnNpbmc6IFN0cmluZyBzdHlsZXNoZWV0IGNvbnRhaW5zIG1vcmUgdG8gcGFyc2UgYnV0IG5vIHNlbGVjdG9yIGFuZCBibG9jayBmb3VuZCBpbjogJyArIHJlbWFpbmluZyk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzZWxBbmRCbG9ja1N0ciA9IHNlbEFuZEJsb2NrWzBdO1xuXG4gICAgLy8gcGFyc2UgdGhlIHNlbGVjdG9yXG4gICAgdmFyIHNlbGVjdG9yU3RyID0gc2VsQW5kQmxvY2tbMV07XG4gICAgaWYoIHNlbGVjdG9yU3RyICE9PSAnY29yZScgKXtcbiAgICAgIHZhciBzZWxlY3RvciA9IG5ldyBTZWxlY3Rvciggc2VsZWN0b3JTdHIgKTtcbiAgICAgIGlmKCBzZWxlY3Rvci5fcHJpdmF0ZS5pbnZhbGlkICl7XG4gICAgICAgIHV0aWwuZXJyb3IoJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgc2VsZWN0b3IgZm91bmQgaW4gc3RyaW5nIHN0eWxlc2hlZXQ6ICcgKyBzZWxlY3RvclN0cik7XG5cbiAgICAgICAgLy8gc2tpcCB0aGlzIHNlbGVjdG9yIGFuZCBibG9ja1xuICAgICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgdGhlIGJsb2NrIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuICAgIHZhciBibG9ja1N0ciA9IHNlbEFuZEJsb2NrWzJdO1xuICAgIHZhciBpbnZhbGlkQmxvY2sgPSBmYWxzZTtcbiAgICBibG9ja1JlbSA9IGJsb2NrU3RyO1xuICAgIHZhciBwcm9wcyA9IFtdO1xuXG4gICAgd2hpbGUodHJ1ZSl7XG4gICAgICB2YXIgbm90aGluZ0xlZnRUb1BhcnNlID0gYmxvY2tSZW0ubWF0Y2goL15cXHMqJC8pO1xuICAgICAgaWYoIG5vdGhpbmdMZWZ0VG9QYXJzZSApeyBicmVhazsgfVxuXG4gICAgICB2YXIgcHJvcEFuZFZhbCA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiguKz8pXFxzKjpcXHMqKC4rPylcXHMqOy8pO1xuXG4gICAgICBpZiggIXByb3BBbmRWYWwgKXtcbiAgICAgICAgdXRpbC5lcnJvcignU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBmb3JtYXR0aW5nIG9mIHN0eWxlIHByb3BlcnR5IGFuZCB2YWx1ZSBkZWZpbml0aW9ucyBmb3VuZCBpbjonICsgYmxvY2tTdHIpO1xuICAgICAgICBpbnZhbGlkQmxvY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcHJvcEFuZFZhbFN0ciA9IHByb3BBbmRWYWxbMF07XG4gICAgICB2YXIgcHJvcFN0ciA9IHByb3BBbmRWYWxbMV07XG4gICAgICB2YXIgdmFsU3RyID0gcHJvcEFuZFZhbFsyXTtcblxuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbIHByb3BTdHIgXTtcbiAgICAgIGlmKCAhcHJvcCApe1xuICAgICAgICB1dGlsLmVycm9yKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBuYW1lIGluOiAnICsgcHJvcEFuZFZhbFN0cik7XG5cbiAgICAgICAgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnNlZFByb3AgPSBzdHlsZS5wYXJzZSggcHJvcFN0ciwgdmFsU3RyICk7XG5cbiAgICAgIGlmKCAhcGFyc2VkUHJvcCApe1xuICAgICAgICB1dGlsLmVycm9yKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGluOiAnICsgcHJvcEFuZFZhbFN0cik7XG5cbiAgICAgICAgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMucHVzaCh7XG4gICAgICAgIG5hbWU6IHByb3BTdHIsXG4gICAgICAgIHZhbDogdmFsU3RyXG4gICAgICB9KTtcbiAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgfVxuXG4gICAgaWYoIGludmFsaWRCbG9jayApe1xuICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBwdXQgdGhlIHBhcnNlZCBibG9jayBpbiB0aGUgc3R5bGVcbiAgICBzdHlsZS5zZWxlY3Rvciggc2VsZWN0b3JTdHIgKTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgc3R5bGUuY3NzKCBwcm9wLm5hbWUsIHByb3AudmFsICk7XG4gICAgfVxuXG4gICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG5zdHlmbi5mcm9tU3RyaW5nID0gZnVuY3Rpb24oIHN0cmluZyApe1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gIHN0eWxlLnJlc2V0VG9EZWZhdWx0KCk7XG4gIHN0eWxlLmFwcGx5RnJvbVN0cmluZyggc3RyaW5nICk7XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcblxufSx7XCIuLi9zZWxlY3RvclwiOjgxLFwiLi4vdXRpbFwiOjk0fV0sOTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuL2lzJyk7XG52YXIgdXRpbCA9IF9kZXJlcV8oJy4vdXRpbCcpO1xudmFyIFN0eWxlID0gX2RlcmVxXygnLi9zdHlsZScpO1xuXG4vLyBhIGR1bW15IHN0eWxlc2hlZXQgb2JqZWN0IHRoYXQgZG9lc24ndCBuZWVkIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlXG4vLyAodXNlZnVsIGZvciBpbml0KVxudmFyIFN0eWxlc2hlZXQgPSBmdW5jdGlvbigpe1xuICBpZiggISh0aGlzIGluc3RhbmNlb2YgU3R5bGVzaGVldCkgKXtcbiAgICByZXR1cm4gbmV3IFN0eWxlc2hlZXQoKTtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMDtcbn07XG5cbnZhciBzaGVldGZuID0gU3R5bGVzaGVldC5wcm90b3R5cGU7XG5cbnNoZWV0Zm4uaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gJ3N0eWxlc2hlZXQnO1xufTtcblxuLy8ganVzdCBzdG9yZSB0aGUgc2VsZWN0b3IgdG8gYmUgcGFyc2VkIGxhdGVyXG5zaGVldGZuLnNlbGVjdG9yID0gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gIHZhciBpID0gdGhpcy5sZW5ndGgrKztcblxuICB0aGlzW2ldID0ge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBwcm9wZXJ0aWVzOiBbXVxuICB9O1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8ganVzdCBzdG9yZSB0aGUgcHJvcGVydHkgdG8gYmUgcGFyc2VkIGxhdGVyXG5zaGVldGZuLmNzcyA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcblxuICBpZiggaXMuc3RyaW5nKG5hbWUpICl7XG4gICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9IGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KG5hbWUpICl7XG4gICAgdmFyIG1hcCA9IG5hbWU7XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IFN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBwcm9wID0gU3R5bGUucHJvcGVydGllc1tqXTtcbiAgICAgIHZhciBtYXBWYWwgPSBtYXBbIHByb3AubmFtZSBdO1xuXG4gICAgICBpZiggbWFwVmFsID09PSB1bmRlZmluZWQgKXsgLy8gYWxzbyB0cnkgY2FtZWwgY2FzZSBuYW1lXG4gICAgICAgIG1hcFZhbCA9IG1hcFsgdXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXTtcbiAgICAgIH1cblxuICAgICAgaWYoIG1hcFZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgdmFsdWUgPSBtYXBWYWw7XG5cbiAgICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc2hlZXRmbi5zdHlsZSA9IHNoZWV0Zm4uY3NzO1xuXG4vLyBnZW5lcmF0ZSBhIHJlYWwgc3R5bGUgb2JqZWN0IGZyb20gdGhlIGR1bW15IHN0eWxlc2hlZXRcbnNoZWV0Zm4uZ2VuZXJhdGVTdHlsZSA9IGZ1bmN0aW9uKCBjeSApe1xuICB2YXIgc3R5bGUgPSBuZXcgU3R5bGUoY3kpO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjb250ZXh0ID0gdGhpc1tpXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBjb250ZXh0LnNlbGVjdG9yO1xuICAgIHZhciBwcm9wcyA9IGNvbnRleHQucHJvcGVydGllcztcblxuICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yKTsgLy8gYXBwbHkgc2VsZWN0b3JcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG5cbiAgICAgIHN0eWxlLmNzcyggcHJvcC5uYW1lLCBwcm9wLnZhbHVlICk7IC8vIGFwcGx5IHByb3BlcnR5XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZXNoZWV0O1xuXG59LHtcIi4vaXNcIjo3NyxcIi4vc3R5bGVcIjo4NixcIi4vdXRpbFwiOjk0fV0sOTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gY3Jvc3MtZW52IHRocmVhZC93b3JrZXJcbi8vIE5CIDogdXNlcyAoaGVhdnl3ZWlnaHQpIHByb2Nlc3NlcyBvbiBub2RlanMgc28gYmVzdCBub3QgdG8gY3JlYXRlIHRvbyBtYW55IHRocmVhZHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2luZG93ID0gX2RlcmVxXygnLi93aW5kb3cnKTtcbnZhciB1dGlsID0gX2RlcmVxXygnLi91dGlsJyk7XG52YXIgUHJvbWlzZSA9IF9kZXJlcV8oJy4vcHJvbWlzZScpO1xudmFyIEV2ZW50ID0gX2RlcmVxXygnLi9ldmVudCcpO1xudmFyIGRlZmluZSA9IF9kZXJlcV8oJy4vZGVmaW5lJyk7XG52YXIgaXMgPSBfZGVyZXFfKCcuL2lzJyk7XG5cbnZhciBUaHJlYWQgPSBmdW5jdGlvbiggb3B0cyApe1xuICBpZiggISh0aGlzIGluc3RhbmNlb2YgVGhyZWFkKSApe1xuICAgIHJldHVybiBuZXcgVGhyZWFkKCBvcHRzICk7XG4gIH1cblxuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0ge1xuICAgIHJlcXVpcmVzOiBbXSxcbiAgICBmaWxlczogW10sXG4gICAgcXVldWU6IG51bGwsXG4gICAgcGFzczogW10sXG4gICAgZGlzYWJsZWQ6IGZhbHNlXG4gIH07XG5cbiAgaWYoIGlzLnBsYWluT2JqZWN0KG9wdHMpICl7XG4gICAgaWYoIG9wdHMuZGlzYWJsZWQgIT0gbnVsbCApe1xuICAgICAgX3AuZGlzYWJsZWQgPSAhIW9wdHMuZGlzYWJsZWQ7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciB0aGRmbiA9IFRocmVhZC5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbnZhciBzdHJpbmdpZnlGaWVsZFZhbCA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgdmFyIHZhbFN0ciA9IGlzLmZuKCB2YWwgKSA/IHZhbC50b1N0cmluZygpIDogXCJKU09OLnBhcnNlKCdcIiArIEpTT04uc3RyaW5naWZ5KHZhbCkgKyBcIicpXCI7XG5cbiAgcmV0dXJuIHZhbFN0cjtcbn07XG5cbi8vIGFsbG93cyBmb3IgcmVxdWlyZXMgd2l0aCBwcm90b3R5cGVzIGFuZCBzdWJvYmpzIGV0Y1xudmFyIGZuQXNSZXF1aXJlID0gZnVuY3Rpb24oIGZuICl7XG4gIHZhciByZXE7XG4gIHZhciBmbk5hbWU7XG5cbiAgaWYoIGlzLm9iamVjdChmbikgJiYgZm4uZm4gKXsgLy8gbWFudWFsIGZuXG4gICAgcmVxID0gZm5BcyggZm4uZm4sIGZuLm5hbWUgKTtcbiAgICBmbk5hbWUgPSBmbi5uYW1lO1xuICAgIGZuID0gZm4uZm47XG4gIH0gZWxzZSBpZiggaXMuZm4oZm4pICl7IC8vIGF1dG8gZm5cbiAgICByZXEgPSBmbi50b1N0cmluZygpO1xuICAgIGZuTmFtZSA9IGZuLm5hbWU7XG4gIH0gZWxzZSBpZiggaXMuc3RyaW5nKGZuKSApeyAvLyBzdHJpbmdpZmllZCBmblxuICAgIHJlcSA9IGZuO1xuICB9IGVsc2UgaWYoIGlzLm9iamVjdChmbikgKXsgLy8gcGxhaW4gb2JqZWN0XG4gICAgaWYoIGZuLnByb3RvICl7XG4gICAgICByZXEgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxID0gZm4ubmFtZSArICcgPSB7fTsnO1xuICAgIH1cblxuICAgIGZuTmFtZSA9IGZuLm5hbWU7XG4gICAgZm4gPSBmbi5vYmo7XG4gIH1cblxuICByZXEgKz0gJ1xcbic7XG5cbiAgdmFyIHByb3RvcmVxID0gZnVuY3Rpb24oIHZhbCwgc3VibmFtZSApe1xuICAgIGlmKCB2YWwucHJvdG90eXBlICl7XG4gICAgICB2YXIgcHJvdG9Ob25lbXB0eSA9IGZhbHNlO1xuICAgICAgZm9yKCB2YXIgcHJvcCBpbiB2YWwucHJvdG90eXBlICl7IHByb3RvTm9uZW1wdHkgPSB0cnVlOyBicmVhazsgfSAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgICAgaWYoIHByb3RvTm9uZW1wdHkgKXtcbiAgICAgICAgcmVxICs9IGZuQXNSZXF1aXJlKCB7XG4gICAgICAgICAgbmFtZTogc3VibmFtZSxcbiAgICAgICAgICBvYmo6IHZhbCxcbiAgICAgICAgICBwcm90bzogdHJ1ZVxuICAgICAgICB9LCB2YWwgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gcHVsbCBpbiBwcm90b3R5cGVcbiAgaWYoIGZuLnByb3RvdHlwZSAmJiBmbk5hbWUgIT0gbnVsbCApe1xuXG4gICAgZm9yKCB2YXIgbmFtZSBpbiBmbi5wcm90b3R5cGUgKXtcbiAgICAgIHZhciBwcm90b1N0ciA9ICcnO1xuXG4gICAgICB2YXIgdmFsID0gZm4ucHJvdG90eXBlWyBuYW1lIF07XG4gICAgICB2YXIgdmFsU3RyID0gc3RyaW5naWZ5RmllbGRWYWwoIHZhbCApO1xuICAgICAgdmFyIHN1Ym5hbWUgPSBmbk5hbWUgKyAnLnByb3RvdHlwZS4nICsgbmFtZTtcblxuICAgICAgcHJvdG9TdHIgKz0gc3VibmFtZSArICcgPSAnICsgdmFsU3RyICsgJztcXG4nO1xuXG4gICAgICBpZiggcHJvdG9TdHIgKXtcbiAgICAgICAgcmVxICs9IHByb3RvU3RyO1xuICAgICAgfVxuXG4gICAgICBwcm90b3JlcSggdmFsLCBzdWJuYW1lICk7IC8vIHN1Ym9iamVjdCB3aXRoIHByb3RvdHlwZVxuICAgIH1cblxuICB9XG5cbiAgLy8gcHVsbCBpbiBwcm9wZXJ0aWVzIGZvciBvYmovZm5zXG4gIGlmKCAhaXMuc3RyaW5nKGZuKSApeyBmb3IoIHZhciBuYW1lIGluIGZuICl7XG4gICAgdmFyIHByb3BzU3RyID0gJyc7XG5cbiAgICBpZiggZm4uaGFzT3duUHJvcGVydHkobmFtZSkgKXtcbiAgICAgIHZhciB2YWwgPSBmblsgbmFtZSBdO1xuICAgICAgdmFyIHZhbFN0ciA9IHN0cmluZ2lmeUZpZWxkVmFsKCB2YWwgKTtcbiAgICAgIHZhciBzdWJuYW1lID0gZm5OYW1lICsgJ1tcIicgKyBuYW1lICsgJ1wiXSc7XG5cbiAgICAgIHByb3BzU3RyICs9IHN1Ym5hbWUgKyAnID0gJyArIHZhbFN0ciArICc7XFxuJztcbiAgICB9XG5cbiAgICBpZiggcHJvcHNTdHIgKXtcbiAgICAgIHJlcSArPSBwcm9wc1N0cjtcbiAgICB9XG5cbiAgICBwcm90b3JlcSggdmFsLCBzdWJuYW1lICk7IC8vIHN1Ym9iamVjdCB3aXRoIHByb3RvdHlwZVxuICB9IH1cblxuICByZXR1cm4gcmVxO1xufTtcblxudmFyIGlzUGF0aFN0ciA9IGZ1bmN0aW9uKCBzdHIgKXtcbiAgcmV0dXJuIGlzLnN0cmluZyhzdHIpICYmIHN0ci5tYXRjaCgvXFwuanMkLyk7XG59O1xuXG51dGlsLmV4dGVuZCh0aGRmbiwge1xuXG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbigpeyByZXR1cm4gJ3RocmVhZCc7IH0sXG5cbiAgcmVxdWlyZTogZnVuY3Rpb24oIGZuLCBhcyApe1xuICAgIHZhciByZXF1aXJlcyA9IHRoaXMuX3ByaXZhdGUucmVxdWlyZXM7XG5cbiAgICBpZiggaXNQYXRoU3RyKGZuKSApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5maWxlcy5wdXNoKCBmbiApO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiggYXMgKXtcbiAgICAgIGlmKCBpcy5mbihmbikgKXtcbiAgICAgICAgZm4gPSB7IG5hbWU6IGFzLCBmbjogZm4gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuID0geyBuYW1lOiBhcywgb2JqOiBmbiB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiggaXMuZm4oZm4pICl7XG4gICAgICAgIGlmKCAhZm4ubmFtZSApe1xuICAgICAgICAgIHRocm93ICdUaGUgZnVuY3Rpb24gbmFtZSBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBkZXRlcm1pbmVkLiAgVXNlIHRocmVhZC5yZXF1aXJlKCBzb21lRnVuY3Rpb24sIFwic29tZUZ1bmN0aW9uXCIgKSc7XG4gICAgICAgIH1cblxuICAgICAgICBmbiA9IHsgbmFtZTogZm4ubmFtZSwgZm46IGZuIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWlyZXMucHVzaCggZm4gKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHBhc3M6IGZ1bmN0aW9uKCBkYXRhICl7XG4gICAgdGhpcy5fcHJpdmF0ZS5wYXNzLnB1c2goIGRhdGEgKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHJ1bjogZnVuY3Rpb24oIGZuLCBwYXNzICl7IC8vIGZuIHVzZWQgbGlrZSBtYWluKClcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBwYXNzID0gcGFzcyB8fCBfcC5wYXNzLnNoaWZ0KCk7XG5cbiAgICBpZiggX3Auc3RvcHBlZCApe1xuICAgICAgdGhyb3cgJ0F0dGVtcHRlZCB0byBydW4gYSBzdG9wcGVkIHRocmVhZCEgIFN0YXJ0IGEgbmV3IHRocmVhZCBvciBkbyBub3Qgc3RvcCB0aGUgZXhpc3RpbmcgdGhyZWFkIGFuZCByZXVzZSBpdC4nO1xuICAgIH1cblxuICAgIGlmKCBfcC5ydW5uaW5nICl7XG4gICAgICByZXR1cm4gKCBfcC5xdWV1ZSA9IF9wLnF1ZXVlLnRoZW4oZnVuY3Rpb24oKXsgLy8gaW5kdWN0aXZlIHN0ZXBcbiAgICAgICAgcmV0dXJuIHNlbGYucnVuKCBmbiwgcGFzcyApO1xuICAgICAgfSkgKTtcbiAgICB9XG5cbiAgICB2YXIgdXNlV1cgPSB3aW5kb3cgIT0gbnVsbCAmJiAhX3AuZGlzYWJsZWQ7XG4gICAgdmFyIHVzZU5vZGUgPSAhd2luZG93ICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmICFfcC5kaXNhYmxlZDtcblxuICAgIHNlbGYudHJpZ2dlcigncnVuJyk7XG5cbiAgICB2YXIgcnVuUCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKCByZXNvbHZlLCByZWplY3QgKXtcblxuICAgICAgX3AucnVubmluZyA9IHRydWU7XG5cbiAgICAgIHZhciB0aHJlYWRUZWNoQWxyZWFkeUV4aXN0cyA9IF9wLnJhbjtcblxuICAgICAgdmFyIGZuSW1wbFN0ciA9IGlzLnN0cmluZyggZm4gKSA/IGZuIDogZm4udG9TdHJpbmcoKTtcblxuICAgICAgLy8gd29ya2VyIGNvZGUgdG8gZXhlY1xuICAgICAgdmFyIGZuU3RyID0gJ1xcbicgKyAoIF9wLnJlcXVpcmVzLm1hcChmdW5jdGlvbiggciApe1xuICAgICAgICByZXR1cm4gZm5Bc1JlcXVpcmUoIHIgKTtcbiAgICAgIH0pICkuY29uY2F0KCBfcC5maWxlcy5tYXAoZnVuY3Rpb24oIGYgKXtcbiAgICAgICAgaWYoIHVzZVdXICl7XG4gICAgICAgICAgdmFyIHd3aWZ5RmlsZSA9IGZ1bmN0aW9uKCBmaWxlICl7XG4gICAgICAgICAgICBpZiggZmlsZS5tYXRjaCgvXlxcLlxcLy8pIHx8IGZpbGUubWF0Y2goL15cXC5cXC4vKSApe1xuICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIGZpbGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYoIGZpbGUubWF0Y2goL15cXC8vKSApe1xuICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArICcvJyArIGZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuICdpbXBvcnRTY3JpcHRzKFwiJyArIHd3aWZ5RmlsZShmKSArICdcIik7JztcbiAgICAgICAgfSBlbHNlIGlmKCB1c2VOb2RlICkge1xuICAgICAgICAgIHJldHVybiAnZXZhbCggcmVxdWlyZShcImZzXCIpLnJlYWRGaWxlU3luYyhcIicgKyBmICsgJ1wiLCB7IGVuY29kaW5nOiBcInV0ZjhcIiB9KSApOyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgJ0V4dGVybmFsIGZpbGUgYCcgKyBmICsgJ2AgY2FuIG5vdCBiZSByZXF1aXJlZCB3aXRob3V0IGFueSB0aHJlYWRpbmcgdGVjaG5vbG9neS4nO1xuICAgICAgICB9XG4gICAgICB9KSApLmNvbmNhdChbXG4gICAgICAgICcoIGZ1bmN0aW9uKCl7JyxcbiAgICAgICAgICAndmFyIHJldCA9ICgnICsgZm5JbXBsU3RyICsgJykoJyArIEpTT04uc3RyaW5naWZ5KHBhc3MpICsgJyk7JyxcbiAgICAgICAgICAnaWYoIHJldCAhPT0gdW5kZWZpbmVkICl7IHJlc29sdmUocmV0KTsgfScsIC8vIGFzc3VtZSBpZiByYW4gZm4gcmV0dXJucyBkZWZpbmVkIHZhbHVlIChpbmNsLiBudWxsKSwgdGhhdCB3ZSB3YW50IHRvIHJlc29sdmUgdG8gaXRcbiAgICAgICAgJ30gKSgpXFxuJ1xuICAgICAgXSkuam9pbignXFxuJyk7XG5cbiAgICAgIC8vIGJlY2F1c2Ugd2UndmUgbm93IGNvbnN1bWVkIHRoZSByZXF1aXJlcywgZW1wdHkgdGhlIGxpc3Qgc28gd2UgZG9uJ3QgZHVwZSBvbiBuZXh0IHJ1bigpXG4gICAgICBfcC5yZXF1aXJlcyA9IFtdO1xuICAgICAgX3AuZmlsZXMgPSBbXTtcblxuICAgICAgaWYoIHVzZVdXICl7XG4gICAgICAgIHZhciBmbkJsb2IsIGZuVXJsO1xuXG4gICAgICAgIC8vIGFkZCBub3JtYWxpc2VkIHRocmVhZCBhcGkgZnVuY3Rpb25zXG4gICAgICAgIGlmKCAhdGhyZWFkVGVjaEFscmVhZHlFeGlzdHMgKXtcbiAgICAgICAgICB2YXIgZm5QcmUgPSBmblN0ciArICcnO1xuXG4gICAgICAgICAgZm5TdHIgPSBbXG4gICAgICAgICAgICAnZnVuY3Rpb24gX3JlZl8obyl7IHJldHVybiBldmFsKG8pOyB9OycsXG4gICAgICAgICAgICAnZnVuY3Rpb24gYnJvYWRjYXN0KG0peyByZXR1cm4gbWVzc2FnZShtKTsgfTsnLCAvLyBhbGlhc1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG1lc3NhZ2UobSl7IHBvc3RNZXNzYWdlKG0pOyB9OycsXG4gICAgICAgICAgICAnZnVuY3Rpb24gbGlzdGVuKGZuKXsnLFxuICAgICAgICAgICAgJyAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihtKXsgJyxcbiAgICAgICAgICAgICcgICAgaWYoIHR5cGVvZiBtID09PSBcIm9iamVjdFwiICYmIChtLmRhdGEuJCRldmFsIHx8IG0uZGF0YSA9PT0gXCIkJHN0YXJ0XCIpICl7JyxcbiAgICAgICAgICAgICcgICAgfSBlbHNlIHsgJyxcbiAgICAgICAgICAgICcgICAgICBmbiggbS5kYXRhICk7JyxcbiAgICAgICAgICAgICcgICAgfScsXG4gICAgICAgICAgICAnICB9KTsnLFxuICAgICAgICAgICAgJ307JyxcbiAgICAgICAgICAgICdzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKG0peyAgaWYoIG0uZGF0YS4kJGV2YWwgKXsgZXZhbCggbS5kYXRhLiQkZXZhbCApOyB9ICB9KTsnLFxuICAgICAgICAgICAgJ2Z1bmN0aW9uIHJlc29sdmUodil7IHBvc3RNZXNzYWdlKHsgJCRyZXNvbHZlOiB2IH0pOyB9OycsXG4gICAgICAgICAgICAnZnVuY3Rpb24gcmVqZWN0KHYpeyBwb3N0TWVzc2FnZSh7ICQkcmVqZWN0OiB2IH0pOyB9OydcbiAgICAgICAgICBdLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgICAgZm5TdHIgKz0gZm5QcmU7XG5cbiAgICAgICAgICBmbkJsb2IgPSBuZXcgQmxvYihbIGZuU3RyIF0sIHtcbiAgICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZuVXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoIGZuQmxvYiApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSB3ZWJ3b3JrZXIgYW5kIGxldCBpdCBleGVjIHRoZSBzZXJpYWxpc2VkIGNvZGVcbiAgICAgICAgdmFyIHd3ID0gX3Aud2Vid29ya2VyID0gX3Aud2Vid29ya2VyIHx8IG5ldyBXb3JrZXIoIGZuVXJsICk7XG5cbiAgICAgICAgaWYoIHRocmVhZFRlY2hBbHJlYWR5RXhpc3RzICl7IC8vIHRoZW4ganVzdCBleGVjIG5ldyBydW4oKSBjb2RlXG4gICAgICAgICAgd3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgJCRldmFsOiBmblN0clxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd29ya2VyIG1lc3NhZ2VzID0+IGV2ZW50c1xuICAgICAgICB2YXIgY2I7XG4gICAgICAgIHd3LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBjYiA9IGZ1bmN0aW9uKCBtICl7XG4gICAgICAgICAgdmFyIGlzT2JqZWN0ID0gaXMub2JqZWN0KG0pICYmIGlzLm9iamVjdCggbS5kYXRhICk7XG5cbiAgICAgICAgICBpZiggaXNPYmplY3QgJiYgKCckJHJlc29sdmUnIGluIG0uZGF0YSkgKXtcbiAgICAgICAgICAgIHd3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBjYik7IC8vIGRvbmUgbGlzdGVuaW5nIGIvYyByZXNvbHZlKClcblxuICAgICAgICAgICAgcmVzb2x2ZSggbS5kYXRhLiQkcmVzb2x2ZSApO1xuICAgICAgICAgIH0gZWxzZSBpZiggaXNPYmplY3QgJiYgKCckJHJlamVjdCcgaW4gbS5kYXRhKSApe1xuICAgICAgICAgICAgd3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGNiKTsgLy8gZG9uZSBsaXN0ZW5pbmcgYi9jIHJlamVjdCgpXG5cbiAgICAgICAgICAgIHJlamVjdCggbS5kYXRhLiQkcmVqZWN0ICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlciggbmV3IEV2ZW50KG0sIHsgdHlwZTogJ21lc3NhZ2UnLCBtZXNzYWdlOiBtLmRhdGEgfSkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICBpZiggIXRocmVhZFRlY2hBbHJlYWR5RXhpc3RzICl7XG4gICAgICAgICAgd3cucG9zdE1lc3NhZ2UoJyQkc3RhcnQnKTsgLy8gc3RhcnQgdXAgdGhlIHdvcmtlclxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiggdXNlTm9kZSApe1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgcHJvY2Vzc1xuXG4gICAgICAgIGlmKCAhX3AuY2hpbGQgKXtcbiAgICAgICAgICBfcC5jaGlsZCA9ICggX2RlcmVxXygnY2hpbGRfcHJvY2VzcycpLmZvcmsoIF9kZXJlcV8oJ3BhdGgnKS5qb2luKF9fZGlybmFtZSwgJ3RocmVhZC1ub2RlLWZvcmsnKSApICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGQgPSBfcC5jaGlsZDtcblxuICAgICAgICAvLyBjaGlsZCBwcm9jZXNzIG1lc3NhZ2VzID0+IGV2ZW50c1xuICAgICAgICB2YXIgY2I7XG4gICAgICAgIGNoaWxkLm9uKCdtZXNzYWdlJywgY2IgPSBmdW5jdGlvbiggbSApe1xuICAgICAgICAgIGlmKCBpcy5vYmplY3QobSkgJiYgKCckJHJlc29sdmUnIGluIG0pICl7XG4gICAgICAgICAgICBjaGlsZC5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIGNiKTsgLy8gZG9uZSBsaXN0ZW5pbmcgYi9jIHJlc29sdmUoKVxuXG4gICAgICAgICAgICByZXNvbHZlKCBtLiQkcmVzb2x2ZSApO1xuICAgICAgICAgIH0gZWxzZSBpZiggaXMub2JqZWN0KG0pICYmICgnJCRyZWplY3QnIGluIG0pICl7XG4gICAgICAgICAgICBjaGlsZC5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIGNiKTsgLy8gZG9uZSBsaXN0ZW5pbmcgYi9jIHJlamVjdCgpXG5cbiAgICAgICAgICAgIHJlamVjdCggbS4kJHJlamVjdCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoIG5ldyBFdmVudCh7fSwgeyB0eXBlOiAnbWVzc2FnZScsIG1lc3NhZ2U6IG0gfSkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFzayB0aGUgY2hpbGQgcHJvY2VzcyB0byBldmFsIHRoZSB3b3JrZXIgY29kZVxuICAgICAgICBjaGlsZC5zZW5kKHtcbiAgICAgICAgICAkJGV2YWw6IGZuU3RyXG4gICAgICAgIH0pO1xuXG4gICAgICB9IGVsc2UgeyAvLyB1c2UgYSBmYWxsYmFjayBtZWNoYW5pc20gdXNpbmcgYSB0aW1lb3V0XG5cbiAgICAgICAgdmFyIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgdmFyIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG5cbiAgICAgICAgdmFyIHRpbWVyID0gX3AudGltZXIgPSBfcC50aW1lciB8fCB7XG5cbiAgICAgICAgICBsaXN0ZW5lcnM6IFtdLFxuXG4gICAgICAgICAgZXhlYzogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vIGFzIGEgc3RyaW5nIHNvIGl0IGNhbid0IGJlIG1hbmdsZWQgYnkgbWluaWZpZXJzIGFuZCBwcm9jZXNzb3JzXG4gICAgICAgICAgICBmblN0ciA9IFtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIF9yZWZfKG8peyByZXR1cm4gZXZhbChvKTsgfTsnLFxuICAgICAgICAgICAgICAnZnVuY3Rpb24gYnJvYWRjYXN0KG0peyByZXR1cm4gbWVzc2FnZShtKTsgfTsnLFxuICAgICAgICAgICAgICAnZnVuY3Rpb24gbWVzc2FnZShtKXsgc2VsZi50cmlnZ2VyKCBuZXcgRXZlbnQoe30sIHsgdHlwZTogXCJtZXNzYWdlXCIsIG1lc3NhZ2U6IG0gfSkgKTsgfTsnLFxuICAgICAgICAgICAgICAnZnVuY3Rpb24gbGlzdGVuKGZuKXsgdGltZXIubGlzdGVuZXJzLnB1c2goIGZuICk7IH07JyxcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIHJlc29sdmUodil7IHByb21pc2VSZXNvbHZlKHYpOyB9OycsXG4gICAgICAgICAgICAgICdmdW5jdGlvbiByZWplY3Qodil7IHByb21pc2VSZWplY3Qodik7IH07J1xuICAgICAgICAgICAgXS5qb2luKCdcXG4nKSArIGZuU3RyO1xuXG4gICAgICAgICAgICAvLyB0aGUgLnJ1bigpIGNvZGVcbiAgICAgICAgICAgIGV2YWwoIGZuU3RyICk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBtZXNzYWdlOiBmdW5jdGlvbiggbSApe1xuICAgICAgICAgICAgdmFyIGxzID0gdGltZXIubGlzdGVuZXJzO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgIHZhciBmbiA9IGxzW2ldO1xuXG4gICAgICAgICAgICAgIGZuKCBtICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgdGltZXIuZXhlYygpO1xuICAgICAgfVxuXG4gICAgfSkudGhlbihmdW5jdGlvbiggdiApe1xuICAgICAgX3AucnVubmluZyA9IGZhbHNlO1xuICAgICAgX3AucmFuID0gdHJ1ZTtcblxuICAgICAgc2VsZi50cmlnZ2VyKCdyYW4nKTtcblxuICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG5cbiAgICBpZiggX3AucXVldWUgPT0gbnVsbCApe1xuICAgICAgX3AucXVldWUgPSBydW5QOyAvLyBpLmUuIGZpcnN0IHN0ZXAgb2YgaW5kdWN0aXZlIHByb21pc2UgY2hhaW4gKGZvciBxdWV1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gcnVuUDtcbiAgfSxcblxuICAvLyBzZW5kIHRoZSB0aHJlYWQgYSBtZXNzYWdlXG4gIG1lc3NhZ2U6IGZ1bmN0aW9uKCBtICl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmKCBfcC53ZWJ3b3JrZXIgKXtcbiAgICAgIF9wLndlYndvcmtlci5wb3N0TWVzc2FnZSggbSApO1xuICAgIH1cblxuICAgIGlmKCBfcC5jaGlsZCApe1xuICAgICAgX3AuY2hpbGQuc2VuZCggbSApO1xuICAgIH1cblxuICAgIGlmKCBfcC50aW1lciApe1xuICAgICAgX3AudGltZXIubWVzc2FnZSggbSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmKCBfcC53ZWJ3b3JrZXIgKXtcbiAgICAgIF9wLndlYndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB9XG5cbiAgICBpZiggX3AuY2hpbGQgKXtcbiAgICAgIF9wLmNoaWxkLmtpbGwoKTtcbiAgICB9XG5cbiAgICBpZiggX3AudGltZXIgKXtcbiAgICAgIC8vIG5vdGhpbmcgd2UgY2FuIGRvIGlmIHdlJ3ZlIHJ1biBhIHRpbWVvdXRcbiAgICB9XG5cbiAgICBfcC5zdG9wcGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ3N0b3AnKTsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBzdG9wcGVkOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0b3BwZWQ7XG4gIH1cblxufSk7XG5cbi8vIHR1cm5zIGEgc3RyaW5naWZpZWQgZnVuY3Rpb24gaW50byBhIChyZSluYW1lZCBmdW5jdGlvblxudmFyIGZuQXMgPSBmdW5jdGlvbiggZm4sIG5hbWUgKXtcbiAgdmFyIGZuU3RyID0gZm4udG9TdHJpbmcoKTtcbiAgZm5TdHIgPSBmblN0ci5yZXBsYWNlKC9mdW5jdGlvblxccyo/XFxTKj9cXHMqP1xcKC8sICdmdW5jdGlvbiAnICsgbmFtZSArICcoJyk7XG5cbiAgcmV0dXJuIGZuU3RyO1xufTtcblxudmFyIGRlZmluZUZuYWwgPSBmdW5jdGlvbiggb3B0cyApe1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24gZm5hbEltcGwoIGZuLCBhcmcxICl7XG4gICAgdmFyIGZuU3RyID0gZm5BcyggZm4sICdfJF8kXycgKyBvcHRzLm5hbWUgKTtcblxuICAgIHRoaXMucmVxdWlyZSggZm5TdHIgKTtcblxuICAgIHJldHVybiB0aGlzLnJ1biggW1xuICAgICAgJ2Z1bmN0aW9uKCBkYXRhICl7JyxcbiAgICAgICcgIHZhciBvcmlnUmVzb2x2ZSA9IHJlc29sdmU7JyxcbiAgICAgICcgIHZhciByZXMgPSBbXTsnLFxuICAgICAgJyAgJyxcbiAgICAgICcgIHJlc29sdmUgPSBmdW5jdGlvbiggdmFsICl7JyxcbiAgICAgICcgICAgcmVzLnB1c2goIHZhbCApOycsXG4gICAgICAnICB9OycsXG4gICAgICAnICAnLFxuICAgICAgJyAgdmFyIHJldCA9IGRhdGEuJyArIG9wdHMubmFtZSArICcoIF8kXyRfJyArIG9wdHMubmFtZSArICggYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAnLCAnICsgSlNPTi5zdHJpbmdpZnkoYXJnMSkgOiAnJyApICsgJyApOycsXG4gICAgICAnICAnLFxuICAgICAgJyAgcmVzb2x2ZSA9IG9yaWdSZXNvbHZlOycsXG4gICAgICAnICByZXNvbHZlKCByZXMubGVuZ3RoID4gMCA/IHJlcyA6IHJldCApOycsXG4gICAgICAnfSdcbiAgICBdLmpvaW4oJ1xcbicpICk7XG4gIH07XG59O1xuXG51dGlsLmV4dGVuZCh0aGRmbiwge1xuICByZWR1Y2U6IGRlZmluZUZuYWwoeyBuYW1lOiAncmVkdWNlJyB9KSxcblxuICByZWR1Y2VSaWdodDogZGVmaW5lRm5hbCh7IG5hbWU6ICdyZWR1Y2VSaWdodCcgfSksXG5cbiAgbWFwOiBkZWZpbmVGbmFsKHsgbmFtZTogJ21hcCcgfSlcbn0pO1xuXG4vLyBhbGlhc2VzXG52YXIgZm4gPSB0aGRmbjtcbmZuLnByb21pc2UgPSBmbi5ydW47XG5mbi50ZXJtaW5hdGUgPSBmbi5oYWx0ID0gZm4uc3RvcDtcbmZuLmluY2x1ZGUgPSBmbi5yZXF1aXJlO1xuXG4vLyBwdWxsIGluIGV2ZW50IGFwaXNcbnV0aWwuZXh0ZW5kKHRoZGZuLCB7XG4gIG9uOiBkZWZpbmUub24oKSxcbiAgb25lOiBkZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICBvZmY6IGRlZmluZS5vZmYoKSxcbiAgdHJpZ2dlcjogZGVmaW5lLnRyaWdnZXIoKVxufSk7XG5cbmRlZmluZS5ldmVudEFsaWFzZXNPbiggdGhkZm4gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaHJlYWQ7XG5cbn0se1wiLi9kZWZpbmVcIjo0MSxcIi4vZXZlbnRcIjo0MixcIi4vaXNcIjo3NyxcIi4vcHJvbWlzZVwiOjgwLFwiLi91dGlsXCI6OTQsXCIuL3dpbmRvd1wiOjEwMCxcImNoaWxkX3Byb2Nlc3NcIjp1bmRlZmluZWQsXCJwYXRoXCI6dW5kZWZpbmVkfV0sOTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi9pcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZ2V0IFtyLCBnLCBiXSBmcm9tICNhYmMgb3IgI2FhYmJjY1xuICBoZXgydHVwbGU6IGZ1bmN0aW9uKCBoZXggKXtcbiAgICBpZiggIShoZXgubGVuZ3RoID09PSA0IHx8IGhleC5sZW5ndGggPT09IDcpIHx8IGhleFswXSAhPT0gXCIjXCIgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgc2hvcnRIZXggPSBoZXgubGVuZ3RoID09PSA0O1xuICAgIHZhciByLCBnLCBiO1xuICAgIHZhciBiYXNlID0gMTY7XG5cbiAgICBpZiggc2hvcnRIZXggKXtcbiAgICAgIHIgPSBwYXJzZUludCggaGV4WzFdICsgaGV4WzFdLCBiYXNlICk7XG4gICAgICBnID0gcGFyc2VJbnQoIGhleFsyXSArIGhleFsyXSwgYmFzZSApO1xuICAgICAgYiA9IHBhcnNlSW50KCBoZXhbM10gKyBoZXhbM10sIGJhc2UgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9IHBhcnNlSW50KCBoZXhbMV0gKyBoZXhbMl0sIGJhc2UgKTtcbiAgICAgIGcgPSBwYXJzZUludCggaGV4WzNdICsgaGV4WzRdLCBiYXNlICk7XG4gICAgICBiID0gcGFyc2VJbnQoIGhleFs1XSArIGhleFs2XSwgYmFzZSApO1xuICAgIH1cblxuICAgIHJldHVybiBbciwgZywgYl07XG4gIH0sXG5cbiAgLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIGhzbCgwLCAwLCAwKSBvciBoc2xhKDAsIDAsIDAsIDApXG4gIGhzbDJ0dXBsZTogZnVuY3Rpb24oIGhzbCApe1xuICAgIHZhciByZXQ7XG4gICAgdmFyIGgsIHMsIGwsIGEsIHIsIGcsIGI7XG4gICAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KXtcbiAgICAgIGlmKHQgPCAwKSB0ICs9IDE7XG4gICAgICBpZih0ID4gMSkgdCAtPSAxO1xuICAgICAgaWYodCA8IDEvNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICBpZih0IDwgMS8yKSByZXR1cm4gcTtcbiAgICAgIGlmKHQgPCAyLzMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICB2YXIgbSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB0aGlzLnJlZ2V4LmhzbGEgKyBcIiRcIikuZXhlYyhoc2wpO1xuICAgIGlmKCBtICl7XG5cbiAgICAgIC8vIGdldCBodWVcbiAgICAgIGggPSBwYXJzZUludCggbVsxXSApO1xuICAgICAgaWYoIGggPCAwICl7XG4gICAgICAgIGggPSAoIDM2MCAtICgtMSpoICUgMzYwKSApICUgMzYwO1xuICAgICAgfSBlbHNlIGlmKCBoID4gMzYwICl7XG4gICAgICAgIGggPSBoICUgMzYwO1xuICAgICAgfVxuICAgICAgaCAvPSAzNjA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgcyA9IHBhcnNlRmxvYXQoIG1bMl0gKTtcbiAgICAgIGlmKCBzIDwgMCB8fCBzID4gMTAwICl7IHJldHVybjsgfSAvLyBzYXR1cmF0aW9uIGlzIFswLCAxMDBdXG4gICAgICBzID0gcy8xMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgbCA9IHBhcnNlRmxvYXQoIG1bM10gKTtcbiAgICAgIGlmKCBsIDwgMCB8fCBsID4gMTAwICl7IHJldHVybjsgfSAvLyBsaWdodG5lc3MgaXMgWzAsIDEwMF1cbiAgICAgIGwgPSBsLzEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgICBhID0gbVs0XTtcbiAgICAgIGlmKCBhICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgYSA9IHBhcnNlRmxvYXQoIGEgKTtcblxuICAgICAgICBpZiggYSA8IDAgfHwgYSA+IDEgKXsgcmV0dXJuOyB9IC8vIGFscGhhIGlzIFswLCAxXVxuICAgICAgfVxuXG4gICAgICAvLyBub3csIGNvbnZlcnQgdG8gcmdiXG4gICAgICAvLyBjb2RlIGZyb20gaHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdFxuICAgICAgaWYoIHMgPT09IDAgKXtcbiAgICAgICAgciA9IGcgPSBiID0gTWF0aC5yb3VuZChsICogMjU1KTsgLy8gYWNocm9tYXRpY1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICAgICAgciA9IE1hdGgucm91bmQoIDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCArIDEvMykgKTtcbiAgICAgICAgZyA9IE1hdGgucm91bmQoIDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCkgKTtcbiAgICAgICAgYiA9IE1hdGgucm91bmQoIDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCAtIDEvMykgKTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gW3IsIGcsIGIsIGFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIHJnYigwLCAwLCAwKSBvciByZ2JhKDAsIDAsIDAsIDApXG4gIHJnYjJ0dXBsZTogZnVuY3Rpb24oIHJnYiApe1xuICAgIHZhciByZXQ7XG5cbiAgICB2YXIgbSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB0aGlzLnJlZ2V4LnJnYmEgKyBcIiRcIikuZXhlYyhyZ2IpO1xuICAgIGlmKCBtICl7XG4gICAgICByZXQgPSBbXTtcblxuICAgICAgdmFyIGlzUGN0ID0gW107XG4gICAgICBmb3IoIHZhciBpID0gMTsgaSA8PSAzOyBpKysgKXtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBtW2ldO1xuXG4gICAgICAgIGlmKCBjaGFubmVsWyBjaGFubmVsLmxlbmd0aCAtIDEgXSA9PT0gXCIlXCIgKXtcbiAgICAgICAgICBpc1BjdFtpXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbm5lbCA9IHBhcnNlRmxvYXQoIGNoYW5uZWwgKTtcblxuICAgICAgICBpZiggaXNQY3RbaV0gKXtcbiAgICAgICAgICBjaGFubmVsID0gY2hhbm5lbC8xMDAgKiAyNTU7IC8vIG5vcm1hbGlzZSB0byBbMCwgMjU1XVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGNoYW5uZWwgPCAwIHx8IGNoYW5uZWwgPiAyNTUgKXsgcmV0dXJuOyB9IC8vIGludmFsaWQgY2hhbm5lbCB2YWx1ZVxuXG4gICAgICAgIHJldC5wdXNoKCBNYXRoLmZsb29yKGNoYW5uZWwpICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdExlYXN0T25lSXNQY3QgPSBpc1BjdFsxXSB8fCBpc1BjdFsyXSB8fCBpc1BjdFszXTtcbiAgICAgIHZhciBhbGxBcmVQY3QgPSBpc1BjdFsxXSAmJiBpc1BjdFsyXSAmJiBpc1BjdFszXTtcbiAgICAgIGlmKCBhdExlYXN0T25lSXNQY3QgJiYgIWFsbEFyZVBjdCApeyByZXR1cm47IH0gLy8gbXVzdCBhbGwgYmUgcGVyY2VudCB2YWx1ZXMgaWYgb25lIGlzXG5cbiAgICAgIHZhciBhbHBoYSA9IG1bNF07XG4gICAgICBpZiggYWxwaGEgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICBhbHBoYSA9IHBhcnNlRmxvYXQoIGFscGhhICk7XG5cbiAgICAgICAgaWYoIGFscGhhIDwgMCB8fCBhbHBoYSA+IDEgKXsgcmV0dXJuOyB9IC8vIGludmFsaWQgYWxwaGEgdmFsdWVcblxuICAgICAgICByZXQucHVzaCggYWxwaGEgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGNvbG9ybmFtZTJ0dXBsZTogZnVuY3Rpb24oIGNvbG9yICl7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JzWyBjb2xvci50b0xvd2VyQ2FzZSgpIF07XG4gIH0sXG5cbiAgY29sb3IydHVwbGU6IGZ1bmN0aW9uKCBjb2xvciApe1xuICAgIHJldHVybiAoIGlzLmFycmF5KGNvbG9yKSA/IGNvbG9yIDogbnVsbCApXG4gICAgICB8fCB0aGlzLmNvbG9ybmFtZTJ0dXBsZShjb2xvcilcbiAgICAgIHx8IHRoaXMuaGV4MnR1cGxlKGNvbG9yKVxuICAgICAgfHwgdGhpcy5yZ2IydHVwbGUoY29sb3IpXG4gICAgICB8fCB0aGlzLmhzbDJ0dXBsZShjb2xvcik7XG4gIH0sXG5cbiAgY29sb3JzOiB7XG4gICAgLy8gc3BlY2lhbCBjb2xvdXIgbmFtZXNcbiAgICB0cmFuc3BhcmVudDogWzAsIDAsIDAsIDBdLCAvLyBOQiBhbHBoYSA9PT0gMFxuXG4gICAgLy8gcmVndWxhciBjb2xvdXJzXG4gICAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG4gICAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG4gICAgYXF1YTogWzAsIDI1NSwgMjU1XSxcbiAgICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG4gICAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcbiAgICBiZWlnZTogWzI0NSwgMjQ1LCAyMjBdLFxuICAgIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuICAgIGJsYWNrOiBbMCwgMCwgMF0sXG4gICAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsIDIzNSwgMjA1XSxcbiAgICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcbiAgICBicm93bjogWzE2NSwgNDIsIDQyXSxcbiAgICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcbiAgICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuICAgIGNoYXJ0cmV1c2U6IFsxMjcsIDI1NSwgMF0sXG4gICAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcbiAgICBjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG4gICAgY29ybmZsb3dlcmJsdWU6IFsxMDAsIDE0OSwgMjM3XSxcbiAgICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuICAgIGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG4gICAgY3lhbjogWzAsIDI1NSwgMjU1XSxcbiAgICBkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG4gICAgZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG4gICAgZGFya2dvbGRlbnJvZDogWzE4NCwgMTM0LCAxMV0sXG4gICAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuICAgIGRhcmtncmV5OiBbMTY5LCAxNjksIDE2OV0sXG4gICAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gICAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG4gICAgZGFya29saXZlZ3JlZW46IFs4NSwgMTA3LCA0N10sXG4gICAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcbiAgICBkYXJrcmVkOiBbMTM5LCAwLCAwXSxcbiAgICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gICAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG4gICAgZGFya3NsYXRlYmx1ZTogWzcyLCA2MSwgMTM5XSxcbiAgICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG4gICAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuICAgIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOV0sXG4gICAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcbiAgICBkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG4gICAgZGVlcHNreWJsdWU6IFswLCAxOTEsIDI1NV0sXG4gICAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuICAgIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICBkb2RnZXJibHVlOiBbMzAsIDE0NCwgMjU1XSxcbiAgICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG4gICAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwXSxcbiAgICBmb3Jlc3RncmVlbjogWzM0LCAxMzksIDM0XSxcbiAgICBmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuICAgIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuICAgIGdob3N0d2hpdGU6IFsyNDgsIDI0OCwgMjU1XSxcbiAgICBnb2xkOiBbMjU1LCAyMTUsIDBdLFxuICAgIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG4gICAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxuICAgIGdyZXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICBncmVlbjogWzAsIDEyOCwgMF0sXG4gICAgZ3JlZW55ZWxsb3c6IFsxNzMsIDI1NSwgNDddLFxuICAgIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG4gICAgaG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuICAgIGluZGlhbnJlZDogWzIwNSwgOTIsIDkyXSxcbiAgICBpbmRpZ286IFs3NSwgMCwgMTMwXSxcbiAgICBpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuICAgIGtoYWtpOiBbMjQwLCAyMzAsIDE0MF0sXG4gICAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG4gICAgbGF3bmdyZWVuOiBbMTI0LCAyNTIsIDBdLFxuICAgIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuICAgIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICAgIGxpZ2h0Y29yYWw6IFsyNDAsIDEyOCwgMTI4XSxcbiAgICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuICAgIGxpZ2h0Z3JheTogWzIxMSwgMjExLCAyMTFdLFxuICAgIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcbiAgICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgICBsaWdodHBpbms6IFsyNTUsIDE4MiwgMTkzXSxcbiAgICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuICAgIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuICAgIGxpZ2h0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyNTBdLFxuICAgIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG4gICAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwgMTk2LCAyMjJdLFxuICAgIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gICAgbGltZTogWzAsIDI1NSwgMF0sXG4gICAgbGltZWdyZWVuOiBbNTAsIDIwNSwgNTBdLFxuICAgIGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG4gICAgbWFnZW50YTogWzI1NSwgMCwgMjU1XSxcbiAgICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcbiAgICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcbiAgICBtZWRpdW1vcmNoaWQ6IFsxODYsIDg1LCAyMTFdLFxuICAgIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6IFsxMjMsIDEwNCwgMjM4XSxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcbiAgICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuICAgIG1lZGl1bXZpb2xldHJlZDogWzE5OSwgMjEsIDEzM10sXG4gICAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuICAgIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuICAgIG1pc3R5cm9zZTogWzI1NSwgMjI4LCAyMjVdLFxuICAgIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG4gICAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcbiAgICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG4gICAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gICAgb2xpdmVkcmFiOiBbMTA3LCAxNDIsIDM1XSxcbiAgICBvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG4gICAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG4gICAgb3JjaGlkOiBbMjE4LCAxMTIsIDIxNF0sXG4gICAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuICAgIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuICAgIHBhbGV0dXJxdW9pc2U6IFsxNzUsIDIzOCwgMjM4XSxcbiAgICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG4gICAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuICAgIHBlYWNocHVmZjogWzI1NSwgMjE4LCAxODVdLFxuICAgIHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuICAgIHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcbiAgICBwbHVtOiBbMjIxLCAxNjAsIDIyMV0sXG4gICAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuICAgIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgICByZWQ6IFsyNTUsIDAsIDBdLFxuICAgIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuICAgIHJveWFsYmx1ZTogWzY1LCAxMDUsIDIyNV0sXG4gICAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG4gICAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG4gICAgc2FuZHlicm93bjogWzI0NCwgMTY0LCA5Nl0sXG4gICAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG4gICAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcbiAgICBzaWVubmE6IFsxNjAsIDgyLCA0NV0sXG4gICAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuICAgIHNsYXRlYmx1ZTogWzEwNiwgOTAsIDIwNV0sXG4gICAgc2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgc2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgc25vdzogWzI1NSwgMjUwLCAyNTBdLFxuICAgIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuICAgIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG4gICAgdGFuOiBbMjEwLCAxODAsIDE0MF0sXG4gICAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG4gICAgdG9tYXRvOiBbMjU1LCA5OSwgNzFdLFxuICAgIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG4gICAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG4gICAgd2hlYXQ6IFsyNDUsIDIyMiwgMTc5XSxcbiAgICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICAgIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgICB5ZWxsb3c6IFsyNTUsIDI1NSwgMF0sXG4gICAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTBdXG4gIH1cbn07XG5cbn0se1wiLi4vaXNcIjo3N31dLDk0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gX2RlcmVxXygnLi4vaXMnKTtcbnZhciBtYXRoID0gX2RlcmVxXygnLi4vbWF0aCcpO1xuXG52YXIgdXRpbCA9IHtcblxuICBmYWxzaWZ5OiBmdW5jdGlvbigpeyByZXR1cm4gZmFsc2U7IH0sXG5cbiAgemVyb2lmeTogZnVuY3Rpb24oKXsgcmV0dXJuIDA7IH0sXG5cbiAgbm9vcDogZnVuY3Rpb24oKXt9LFxuXG4gIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKXtcbiAgICBpZiggY29uc29sZS5lcnJvciApe1xuICAgICAgY29uc29sZS5lcnJvci5hcHBseSggY29uc29sZSwgYXJndW1lbnRzICk7XG5cbiAgICAgIGlmKCBjb25zb2xlLnRyYWNlICl7IGNvbnNvbGUudHJhY2UoKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZy5hcHBseSggY29uc29sZSwgYXJndW1lbnRzICk7XG5cbiAgICAgIGlmKCBjb25zb2xlLnRyYWNlICl7IGNvbnNvbGUudHJhY2UoKTsgfVxuICAgIH1cbiAgfSxcbiAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICBjbG9uZTogZnVuY3Rpb24oIG9iaiApe1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCgge30sIG9iaiApO1xuICB9LFxuXG4gIC8vIGdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFyZ3VtZW50XG4gIGNvcHk6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICBpZiggb2JqID09IG51bGwgKXtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSBpZiggaXMuYXJyYXkob2JqKSApe1xuICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICAgIH0gZWxzZSBpZiggaXMucGxhaW5PYmplY3Qob2JqKSApe1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoIG9iaiApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfVxuXG59O1xuXG51dGlsLm1ha2VCb3VuZGluZ0JveCA9IG1hdGgubWFrZUJvdW5kaW5nQm94LmJpbmQoIG1hdGggKTtcblxudXRpbC5fc3RhdGljRW1wdHlPYmplY3QgPSB7fTtcblxudXRpbC5zdGF0aWNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB1dGlsLl9zdGF0aWNFbXB0eU9iamVjdDtcbn07XG5cbnV0aWwuZXh0ZW5kID0gT2JqZWN0LmFzc2lnbiAhPSBudWxsID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uKCB0Z3QgKXtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgZm9yKCB2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIG9iaiA9IGFyZ3NbaV07XG5cbiAgICBmb3IoIHZhciBrIGluIG9iaiApe1xuICAgICAgdGd0W2tdID0gb2JqW2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0Z3Q7XG59O1xuXG5bXG4gIF9kZXJlcV8oJy4vY29sb3JzJyksXG4gIF9kZXJlcV8oJy4vbWFwcycpLFxuICB7IG1lbW9pemU6IF9kZXJlcV8oJy4vbWVtb2l6ZScpIH0sXG4gIF9kZXJlcV8oJy4vcmVnZXgnKSxcbiAgX2RlcmVxXygnLi9zdHJpbmdzJyksXG4gIF9kZXJlcV8oJy4vdGltaW5nJylcbl0uZm9yRWFjaChmdW5jdGlvbiggcmVxICl7XG4gIHV0aWwuZXh0ZW5kKCB1dGlsLCByZXEgKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG5cbn0se1wiLi4vaXNcIjo3NyxcIi4uL21hdGhcIjo3OSxcIi4vY29sb3JzXCI6OTMsXCIuL21hcHNcIjo5NSxcIi4vbWVtb2l6ZVwiOjk2LFwiLi9yZWdleFwiOjk3LFwiLi9zdHJpbmdzXCI6OTgsXCIuL3RpbWluZ1wiOjk5fV0sOTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSBfZGVyZXFfKCcuLi9pcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gaGFzIGFueXRoaW5nIGJlZW4gc2V0IGluIHRoZSBtYXBcbiAgbWFwRW1wdHk6IGZ1bmN0aW9uKCBtYXAgKXtcbiAgICB2YXIgZW1wdHkgPSB0cnVlO1xuXG4gICAgaWYoIG1hcCAhPSBudWxsICl7XG4gICAgICBmb3IodmFyIGkgaW4gbWFwKXsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbXB0eTtcbiAgfSxcblxuICAvLyBwdXNoZXMgdG8gdGhlIGFycmF5IGF0IHRoZSBlbmQgb2YgYSBtYXAgKG1hcCBtYXkgbm90IGJlIGJ1aWx0KVxuICBwdXNoTWFwOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBhcnJheSA9IHRoaXMuZ2V0TWFwKG9wdGlvbnMpO1xuXG4gICAgaWYoIGFycmF5ID09IG51bGwgKXsgLy8gaWYgZW1wdHksIHB1dCBpbml0aWFsIGFycmF5XG4gICAgICB0aGlzLnNldE1hcCggdGhpcy5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgdmFsdWU6IFsgb3B0aW9ucy52YWx1ZSBdXG4gICAgICB9KSApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnJheS5wdXNoKCBvcHRpb25zLnZhbHVlICk7XG4gICAgfVxuICB9LFxuXG4gIC8vIHNldHMgdGhlIHZhbHVlIGluIGEgbWFwIChtYXAgbWF5IG5vdCBiZSBidWlsdClcbiAgc2V0TWFwOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgICB2YXIga2V5O1xuICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKXtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiggaXMucGxhaW5PYmplY3QoIGtleSApICl7XG4gICAgICAgIHRoaXMuZXJyb3IoJ1RyaWVkIHRvIHNldCBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBpIDwga2V5cy5sZW5ndGggLSAxICl7XG5cbiAgICAgICAgLy8gZXh0ZW5kIHRoZSBtYXAgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmKCBvYmpba2V5XSA9PSBudWxsICl7XG4gICAgICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZVxuICAgICAgICBvYmpba2V5XSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIGdldHMgdGhlIHZhbHVlIGluIGEgbWFwIGV2ZW4gaWYgaXQncyBub3QgYnVpbHQgaW4gcGxhY2VzXG4gIGdldE1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspe1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmKCBpcy5wbGFpbk9iamVjdCgga2V5ICkgKXtcbiAgICAgICAgdGhpcy5lcnJvcignVHJpZWQgdG8gZ2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICAgIH1cblxuICAgICAgb2JqID0gb2JqW2tleV07XG5cbiAgICAgIGlmKCBvYmogPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgLy8gZGVsZXRlcyB0aGUgZW50cnkgaW4gdGhlIG1hcFxuICBkZWxldGVNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGtlZXBDaGlsZHJlbiA9IG9wdGlvbnMua2VlcENoaWxkcmVuO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyl7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBrZXkgKSApe1xuICAgICAgICB0aGlzLmVycm9yKCdUcmllZCB0byBkZWxldGUgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEtleSA9IGkgPT09IG9wdGlvbnMua2V5cy5sZW5ndGggLSAxO1xuICAgICAgaWYoIGxhc3RLZXkgKXtcblxuICAgICAgICBpZigga2VlcENoaWxkcmVuICl7IC8vIHRoZW4gb25seSBkZWxldGUgY2hpbGQgZmllbGRzIG5vdCBpbiBrZWVwQ2hpbGRyZW5cbiAgICAgICAgICBmb3IoIHZhciBjaGlsZCBpbiBvYmogKXtcbiAgICAgICAgICAgIGlmKCAha2VlcENoaWxkcmVuW2NoaWxkXSApe1xuICAgICAgICAgICAgICBvYmpbY2hpbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbn0se1wiLi4vaXNcIjo3N31dLDk2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZW1vaXplKCBmbiwga2V5Rm4gKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FjaGUgPSB7fTtcblxuICBpZiggIWtleUZuICl7XG4gICAga2V5Rm4gPSBmdW5jdGlvbigpe1xuICAgICAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKXtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgYXJncy5wdXNoKCBhcmd1bWVudHNbaV0gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyZ3Muam9pbignJCcpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gbWVtb2l6ZWRGbigpe1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciByZXQ7XG4gICAgdmFyIGsgPSBrZXlGbi5hcHBseSggc2VsZiwgYXJncyApO1xuXG4gICAgaWYoICEocmV0ID0gY2FjaGVba10pICl7XG4gICAgICByZXQgPSBjYWNoZVtrXSA9IGZuLmFwcGx5KCBzZWxmLCBhcmdzICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn07XG5cbn0se31dLDk3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlciA9IFwiKD86Wy0rXT8oPzooPzpcXFxcZCt8XFxcXGQqXFxcXC5cXFxcZCspKD86W0VlXVsrLV0/XFxcXGQrKT8pKVwiO1xuXG52YXIgcmdiYSA9IFwicmdiW2FdP1xcXFwoKFwiKyBudW1iZXIgK1wiWyVdPylcXFxccyosXFxcXHMqKFwiKyBudW1iZXIgK1wiWyVdPylcXFxccyosXFxcXHMqKFwiKyBudW1iZXIgK1wiWyVdPykoPzpcXFxccyosXFxcXHMqKFwiKyBudW1iZXIgK1wiKSk/XFxcXClcIjtcbnZhciByZ2JhTm9CYWNrUmVmcyA9IFwicmdiW2FdP1xcXFwoKD86XCIrIG51bWJlciArXCJbJV0/KVxcXFxzKixcXFxccyooPzpcIisgbnVtYmVyICtcIlslXT8pXFxcXHMqLFxcXFxzKig/OlwiKyBudW1iZXIgK1wiWyVdPykoPzpcXFxccyosXFxcXHMqKD86XCIrIG51bWJlciArXCIpKT9cXFxcKVwiO1xuXG52YXIgaHNsYSA9IFwiaHNsW2FdP1xcXFwoKFwiKyBudW1iZXIgK1wiKVxcXFxzKixcXFxccyooXCIrIG51bWJlciArXCJbJV0pXFxcXHMqLFxcXFxzKihcIisgbnVtYmVyICtcIlslXSkoPzpcXFxccyosXFxcXHMqKFwiKyBudW1iZXIgK1wiKSk/XFxcXClcIjtcbnZhciBoc2xhTm9CYWNrUmVmcyA9IFwiaHNsW2FdP1xcXFwoKD86XCIrIG51bWJlciArXCIpXFxcXHMqLFxcXFxzKig/OlwiKyBudW1iZXIgK1wiWyVdKVxcXFxzKixcXFxccyooPzpcIisgbnVtYmVyICtcIlslXSkoPzpcXFxccyosXFxcXHMqKD86XCIrIG51bWJlciArXCIpKT9cXFxcKVwiO1xuXG52YXIgaGV4MyA9IFwiXFxcXCNbMC05YS1mQS1GXXszfVwiO1xudmFyIGhleDYgPSBcIlxcXFwjWzAtOWEtZkEtRl17Nn1cIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlZ2V4OiB7XG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgcmdiYTogcmdiYSxcbiAgICByZ2JhTm9CYWNrUmVmczogcmdiYU5vQmFja1JlZnMsXG4gICAgaHNsYTogaHNsYSxcbiAgICBoc2xhTm9CYWNrUmVmczogaHNsYU5vQmFja1JlZnMsXG4gICAgaGV4MzogaGV4MyxcbiAgICBoZXg2OiBoZXg2XG4gIH1cbn07XG5cbn0se31dLDk4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIG1lbW9pemUgPSBfZGVyZXFfKCcuL21lbW9pemUnKTtcbnZhciBpcyA9IF9kZXJlcV8oJy4uL2lzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGNhbWVsMmRhc2g6IG1lbW9pemUoIGZ1bmN0aW9uKCBzdHIgKXtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24oIHYgKXtcbiAgICAgIHJldHVybiAnLScgKyB2LnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gIH0gKSxcblxuICBkYXNoMmNhbWVsOiBtZW1vaXplKCBmdW5jdGlvbiggc3RyICl7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oLVxcdykvZywgZnVuY3Rpb24oIHYgKXtcbiAgICAgIHJldHVybiB2WzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH0gKSxcblxuICBjYXBpdGFsaXplOiBmdW5jdGlvbihzdHIpe1xuICAgIGlmKCBpcy5lbXB0eVN0cmluZyhzdHIpICl7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICB9XG5cbn07XG5cbn0se1wiLi4vaXNcIjo3NyxcIi4vbWVtb2l6ZVwiOjk2fV0sOTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2luZG93ID0gX2RlcmVxXygnLi4vd2luZG93Jyk7XG52YXIgaXMgPSBfZGVyZXFfKCcuLi9pcycpO1xudmFyIHBlcmZvcm1hbmNlID0gd2luZG93ID8gd2luZG93LnBlcmZvcm1hbmNlIDogbnVsbDtcblxudmFyIHV0aWwgPSB7fTtcblxudmFyIHJhZiA9ICF3aW5kb3cgPyBudWxsIDogKCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICk7XG5cbnJhZiA9IHJhZiB8fCBmdW5jdGlvbiggZm4gKXtcbiAgaWYoIGZuICl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgZm4oIHBub3coKSApO1xuICAgIH0sIDEwMDAvNjApO1xuICB9XG59O1xuXG51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGZuKXtcbiAgcmFmKCBmbiApO1xufTtcblxudmFyIHBub3cgPSBwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgPyBmdW5jdGlvbigpeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH0gOiBmdW5jdGlvbigpeyByZXR1cm4gRGF0ZS5ub3coKTsgfTtcblxudXRpbC5wZXJmb3JtYW5jZU5vdyA9IHBub3c7XG5cbi8vIHBvcnRlZCBsb2Rhc2ggdGhyb3R0bGUgZnVuY3Rpb25cbnV0aWwudGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICBsZWFkaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXMucGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICBvcHRpb25zLm1heFdhaXQgPSB3YWl0O1xuICBvcHRpb25zLnRyYWlsaW5nID0gdHJhaWxpbmc7XG5cbiAgcmV0dXJuIHV0aWwuZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucyk7XG59O1xuXG51dGlsLm5vdyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcblxudXRpbC5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHsgLy8gcG9ydGVkIGxvZGFzaCBkZWJvdW5jZSBmdW5jdGlvblxuICB2YXIgdXRpbCA9IHRoaXM7XG4gIHZhciBhcmdzLFxuICAgICAgbWF4VGltZW91dElkLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhbXAsXG4gICAgICB0aGlzQXJnLFxuICAgICAgdGltZW91dElkLFxuICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgbGFzdENhbGxlZCA9IDAsXG4gICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKCFpcy5mbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YWl0ID0gTWF0aC5tYXgoMCwgd2FpdCkgfHwgMDtcbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgdHJhaWxpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChpcy5wbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSBvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIChNYXRoLm1heCh3YWl0LCBvcHRpb25zLm1heFdhaXQpIHx8IDApO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHZhciBkZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAodXRpbC5ub3coKSAtIHN0YW1wKTtcbiAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNDYWxsZWQgPSB0cmFpbGluZ0NhbGw7XG4gICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgbGFzdENhbGxlZCA9IHV0aWwubm93KCk7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRyYWlsaW5nIHx8IChtYXhXYWl0ICE9PSB3YWl0KSkge1xuICAgICAgbGFzdENhbGxlZCA9IHV0aWwubm93KCk7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHN0YW1wID0gdXRpbC5ub3coKTtcbiAgICB0aGlzQXJnID0gdGhpcztcbiAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblxuICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICB9XG4gICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDA7XG5cbiAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgIHRpbWVvdXRJZCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgd2FpdCk7XG4gICAgfVxuICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgaXNDYWxsZWQgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICB9XG4gICAgaWYgKGlzQ2FsbGVkICYmICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuXG59LHtcIi4uL2lzXCI6NzcsXCIuLi93aW5kb3dcIjoxMDB9XSwxMDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSAoIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyApO1xuXG59LHt9XX0se30sWzc2XSkoNzYpXG59KTtcblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jeXRvc2NhcGUuanMubWFwXG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMi4wXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDEtMDhUMjA6MDJaXG4gKi9cblxuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gU3VwcG9ydDogRmlyZWZveCAxOCtcbi8vIENhbid0IGJlIGluIHN0cmljdCBtb2RlLCBzZXZlcmFsIGxpYnMgaW5jbHVkaW5nIEFTUC5ORVQgdHJhY2Vcbi8vIHRoZSBzdGFjayB2aWEgYXJndW1lbnRzLmNhbGxlci5jYWxsZWUgYW5kIEZpcmVmb3ggZGllcyBpZlxuLy8geW91IHRyeSB0byB0cmFjZSB0aHJvdWdoIFwidXNlIHN0cmljdFwiIGNhbGwgY2hhaW5zLiAoIzEzMzM1KVxuLy9cInVzZSBzdHJpY3RcIjtcbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIyLjIuMFwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbXFxkYS16XSkvZ2ksXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0Ly8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG5cdFx0dmFyIHJlYWxTdHJpbmdPYmogPSBvYmogJiYgb2JqLnRvU3RyaW5nKCk7XG5cdFx0cmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgKCByZWFsU3RyaW5nT2JqIC0gcGFyc2VGbG9hdCggcmVhbFN0cmluZ09iaiApICsgMSApID49IDA7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIE5vdCBwbGFpbiBvYmplY3RzOlxuXHRcdC8vIC0gQW55IG9iamVjdCBvciB2YWx1ZSB3aG9zZSBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHkgaXMgbm90IFwiW29iamVjdCBPYmplY3RdXCJcblx0XHQvLyAtIERPTSBub2Rlc1xuXHRcdC8vIC0gd2luZG93XG5cdFx0aWYgKCBqUXVlcnkudHlwZSggb2JqICkgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCBvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgcmV0dXJuZWQgYWxyZWFkeSwgd2UncmUgY29uZmlkZW50IHRoYXRcblx0XHQvLyB8b2JqfCBpcyBhIHBsYWluIG9iamVjdCwgY3JlYXRlZCBieSB7fSBvciBjb25zdHJ1Y3RlZCB3aXRoIG5ldyBPYmplY3Rcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMCwgaU9TPDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0dmFyIHNjcmlwdCxcblx0XHRcdGluZGlyZWN0ID0gZXZhbDtcblxuXHRcdGNvZGUgPSBqUXVlcnkudHJpbSggY29kZSApO1xuXG5cdFx0aWYgKCBjb2RlICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgY29kZSBpbmNsdWRlcyBhIHZhbGlkLCBwcm9sb2d1ZSBwb3NpdGlvblxuXHRcdFx0Ly8gc3RyaWN0IG1vZGUgcHJhZ21hLCBleGVjdXRlIGNvZGUgYnkgaW5qZWN0aW5nIGFcblx0XHRcdC8vIHNjcmlwdCB0YWcgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpZiAoIGNvZGUuaW5kZXhPZiggXCJ1c2Ugc3RyaWN0XCIgKSA9PT0gMSApIHtcblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXHRcdFx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGF2b2lkIHRoZSBET00gbm9kZSBjcmVhdGlvbiwgaW5zZXJ0aW9uXG5cdFx0XHRcdC8vIGFuZCByZW1vdmFsIGJ5IHVzaW5nIGFuIGluZGlyZWN0IGdsb2JhbCBldmFsXG5cblx0XHRcdFx0aW5kaXJlY3QoIGNvZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbi8vIEpTSGludCB3b3VsZCBlcnJvciBvbiB0aGlzIGNvZGUgZHVlIHRvIHRoZSBTeW1ib2wgbm90IGJlaW5nIGRlZmluZWQgaW4gRVM1LlxuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmpzaGludHJjIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8ganVzdCBkaXNhYmxlIEpTSGludCBmb3IgdGhlc2Vcbi8vIHRocmVlIGxpbmVzLlxuLyoganNoaW50IGlnbm9yZTogc3RhcnQgKi9cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cbi8qIGpzaGludCBpZ25vcmU6IGVuZCAqL1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDguMiAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4yLjFcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTUtMTAtMTdcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXHRyZXNjYXBlID0gLyd8XFxcXC9nLFxuXG5cdC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBuaWRzZWxlY3QsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdG5pZHNlbGVjdCA9IHJpZGVudGlmaWVyLnRlc3QoIG5pZCApID8gXCIjXCIgKyBuaWQgOiBcIltpZD0nXCIgKyBuaWQgKyBcIiddXCI7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBuaWRzZWxlY3QgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGRpdiBhbmQgZXhwZWN0cyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGRpdiApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZGl2LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZGl2ICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdCggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLVxuXHRcdFx0KCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgcGFyZW50LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCAocGFyZW50ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHBhcmVudC50b3AgIT09IHBhcmVudCApIHtcblx0XHQvLyBTdXBwb3J0OiBJRSAxMVxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggcGFyZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0cGFyZW50LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZGl2LmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gbSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2liaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRkaXYucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGRpdiwgXCJkaXZcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGRpdiwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGRpciBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYxICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFtcXHctXSspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvICk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0cmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW10gOlxuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQmxhY2tiZXJyeSA0LjZcblx0XHRcdFx0XHQvLyBnRUJJRCByZXR1cm5zIG5vZGVzIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKCM2OTYzKVxuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCApIDpcblx0XHRcdFx0MDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCBwb3MgP1xuXHRcdFx0XHRcdHBvcy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3R3aGl0ZSA9ICggL1xcUysvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCBcInJlamVjdGVkXCIgXSxcblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgaSBdICkgJiYgZm5zWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzID09PSBwcm9taXNlID8gbmV3RGVmZXIucHJvbWlzZSgpIDogdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cblx0XHRcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuXHRcdFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8XG5cdFx0XHRcdCggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC5cblx0XHRcdC8vIElmIHJlc29sdmVWYWx1ZXMgY29uc2lzdCBvZiBvbmx5IGEgc2luZ2xlIERlZmVycmVkLCBqdXN0IHVzZSB0aGF0LlxuXHRcdFx0ZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBVcGRhdGUgZnVuY3Rpb24gZm9yIGJvdGggcmVzb2x2ZSBhbmQgcHJvZ3Jlc3MgdmFsdWVzXG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGksIGNvbnRleHRzLCB2YWx1ZXMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0Y29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0dmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XG5cblx0XHQvLyBBZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG5cdFx0aWYgKCBsZW5ndGggPiAxICkge1xuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcblx0XHRcdFx0XHRcdC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC0tcmVtYWluaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxuXHRcdGlmICggIXJlbWFpbmluZyApIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0Ly8gQWRkIHRoZSBjYWxsYmFja1xuXHRqUXVlcnkucmVhZHkucHJvbWlzZSgpLmRvbmUoIGZuICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG5cdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG5cdFx0aWYgKCBqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIgKSB7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlckhhbmRsZXIoIFwicmVhZHlcIiApO1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLm9mZiggXCJyZWFkeVwiICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8qKlxuICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG5qUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdGlmICggIXJlYWR5TGlzdCApIHtcblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcblx0XHQvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyBTdXBwb3J0OiBJRTktMTAgb25seVxuXHRcdC8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdFx0XHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHRcdFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG5qUXVlcnkucmVhZHkucHJvbWlzZSgpO1xuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hhaW5hYmxlID9cblx0XHRlbGVtcyA6XG5cblx0XHQvLyBHZXRzXG5cdFx0YnVsayA/XG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHQvKiBqc2hpbnQgLVcwMTggKi9cblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdHJlZ2lzdGVyOiBmdW5jdGlvbiggb3duZXIsIGluaXRpYWwgKSB7XG5cdFx0dmFyIHZhbHVlID0gaW5pdGlhbCB8fCB7fTtcblxuXHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlIHByb3BlcnR5XG5cdFx0Ly8gY29uZmlndXJhYmlsaXR5IG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHQvLyBkZWxldGVkIHdpdGggdGhlIGRlbGV0ZSBvcGVyYXRvclxuXHRcdH0gZWxzZSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdH0sXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdGlmICggIWFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgZGF0YSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBwcm9wIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBrZXkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHN0b3JlZDtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0c3RvcmVkID0gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblxuXHRcdFx0cmV0dXJuIHN0b3JlZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0c3RvcmVkIDogdGhpcy5nZXQoIG93bmVyLCBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSwgbmFtZSwgY2FtZWwsXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5yZWdpc3Rlciggb3duZXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0ga2V5LmNvbmNhdCgga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIFRyeSB0aGUgc3RyaW5nIGFzIGEga2V5IGJlZm9yZSBhbnkgbWFuaXB1bGF0aW9uXG5cdFx0XHRcdGlmICgga2V5IGluIGNhY2hlICkge1xuXHRcdFx0XHRcdG5hbWUgPSBbIGtleSwgY2FtZWwgXTtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRcdG5hbWUgPSBjYW1lbDtcblx0XHRcdFx0XHRuYW1lID0gbmFtZSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0XHRbIG5hbWUgXSA6ICggbmFtZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIG5hbWVbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PSAzNS00NStcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3XG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMStcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhLCBjYW1lbEtleTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApIHx8XG5cblx0XHRcdFx0XHQvLyBUcnkgdG8gZmluZCBkYXNoZWQga2V5IGlmIGl0IGV4aXN0cyAoZ2gtMjc3OSlcblx0XHRcdFx0XHQvLyBUaGlzIGlzIGZvciAyLjIueCBvbmx5XG5cdFx0XHRcdFx0ZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCkgKTtcblxuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGNhbWVsS2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGNhbWVsS2V5LCB1bmRlZmluZWQgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBGaXJzdCwgYXR0ZW1wdCB0byBzdG9yZSBhIGNvcHkgb3IgcmVmZXJlbmNlIG9mIGFueVxuXHRcdFx0XHQvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXG5cdFx0XHRcdHZhciBkYXRhID0gZGF0YVVzZXIuZ2V0KCB0aGlzLCBjYW1lbEtleSApO1xuXG5cdFx0XHRcdC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cblx0XHRcdFx0Ly8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cblx0XHRcdFx0Ly8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywgY2FtZWxLZXksIHZhbHVlICk7XG5cblx0XHRcdFx0Ly8gKi4uLiBJbiB0aGUgY2FzZSBvZiBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgX2FjdHVhbGx5X1xuXHRcdFx0XHQvLyBoYXZlIGRhc2hlcywgd2UgbmVlZCB0byBhbHNvIHN0b3JlIGEgY29weSBvZiB0aGF0XG5cdFx0XHRcdC8vIHVuY2hhbmdlZCBwcm9wZXJ0eS5cblx0XHRcdFx0aWYgKCBrZXkuaW5kZXhPZiggXCItXCIgKSA+IC0xICYmIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHQhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHdlZW4uY3VyKCk7IH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7IH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFtcXHc6LV0rKS8gKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldCA9IHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMC00LjMsIFNhZmFyaTw9NS4xXG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmk8PTUuMSwgQW5kcm9pZDw0LjJcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUU5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gU3VwcG9ydCAoYXQgbGVhc3QpOiBDaHJvbWUsIElFOVxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDw9NDIrXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgaW4gRkYgYnV0IGRvbid0IGJsb2NrIElFIHJhZGlvIGV2ZW50cyAoIzM4NjEsIGdoLTIzNDMpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJlxuXHRcdFx0KCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgfHwgaXNOYU4oIGV2ZW50LmJ1dHRvbiApIHx8IGV2ZW50LmJ1dHRvbiA8IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAoIGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gW107XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHQvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxuXHRwcm9wczogKCBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGRldGFpbCBldmVudFBoYXNlIFwiICtcblx0XHRcIm1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIiApLnNwbGl0KCBcIiBcIiApLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdCggXCIgXCIgKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0bW91c2VIb29rczoge1xuXHRcdHByb3BzOiAoIFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBcIiArXG5cdFx0XHRcInNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b247XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcblx0XHRcdFx0ZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCwgY29weSxcblx0XHRcdHR5cGUgPSBldmVudC50eXBlLFxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxuXHRcdFx0Zml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuXHRcdGlmICggIWZpeEhvb2sgKSB7XG5cdFx0XHR0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cblx0XHRcdFx0cm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuXHRcdFx0XHR7fTtcblx0XHR9XG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuXHRcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0aSA9IGNvcHkubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ29yZG92YSAyLjUgKFdlYktpdCkgKCMxMzI1NSlcblx0XHQvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3Rcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lPDI4XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6LV0rKVtePl0qKVxcLz4vZ2ksXG5cblx0Ly8gU3VwcG9ydDogSUUgMTAtMTEsIEVkZ2UgMTAyNDArXG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0gMzUtNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gS2VlcCBkb21NYW5pcCBleHBvc2VkIHVudGlsIDMuMCAoZ2gtMjIyNSlcblx0ZG9tTWFuaXA6IGRvbU1hbmlwLFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcblxuXG52YXIgaWZyYW1lLFxuXHRlbGVtZGlzcGxheSA9IHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3hcblx0XHQvLyBXZSBoYXZlIHRvIHByZS1kZWZpbmUgdGhlc2UgdmFsdWVzIGZvciBGRiAoIzEwMjI3KVxuXHRcdEhUTUw6IFwiYmxvY2tcIixcblx0XHRCT0RZOiBcImJsb2NrXCJcblx0fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAqL1xuXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxuZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuXHR2YXIgZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW1bIDAgXSwgXCJkaXNwbGF5XCIgKTtcblxuXHQvLyBXZSBkb24ndCBoYXZlIGFueSBkYXRhIHN0b3JlZCBvbiB0aGUgZWxlbWVudCxcblx0Ly8gc28gdXNlIFwiZGV0YWNoXCIgbWV0aG9kIGFzIGZhc3Qgd2F5IHRvIGdldCByaWQgb2YgdGhlIGVsZW1lbnRcblx0ZWxlbS5kZXRhY2goKTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblx0dmFyIGRvYyA9IGRvY3VtZW50LFxuXHRcdGRpc3BsYXkgPSBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcblxuXHRpZiAoICFkaXNwbGF5ICkge1xuXHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cblx0XHQvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFkaXNwbGF5ICkge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcblx0XHRcdGlmcmFtZSA9ICggaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSApXG5cdFx0XHRcdC5hcHBlbmRUbyggZG9jLmRvY3VtZW50RWxlbWVudCApO1xuXG5cdFx0XHQvLyBBbHdheXMgd3JpdGUgYSBuZXcgSFRNTCBza2VsZXRvbiBzbyBXZWJraXQgYW5kIEZpcmVmb3ggZG9uJ3QgY2hva2Ugb24gcmV1c2Vcblx0XHRcdGRvYyA9IGlmcmFtZVsgMCBdLmNvbnRlbnREb2N1bWVudDtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUVcblx0XHRcdGRvYy53cml0ZSgpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cblx0XHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cdFx0XHRpZnJhbWUuZGV0YWNoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XG5cdFx0ZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXHR9XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHR9XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBUaGlzIHRlc3QgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGJ1dCB3ZSBzdGlsbCBkbyBtZW1vaXppbmdcblx0XHRcdC8vIHNpbmNlIHdlIGNhbiB1c2UgdGhlIGJveFNpemluZ1JlbGlhYmxlIHByZS1jb21wdXRpbmcuXG5cdFx0XHQvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wLTQuM1xuXHRcdFx0Ly8gV2UncmUgY2hlY2tpbmcgZm9yIGJveFNpemluZ1JlbGlhYmxlVmFsIGhlcmUgaW5zdGVhZCBvZiBwaXhlbE1hcmdpblJpZ2h0VmFsXG5cdFx0XHQvLyBzaW5jZSB0aGF0IGNvbXByZXNzZXMgYmV0dGVyIGFuZCB0aGV5J3JlIGNvbXB1dGVkIHRvZ2V0aGVyIGFueXdheS5cblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IG9ubHksIEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gMzdcblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gKCMzMzMzKVxuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRtYXJnaW5EaXYgPSBkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nXG5cdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFwiZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcblx0XHRcdG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcblx0XHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRcdHJldCA9ICFwYXJzZUZsb2F0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2ICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0XHRcdGRpdi5yZW1vdmVDaGlsZCggbWFyZ2luRGl2ICk7XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJPXCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cblx0XHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0XHQ0IDpcblxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHR2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFMTEgb25seVxuXHQvLyBJbiBJRSAxMSBmdWxsc2NyZWVuIGVsZW1lbnRzIGluc2lkZSBvZiBhbiBpZnJhbWUgaGF2ZVxuXHQvLyAxMDB4IHRvbyBzbWFsbCBkaW1lbnNpb25zIChnaC0xNzY0KS5cblx0aWYgKCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50ICYmIHdpbmRvdy50b3AgIT09IHdpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFMTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0aWYgKCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0dmFsID0gTWF0aC5yb3VuZCggZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVsgbmFtZSBdICogMTAwICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblxuXHRcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdFx0dmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuXHRcdFx0Ly8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICYmIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXG5cdFx0XHQvLyBpbiBhIHN0eWxlc2hlZXQgdG8gd2hhdGV2ZXIgdGhlIGRlZmF1bHQgYnJvd3NlciBzdHlsZSBpc1xuXHRcdFx0Ly8gZm9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW4oIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuYWNjZXNzKFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XCJvbGRkaXNwbGF5XCIsXG5cdFx0XHRcdFx0ZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuXG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4gKSB7XG5cdFx0XHRcdGRhdGFQcml2LnNldChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFwib2xkZGlzcGxheVwiLFxuXHRcdFx0XHRcdGhpZGRlbiA/IGRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3Bcblx0Ly8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmICggIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gdmFsdWVzWyBpbmRleCBdIHx8IFwiXCIgOiBcIm5vbmVcIjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXHRcdFx0XHRcdGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiBzd2FwKCBlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sXG5cdFx0XHRcdGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBDb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0LyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLCBkaXNwbGF5LCBjaGVja0Rpc3BsYXksXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBIYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzXG5cdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiaGVpZ2h0XCIgaW4gcHJvcHMgfHwgXCJ3aWR0aFwiIGluIHByb3BzICkgKSB7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFOS0xMCBkbyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTtcblxuXHRcdGlmICggY2hlY2tEaXNwbGF5ID09PSBcImlubGluZVwiICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gc2hvdy9oaWRlIHBhc3Ncblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy5leGVjKCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBkYXRhU2hvdyBsZWZ0IG92ZXIgZnJvbSBhIHN0b3BwZWQgaGlkZSBvciBzaG93XG5cdFx0XHRcdC8vIGFuZCB3ZSBhcmUgZ29pbmcgdG8gcHJvY2VlZCB3aXRoIHNob3csIHdlIHNob3VsZCBwcmV0ZW5kIHRvIGJlIGhpZGRlblxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblxuXHRcdC8vIEFueSBub24tZnggdmFsdWUgc3RvcHMgdXMgZnJvbSByZXN0b3JpbmcgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzcGxheSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHt9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcInJldmVyc2VcIlxuXHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHR9XG5cdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5zaG93KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0dHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblxuXHRcdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdFx0dHdlZW4uZW5kID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdFx0dHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdC8vIElmIHRoaXMgaXMgYSBub29wIGxpa2UgLmhpZGUoKS5oaWRlKCksIHJlc3RvcmUgYW4gb3ZlcndyaXR0ZW4gZGlzcGxheSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCAoIGRpc3BsYXkgPT09IFwibm9uZVwiID8gZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXkgKSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/XG5cdFx0b3B0LmR1cmF0aW9uIDogb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgP1xuXHRcdFx0alF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHR3aW5kb3cuY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBpT1M8PTUuMSwgQW5kcm9pZDw9NC4yK1xuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8PTIuM1xuXHQvLyBPcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZSBpbmNvcnJlY3RseSBtYXJrZWQgYXMgZGlzYWJsZWRcblx0c2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcblx0c3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsIHByb3BOYW1lLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcblx0XHRcdFx0aWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0XHRcdC8vIFNldCBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHRvIGZhbHNlXG5cdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIG5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGFiaW5kZXggP1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKSA6XG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIGdldENsYXNzKCBlbGVtICkgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApIDpcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8MTFcblx0XHRcdFx0Ly8gb3B0aW9uLnZhbHVlIG5vdCB0cmltbWVkICgjMTQ4NTgpXG5cdFx0XHRcdHJldHVybiBqUXVlcnkudHJpbSggZWxlbS52YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIgfHwgaW5kZXggPCAwLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCggc3VwcG9ydC5vcHREaXNhYmxlZCA/XG5cdFx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09PSBudWxsICkgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cblx0XHRcdFx0Ly8gUHJldmlvdXNseSwgYG9yaWdpbmFsRXZlbnQ6IHt9YCB3YXMgc2V0IGhlcmUsIHNvIHN0b3BQcm9wYWdhdGlvbiBjYWxsXG5cdFx0XHRcdC8vIHdvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgb24gZG9ub3IgZXZlbnQsIHNpbmNlIGluIG91ciBvd25cblx0XHRcdFx0Ly8galF1ZXJ5LmV2ZW50LnN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvbiB3ZSBoYWQgYSBjaGVjayBmb3IgZXhpc3RlbmNlIG9mXG5cdFx0XHRcdC8vIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uIG1ldGhvZCwgc28sIGNvbnNlcXVlbnRseSBpdCB3b3VsZCBiZSBhIG5vb3AuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIEJ1dCBub3csIHRoaXMgXCJzaW11bGF0ZVwiIGZ1bmN0aW9uIGlzIHVzZWQgb25seSBmb3IgZXZlbnRzXG5cdFx0XHRcdC8vIGZvciB3aGljaCBzdG9wUHJvcGFnYXRpb24oKSBpcyBub29wLCBzbyB0aGVyZSBpcyBubyBuZWVkIGZvciB0aGF0IGFueW1vcmUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIEZvciB0aGUgY29tcGF0IGJyYW5jaCB0aG91Z2gsIGd1YXJkIGZvciBcImNsaWNrXCIgYW5kIFwic3VibWl0XCJcblx0XHRcdFx0Ly8gZXZlbnRzIGlzIHN0aWxsIHVzZWQsIGJ1dCB3YXMgbW92ZWQgdG8galF1ZXJ5LmV2ZW50LnN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvblxuXHRcdFx0XHQvLyBiZWNhdXNlIGBvcmlnaW5hbEV2ZW50YCBzaG91bGQgcG9pbnQgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IGZvciB0aGUgY29uc3RhbmN5XG5cdFx0XHRcdC8vIHdpdGggb3RoZXIgZXZlbnRzIGFuZCBmb3IgbW9yZSBmb2N1c2VkIGxvZ2ljXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUsIFNhZmFyaVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuLy8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcbmpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKyBcIlwiICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cblx0XHQvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgtMTErXG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIGlmIHVybCBpcyBtYWxmb3JtZWQsIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU4LTExK1xuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdGNhY2hlVVJMID0gcy51cmw7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gKCBzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhICk7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0gKS5lbmQoKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0Ly8gU3VwcG9ydDogT3BlcmEgPD0gMTIuMTJcblx0Ly8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xuXHQvLyBVc2UgT1IgaW5zdGVhZCBvZiBBTkQgYXMgdGhlIGVsZW1lbnQgaXMgbm90IHZpc2libGUgaWYgZWl0aGVyIGlzIHRydWVcblx0Ly8gU2VlIHRpY2tldHMgIzEwNDA2IGFuZCAjMTMxMzJcblx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPiAwIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0ID4gMCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID4gMDtcbn07XG5cblxuXG5cbnZhciByMjAgPSAvJTIwL2csXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0eyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFOSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCtcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRjb250ZXh0ID0gY29udGV4dCB8fCAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID9cblx0XHRkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKSA6XG5cdFx0ZG9jdW1lbnQgKTtcblxuXHR2YXIgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICksXG5cdFx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxudmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcblx0XHRyZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0galF1ZXJ5LnRyaW0oIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHNlbGYsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRpZiAoICFkb2MgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNYWtlIHN1cmUgaXQncyBub3QgYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcblx0XHRpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcblx0XHRcdHJldHVybiBib3g7XG5cdFx0fVxuXG5cdFx0Ym94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IGJveC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0fTtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcblx0XHQvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdC8vIFN1YnRyYWN0IG9mZnNldFBhcmVudCBzY3JvbGwgcG9zaXRpb25zXG5cdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKSAtXG5cdFx0XHRcdG9mZnNldFBhcmVudC5zY3JvbGxUb3AoKTtcblx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICkgLVxuXHRcdFx0XHRvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdCgpO1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmk8Ny04KywgQ2hyb21lPDM3LTQ0K1xuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MjgwXG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlLCBudWxsICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cdHNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cbnJldHVybiBqUXVlcnk7XG59KSk7XG4iLCJ2YXIgcmVxID0gcmVxdWlyZSgncmVxdWVzdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gTmV0c1xuXG5mdW5jdGlvbiBOZXRzIChvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSBvcHRzID0geyB1cmk6IG9wdHMgfVxuXG4gIC8vIGluIG5vZGUsIGlmIGVuY29kaW5nID09PSBudWxsIHRoZW4gcmVzcG9uc2Ugd2lsbCBiZSBhIEJ1ZmZlci4gd2Ugd2FudCB0aGlzIHRvIGJlIHRoZSBkZWZhdWx0XG4gIGlmICghb3B0cy5oYXNPd25Qcm9wZXJ0eSgnZW5jb2RpbmcnKSkgb3B0cy5lbmNvZGluZyA9IG51bGxcblxuICAvLyBpbiBicm93c2VyLCB3ZSBzaG91bGQgYnkgZGVmYXVsdCBjb252ZXJ0IHRoZSBhcnJheWJ1ZmZlciBpbnRvIGEgQnVmZmVyXG4gIGlmIChwcm9jZXNzLmJyb3dzZXIgJiYgIW9wdHMuaGFzT3duUHJvcGVydHkoJ2pzb24nKSAmJiBvcHRzLmVuY29kaW5nID09PSBudWxsKSB7XG4gICAgb3B0cy5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgdmFyIG9yaWdpbmFsQ2IgPSBjYlxuICAgIGNiID0gYnVmZmVyaWZ5XG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJpZnkgKGVyciwgcmVzcCwgYm9keSkge1xuICAgIGlmIChib2R5KSBib2R5ID0gbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShib2R5KSlcbiAgICBvcmlnaW5hbENiKGVyciwgcmVzcCwgYm9keSlcbiAgfVxuXG4gIHJldHVybiByZXEob3B0cywgY2IpXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB3aW5kb3cgPSByZXF1aXJlKFwiZ2xvYmFsL3dpbmRvd1wiKVxudmFyIG9uY2UgPSByZXF1aXJlKFwib25jZVwiKVxudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKFwiaXMtZnVuY3Rpb25cIilcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKFwicGFyc2UtaGVhZGVyc1wiKVxudmFyIHh0ZW5kID0gcmVxdWlyZShcInh0ZW5kXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlWEhSXG5jcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgbm9vcFxuY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0ID0gXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiAobmV3IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCgpKSA/IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA6IHdpbmRvdy5YRG9tYWluUmVxdWVzdFxuXG5mb3JFYWNoQXJyYXkoW1wiZ2V0XCIsIFwicHV0XCIsIFwicG9zdFwiLCBcInBhdGNoXCIsIFwiaGVhZFwiLCBcImRlbGV0ZVwiXSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgY3JlYXRlWEhSW21ldGhvZCA9PT0gXCJkZWxldGVcIiA/IFwiZGVsXCIgOiBtZXRob2RdID0gZnVuY3Rpb24odXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICAgIHJldHVybiBfY3JlYXRlWEhSKG9wdGlvbnMpXG4gICAgfVxufSlcblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0pXG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0VtcHR5KG9iail7XG4gICAgZm9yKHZhciBpIGluIG9iail7XG4gICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJhbXMgPSB1cmlcblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcGFyYW1zID0ge3VyaTp1cml9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMgPSB4dGVuZChvcHRpb25zLCB7dXJpOiB1cml9KVxuICAgIH1cblxuICAgIHBhcmFtcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgcmV0dXJuIHBhcmFtc1xufVxuXG5mdW5jdGlvbiBjcmVhdGVYSFIodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVhIUihvcHRpb25zKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFja1xuICAgIGlmKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIilcbiAgICB9XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKVxuXG4gICAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBsb2FkRnVuYygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XG4gICAgICAgIHZhciBib2R5ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVxuICAgICAgICB9IGVsc2UgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09IFwidGV4dFwiIHx8ICF4aHIucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlVGV4dCB8fCB4aHIucmVzcG9uc2VYTUxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0pzb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9keVxuICAgIH1cblxuICAgIHZhciBmYWlsdXJlUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgICAgICAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvckZ1bmMoZXZ0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIGlmKCEoZXZ0IGluc3RhbmNlb2YgRXJyb3IpKXtcbiAgICAgICAgICAgIGV2dCA9IG5ldyBFcnJvcihcIlwiICsgKGV2dCB8fCBcIlVua25vd24gWE1MSHR0cFJlcXVlc3QgRXJyb3JcIikgKVxuICAgICAgICB9XG4gICAgICAgIGV2dC5zdGF0dXNDb2RlID0gMFxuICAgICAgICBjYWxsYmFjayhldnQsIGZhaWx1cmVSZXNwb25zZSlcbiAgICB9XG5cbiAgICAvLyB3aWxsIGxvYWQgdGhlIGRhdGEgJiBwcm9jZXNzIHRoZSByZXNwb25zZSBpbiBhIHNwZWNpYWwgcmVzcG9uc2Ugb2JqZWN0XG4gICAgZnVuY3Rpb24gbG9hZEZ1bmMoKSB7XG4gICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm5cbiAgICAgICAgdmFyIHN0YXR1c1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBpZihvcHRpb25zLnVzZVhEUiAmJiB4aHIuc3RhdHVzPT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL0lFOCBDT1JTIEdFVCBzdWNjZXNzZnVsIHJlc3BvbnNlIGRvZXNuJ3QgaGF2ZSBhIHN0YXR1cyBmaWVsZCwgYnV0IGJvZHkgaXMgZmluZVxuICAgICAgICAgICAgc3RhdHVzID0gMjAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAoeGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXMpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3BvbnNlID0gZmFpbHVyZVJlc3BvbnNlXG4gICAgICAgIHZhciBlcnIgPSBudWxsXG5cbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gMCl7XG4gICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiBnZXRCb2R5KCksXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHVybDogdXJpLFxuICAgICAgICAgICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyl7IC8vcmVtZW1iZXIgeGhyIGNhbiBpbiBmYWN0IGJlIFhEUiBmb3IgQ09SUyBpbiBJRVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKFwiSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3JcIilcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KVxuXG4gICAgfVxuXG4gICAgdmFyIHhociA9IG9wdGlvbnMueGhyIHx8IG51bGxcblxuICAgIGlmICgheGhyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvcnMgfHwgb3B0aW9ucy51c2VYRFIpIHtcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWERvbWFpblJlcXVlc3QoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleVxuICAgIHZhciBhYm9ydGVkXG4gICAgdmFyIHVyaSA9IHhoci51cmwgPSBvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybFxuICAgIHZhciBtZXRob2QgPSB4aHIubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIlxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMuZGF0YSB8fCBudWxsXG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmNcbiAgICB2YXIgaXNKc29uID0gZmFsc2VcbiAgICB2YXIgdGltZW91dFRpbWVyXG5cbiAgICBpZiAoXCJqc29uXCIgaW4gb3B0aW9ucykge1xuICAgICAgICBpc0pzb24gPSB0cnVlXG4gICAgICAgIGhlYWRlcnNbXCJhY2NlcHRcIl0gfHwgaGVhZGVyc1tcIkFjY2VwdFwiXSB8fCAoaGVhZGVyc1tcIkFjY2VwdFwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKSAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuICAgICAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSB8fCAoaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKSAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByZWFkeXN0YXRlY2hhbmdlXG4gICAgeGhyLm9ubG9hZCA9IGxvYWRGdW5jXG4gICAgeGhyLm9uZXJyb3IgPSBlcnJvckZ1bmNcbiAgICAvLyBJRTkgbXVzdCBoYXZlIG9ucHJvZ3Jlc3MgYmUgc2V0IHRvIGEgdW5pcXVlIGZ1bmN0aW9uLlxuICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJRSBtdXN0IGRpZVxuICAgIH1cbiAgICB4aHIub250aW1lb3V0ID0gZXJyb3JGdW5jXG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmksICFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkKVxuICAgIC8vaGFzIHRvIGJlIGFmdGVyIG9wZW5cbiAgICBpZighc3luYykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRpb25zLndpdGhDcmVkZW50aWFsc1xuICAgIH1cbiAgICAvLyBDYW5ub3Qgc2V0IHRpbWVvdXQgd2l0aCBzeW5jIHJlcXVlc3RcbiAgICAvLyBub3Qgc2V0dGluZyB0aW1lb3V0IG9uIHRoZSB4aHIgb2JqZWN0LCBiZWNhdXNlIG9mIG9sZCB3ZWJraXRzIGV0Yy4gbm90IGhhbmRsaW5nIHRoYXQgY29ycmVjdGx5XG4gICAgLy8gYm90aCBucG0ncyByZXF1ZXN0IGFuZCBqcXVlcnkgMS54IHVzZSB0aGlzIGtpbmQgb2YgdGltZW91dCwgc28gdGhpcyBpcyBiZWluZyBjb25zaXN0ZW50XG4gICAgaWYgKCFzeW5jICYmIG9wdGlvbnMudGltZW91dCA+IDAgKSB7XG4gICAgICAgIHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGFib3J0ZWQ9dHJ1ZS8vSUU5IG1heSBzdGlsbCBjYWxsIHJlYWR5c3RhdGVjaGFuZ2VcbiAgICAgICAgICAgIHhoci5hYm9ydChcInRpbWVvdXRcIilcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKFwiWE1MSHR0cFJlcXVlc3QgdGltZW91dFwiKVxuICAgICAgICAgICAgZS5jb2RlID0gXCJFVElNRURPVVRcIlxuICAgICAgICAgICAgZXJyb3JGdW5jKGUpXG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCApXG4gICAgfVxuXG4gICAgaWYgKHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgIGZvcihrZXkgaW4gaGVhZGVycyl7XG4gICAgICAgICAgICBpZihoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmhlYWRlcnMgJiYgIWlzRW1wdHkob3B0aW9ucy5oZWFkZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXJzIGNhbm5vdCBiZSBzZXQgb24gYW4gWERvbWFpblJlcXVlc3Qgb2JqZWN0XCIpXG4gICAgfVxuXG4gICAgaWYgKFwicmVzcG9uc2VUeXBlXCIgaW4gb3B0aW9ucykge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGVcbiAgICB9XG5cbiAgICBpZiAoXCJiZWZvcmVTZW5kXCIgaW4gb3B0aW9ucyAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTZW5kID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kKHhocilcbiAgICB9XG5cbiAgICB4aHIuc2VuZChib2R5KVxuXG4gICAgcmV0dXJuIHhoclxuXG5cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCJpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNlbGY7XG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge307XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb25cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChmbikge1xuICB2YXIgc3RyaW5nID0gdG9TdHJpbmcuY2FsbChmbilcbiAgcmV0dXJuIHN0cmluZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fFxuICAgICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgc3RyaW5nICE9PSAnW29iamVjdCBSZWdFeHBdJykgfHxcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgLy8gSUU4IGFuZCBiZWxvd1xuICAgICAoZm4gPT09IHdpbmRvdy5zZXRUaW1lb3V0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmFsZXJ0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmNvbmZpcm0gfHxcbiAgICAgIGZuID09PSB3aW5kb3cucHJvbXB0KSlcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG9uY2Vcblxub25jZS5wcm90byA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2UodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuXG4gICAgY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbn1cbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuXG5mdW5jdGlvbiBmb3JFYWNoKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGl0ZXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBjb250ZXh0ID0gdGhpc1xuICAgIH1cbiAgICBcbiAgICBpZiAodG9TdHJpbmcuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJylcbiAgICAgICAgZm9yRWFjaEFycmF5KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgZm9yRWFjaFN0cmluZyhsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlXG4gICAgICAgIGZvckVhY2hPYmplY3QobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG59XG5cbmZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGkpKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGFycmF5W2ldLCBpLCBhcnJheSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBubyBzdWNoIHRoaW5nIGFzIGEgc3BhcnNlIHN0cmluZy5cbiAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoT2JqZWN0KG9iamVjdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBrIGluIG9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGspKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9iamVjdFtrXSwgaywgb2JqZWN0KVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0cmltO1xuXG5mdW5jdGlvbiB0cmltKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xufTtcblxuZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59O1xuIiwidmFyIHRyaW0gPSByZXF1aXJlKCd0cmltJylcbiAgLCBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKVxuICAsIGlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgaWYgKCFoZWFkZXJzKVxuICAgIHJldHVybiB7fVxuXG4gIHZhciByZXN1bHQgPSB7fVxuXG4gIGZvckVhY2goXG4gICAgICB0cmltKGhlYWRlcnMpLnNwbGl0KCdcXG4nKVxuICAgICwgZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgaW5kZXggPSByb3cuaW5kZXhPZignOicpXG4gICAgICAgICAgLCBrZXkgPSB0cmltKHJvdy5zbGljZSgwLCBpbmRleCkpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAsIHZhbHVlID0gdHJpbShyb3cuc2xpY2UoaW5kZXggKyAxKSlcblxuICAgICAgICBpZiAodHlwZW9mKHJlc3VsdFtrZXldKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gWyByZXN1bHRba2V5XSwgdmFsdWUgXVxuICAgICAgICB9XG4gICAgICB9XG4gIClcblxuICByZXR1cm4gcmVzdWx0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsImJpb2pzdmlza2VnZyA9IHJlcXVpcmUoJy4vanMvYXBwLmpzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGJpb2pzdmlza2VnZzsiXX0=
